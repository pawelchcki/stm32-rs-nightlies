#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 4;
#[cfg(feature = "rt")]
extern "C" {
    fn WWDG();
    fn PVD();
    fn TAMPER_STAMP();
    fn RTC_WKUP();
    fn FLASH();
    fn RCC();
    fn EXTI0();
    fn EXTI1();
    fn EXTI2();
    fn EXTI3();
    fn EXTI4();
    fn DMA1_CHANNEL1();
    fn DMA1_CHANNEL2();
    fn DMA1_CHANNEL3();
    fn DMA1_CHANNEL4();
    fn DMA1_CHANNEL5();
    fn DMA1_CHANNEL6();
    fn DMA1_CHANNEL7();
    fn ADC();
    fn EXTI9_5();
    fn TIM1_BRK_TIM15();
    fn TIM1_UP_TIM16();
    fn TIM1_TRG_COM_TIM17();
    fn TIM1_CC();
    fn TIM2();
    fn TIM3();
    fn TIM4();
    fn I2C1_EV();
    fn I2C1_ER();
    fn I2C2_EV();
    fn I2C2_ER();
    fn SPI1();
    fn SPI2();
    fn USART1();
    fn USART2();
    fn USART3();
    fn EXTI15_10();
    fn RTCALARM();
    fn CEC();
    fn TIM12();
    fn TIM13();
    fn TIM14();
    fn FSMC();
    fn TIM5();
    fn SPI3();
    fn UART4();
    fn UART5();
    fn TIM6_DAC();
    fn TIM7();
    fn DMA2_CHANNEL1();
    fn DMA2_CHANNEL2();
    fn DMA2_CHANNEL3();
    fn DMA2_CHANNEL4_5();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 60] = [
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector {
        _handler: TAMPER_STAMP,
    },
    Vector { _handler: RTC_WKUP },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI0 },
    Vector { _handler: EXTI1 },
    Vector { _handler: EXTI2 },
    Vector { _handler: EXTI3 },
    Vector { _handler: EXTI4 },
    Vector {
        _handler: DMA1_CHANNEL1,
    },
    Vector {
        _handler: DMA1_CHANNEL2,
    },
    Vector {
        _handler: DMA1_CHANNEL3,
    },
    Vector {
        _handler: DMA1_CHANNEL4,
    },
    Vector {
        _handler: DMA1_CHANNEL5,
    },
    Vector {
        _handler: DMA1_CHANNEL6,
    },
    Vector {
        _handler: DMA1_CHANNEL7,
    },
    Vector { _handler: ADC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: EXTI9_5 },
    Vector {
        _handler: TIM1_BRK_TIM15,
    },
    Vector {
        _handler: TIM1_UP_TIM16,
    },
    Vector {
        _handler: TIM1_TRG_COM_TIM17,
    },
    Vector { _handler: TIM1_CC },
    Vector { _handler: TIM2 },
    Vector { _handler: TIM3 },
    Vector { _handler: TIM4 },
    Vector { _handler: I2C1_EV },
    Vector { _handler: I2C1_ER },
    Vector { _handler: I2C2_EV },
    Vector { _handler: I2C2_ER },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: USART1 },
    Vector { _handler: USART2 },
    Vector { _handler: USART3 },
    Vector {
        _handler: EXTI15_10,
    },
    Vector { _handler: RTCALARM },
    Vector { _handler: CEC },
    Vector { _handler: TIM12 },
    Vector { _handler: TIM13 },
    Vector { _handler: TIM14 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: FSMC },
    Vector { _reserved: 0 },
    Vector { _handler: TIM5 },
    Vector { _handler: SPI3 },
    Vector { _handler: UART4 },
    Vector { _handler: UART5 },
    Vector { _handler: TIM6_DAC },
    Vector { _handler: TIM7 },
    Vector {
        _handler: DMA2_CHANNEL1,
    },
    Vector {
        _handler: DMA2_CHANNEL2,
    },
    Vector {
        _handler: DMA2_CHANNEL3,
    },
    Vector {
        _handler: DMA2_CHANNEL4_5,
    },
];
#[doc = r"Enumeration of all the interrupts"]
#[derive(Copy, Clone, Debug)]
#[repr(u8)]
pub enum Interrupt {
    #[doc = "0 - Window Watchdog interrupt"]
    WWDG = 0,
    #[doc = "1 - PVD through EXTI line detection interrupt"]
    PVD = 1,
    #[doc = "2 - Tamper and TimeStamp through EXTI line interrupts"]
    TAMPER_STAMP = 2,
    #[doc = "3 - RTC Wakeup through EXTI line interrupt"]
    RTC_WKUP = 3,
    #[doc = "4 - Flash global interrupt"]
    FLASH = 4,
    #[doc = "5 - RCC global interrupt"]
    RCC = 5,
    #[doc = "6 - EXTI Line0 interrupt"]
    EXTI0 = 6,
    #[doc = "7 - EXTI Line1 interrupt"]
    EXTI1 = 7,
    #[doc = "8 - EXTI Line2 interrupt"]
    EXTI2 = 8,
    #[doc = "9 - EXTI Line3 interrupt"]
    EXTI3 = 9,
    #[doc = "10 - EXTI Line4 interrupt"]
    EXTI4 = 10,
    #[doc = "11 - DMA1 Channel1 global interrupt"]
    DMA1_CHANNEL1 = 11,
    #[doc = "12 - DMA1 Channel2 global interrupt"]
    DMA1_CHANNEL2 = 12,
    #[doc = "13 - DMA1 Channel3 global interrupt"]
    DMA1_CHANNEL3 = 13,
    #[doc = "14 - DMA1 Channel4 global interrupt"]
    DMA1_CHANNEL4 = 14,
    #[doc = "15 - DMA1 Channel5 global interrupt"]
    DMA1_CHANNEL5 = 15,
    #[doc = "16 - DMA1 Channel6 global interrupt"]
    DMA1_CHANNEL6 = 16,
    #[doc = "17 - DMA1 Channel7 global interrupt"]
    DMA1_CHANNEL7 = 17,
    #[doc = "18 - ADC1 global interrupt"]
    ADC = 18,
    #[doc = "23 - EXTI Line\\[9:5\\]
interrupts"]
    EXTI9_5 = 23,
    #[doc = "24 - TIM1 Break interrupt and TIM15 global interrupt"]
    TIM1_BRK_TIM15 = 24,
    #[doc = "25 - TIM1 Update interrupt and TIM16 global interrupt"]
    TIM1_UP_TIM16 = 25,
    #[doc = "26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt"]
    TIM1_TRG_COM_TIM17 = 26,
    #[doc = "27 - TIM1 Capture Compare interrupt"]
    TIM1_CC = 27,
    #[doc = "28 - TIM2 global interrupt"]
    TIM2 = 28,
    #[doc = "29 - TIM3 global interrupt"]
    TIM3 = 29,
    #[doc = "30 - TIM4 global interrupt"]
    TIM4 = 30,
    #[doc = "31 - I2C1 event interrupt"]
    I2C1_EV = 31,
    #[doc = "32 - I2C1 error interrupt"]
    I2C1_ER = 32,
    #[doc = "33 - I2C2 event interrupt"]
    I2C2_EV = 33,
    #[doc = "34 - I2C2 error interrupt"]
    I2C2_ER = 34,
    #[doc = "35 - SPI1 global interrupt"]
    SPI1 = 35,
    #[doc = "36 - SPI2 global interrupt"]
    SPI2 = 36,
    #[doc = "37 - USART1 global interrupt"]
    USART1 = 37,
    #[doc = "38 - USART2 global interrupt"]
    USART2 = 38,
    #[doc = "39 - USART3 global interrupt"]
    USART3 = 39,
    #[doc = "40 - EXTI Line\\[15:10\\]
interrupts"]
    EXTI15_10 = 40,
    #[doc = "41 - RTC Alarms through EXTI line interrupt"]
    RTCALARM = 41,
    #[doc = "42 - CEC global interrupt"]
    CEC = 42,
    #[doc = "43 - TIM12 global interrupt"]
    TIM12 = 43,
    #[doc = "44 - TIM13 global interrupt"]
    TIM13 = 44,
    #[doc = "45 - TIM14 global interrupt"]
    TIM14 = 45,
    #[doc = "48 - FSMC global interrupt"]
    FSMC = 48,
    #[doc = "50 - TIM5 global interrupt"]
    TIM5 = 50,
    #[doc = "51 - SPI3 global interrupt"]
    SPI3 = 51,
    #[doc = "52 - UART4 global interrupt"]
    UART4 = 52,
    #[doc = "53 - UART5 global interrupt"]
    UART5 = 53,
    #[doc = "54 - TIM6 global and DAC underrun interrupts"]
    TIM6_DAC = 54,
    #[doc = "55 - TIM7 global interrupt"]
    TIM7 = 55,
    #[doc = "56 - DMA2 Channel1 global interrupt"]
    DMA2_CHANNEL1 = 56,
    #[doc = "57 - DMA2 Channel2 global interrupt"]
    DMA2_CHANNEL2 = 57,
    #[doc = "58 - DMA2 Channel3 global interrupt"]
    DMA2_CHANNEL3 = 58,
    #[doc = "59 - DMA2 Channel4 and DMA2 Channel5 global interrupt"]
    DMA2_CHANNEL4_5 = 59,
}
unsafe impl bare_metal::Nr for Interrupt {
    #[inline(always)]
    fn nr(&self) -> u8 {
        *self as u8
    }
}
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[doc = "Flexible static memory controller"]
pub struct FSMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FSMC {}
impl FSMC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsmc::RegisterBlock {
        0xa000_0000 as *const _
    }
}
impl Deref for FSMC {
    type Target = fsmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*FSMC::ptr() }
    }
}
#[doc = "Flexible static memory controller"]
pub mod fsmc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SRAM/NOR-Flash chip-select control register 1"]
        pub bcr1: BCR1,
        #[doc = "0x04 - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr1: BTR,
        #[doc = "0x08 - SRAM/NOR-Flash chip-select control register 2"]
        pub bcr2: BCR,
        #[doc = "0x0c - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr2: BTR,
        #[doc = "0x10 - SRAM/NOR-Flash chip-select control register 2"]
        pub bcr3: BCR,
        #[doc = "0x14 - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr3: BTR,
        #[doc = "0x18 - SRAM/NOR-Flash chip-select control register 2"]
        pub bcr4: BCR,
        #[doc = "0x1c - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr4: BTR,
        _reserved8: [u8; 228usize],
        #[doc = "0x104 - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr1: BWTR,
        _reserved9: [u8; 4usize],
        #[doc = "0x10c - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr2: BWTR,
        _reserved10: [u8; 4usize],
        #[doc = "0x114 - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr3: BWTR,
        _reserved11: [u8; 4usize],
        #[doc = "0x11c - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr4: BWTR,
    }
    #[doc = "SRAM/NOR-Flash chip-select control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bcr1](bcr1) module"]
    pub type BCR1 = crate::Reg<u32, _BCR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BCR1;
    #[doc = "`read()` method returns [bcr1::R](bcr1::R) reader structure"]
    impl crate::Readable for BCR1 {}
    #[doc = "`write(|w| ..)` method takes [bcr1::W](bcr1::W) writer structure"]
    impl crate::Writable for BCR1 {}
    #[doc = "SRAM/NOR-Flash chip-select control register 1"]
    pub mod bcr1 {
        #[doc = "Reader of register BCR1"]
        pub type R = crate::R<u32, super::BCR1>;
        #[doc = "Writer for register BCR1"]
        pub type W = crate::W<u32, super::BCR1>;
        #[doc = "Register BCR1 `reset()`'s with value 0x30d0"]
        impl crate::ResetValue for super::BCR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x30d0
            }
        }
        #[doc = "CBURSTRW\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CBURSTRW_A {
            #[doc = "1: Write operations are performed in synchronous mode"]
            ENABLED = 1,
            #[doc = "0: Write operations are always performed in asynchronous mode"]
            DISABLED = 0,
        }
        impl From<CBURSTRW_A> for bool {
            #[inline(always)]
            fn from(variant: CBURSTRW_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CBURSTRW`"]
        pub type CBURSTRW_R = crate::R<bool, CBURSTRW_A>;
        impl CBURSTRW_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CBURSTRW_A {
                match self.bits {
                    true => CBURSTRW_A::ENABLED,
                    false => CBURSTRW_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CBURSTRW_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CBURSTRW_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `CBURSTRW`"]
        pub struct CBURSTRW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CBURSTRW_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CBURSTRW_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Write operations are performed in synchronous mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::ENABLED)
            }
            #[doc = "Write operations are always performed in asynchronous mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "ASYNCWAIT\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASYNCWAIT_A {
            #[doc = "0: Wait signal not used in asynchronous mode"]
            DISABLED = 0,
            #[doc = "1: Wait signal used even in asynchronous mode"]
            ENABLED = 1,
        }
        impl From<ASYNCWAIT_A> for bool {
            #[inline(always)]
            fn from(variant: ASYNCWAIT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ASYNCWAIT`"]
        pub type ASYNCWAIT_R = crate::R<bool, ASYNCWAIT_A>;
        impl ASYNCWAIT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ASYNCWAIT_A {
                match self.bits {
                    false => ASYNCWAIT_A::DISABLED,
                    true => ASYNCWAIT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ASYNCWAIT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ASYNCWAIT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ASYNCWAIT`"]
        pub struct ASYNCWAIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASYNCWAIT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ASYNCWAIT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Wait signal not used in asynchronous mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::DISABLED)
            }
            #[doc = "Wait signal used even in asynchronous mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "EXTMOD\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTMOD_A {
            #[doc = "0: Values inside the FMC_BWTR are not taken into account"]
            DISABLED = 0,
            #[doc = "1: Values inside the FMC_BWTR are taken into account"]
            ENABLED = 1,
        }
        impl From<EXTMOD_A> for bool {
            #[inline(always)]
            fn from(variant: EXTMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EXTMOD`"]
        pub type EXTMOD_R = crate::R<bool, EXTMOD_A>;
        impl EXTMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTMOD_A {
                match self.bits {
                    false => EXTMOD_A::DISABLED,
                    true => EXTMOD_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EXTMOD_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EXTMOD_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EXTMOD`"]
        pub struct EXTMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTMOD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Values inside the FMC_BWTR are not taken into account"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::DISABLED)
            }
            #[doc = "Values inside the FMC_BWTR are taken into account"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "WAITEN\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITEN_A {
            #[doc = "0: Values inside the FMC_BWTR are taken into account"]
            DISABLED = 0,
            #[doc = "1: NWAIT signal enabled"]
            ENABLED = 1,
        }
        impl From<WAITEN_A> for bool {
            #[inline(always)]
            fn from(variant: WAITEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAITEN`"]
        pub type WAITEN_R = crate::R<bool, WAITEN_A>;
        impl WAITEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAITEN_A {
                match self.bits {
                    false => WAITEN_A::DISABLED,
                    true => WAITEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WAITEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WAITEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WAITEN`"]
        pub struct WAITEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Values inside the FMC_BWTR are taken into account"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAITEN_A::DISABLED)
            }
            #[doc = "NWAIT signal enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAITEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "WREN\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WREN_A {
            #[doc = "0: Write operations disabled for the bank by the FMC"]
            DISABLED = 0,
            #[doc = "1: Write operations enabled for the bank by the FMC"]
            ENABLED = 1,
        }
        impl From<WREN_A> for bool {
            #[inline(always)]
            fn from(variant: WREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WREN`"]
        pub type WREN_R = crate::R<bool, WREN_A>;
        impl WREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WREN_A {
                match self.bits {
                    false => WREN_A::DISABLED,
                    true => WREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WREN`"]
        pub struct WREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Write operations disabled for the bank by the FMC"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WREN_A::DISABLED)
            }
            #[doc = "Write operations enabled for the bank by the FMC"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "WAITCFG\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITCFG_A {
            #[doc = "0: NWAIT signal is active one data cycle before wait state"]
            BEFOREWAITSTATE = 0,
            #[doc = "1: NWAIT signal is active during wait state"]
            DURINGWAITSTATE = 1,
        }
        impl From<WAITCFG_A> for bool {
            #[inline(always)]
            fn from(variant: WAITCFG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAITCFG`"]
        pub type WAITCFG_R = crate::R<bool, WAITCFG_A>;
        impl WAITCFG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAITCFG_A {
                match self.bits {
                    false => WAITCFG_A::BEFOREWAITSTATE,
                    true => WAITCFG_A::DURINGWAITSTATE,
                }
            }
            #[doc = "Checks if the value of the field is `BEFOREWAITSTATE`"]
            #[inline(always)]
            pub fn is_before_wait_state(&self) -> bool {
                *self == WAITCFG_A::BEFOREWAITSTATE
            }
            #[doc = "Checks if the value of the field is `DURINGWAITSTATE`"]
            #[inline(always)]
            pub fn is_during_wait_state(&self) -> bool {
                *self == WAITCFG_A::DURINGWAITSTATE
            }
        }
        #[doc = "Write proxy for field `WAITCFG`"]
        pub struct WAITCFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITCFG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITCFG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NWAIT signal is active one data cycle before wait state"]
            #[inline(always)]
            pub fn before_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::BEFOREWAITSTATE)
            }
            #[doc = "NWAIT signal is active during wait state"]
            #[inline(always)]
            pub fn during_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::DURINGWAITSTATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "WAITPOL\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITPOL_A {
            #[doc = "0: NWAIT active low"]
            ACTIVELOW = 0,
            #[doc = "1: NWAIT active high"]
            ACTIVEHIGH = 1,
        }
        impl From<WAITPOL_A> for bool {
            #[inline(always)]
            fn from(variant: WAITPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAITPOL`"]
        pub type WAITPOL_R = crate::R<bool, WAITPOL_A>;
        impl WAITPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAITPOL_A {
                match self.bits {
                    false => WAITPOL_A::ACTIVELOW,
                    true => WAITPOL_A::ACTIVEHIGH,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVELOW`"]
            #[inline(always)]
            pub fn is_active_low(&self) -> bool {
                *self == WAITPOL_A::ACTIVELOW
            }
            #[doc = "Checks if the value of the field is `ACTIVEHIGH`"]
            #[inline(always)]
            pub fn is_active_high(&self) -> bool {
                *self == WAITPOL_A::ACTIVEHIGH
            }
        }
        #[doc = "Write proxy for field `WAITPOL`"]
        pub struct WAITPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NWAIT active low"]
            #[inline(always)]
            pub fn active_low(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVELOW)
            }
            #[doc = "NWAIT active high"]
            #[inline(always)]
            pub fn active_high(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVEHIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "BURSTEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BURSTEN_A {
            #[doc = "0: Burst mode disabled"]
            DISABLED = 0,
            #[doc = "1: Burst mode enabled"]
            ENABLED = 1,
        }
        impl From<BURSTEN_A> for bool {
            #[inline(always)]
            fn from(variant: BURSTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BURSTEN`"]
        pub type BURSTEN_R = crate::R<bool, BURSTEN_A>;
        impl BURSTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BURSTEN_A {
                match self.bits {
                    false => BURSTEN_A::DISABLED,
                    true => BURSTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BURSTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BURSTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `BURSTEN`"]
        pub struct BURSTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BURSTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BURSTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Burst mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::DISABLED)
            }
            #[doc = "Burst mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "FACCEN\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FACCEN_A {
            #[doc = "0: Corresponding NOR Flash memory access is disabled"]
            DISABLED = 0,
            #[doc = "1: Corresponding NOR Flash memory access is enabled"]
            ENABLED = 1,
        }
        impl From<FACCEN_A> for bool {
            #[inline(always)]
            fn from(variant: FACCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FACCEN`"]
        pub type FACCEN_R = crate::R<bool, FACCEN_A>;
        impl FACCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FACCEN_A {
                match self.bits {
                    false => FACCEN_A::DISABLED,
                    true => FACCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == FACCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == FACCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `FACCEN`"]
        pub struct FACCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FACCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FACCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Corresponding NOR Flash memory access is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FACCEN_A::DISABLED)
            }
            #[doc = "Corresponding NOR Flash memory access is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FACCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "MWID\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MWID_A {
            #[doc = "0: Memory data bus width 8 bits"]
            BITS8 = 0,
            #[doc = "1: Memory data bus width 16 bits"]
            BITS16 = 1,
            #[doc = "2: Memory data bus width 32 bits"]
            BITS32 = 2,
        }
        impl From<MWID_A> for u8 {
            #[inline(always)]
            fn from(variant: MWID_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MWID`"]
        pub type MWID_R = crate::R<u8, MWID_A>;
        impl MWID_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MWID_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MWID_A::BITS8),
                    1 => Val(MWID_A::BITS16),
                    2 => Val(MWID_A::BITS32),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `BITS8`"]
            #[inline(always)]
            pub fn is_bits8(&self) -> bool {
                *self == MWID_A::BITS8
            }
            #[doc = "Checks if the value of the field is `BITS16`"]
            #[inline(always)]
            pub fn is_bits16(&self) -> bool {
                *self == MWID_A::BITS16
            }
            #[doc = "Checks if the value of the field is `BITS32`"]
            #[inline(always)]
            pub fn is_bits32(&self) -> bool {
                *self == MWID_A::BITS32
            }
        }
        #[doc = "Write proxy for field `MWID`"]
        pub struct MWID_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MWID_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MWID_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Memory data bus width 8 bits"]
            #[inline(always)]
            pub fn bits8(self) -> &'a mut W {
                self.variant(MWID_A::BITS8)
            }
            #[doc = "Memory data bus width 16 bits"]
            #[inline(always)]
            pub fn bits16(self) -> &'a mut W {
                self.variant(MWID_A::BITS16)
            }
            #[doc = "Memory data bus width 32 bits"]
            #[inline(always)]
            pub fn bits32(self) -> &'a mut W {
                self.variant(MWID_A::BITS32)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "MTYP\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MTYP_A {
            #[doc = "0: SRAM memory type"]
            SRAM = 0,
            #[doc = "1: PSRAM (CRAM) memory type"]
            PSRAM = 1,
            #[doc = "2: NOR Flash/OneNAND Flash"]
            FLASH = 2,
        }
        impl From<MTYP_A> for u8 {
            #[inline(always)]
            fn from(variant: MTYP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MTYP`"]
        pub type MTYP_R = crate::R<u8, MTYP_A>;
        impl MTYP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MTYP_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MTYP_A::SRAM),
                    1 => Val(MTYP_A::PSRAM),
                    2 => Val(MTYP_A::FLASH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SRAM`"]
            #[inline(always)]
            pub fn is_sram(&self) -> bool {
                *self == MTYP_A::SRAM
            }
            #[doc = "Checks if the value of the field is `PSRAM`"]
            #[inline(always)]
            pub fn is_psram(&self) -> bool {
                *self == MTYP_A::PSRAM
            }
            #[doc = "Checks if the value of the field is `FLASH`"]
            #[inline(always)]
            pub fn is_flash(&self) -> bool {
                *self == MTYP_A::FLASH
            }
        }
        #[doc = "Write proxy for field `MTYP`"]
        pub struct MTYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MTYP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MTYP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "SRAM memory type"]
            #[inline(always)]
            pub fn sram(self) -> &'a mut W {
                self.variant(MTYP_A::SRAM)
            }
            #[doc = "PSRAM (CRAM) memory type"]
            #[inline(always)]
            pub fn psram(self) -> &'a mut W {
                self.variant(MTYP_A::PSRAM)
            }
            #[doc = "NOR Flash/OneNAND Flash"]
            #[inline(always)]
            pub fn flash(self) -> &'a mut W {
                self.variant(MTYP_A::FLASH)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "MUXEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXEN_A {
            #[doc = "0: Address/Data non-multiplexed"]
            DISABLED = 0,
            #[doc = "1: Address/Data multiplexed on databus"]
            ENABLED = 1,
        }
        impl From<MUXEN_A> for bool {
            #[inline(always)]
            fn from(variant: MUXEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MUXEN`"]
        pub type MUXEN_R = crate::R<bool, MUXEN_A>;
        impl MUXEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MUXEN_A {
                match self.bits {
                    false => MUXEN_A::DISABLED,
                    true => MUXEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MUXEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MUXEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MUXEN`"]
        pub struct MUXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MUXEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MUXEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Address/Data non-multiplexed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MUXEN_A::DISABLED)
            }
            #[doc = "Address/Data multiplexed on databus"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MUXEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "MBKEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MBKEN_A {
            #[doc = "0: Corresponding memory bank is disabled"]
            DISABLED = 0,
            #[doc = "1: Corresponding memory bank is enabled"]
            ENABLED = 1,
        }
        impl From<MBKEN_A> for bool {
            #[inline(always)]
            fn from(variant: MBKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MBKEN`"]
        pub type MBKEN_R = crate::R<bool, MBKEN_A>;
        impl MBKEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MBKEN_A {
                match self.bits {
                    false => MBKEN_A::DISABLED,
                    true => MBKEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MBKEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MBKEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MBKEN`"]
        pub struct MBKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MBKEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MBKEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Corresponding memory bank is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MBKEN_A::DISABLED)
            }
            #[doc = "Corresponding memory bank is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MBKEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `WRAPMOD`"]
        pub type WRAPMOD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `WRAPMOD`"]
        pub struct WRAPMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRAPMOD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "CRAM page size\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CPSIZE_A {
            #[doc = "0: No burst split when crossing page boundary"]
            NOBURSTSPLIT = 0,
            #[doc = "1: 128 bytes CRAM page size"]
            BYTES128 = 1,
            #[doc = "2: 256 bytes CRAM page size"]
            BYTES256 = 2,
            #[doc = "3: 512 bytes CRAM page size"]
            BYTES512 = 3,
            #[doc = "4: 1024 bytes CRAM page size"]
            BYTES1024 = 4,
        }
        impl From<CPSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: CPSIZE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CPSIZE`"]
        pub type CPSIZE_R = crate::R<u8, CPSIZE_A>;
        impl CPSIZE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CPSIZE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CPSIZE_A::NOBURSTSPLIT),
                    1 => Val(CPSIZE_A::BYTES128),
                    2 => Val(CPSIZE_A::BYTES256),
                    3 => Val(CPSIZE_A::BYTES512),
                    4 => Val(CPSIZE_A::BYTES1024),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOBURSTSPLIT`"]
            #[inline(always)]
            pub fn is_no_burst_split(&self) -> bool {
                *self == CPSIZE_A::NOBURSTSPLIT
            }
            #[doc = "Checks if the value of the field is `BYTES128`"]
            #[inline(always)]
            pub fn is_bytes128(&self) -> bool {
                *self == CPSIZE_A::BYTES128
            }
            #[doc = "Checks if the value of the field is `BYTES256`"]
            #[inline(always)]
            pub fn is_bytes256(&self) -> bool {
                *self == CPSIZE_A::BYTES256
            }
            #[doc = "Checks if the value of the field is `BYTES512`"]
            #[inline(always)]
            pub fn is_bytes512(&self) -> bool {
                *self == CPSIZE_A::BYTES512
            }
            #[doc = "Checks if the value of the field is `BYTES1024`"]
            #[inline(always)]
            pub fn is_bytes1024(&self) -> bool {
                *self == CPSIZE_A::BYTES1024
            }
        }
        #[doc = "Write proxy for field `CPSIZE`"]
        pub struct CPSIZE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPSIZE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPSIZE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No burst split when crossing page boundary"]
            #[inline(always)]
            pub fn no_burst_split(self) -> &'a mut W {
                self.variant(CPSIZE_A::NOBURSTSPLIT)
            }
            #[doc = "128 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes128(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES128)
            }
            #[doc = "256 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes256(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES256)
            }
            #[doc = "512 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes512(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES512)
            }
            #[doc = "1024 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes1024(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES1024)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 16)) | (((value as u32) & 0x07) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 19 - CBURSTRW"]
            #[inline(always)]
            pub fn cburstrw(&self) -> CBURSTRW_R {
                CBURSTRW_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 15 - ASYNCWAIT"]
            #[inline(always)]
            pub fn asyncwait(&self) -> ASYNCWAIT_R {
                ASYNCWAIT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - EXTMOD"]
            #[inline(always)]
            pub fn extmod(&self) -> EXTMOD_R {
                EXTMOD_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - WAITEN"]
            #[inline(always)]
            pub fn waiten(&self) -> WAITEN_R {
                WAITEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - WREN"]
            #[inline(always)]
            pub fn wren(&self) -> WREN_R {
                WREN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - WAITCFG"]
            #[inline(always)]
            pub fn waitcfg(&self) -> WAITCFG_R {
                WAITCFG_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 9 - WAITPOL"]
            #[inline(always)]
            pub fn waitpol(&self) -> WAITPOL_R {
                WAITPOL_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - BURSTEN"]
            #[inline(always)]
            pub fn bursten(&self) -> BURSTEN_R {
                BURSTEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - FACCEN"]
            #[inline(always)]
            pub fn faccen(&self) -> FACCEN_R {
                FACCEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bits 4:5 - MWID"]
            #[inline(always)]
            pub fn mwid(&self) -> MWID_R {
                MWID_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - MTYP"]
            #[inline(always)]
            pub fn mtyp(&self) -> MTYP_R {
                MTYP_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bit 1 - MUXEN"]
            #[inline(always)]
            pub fn muxen(&self) -> MUXEN_R {
                MUXEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - MBKEN"]
            #[inline(always)]
            pub fn mbken(&self) -> MBKEN_R {
                MBKEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 10 - WRAPMOD"]
            #[inline(always)]
            pub fn wrapmod(&self) -> WRAPMOD_R {
                WRAPMOD_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 16:18 - CRAM page size"]
            #[inline(always)]
            pub fn cpsize(&self) -> CPSIZE_R {
                CPSIZE_R::new(((self.bits >> 16) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 19 - CBURSTRW"]
            #[inline(always)]
            pub fn cburstrw(&mut self) -> CBURSTRW_W {
                CBURSTRW_W { w: self }
            }
            #[doc = "Bit 15 - ASYNCWAIT"]
            #[inline(always)]
            pub fn asyncwait(&mut self) -> ASYNCWAIT_W {
                ASYNCWAIT_W { w: self }
            }
            #[doc = "Bit 14 - EXTMOD"]
            #[inline(always)]
            pub fn extmod(&mut self) -> EXTMOD_W {
                EXTMOD_W { w: self }
            }
            #[doc = "Bit 13 - WAITEN"]
            #[inline(always)]
            pub fn waiten(&mut self) -> WAITEN_W {
                WAITEN_W { w: self }
            }
            #[doc = "Bit 12 - WREN"]
            #[inline(always)]
            pub fn wren(&mut self) -> WREN_W {
                WREN_W { w: self }
            }
            #[doc = "Bit 11 - WAITCFG"]
            #[inline(always)]
            pub fn waitcfg(&mut self) -> WAITCFG_W {
                WAITCFG_W { w: self }
            }
            #[doc = "Bit 9 - WAITPOL"]
            #[inline(always)]
            pub fn waitpol(&mut self) -> WAITPOL_W {
                WAITPOL_W { w: self }
            }
            #[doc = "Bit 8 - BURSTEN"]
            #[inline(always)]
            pub fn bursten(&mut self) -> BURSTEN_W {
                BURSTEN_W { w: self }
            }
            #[doc = "Bit 6 - FACCEN"]
            #[inline(always)]
            pub fn faccen(&mut self) -> FACCEN_W {
                FACCEN_W { w: self }
            }
            #[doc = "Bits 4:5 - MWID"]
            #[inline(always)]
            pub fn mwid(&mut self) -> MWID_W {
                MWID_W { w: self }
            }
            #[doc = "Bits 2:3 - MTYP"]
            #[inline(always)]
            pub fn mtyp(&mut self) -> MTYP_W {
                MTYP_W { w: self }
            }
            #[doc = "Bit 1 - MUXEN"]
            #[inline(always)]
            pub fn muxen(&mut self) -> MUXEN_W {
                MUXEN_W { w: self }
            }
            #[doc = "Bit 0 - MBKEN"]
            #[inline(always)]
            pub fn mbken(&mut self) -> MBKEN_W {
                MBKEN_W { w: self }
            }
            #[doc = "Bit 10 - WRAPMOD"]
            #[inline(always)]
            pub fn wrapmod(&mut self) -> WRAPMOD_W {
                WRAPMOD_W { w: self }
            }
            #[doc = "Bits 16:18 - CRAM page size"]
            #[inline(always)]
            pub fn cpsize(&mut self) -> CPSIZE_W {
                CPSIZE_W { w: self }
            }
        }
    }
    #[doc = "SRAM/NOR-Flash chip-select timing register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [btr](btr) module"]
    pub type BTR = crate::Reg<u32, _BTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BTR;
    #[doc = "`read()` method returns [btr::R](btr::R) reader structure"]
    impl crate::Readable for BTR {}
    #[doc = "`write(|w| ..)` method takes [btr::W](btr::W) writer structure"]
    impl crate::Writable for BTR {}
    #[doc = "SRAM/NOR-Flash chip-select timing register 1"]
    pub mod btr {
        #[doc = "Reader of register BTR%s"]
        pub type R = crate::R<u32, super::BTR>;
        #[doc = "Writer for register BTR%s"]
        pub type W = crate::W<u32, super::BTR>;
        #[doc = "Register BTR%s `reset()`'s with value 0xffff_ffff"]
        impl crate::ResetValue for super::BTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff_ffff
            }
        }
        #[doc = "ACCMOD\n\nValue on reset: 3"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ACCMOD_A {
            #[doc = "0: Access mode A"]
            A = 0,
            #[doc = "1: Access mode B"]
            B = 1,
            #[doc = "2: Access mode C"]
            C = 2,
            #[doc = "3: Access mode D"]
            D = 3,
        }
        impl From<ACCMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: ACCMOD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ACCMOD`"]
        pub type ACCMOD_R = crate::R<u8, ACCMOD_A>;
        impl ACCMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ACCMOD_A {
                match self.bits {
                    0 => ACCMOD_A::A,
                    1 => ACCMOD_A::B,
                    2 => ACCMOD_A::C,
                    3 => ACCMOD_A::D,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `A`"]
            #[inline(always)]
            pub fn is_a(&self) -> bool {
                *self == ACCMOD_A::A
            }
            #[doc = "Checks if the value of the field is `B`"]
            #[inline(always)]
            pub fn is_b(&self) -> bool {
                *self == ACCMOD_A::B
            }
            #[doc = "Checks if the value of the field is `C`"]
            #[inline(always)]
            pub fn is_c(&self) -> bool {
                *self == ACCMOD_A::C
            }
            #[doc = "Checks if the value of the field is `D`"]
            #[inline(always)]
            pub fn is_d(&self) -> bool {
                *self == ACCMOD_A::D
            }
        }
        #[doc = "Write proxy for field `ACCMOD`"]
        pub struct ACCMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACCMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACCMOD_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Access mode A"]
            #[inline(always)]
            pub fn a(self) -> &'a mut W {
                self.variant(ACCMOD_A::A)
            }
            #[doc = "Access mode B"]
            #[inline(always)]
            pub fn b(self) -> &'a mut W {
                self.variant(ACCMOD_A::B)
            }
            #[doc = "Access mode C"]
            #[inline(always)]
            pub fn c(self) -> &'a mut W {
                self.variant(ACCMOD_A::C)
            }
            #[doc = "Access mode D"]
            #[inline(always)]
            pub fn d(self) -> &'a mut W {
                self.variant(ACCMOD_A::D)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Reader of field `DATLAT`"]
        pub type DATLAT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DATLAT`"]
        pub struct DATLAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATLAT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `CLKDIV`"]
        pub type CLKDIV_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CLKDIV`"]
        pub struct CLKDIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKDIV_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `BUSTURN`"]
        pub type BUSTURN_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `BUSTURN`"]
        pub struct BUSTURN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BUSTURN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `DATAST`"]
        pub type DATAST_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DATAST`"]
        pub struct DATAST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATAST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `ADDHLD`"]
        pub type ADDHLD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADDHLD`"]
        pub struct ADDHLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDHLD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `ADDSET`"]
        pub type ADDSET_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADDSET`"]
        pub struct ADDSET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDSET_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline(always)]
            pub fn accmod(&self) -> ACCMOD_R {
                ACCMOD_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline(always)]
            pub fn datlat(&self) -> DATLAT_R {
                DATLAT_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline(always)]
            pub fn clkdiv(&self) -> CLKDIV_R {
                CLKDIV_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - BUSTURN"]
            #[inline(always)]
            pub fn busturn(&self) -> BUSTURN_R {
                BUSTURN_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline(always)]
            pub fn datast(&self) -> DATAST_R {
                DATAST_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline(always)]
            pub fn addhld(&self) -> ADDHLD_R {
                ADDHLD_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline(always)]
            pub fn addset(&self) -> ADDSET_R {
                ADDSET_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline(always)]
            pub fn accmod(&mut self) -> ACCMOD_W {
                ACCMOD_W { w: self }
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline(always)]
            pub fn datlat(&mut self) -> DATLAT_W {
                DATLAT_W { w: self }
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline(always)]
            pub fn clkdiv(&mut self) -> CLKDIV_W {
                CLKDIV_W { w: self }
            }
            #[doc = "Bits 16:19 - BUSTURN"]
            #[inline(always)]
            pub fn busturn(&mut self) -> BUSTURN_W {
                BUSTURN_W { w: self }
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline(always)]
            pub fn datast(&mut self) -> DATAST_W {
                DATAST_W { w: self }
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline(always)]
            pub fn addhld(&mut self) -> ADDHLD_W {
                ADDHLD_W { w: self }
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline(always)]
            pub fn addset(&mut self) -> ADDSET_W {
                ADDSET_W { w: self }
            }
        }
    }
    #[doc = "SRAM/NOR-Flash chip-select control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bcr](bcr) module"]
    pub type BCR = crate::Reg<u32, _BCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BCR;
    #[doc = "`read()` method returns [bcr::R](bcr::R) reader structure"]
    impl crate::Readable for BCR {}
    #[doc = "`write(|w| ..)` method takes [bcr::W](bcr::W) writer structure"]
    impl crate::Writable for BCR {}
    #[doc = "SRAM/NOR-Flash chip-select control register 2"]
    pub mod bcr {
        #[doc = "Reader of register BCR%s"]
        pub type R = crate::R<u32, super::BCR>;
        #[doc = "Writer for register BCR%s"]
        pub type W = crate::W<u32, super::BCR>;
        #[doc = "Register BCR%s `reset()`'s with value 0x30d0"]
        impl crate::ResetValue for super::BCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x30d0
            }
        }
        #[doc = "CBURSTRW\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CBURSTRW_A {
            #[doc = "1: Write operations are performed in synchronous mode"]
            ENABLED = 1,
            #[doc = "0: Write operations are always performed in asynchronous mode"]
            DISABLED = 0,
        }
        impl From<CBURSTRW_A> for bool {
            #[inline(always)]
            fn from(variant: CBURSTRW_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CBURSTRW`"]
        pub type CBURSTRW_R = crate::R<bool, CBURSTRW_A>;
        impl CBURSTRW_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CBURSTRW_A {
                match self.bits {
                    true => CBURSTRW_A::ENABLED,
                    false => CBURSTRW_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CBURSTRW_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CBURSTRW_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `CBURSTRW`"]
        pub struct CBURSTRW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CBURSTRW_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CBURSTRW_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Write operations are performed in synchronous mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::ENABLED)
            }
            #[doc = "Write operations are always performed in asynchronous mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "ASYNCWAIT\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASYNCWAIT_A {
            #[doc = "0: Wait signal not used in asynchronous mode"]
            DISABLED = 0,
            #[doc = "1: Wait signal used even in asynchronous mode"]
            ENABLED = 1,
        }
        impl From<ASYNCWAIT_A> for bool {
            #[inline(always)]
            fn from(variant: ASYNCWAIT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ASYNCWAIT`"]
        pub type ASYNCWAIT_R = crate::R<bool, ASYNCWAIT_A>;
        impl ASYNCWAIT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ASYNCWAIT_A {
                match self.bits {
                    false => ASYNCWAIT_A::DISABLED,
                    true => ASYNCWAIT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ASYNCWAIT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ASYNCWAIT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ASYNCWAIT`"]
        pub struct ASYNCWAIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASYNCWAIT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ASYNCWAIT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Wait signal not used in asynchronous mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::DISABLED)
            }
            #[doc = "Wait signal used even in asynchronous mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "EXTMOD\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTMOD_A {
            #[doc = "0: Values inside the FMC_BWTR are not taken into account"]
            DISABLED = 0,
            #[doc = "1: Values inside the FMC_BWTR are taken into account"]
            ENABLED = 1,
        }
        impl From<EXTMOD_A> for bool {
            #[inline(always)]
            fn from(variant: EXTMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EXTMOD`"]
        pub type EXTMOD_R = crate::R<bool, EXTMOD_A>;
        impl EXTMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTMOD_A {
                match self.bits {
                    false => EXTMOD_A::DISABLED,
                    true => EXTMOD_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EXTMOD_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EXTMOD_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EXTMOD`"]
        pub struct EXTMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTMOD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Values inside the FMC_BWTR are not taken into account"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::DISABLED)
            }
            #[doc = "Values inside the FMC_BWTR are taken into account"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "WAITEN\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITEN_A {
            #[doc = "0: Values inside the FMC_BWTR are taken into account"]
            DISABLED = 0,
            #[doc = "1: NWAIT signal enabled"]
            ENABLED = 1,
        }
        impl From<WAITEN_A> for bool {
            #[inline(always)]
            fn from(variant: WAITEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAITEN`"]
        pub type WAITEN_R = crate::R<bool, WAITEN_A>;
        impl WAITEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAITEN_A {
                match self.bits {
                    false => WAITEN_A::DISABLED,
                    true => WAITEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WAITEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WAITEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WAITEN`"]
        pub struct WAITEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Values inside the FMC_BWTR are taken into account"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAITEN_A::DISABLED)
            }
            #[doc = "NWAIT signal enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAITEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "WREN\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WREN_A {
            #[doc = "0: Write operations disabled for the bank by the FMC"]
            DISABLED = 0,
            #[doc = "1: Write operations enabled for the bank by the FMC"]
            ENABLED = 1,
        }
        impl From<WREN_A> for bool {
            #[inline(always)]
            fn from(variant: WREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WREN`"]
        pub type WREN_R = crate::R<bool, WREN_A>;
        impl WREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WREN_A {
                match self.bits {
                    false => WREN_A::DISABLED,
                    true => WREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WREN`"]
        pub struct WREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Write operations disabled for the bank by the FMC"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WREN_A::DISABLED)
            }
            #[doc = "Write operations enabled for the bank by the FMC"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "WAITCFG\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITCFG_A {
            #[doc = "0: NWAIT signal is active one data cycle before wait state"]
            BEFOREWAITSTATE = 0,
            #[doc = "1: NWAIT signal is active during wait state"]
            DURINGWAITSTATE = 1,
        }
        impl From<WAITCFG_A> for bool {
            #[inline(always)]
            fn from(variant: WAITCFG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAITCFG`"]
        pub type WAITCFG_R = crate::R<bool, WAITCFG_A>;
        impl WAITCFG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAITCFG_A {
                match self.bits {
                    false => WAITCFG_A::BEFOREWAITSTATE,
                    true => WAITCFG_A::DURINGWAITSTATE,
                }
            }
            #[doc = "Checks if the value of the field is `BEFOREWAITSTATE`"]
            #[inline(always)]
            pub fn is_before_wait_state(&self) -> bool {
                *self == WAITCFG_A::BEFOREWAITSTATE
            }
            #[doc = "Checks if the value of the field is `DURINGWAITSTATE`"]
            #[inline(always)]
            pub fn is_during_wait_state(&self) -> bool {
                *self == WAITCFG_A::DURINGWAITSTATE
            }
        }
        #[doc = "Write proxy for field `WAITCFG`"]
        pub struct WAITCFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITCFG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITCFG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NWAIT signal is active one data cycle before wait state"]
            #[inline(always)]
            pub fn before_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::BEFOREWAITSTATE)
            }
            #[doc = "NWAIT signal is active during wait state"]
            #[inline(always)]
            pub fn during_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::DURINGWAITSTATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `WRAPMOD`"]
        pub type WRAPMOD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `WRAPMOD`"]
        pub struct WRAPMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRAPMOD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "WAITPOL\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITPOL_A {
            #[doc = "0: NWAIT active low"]
            ACTIVELOW = 0,
            #[doc = "1: NWAIT active high"]
            ACTIVEHIGH = 1,
        }
        impl From<WAITPOL_A> for bool {
            #[inline(always)]
            fn from(variant: WAITPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAITPOL`"]
        pub type WAITPOL_R = crate::R<bool, WAITPOL_A>;
        impl WAITPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAITPOL_A {
                match self.bits {
                    false => WAITPOL_A::ACTIVELOW,
                    true => WAITPOL_A::ACTIVEHIGH,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVELOW`"]
            #[inline(always)]
            pub fn is_active_low(&self) -> bool {
                *self == WAITPOL_A::ACTIVELOW
            }
            #[doc = "Checks if the value of the field is `ACTIVEHIGH`"]
            #[inline(always)]
            pub fn is_active_high(&self) -> bool {
                *self == WAITPOL_A::ACTIVEHIGH
            }
        }
        #[doc = "Write proxy for field `WAITPOL`"]
        pub struct WAITPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAITPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NWAIT active low"]
            #[inline(always)]
            pub fn active_low(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVELOW)
            }
            #[doc = "NWAIT active high"]
            #[inline(always)]
            pub fn active_high(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVEHIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "BURSTEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BURSTEN_A {
            #[doc = "0: Burst mode disabled"]
            DISABLED = 0,
            #[doc = "1: Burst mode enabled"]
            ENABLED = 1,
        }
        impl From<BURSTEN_A> for bool {
            #[inline(always)]
            fn from(variant: BURSTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BURSTEN`"]
        pub type BURSTEN_R = crate::R<bool, BURSTEN_A>;
        impl BURSTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BURSTEN_A {
                match self.bits {
                    false => BURSTEN_A::DISABLED,
                    true => BURSTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BURSTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BURSTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `BURSTEN`"]
        pub struct BURSTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BURSTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BURSTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Burst mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::DISABLED)
            }
            #[doc = "Burst mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "FACCEN\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FACCEN_A {
            #[doc = "0: Corresponding NOR Flash memory access is disabled"]
            DISABLED = 0,
            #[doc = "1: Corresponding NOR Flash memory access is enabled"]
            ENABLED = 1,
        }
        impl From<FACCEN_A> for bool {
            #[inline(always)]
            fn from(variant: FACCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FACCEN`"]
        pub type FACCEN_R = crate::R<bool, FACCEN_A>;
        impl FACCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FACCEN_A {
                match self.bits {
                    false => FACCEN_A::DISABLED,
                    true => FACCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == FACCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == FACCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `FACCEN`"]
        pub struct FACCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FACCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FACCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Corresponding NOR Flash memory access is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FACCEN_A::DISABLED)
            }
            #[doc = "Corresponding NOR Flash memory access is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FACCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "MWID\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MWID_A {
            #[doc = "0: Memory data bus width 8 bits"]
            BITS8 = 0,
            #[doc = "1: Memory data bus width 16 bits"]
            BITS16 = 1,
            #[doc = "2: Memory data bus width 32 bits"]
            BITS32 = 2,
        }
        impl From<MWID_A> for u8 {
            #[inline(always)]
            fn from(variant: MWID_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MWID`"]
        pub type MWID_R = crate::R<u8, MWID_A>;
        impl MWID_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MWID_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MWID_A::BITS8),
                    1 => Val(MWID_A::BITS16),
                    2 => Val(MWID_A::BITS32),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `BITS8`"]
            #[inline(always)]
            pub fn is_bits8(&self) -> bool {
                *self == MWID_A::BITS8
            }
            #[doc = "Checks if the value of the field is `BITS16`"]
            #[inline(always)]
            pub fn is_bits16(&self) -> bool {
                *self == MWID_A::BITS16
            }
            #[doc = "Checks if the value of the field is `BITS32`"]
            #[inline(always)]
            pub fn is_bits32(&self) -> bool {
                *self == MWID_A::BITS32
            }
        }
        #[doc = "Write proxy for field `MWID`"]
        pub struct MWID_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MWID_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MWID_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Memory data bus width 8 bits"]
            #[inline(always)]
            pub fn bits8(self) -> &'a mut W {
                self.variant(MWID_A::BITS8)
            }
            #[doc = "Memory data bus width 16 bits"]
            #[inline(always)]
            pub fn bits16(self) -> &'a mut W {
                self.variant(MWID_A::BITS16)
            }
            #[doc = "Memory data bus width 32 bits"]
            #[inline(always)]
            pub fn bits32(self) -> &'a mut W {
                self.variant(MWID_A::BITS32)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "MTYP\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MTYP_A {
            #[doc = "0: SRAM memory type"]
            SRAM = 0,
            #[doc = "1: PSRAM (CRAM) memory type"]
            PSRAM = 1,
            #[doc = "2: NOR Flash/OneNAND Flash"]
            FLASH = 2,
        }
        impl From<MTYP_A> for u8 {
            #[inline(always)]
            fn from(variant: MTYP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MTYP`"]
        pub type MTYP_R = crate::R<u8, MTYP_A>;
        impl MTYP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MTYP_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MTYP_A::SRAM),
                    1 => Val(MTYP_A::PSRAM),
                    2 => Val(MTYP_A::FLASH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SRAM`"]
            #[inline(always)]
            pub fn is_sram(&self) -> bool {
                *self == MTYP_A::SRAM
            }
            #[doc = "Checks if the value of the field is `PSRAM`"]
            #[inline(always)]
            pub fn is_psram(&self) -> bool {
                *self == MTYP_A::PSRAM
            }
            #[doc = "Checks if the value of the field is `FLASH`"]
            #[inline(always)]
            pub fn is_flash(&self) -> bool {
                *self == MTYP_A::FLASH
            }
        }
        #[doc = "Write proxy for field `MTYP`"]
        pub struct MTYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MTYP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MTYP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "SRAM memory type"]
            #[inline(always)]
            pub fn sram(self) -> &'a mut W {
                self.variant(MTYP_A::SRAM)
            }
            #[doc = "PSRAM (CRAM) memory type"]
            #[inline(always)]
            pub fn psram(self) -> &'a mut W {
                self.variant(MTYP_A::PSRAM)
            }
            #[doc = "NOR Flash/OneNAND Flash"]
            #[inline(always)]
            pub fn flash(self) -> &'a mut W {
                self.variant(MTYP_A::FLASH)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "MUXEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXEN_A {
            #[doc = "0: Address/Data non-multiplexed"]
            DISABLED = 0,
            #[doc = "1: Address/Data multiplexed on databus"]
            ENABLED = 1,
        }
        impl From<MUXEN_A> for bool {
            #[inline(always)]
            fn from(variant: MUXEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MUXEN`"]
        pub type MUXEN_R = crate::R<bool, MUXEN_A>;
        impl MUXEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MUXEN_A {
                match self.bits {
                    false => MUXEN_A::DISABLED,
                    true => MUXEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MUXEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MUXEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MUXEN`"]
        pub struct MUXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MUXEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MUXEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Address/Data non-multiplexed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MUXEN_A::DISABLED)
            }
            #[doc = "Address/Data multiplexed on databus"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MUXEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "MBKEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MBKEN_A {
            #[doc = "0: Corresponding memory bank is disabled"]
            DISABLED = 0,
            #[doc = "1: Corresponding memory bank is enabled"]
            ENABLED = 1,
        }
        impl From<MBKEN_A> for bool {
            #[inline(always)]
            fn from(variant: MBKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MBKEN`"]
        pub type MBKEN_R = crate::R<bool, MBKEN_A>;
        impl MBKEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MBKEN_A {
                match self.bits {
                    false => MBKEN_A::DISABLED,
                    true => MBKEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MBKEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MBKEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MBKEN`"]
        pub struct MBKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MBKEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MBKEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Corresponding memory bank is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MBKEN_A::DISABLED)
            }
            #[doc = "Corresponding memory bank is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MBKEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "CRAM page size\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CPSIZE_A {
            #[doc = "0: No burst split when crossing page boundary"]
            NOBURSTSPLIT = 0,
            #[doc = "1: 128 bytes CRAM page size"]
            BYTES128 = 1,
            #[doc = "2: 256 bytes CRAM page size"]
            BYTES256 = 2,
            #[doc = "3: 512 bytes CRAM page size"]
            BYTES512 = 3,
            #[doc = "4: 1024 bytes CRAM page size"]
            BYTES1024 = 4,
        }
        impl From<CPSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: CPSIZE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CPSIZE`"]
        pub type CPSIZE_R = crate::R<u8, CPSIZE_A>;
        impl CPSIZE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CPSIZE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CPSIZE_A::NOBURSTSPLIT),
                    1 => Val(CPSIZE_A::BYTES128),
                    2 => Val(CPSIZE_A::BYTES256),
                    3 => Val(CPSIZE_A::BYTES512),
                    4 => Val(CPSIZE_A::BYTES1024),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOBURSTSPLIT`"]
            #[inline(always)]
            pub fn is_no_burst_split(&self) -> bool {
                *self == CPSIZE_A::NOBURSTSPLIT
            }
            #[doc = "Checks if the value of the field is `BYTES128`"]
            #[inline(always)]
            pub fn is_bytes128(&self) -> bool {
                *self == CPSIZE_A::BYTES128
            }
            #[doc = "Checks if the value of the field is `BYTES256`"]
            #[inline(always)]
            pub fn is_bytes256(&self) -> bool {
                *self == CPSIZE_A::BYTES256
            }
            #[doc = "Checks if the value of the field is `BYTES512`"]
            #[inline(always)]
            pub fn is_bytes512(&self) -> bool {
                *self == CPSIZE_A::BYTES512
            }
            #[doc = "Checks if the value of the field is `BYTES1024`"]
            #[inline(always)]
            pub fn is_bytes1024(&self) -> bool {
                *self == CPSIZE_A::BYTES1024
            }
        }
        #[doc = "Write proxy for field `CPSIZE`"]
        pub struct CPSIZE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPSIZE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPSIZE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No burst split when crossing page boundary"]
            #[inline(always)]
            pub fn no_burst_split(self) -> &'a mut W {
                self.variant(CPSIZE_A::NOBURSTSPLIT)
            }
            #[doc = "128 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes128(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES128)
            }
            #[doc = "256 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes256(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES256)
            }
            #[doc = "512 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes512(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES512)
            }
            #[doc = "1024 bytes CRAM page size"]
            #[inline(always)]
            pub fn bytes1024(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES1024)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 16)) | (((value as u32) & 0x07) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 19 - CBURSTRW"]
            #[inline(always)]
            pub fn cburstrw(&self) -> CBURSTRW_R {
                CBURSTRW_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 15 - ASYNCWAIT"]
            #[inline(always)]
            pub fn asyncwait(&self) -> ASYNCWAIT_R {
                ASYNCWAIT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - EXTMOD"]
            #[inline(always)]
            pub fn extmod(&self) -> EXTMOD_R {
                EXTMOD_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - WAITEN"]
            #[inline(always)]
            pub fn waiten(&self) -> WAITEN_R {
                WAITEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - WREN"]
            #[inline(always)]
            pub fn wren(&self) -> WREN_R {
                WREN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - WAITCFG"]
            #[inline(always)]
            pub fn waitcfg(&self) -> WAITCFG_R {
                WAITCFG_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - WRAPMOD"]
            #[inline(always)]
            pub fn wrapmod(&self) -> WRAPMOD_R {
                WRAPMOD_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - WAITPOL"]
            #[inline(always)]
            pub fn waitpol(&self) -> WAITPOL_R {
                WAITPOL_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - BURSTEN"]
            #[inline(always)]
            pub fn bursten(&self) -> BURSTEN_R {
                BURSTEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - FACCEN"]
            #[inline(always)]
            pub fn faccen(&self) -> FACCEN_R {
                FACCEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bits 4:5 - MWID"]
            #[inline(always)]
            pub fn mwid(&self) -> MWID_R {
                MWID_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - MTYP"]
            #[inline(always)]
            pub fn mtyp(&self) -> MTYP_R {
                MTYP_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bit 1 - MUXEN"]
            #[inline(always)]
            pub fn muxen(&self) -> MUXEN_R {
                MUXEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - MBKEN"]
            #[inline(always)]
            pub fn mbken(&self) -> MBKEN_R {
                MBKEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 16:18 - CRAM page size"]
            #[inline(always)]
            pub fn cpsize(&self) -> CPSIZE_R {
                CPSIZE_R::new(((self.bits >> 16) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 19 - CBURSTRW"]
            #[inline(always)]
            pub fn cburstrw(&mut self) -> CBURSTRW_W {
                CBURSTRW_W { w: self }
            }
            #[doc = "Bit 15 - ASYNCWAIT"]
            #[inline(always)]
            pub fn asyncwait(&mut self) -> ASYNCWAIT_W {
                ASYNCWAIT_W { w: self }
            }
            #[doc = "Bit 14 - EXTMOD"]
            #[inline(always)]
            pub fn extmod(&mut self) -> EXTMOD_W {
                EXTMOD_W { w: self }
            }
            #[doc = "Bit 13 - WAITEN"]
            #[inline(always)]
            pub fn waiten(&mut self) -> WAITEN_W {
                WAITEN_W { w: self }
            }
            #[doc = "Bit 12 - WREN"]
            #[inline(always)]
            pub fn wren(&mut self) -> WREN_W {
                WREN_W { w: self }
            }
            #[doc = "Bit 11 - WAITCFG"]
            #[inline(always)]
            pub fn waitcfg(&mut self) -> WAITCFG_W {
                WAITCFG_W { w: self }
            }
            #[doc = "Bit 10 - WRAPMOD"]
            #[inline(always)]
            pub fn wrapmod(&mut self) -> WRAPMOD_W {
                WRAPMOD_W { w: self }
            }
            #[doc = "Bit 9 - WAITPOL"]
            #[inline(always)]
            pub fn waitpol(&mut self) -> WAITPOL_W {
                WAITPOL_W { w: self }
            }
            #[doc = "Bit 8 - BURSTEN"]
            #[inline(always)]
            pub fn bursten(&mut self) -> BURSTEN_W {
                BURSTEN_W { w: self }
            }
            #[doc = "Bit 6 - FACCEN"]
            #[inline(always)]
            pub fn faccen(&mut self) -> FACCEN_W {
                FACCEN_W { w: self }
            }
            #[doc = "Bits 4:5 - MWID"]
            #[inline(always)]
            pub fn mwid(&mut self) -> MWID_W {
                MWID_W { w: self }
            }
            #[doc = "Bits 2:3 - MTYP"]
            #[inline(always)]
            pub fn mtyp(&mut self) -> MTYP_W {
                MTYP_W { w: self }
            }
            #[doc = "Bit 1 - MUXEN"]
            #[inline(always)]
            pub fn muxen(&mut self) -> MUXEN_W {
                MUXEN_W { w: self }
            }
            #[doc = "Bit 0 - MBKEN"]
            #[inline(always)]
            pub fn mbken(&mut self) -> MBKEN_W {
                MBKEN_W { w: self }
            }
            #[doc = "Bits 16:18 - CRAM page size"]
            #[inline(always)]
            pub fn cpsize(&mut self) -> CPSIZE_W {
                CPSIZE_W { w: self }
            }
        }
    }
    #[doc = "SRAM/NOR-Flash write timing registers 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bwtr](bwtr) module"]
    pub type BWTR = crate::Reg<u32, _BWTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BWTR;
    #[doc = "`read()` method returns [bwtr::R](bwtr::R) reader structure"]
    impl crate::Readable for BWTR {}
    #[doc = "`write(|w| ..)` method takes [bwtr::W](bwtr::W) writer structure"]
    impl crate::Writable for BWTR {}
    #[doc = "SRAM/NOR-Flash write timing registers 1"]
    pub mod bwtr {
        #[doc = "Reader of register BWTR%s"]
        pub type R = crate::R<u32, super::BWTR>;
        #[doc = "Writer for register BWTR%s"]
        pub type W = crate::W<u32, super::BWTR>;
        #[doc = "Register BWTR%s `reset()`'s with value 0x0fff_ffff"]
        impl crate::ResetValue for super::BWTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0fff_ffff
            }
        }
        #[doc = "ACCMOD\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ACCMOD_A {
            #[doc = "0: Access mode A"]
            A = 0,
            #[doc = "1: Access mode B"]
            B = 1,
            #[doc = "2: Access mode C"]
            C = 2,
            #[doc = "3: Access mode D"]
            D = 3,
        }
        impl From<ACCMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: ACCMOD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ACCMOD`"]
        pub type ACCMOD_R = crate::R<u8, ACCMOD_A>;
        impl ACCMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ACCMOD_A {
                match self.bits {
                    0 => ACCMOD_A::A,
                    1 => ACCMOD_A::B,
                    2 => ACCMOD_A::C,
                    3 => ACCMOD_A::D,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `A`"]
            #[inline(always)]
            pub fn is_a(&self) -> bool {
                *self == ACCMOD_A::A
            }
            #[doc = "Checks if the value of the field is `B`"]
            #[inline(always)]
            pub fn is_b(&self) -> bool {
                *self == ACCMOD_A::B
            }
            #[doc = "Checks if the value of the field is `C`"]
            #[inline(always)]
            pub fn is_c(&self) -> bool {
                *self == ACCMOD_A::C
            }
            #[doc = "Checks if the value of the field is `D`"]
            #[inline(always)]
            pub fn is_d(&self) -> bool {
                *self == ACCMOD_A::D
            }
        }
        #[doc = "Write proxy for field `ACCMOD`"]
        pub struct ACCMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACCMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACCMOD_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Access mode A"]
            #[inline(always)]
            pub fn a(self) -> &'a mut W {
                self.variant(ACCMOD_A::A)
            }
            #[doc = "Access mode B"]
            #[inline(always)]
            pub fn b(self) -> &'a mut W {
                self.variant(ACCMOD_A::B)
            }
            #[doc = "Access mode C"]
            #[inline(always)]
            pub fn c(self) -> &'a mut W {
                self.variant(ACCMOD_A::C)
            }
            #[doc = "Access mode D"]
            #[inline(always)]
            pub fn d(self) -> &'a mut W {
                self.variant(ACCMOD_A::D)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Reader of field `DATLAT`"]
        pub type DATLAT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DATLAT`"]
        pub struct DATLAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATLAT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `CLKDIV`"]
        pub type CLKDIV_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CLKDIV`"]
        pub struct CLKDIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKDIV_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `DATAST`"]
        pub type DATAST_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DATAST`"]
        pub struct DATAST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATAST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `ADDHLD`"]
        pub type ADDHLD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADDHLD`"]
        pub struct ADDHLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDHLD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `ADDSET`"]
        pub type ADDSET_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADDSET`"]
        pub struct ADDSET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDSET_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `BUSTURN`"]
        pub type BUSTURN_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `BUSTURN`"]
        pub struct BUSTURN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BUSTURN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline(always)]
            pub fn accmod(&self) -> ACCMOD_R {
                ACCMOD_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline(always)]
            pub fn datlat(&self) -> DATLAT_R {
                DATLAT_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline(always)]
            pub fn clkdiv(&self) -> CLKDIV_R {
                CLKDIV_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline(always)]
            pub fn datast(&self) -> DATAST_R {
                DATAST_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline(always)]
            pub fn addhld(&self) -> ADDHLD_R {
                ADDHLD_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline(always)]
            pub fn addset(&self) -> ADDSET_R {
                ADDSET_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Bus turnaround phase duration"]
            #[inline(always)]
            pub fn busturn(&self) -> BUSTURN_R {
                BUSTURN_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline(always)]
            pub fn accmod(&mut self) -> ACCMOD_W {
                ACCMOD_W { w: self }
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline(always)]
            pub fn datlat(&mut self) -> DATLAT_W {
                DATLAT_W { w: self }
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline(always)]
            pub fn clkdiv(&mut self) -> CLKDIV_W {
                CLKDIV_W { w: self }
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline(always)]
            pub fn datast(&mut self) -> DATAST_W {
                DATAST_W { w: self }
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline(always)]
            pub fn addhld(&mut self) -> ADDHLD_W {
                ADDHLD_W { w: self }
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline(always)]
            pub fn addset(&mut self) -> ADDSET_W {
                ADDSET_W { w: self }
            }
            #[doc = "Bits 16:19 - Bus turnaround phase duration"]
            #[inline(always)]
            pub fn busturn(&mut self) -> BUSTURN_W {
                BUSTURN_W { w: self }
            }
        }
    }
}
#[doc = "Power control"]
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR {}
impl PWR {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwr::RegisterBlock {
        0x4000_7000 as *const _
    }
}
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*PWR::ptr() }
    }
}
#[doc = "Power control"]
pub mod pwr {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Power control register (PWR_CR)"]
        pub cr: CR,
        #[doc = "0x04 - Power control register (PWR_CR)"]
        pub csr: CSR,
    }
    #[doc = "Power control register (PWR_CR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Power control register (PWR_CR)"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `LPDS`"]
        pub type LPDS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `LPDS`"]
        pub struct LPDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPDS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Power Down Deep Sleep\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PDDS_A {
            #[doc = "0: Enter Stop mode when the CPU enters deepsleep"]
            STOP_MODE = 0,
            #[doc = "1: Enter Standby mode when the CPU enters deepsleep"]
            STANDBY_MODE = 1,
        }
        impl From<PDDS_A> for bool {
            #[inline(always)]
            fn from(variant: PDDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PDDS`"]
        pub type PDDS_R = crate::R<bool, PDDS_A>;
        impl PDDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PDDS_A {
                match self.bits {
                    false => PDDS_A::STOP_MODE,
                    true => PDDS_A::STANDBY_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `STOP_MODE`"]
            #[inline(always)]
            pub fn is_stop_mode(&self) -> bool {
                *self == PDDS_A::STOP_MODE
            }
            #[doc = "Checks if the value of the field is `STANDBY_MODE`"]
            #[inline(always)]
            pub fn is_standby_mode(&self) -> bool {
                *self == PDDS_A::STANDBY_MODE
            }
        }
        #[doc = "Write proxy for field `PDDS`"]
        pub struct PDDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PDDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PDDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Enter Stop mode when the CPU enters deepsleep"]
            #[inline(always)]
            pub fn stop_mode(self) -> &'a mut W {
                self.variant(PDDS_A::STOP_MODE)
            }
            #[doc = "Enter Standby mode when the CPU enters deepsleep"]
            #[inline(always)]
            pub fn standby_mode(self) -> &'a mut W {
                self.variant(PDDS_A::STANDBY_MODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CWUF`"]
        pub type CWUF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CWUF`"]
        pub struct CWUF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CWUF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CSBF`"]
        pub type CSBF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CSBF`"]
        pub struct CSBF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSBF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `PVDE`"]
        pub type PVDE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PVDE`"]
        pub struct PVDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PVDE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `PLS`"]
        pub type PLS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PLS`"]
        pub struct PLS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 5)) | (((value as u32) & 0x07) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `DBP`"]
        pub type DBP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBP`"]
        pub struct DBP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Low Power Deep Sleep"]
            #[inline(always)]
            pub fn lpds(&self) -> LPDS_R {
                LPDS_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Power Down Deep Sleep"]
            #[inline(always)]
            pub fn pdds(&self) -> PDDS_R {
                PDDS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Clear Wake-up Flag"]
            #[inline(always)]
            pub fn cwuf(&self) -> CWUF_R {
                CWUF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Clear STANDBY Flag"]
            #[inline(always)]
            pub fn csbf(&self) -> CSBF_R {
                CSBF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Power Voltage Detector Enable"]
            #[inline(always)]
            pub fn pvde(&self) -> PVDE_R {
                PVDE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 5:7 - PVD Level Selection"]
            #[inline(always)]
            pub fn pls(&self) -> PLS_R {
                PLS_R::new(((self.bits >> 5) & 0x07) as u8)
            }
            #[doc = "Bit 8 - Disable Backup Domain write protection"]
            #[inline(always)]
            pub fn dbp(&self) -> DBP_R {
                DBP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Low Power Deep Sleep"]
            #[inline(always)]
            pub fn lpds(&mut self) -> LPDS_W {
                LPDS_W { w: self }
            }
            #[doc = "Bit 1 - Power Down Deep Sleep"]
            #[inline(always)]
            pub fn pdds(&mut self) -> PDDS_W {
                PDDS_W { w: self }
            }
            #[doc = "Bit 2 - Clear Wake-up Flag"]
            #[inline(always)]
            pub fn cwuf(&mut self) -> CWUF_W {
                CWUF_W { w: self }
            }
            #[doc = "Bit 3 - Clear STANDBY Flag"]
            #[inline(always)]
            pub fn csbf(&mut self) -> CSBF_W {
                CSBF_W { w: self }
            }
            #[doc = "Bit 4 - Power Voltage Detector Enable"]
            #[inline(always)]
            pub fn pvde(&mut self) -> PVDE_W {
                PVDE_W { w: self }
            }
            #[doc = "Bits 5:7 - PVD Level Selection"]
            #[inline(always)]
            pub fn pls(&mut self) -> PLS_W {
                PLS_W { w: self }
            }
            #[doc = "Bit 8 - Disable Backup Domain write protection"]
            #[inline(always)]
            pub fn dbp(&mut self) -> DBP_W {
                DBP_W { w: self }
            }
        }
    }
    #[doc = "Power control register (PWR_CR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
    pub type CSR = crate::Reg<u32, _CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSR;
    #[doc = "`read()` method returns [csr::R](csr::R) reader structure"]
    impl crate::Readable for CSR {}
    #[doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
    impl crate::Writable for CSR {}
    #[doc = "Power control register (PWR_CR)"]
    pub mod csr {
        #[doc = "Reader of register CSR"]
        pub type R = crate::R<u32, super::CSR>;
        #[doc = "Writer for register CSR"]
        pub type W = crate::W<u32, super::CSR>;
        #[doc = "Register CSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `WUF`"]
        pub type WUF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `SBF`"]
        pub type SBF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `PVDO`"]
        pub type PVDO_R = crate::R<bool, bool>;
        #[doc = "Reader of field `EWUP`"]
        pub type EWUP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `EWUP`"]
        pub struct EWUP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWUP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Wake-Up Flag"]
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - STANDBY Flag"]
            #[inline(always)]
            pub fn sbf(&self) -> SBF_R {
                SBF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - PVD Output"]
            #[inline(always)]
            pub fn pvdo(&self) -> PVDO_R {
                PVDO_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Enable WKUP pin"]
            #[inline(always)]
            pub fn ewup(&self) -> EWUP_R {
                EWUP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 8 - Enable WKUP pin"]
            #[inline(always)]
            pub fn ewup(&mut self) -> EWUP_W {
                EWUP_W { w: self }
            }
        }
    }
}
#[doc = "Reset and clock control"]
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RCC {}
impl RCC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rcc::RegisterBlock {
        0x4002_1000 as *const _
    }
}
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*RCC::ptr() }
    }
}
#[doc = "Reset and clock control"]
pub mod rcc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Clock control register"]
        pub cr: CR,
        #[doc = "0x04 - Clock configuration register (RCC_CFGR)"]
        pub cfgr: CFGR,
        #[doc = "0x08 - Clock interrupt register (RCC_CIR)"]
        pub cir: CIR,
        #[doc = "0x0c - APB2 peripheral reset register (RCC_APB2RSTR)"]
        pub apb2rstr: APB2RSTR,
        #[doc = "0x10 - APB1 peripheral reset register (RCC_APB1RSTR)"]
        pub apb1rstr: APB1RSTR,
        #[doc = "0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)"]
        pub ahbenr: AHBENR,
        #[doc = "0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)"]
        pub apb2enr: APB2ENR,
        #[doc = "0x1c - APB1 peripheral clock enable register (RCC_APB1ENR)"]
        pub apb1enr: APB1ENR,
        #[doc = "0x20 - Backup domain control register (RCC_BDCR)"]
        pub bdcr: BDCR,
        #[doc = "0x24 - Control/status register (RCC_CSR)"]
        pub csr: CSR,
        _reserved10: [u8; 4usize],
        #[doc = "0x2c - Clock configuration register 2"]
        pub cfgr2: CFGR2,
    }
    #[doc = "Clock control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Clock control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0x83"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x83
            }
        }
        #[doc = "Internal High Speed clock enable\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSION_A {
            #[doc = "0: Clock Off"]
            OFF = 0,
            #[doc = "1: Clock On"]
            ON = 1,
        }
        impl From<HSION_A> for bool {
            #[inline(always)]
            fn from(variant: HSION_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSION`"]
        pub type HSION_R = crate::R<bool, HSION_A>;
        impl HSION_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSION_A {
                match self.bits {
                    false => HSION_A::OFF,
                    true => HSION_A::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == HSION_A::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == HSION_A::ON
            }
        }
        #[doc = "Write proxy for field `HSION`"]
        pub struct HSION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSION_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSION_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock Off"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(HSION_A::OFF)
            }
            #[doc = "Clock On"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(HSION_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Internal High Speed clock ready flag\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSIRDY_A {
            #[doc = "0: Clock not ready"]
            NOTREADY = 0,
            #[doc = "1: Clock ready"]
            READY = 1,
        }
        impl From<HSIRDY_A> for bool {
            #[inline(always)]
            fn from(variant: HSIRDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSIRDY`"]
        pub type HSIRDY_R = crate::R<bool, HSIRDY_A>;
        impl HSIRDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSIRDY_A {
                match self.bits {
                    false => HSIRDY_A::NOTREADY,
                    true => HSIRDY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == HSIRDY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == HSIRDY_A::READY
            }
        }
        #[doc = "Reader of field `HSITRIM`"]
        pub type HSITRIM_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HSITRIM`"]
        pub struct HSITRIM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSITRIM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 3)) | (((value as u32) & 0x1f) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `HSICAL`"]
        pub type HSICAL_R = crate::R<u8, u8>;
        #[doc = "External High Speed clock enable"]
        pub type HSEON_A = HSION_A;
        #[doc = "Reader of field `HSEON`"]
        pub type HSEON_R = crate::R<bool, HSION_A>;
        #[doc = "Write proxy for field `HSEON`"]
        pub struct HSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSEON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSEON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock Off"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(HSION_A::OFF)
            }
            #[doc = "Clock On"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(HSION_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "External High Speed clock ready flag"]
        pub type HSERDY_A = HSIRDY_A;
        #[doc = "Reader of field `HSERDY`"]
        pub type HSERDY_R = crate::R<bool, HSIRDY_A>;
        #[doc = "External High Speed clock Bypass\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSEBYP_A {
            #[doc = "0: HSE crystal oscillator not bypassed"]
            NOTBYPASSED = 0,
            #[doc = "1: HSE crystal oscillator bypassed with external clock"]
            BYPASSED = 1,
        }
        impl From<HSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: HSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSEBYP`"]
        pub type HSEBYP_R = crate::R<bool, HSEBYP_A>;
        impl HSEBYP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSEBYP_A {
                match self.bits {
                    false => HSEBYP_A::NOTBYPASSED,
                    true => HSEBYP_A::BYPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBYPASSED`"]
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                *self == HSEBYP_A::NOTBYPASSED
            }
            #[doc = "Checks if the value of the field is `BYPASSED`"]
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                *self == HSEBYP_A::BYPASSED
            }
        }
        #[doc = "Write proxy for field `HSEBYP`"]
        pub struct HSEBYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSEBYP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSEBYP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSE crystal oscillator not bypassed"]
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::NOTBYPASSED)
            }
            #[doc = "HSE crystal oscillator bypassed with external clock"]
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::BYPASSED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Clock Security System enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSON_A {
            #[doc = "0: Clock security system disabled (clock detector OFF)"]
            OFF = 0,
            #[doc = "1: Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"]
            ON = 1,
        }
        impl From<CSSON_A> for bool {
            #[inline(always)]
            fn from(variant: CSSON_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSON`"]
        pub type CSSON_R = crate::R<bool, CSSON_A>;
        impl CSSON_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSON_A {
                match self.bits {
                    false => CSSON_A::OFF,
                    true => CSSON_A::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == CSSON_A::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == CSSON_A::ON
            }
        }
        #[doc = "Write proxy for field `CSSON`"]
        pub struct CSSON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CSSON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock security system disabled (clock detector OFF)"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(CSSON_A::OFF)
            }
            #[doc = "Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(CSSON_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "PLL enable"]
        pub type PLLON_A = HSION_A;
        #[doc = "Reader of field `PLLON`"]
        pub type PLLON_R = crate::R<bool, HSION_A>;
        #[doc = "Write proxy for field `PLLON`"]
        pub struct PLLON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock Off"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(HSION_A::OFF)
            }
            #[doc = "Clock On"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(HSION_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "PLL clock ready flag"]
        pub type PLLRDY_A = HSIRDY_A;
        #[doc = "Reader of field `PLLRDY`"]
        pub type PLLRDY_R = crate::R<bool, HSIRDY_A>;
        impl R {
            #[doc = "Bit 0 - Internal High Speed clock enable"]
            #[inline(always)]
            pub fn hsion(&self) -> HSION_R {
                HSION_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Internal High Speed clock ready flag"]
            #[inline(always)]
            pub fn hsirdy(&self) -> HSIRDY_R {
                HSIRDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bits 3:7 - Internal High Speed clock trimming"]
            #[inline(always)]
            pub fn hsitrim(&self) -> HSITRIM_R {
                HSITRIM_R::new(((self.bits >> 3) & 0x1f) as u8)
            }
            #[doc = "Bits 8:15 - Internal High Speed clock Calibration"]
            #[inline(always)]
            pub fn hsical(&self) -> HSICAL_R {
                HSICAL_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bit 16 - External High Speed clock enable"]
            #[inline(always)]
            pub fn hseon(&self) -> HSEON_R {
                HSEON_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - External High Speed clock ready flag"]
            #[inline(always)]
            pub fn hserdy(&self) -> HSERDY_R {
                HSERDY_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - External High Speed clock Bypass"]
            #[inline(always)]
            pub fn hsebyp(&self) -> HSEBYP_R {
                HSEBYP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Clock Security System enable"]
            #[inline(always)]
            pub fn csson(&self) -> CSSON_R {
                CSSON_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 24 - PLL enable"]
            #[inline(always)]
            pub fn pllon(&self) -> PLLON_R {
                PLLON_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - PLL clock ready flag"]
            #[inline(always)]
            pub fn pllrdy(&self) -> PLLRDY_R {
                PLLRDY_R::new(((self.bits >> 25) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Internal High Speed clock enable"]
            #[inline(always)]
            pub fn hsion(&mut self) -> HSION_W {
                HSION_W { w: self }
            }
            #[doc = "Bits 3:7 - Internal High Speed clock trimming"]
            #[inline(always)]
            pub fn hsitrim(&mut self) -> HSITRIM_W {
                HSITRIM_W { w: self }
            }
            #[doc = "Bit 16 - External High Speed clock enable"]
            #[inline(always)]
            pub fn hseon(&mut self) -> HSEON_W {
                HSEON_W { w: self }
            }
            #[doc = "Bit 18 - External High Speed clock Bypass"]
            #[inline(always)]
            pub fn hsebyp(&mut self) -> HSEBYP_W {
                HSEBYP_W { w: self }
            }
            #[doc = "Bit 19 - Clock Security System enable"]
            #[inline(always)]
            pub fn csson(&mut self) -> CSSON_W {
                CSSON_W { w: self }
            }
            #[doc = "Bit 24 - PLL enable"]
            #[inline(always)]
            pub fn pllon(&mut self) -> PLLON_W {
                PLLON_W { w: self }
            }
        }
    }
    #[doc = "Clock configuration register (RCC_CFGR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr](cfgr) module"]
    pub type CFGR = crate::Reg<u32, _CFGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR;
    #[doc = "`read()` method returns [cfgr::R](cfgr::R) reader structure"]
    impl crate::Readable for CFGR {}
    #[doc = "`write(|w| ..)` method takes [cfgr::W](cfgr::W) writer structure"]
    impl crate::Writable for CFGR {}
    #[doc = "Clock configuration register (RCC_CFGR)"]
    pub mod cfgr {
        #[doc = "Reader of register CFGR"]
        pub type R = crate::R<u32, super::CFGR>;
        #[doc = "Writer for register CFGR"]
        pub type W = crate::W<u32, super::CFGR>;
        #[doc = "Register CFGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "System clock Switch\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SW_A {
            #[doc = "0: HSI selected as system clock"]
            HSI = 0,
            #[doc = "1: HSE selected as system clock"]
            HSE = 1,
            #[doc = "2: PLL selected as system clock"]
            PLL = 2,
        }
        impl From<SW_A> for u8 {
            #[inline(always)]
            fn from(variant: SW_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SW`"]
        pub type SW_R = crate::R<u8, SW_A>;
        impl SW_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, SW_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(SW_A::HSI),
                    1 => Val(SW_A::HSE),
                    2 => Val(SW_A::PLL),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == SW_A::HSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == SW_A::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == SW_A::PLL
            }
        }
        #[doc = "Write proxy for field `SW`"]
        pub struct SW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SW_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SW_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "HSI selected as system clock"]
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(SW_A::HSI)
            }
            #[doc = "HSE selected as system clock"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(SW_A::HSE)
            }
            #[doc = "PLL selected as system clock"]
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(SW_A::PLL)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "System Clock Switch Status\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SWS_A {
            #[doc = "0: HSI oscillator used as system clock"]
            HSI = 0,
            #[doc = "1: HSE oscillator used as system clock"]
            HSE = 1,
            #[doc = "2: PLL used as system clock"]
            PLL = 2,
        }
        impl From<SWS_A> for u8 {
            #[inline(always)]
            fn from(variant: SWS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SWS`"]
        pub type SWS_R = crate::R<u8, SWS_A>;
        impl SWS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, SWS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(SWS_A::HSI),
                    1 => Val(SWS_A::HSE),
                    2 => Val(SWS_A::PLL),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == SWS_A::HSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == SWS_A::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == SWS_A::PLL
            }
        }
        #[doc = "AHB prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum HPRE_A {
            #[doc = "0: SYSCLK not divided"]
            DIV1 = 0,
            #[doc = "8: SYSCLK divided by 2"]
            DIV2 = 8,
            #[doc = "9: SYSCLK divided by 4"]
            DIV4 = 9,
            #[doc = "10: SYSCLK divided by 8"]
            DIV8 = 10,
            #[doc = "11: SYSCLK divided by 16"]
            DIV16 = 11,
            #[doc = "12: SYSCLK divided by 64"]
            DIV64 = 12,
            #[doc = "13: SYSCLK divided by 128"]
            DIV128 = 13,
            #[doc = "14: SYSCLK divided by 256"]
            DIV256 = 14,
            #[doc = "15: SYSCLK divided by 512"]
            DIV512 = 15,
        }
        impl From<HPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: HPRE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `HPRE`"]
        pub type HPRE_R = crate::R<u8, HPRE_A>;
        impl HPRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, HPRE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(HPRE_A::DIV1),
                    8 => Val(HPRE_A::DIV2),
                    9 => Val(HPRE_A::DIV4),
                    10 => Val(HPRE_A::DIV8),
                    11 => Val(HPRE_A::DIV16),
                    12 => Val(HPRE_A::DIV64),
                    13 => Val(HPRE_A::DIV128),
                    14 => Val(HPRE_A::DIV256),
                    15 => Val(HPRE_A::DIV512),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == HPRE_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == HPRE_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == HPRE_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == HPRE_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == HPRE_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == HPRE_A::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == HPRE_A::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == HPRE_A::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                *self == HPRE_A::DIV512
            }
        }
        #[doc = "Write proxy for field `HPRE`"]
        pub struct HPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HPRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HPRE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "SYSCLK not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(HPRE_A::DIV1)
            }
            #[doc = "SYSCLK divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(HPRE_A::DIV2)
            }
            #[doc = "SYSCLK divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(HPRE_A::DIV4)
            }
            #[doc = "SYSCLK divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(HPRE_A::DIV8)
            }
            #[doc = "SYSCLK divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(HPRE_A::DIV16)
            }
            #[doc = "SYSCLK divided by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(HPRE_A::DIV64)
            }
            #[doc = "SYSCLK divided by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(HPRE_A::DIV128)
            }
            #[doc = "SYSCLK divided by 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(HPRE_A::DIV256)
            }
            #[doc = "SYSCLK divided by 512"]
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(HPRE_A::DIV512)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "APB Low speed prescaler (APB1)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PPRE1_A {
            #[doc = "0: HCLK not divided"]
            DIV1 = 0,
            #[doc = "4: HCLK divided by 2"]
            DIV2 = 4,
            #[doc = "5: HCLK divided by 4"]
            DIV4 = 5,
            #[doc = "6: HCLK divided by 8"]
            DIV8 = 6,
            #[doc = "7: HCLK divided by 16"]
            DIV16 = 7,
        }
        impl From<PPRE1_A> for u8 {
            #[inline(always)]
            fn from(variant: PPRE1_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PPRE1`"]
        pub type PPRE1_R = crate::R<u8, PPRE1_A>;
        impl PPRE1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PPRE1_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(PPRE1_A::DIV1),
                    4 => Val(PPRE1_A::DIV2),
                    5 => Val(PPRE1_A::DIV4),
                    6 => Val(PPRE1_A::DIV8),
                    7 => Val(PPRE1_A::DIV16),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PPRE1_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PPRE1_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PPRE1_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PPRE1_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PPRE1_A::DIV16
            }
        }
        #[doc = "Write proxy for field `PPRE1`"]
        pub struct PPRE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PPRE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PPRE1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "HCLK not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV1)
            }
            #[doc = "HCLK divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV2)
            }
            #[doc = "HCLK divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV4)
            }
            #[doc = "HCLK divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV8)
            }
            #[doc = "HCLK divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 8)) | (((value as u32) & 0x07) << 8);
                self.w
            }
        }
        #[doc = "APB High speed prescaler (APB2)"]
        pub type PPRE2_A = PPRE1_A;
        #[doc = "Reader of field `PPRE2`"]
        pub type PPRE2_R = crate::R<u8, PPRE1_A>;
        #[doc = "Write proxy for field `PPRE2`"]
        pub struct PPRE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PPRE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PPRE2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "HCLK not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV1)
            }
            #[doc = "HCLK divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV2)
            }
            #[doc = "HCLK divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV4)
            }
            #[doc = "HCLK divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV8)
            }
            #[doc = "HCLK divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 11)) | (((value as u32) & 0x07) << 11);
                self.w
            }
        }
        #[doc = "ADC prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ADCPRE_A {
            #[doc = "0: PCLK2 divided by 2"]
            DIV2 = 0,
            #[doc = "1: PCLK2 divided by 4"]
            DIV4 = 1,
            #[doc = "2: PCLK2 divided by 8"]
            DIV6 = 2,
            #[doc = "3: PCLK2 divided by 16"]
            DIV8 = 3,
        }
        impl From<ADCPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: ADCPRE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ADCPRE`"]
        pub type ADCPRE_R = crate::R<u8, ADCPRE_A>;
        impl ADCPRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADCPRE_A {
                match self.bits {
                    0 => ADCPRE_A::DIV2,
                    1 => ADCPRE_A::DIV4,
                    2 => ADCPRE_A::DIV6,
                    3 => ADCPRE_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ADCPRE_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ADCPRE_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV6`"]
            #[inline(always)]
            pub fn is_div6(&self) -> bool {
                *self == ADCPRE_A::DIV6
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ADCPRE_A::DIV8
            }
        }
        #[doc = "Write proxy for field `ADCPRE`"]
        pub struct ADCPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADCPRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADCPRE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "PCLK2 divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV2)
            }
            #[doc = "PCLK2 divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV4)
            }
            #[doc = "PCLK2 divided by 8"]
            #[inline(always)]
            pub fn div6(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV6)
            }
            #[doc = "PCLK2 divided by 16"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "PLL entry clock source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLSRC_A {
            #[doc = "0: HSI divided by 2 selected as PLL input clock"]
            HSI_DIV2 = 0,
            #[doc = "1: HSE divided by PREDIV selected as PLL input clock"]
            HSE_DIV_PREDIV = 1,
        }
        impl From<PLLSRC_A> for bool {
            #[inline(always)]
            fn from(variant: PLLSRC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PLLSRC`"]
        pub type PLLSRC_R = crate::R<bool, PLLSRC_A>;
        impl PLLSRC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLLSRC_A {
                match self.bits {
                    false => PLLSRC_A::HSI_DIV2,
                    true => PLLSRC_A::HSE_DIV_PREDIV,
                }
            }
            #[doc = "Checks if the value of the field is `HSI_DIV2`"]
            #[inline(always)]
            pub fn is_hsi_div2(&self) -> bool {
                *self == PLLSRC_A::HSI_DIV2
            }
            #[doc = "Checks if the value of the field is `HSE_DIV_PREDIV`"]
            #[inline(always)]
            pub fn is_hse_div_prediv(&self) -> bool {
                *self == PLLSRC_A::HSE_DIV_PREDIV
            }
        }
        #[doc = "Write proxy for field `PLLSRC`"]
        pub struct PLLSRC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLSRC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLSRC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSI divided by 2 selected as PLL input clock"]
            #[inline(always)]
            pub fn hsi_div2(self) -> &'a mut W {
                self.variant(PLLSRC_A::HSI_DIV2)
            }
            #[doc = "HSE divided by PREDIV selected as PLL input clock"]
            #[inline(always)]
            pub fn hse_div_prediv(self) -> &'a mut W {
                self.variant(PLLSRC_A::HSE_DIV_PREDIV)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "HSE divider for PLL entry\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLXTPRE_A {
            #[doc = "0: HSE clock not divided"]
            DIV1 = 0,
            #[doc = "1: HSE clock divided by 2"]
            DIV2 = 1,
        }
        impl From<PLLXTPRE_A> for bool {
            #[inline(always)]
            fn from(variant: PLLXTPRE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PLLXTPRE`"]
        pub type PLLXTPRE_R = crate::R<bool, PLLXTPRE_A>;
        impl PLLXTPRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLLXTPRE_A {
                match self.bits {
                    false => PLLXTPRE_A::DIV1,
                    true => PLLXTPRE_A::DIV2,
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PLLXTPRE_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PLLXTPRE_A::DIV2
            }
        }
        #[doc = "Write proxy for field `PLLXTPRE`"]
        pub struct PLLXTPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLXTPRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLXTPRE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSE clock not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PLLXTPRE_A::DIV1)
            }
            #[doc = "HSE clock divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PLLXTPRE_A::DIV2)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "PLL Multiplication Factor\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PLLMUL_A {
            #[doc = "0: PLL input clock x2"]
            MUL2 = 0,
            #[doc = "1: PLL input clock x3"]
            MUL3 = 1,
            #[doc = "2: PLL input clock x4"]
            MUL4 = 2,
            #[doc = "3: PLL input clock x5"]
            MUL5 = 3,
            #[doc = "4: PLL input clock x6"]
            MUL6 = 4,
            #[doc = "5: PLL input clock x7"]
            MUL7 = 5,
            #[doc = "6: PLL input clock x8"]
            MUL8 = 6,
            #[doc = "7: PLL input clock x9"]
            MUL9 = 7,
            #[doc = "8: PLL input clock x10"]
            MUL10 = 8,
            #[doc = "9: PLL input clock x11"]
            MUL11 = 9,
            #[doc = "10: PLL input clock x12"]
            MUL12 = 10,
            #[doc = "11: PLL input clock x13"]
            MUL13 = 11,
            #[doc = "12: PLL input clock x14"]
            MUL14 = 12,
            #[doc = "13: PLL input clock x15"]
            MUL15 = 13,
            #[doc = "14: PLL input clock x16"]
            MUL16 = 14,
            #[doc = "15: PLL input clock x16"]
            MUL16X = 15,
        }
        impl From<PLLMUL_A> for u8 {
            #[inline(always)]
            fn from(variant: PLLMUL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PLLMUL`"]
        pub type PLLMUL_R = crate::R<u8, PLLMUL_A>;
        impl PLLMUL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLLMUL_A {
                match self.bits {
                    0 => PLLMUL_A::MUL2,
                    1 => PLLMUL_A::MUL3,
                    2 => PLLMUL_A::MUL4,
                    3 => PLLMUL_A::MUL5,
                    4 => PLLMUL_A::MUL6,
                    5 => PLLMUL_A::MUL7,
                    6 => PLLMUL_A::MUL8,
                    7 => PLLMUL_A::MUL9,
                    8 => PLLMUL_A::MUL10,
                    9 => PLLMUL_A::MUL11,
                    10 => PLLMUL_A::MUL12,
                    11 => PLLMUL_A::MUL13,
                    12 => PLLMUL_A::MUL14,
                    13 => PLLMUL_A::MUL15,
                    14 => PLLMUL_A::MUL16,
                    15 => PLLMUL_A::MUL16X,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MUL2`"]
            #[inline(always)]
            pub fn is_mul2(&self) -> bool {
                *self == PLLMUL_A::MUL2
            }
            #[doc = "Checks if the value of the field is `MUL3`"]
            #[inline(always)]
            pub fn is_mul3(&self) -> bool {
                *self == PLLMUL_A::MUL3
            }
            #[doc = "Checks if the value of the field is `MUL4`"]
            #[inline(always)]
            pub fn is_mul4(&self) -> bool {
                *self == PLLMUL_A::MUL4
            }
            #[doc = "Checks if the value of the field is `MUL5`"]
            #[inline(always)]
            pub fn is_mul5(&self) -> bool {
                *self == PLLMUL_A::MUL5
            }
            #[doc = "Checks if the value of the field is `MUL6`"]
            #[inline(always)]
            pub fn is_mul6(&self) -> bool {
                *self == PLLMUL_A::MUL6
            }
            #[doc = "Checks if the value of the field is `MUL7`"]
            #[inline(always)]
            pub fn is_mul7(&self) -> bool {
                *self == PLLMUL_A::MUL7
            }
            #[doc = "Checks if the value of the field is `MUL8`"]
            #[inline(always)]
            pub fn is_mul8(&self) -> bool {
                *self == PLLMUL_A::MUL8
            }
            #[doc = "Checks if the value of the field is `MUL9`"]
            #[inline(always)]
            pub fn is_mul9(&self) -> bool {
                *self == PLLMUL_A::MUL9
            }
            #[doc = "Checks if the value of the field is `MUL10`"]
            #[inline(always)]
            pub fn is_mul10(&self) -> bool {
                *self == PLLMUL_A::MUL10
            }
            #[doc = "Checks if the value of the field is `MUL11`"]
            #[inline(always)]
            pub fn is_mul11(&self) -> bool {
                *self == PLLMUL_A::MUL11
            }
            #[doc = "Checks if the value of the field is `MUL12`"]
            #[inline(always)]
            pub fn is_mul12(&self) -> bool {
                *self == PLLMUL_A::MUL12
            }
            #[doc = "Checks if the value of the field is `MUL13`"]
            #[inline(always)]
            pub fn is_mul13(&self) -> bool {
                *self == PLLMUL_A::MUL13
            }
            #[doc = "Checks if the value of the field is `MUL14`"]
            #[inline(always)]
            pub fn is_mul14(&self) -> bool {
                *self == PLLMUL_A::MUL14
            }
            #[doc = "Checks if the value of the field is `MUL15`"]
            #[inline(always)]
            pub fn is_mul15(&self) -> bool {
                *self == PLLMUL_A::MUL15
            }
            #[doc = "Checks if the value of the field is `MUL16`"]
            #[inline(always)]
            pub fn is_mul16(&self) -> bool {
                *self == PLLMUL_A::MUL16
            }
            #[doc = "Checks if the value of the field is `MUL16X`"]
            #[inline(always)]
            pub fn is_mul16x(&self) -> bool {
                *self == PLLMUL_A::MUL16X
            }
        }
        #[doc = "Write proxy for field `PLLMUL`"]
        pub struct PLLMUL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLMUL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLMUL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "PLL input clock x2"]
            #[inline(always)]
            pub fn mul2(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL2)
            }
            #[doc = "PLL input clock x3"]
            #[inline(always)]
            pub fn mul3(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL3)
            }
            #[doc = "PLL input clock x4"]
            #[inline(always)]
            pub fn mul4(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL4)
            }
            #[doc = "PLL input clock x5"]
            #[inline(always)]
            pub fn mul5(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL5)
            }
            #[doc = "PLL input clock x6"]
            #[inline(always)]
            pub fn mul6(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL6)
            }
            #[doc = "PLL input clock x7"]
            #[inline(always)]
            pub fn mul7(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL7)
            }
            #[doc = "PLL input clock x8"]
            #[inline(always)]
            pub fn mul8(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL8)
            }
            #[doc = "PLL input clock x9"]
            #[inline(always)]
            pub fn mul9(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL9)
            }
            #[doc = "PLL input clock x10"]
            #[inline(always)]
            pub fn mul10(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL10)
            }
            #[doc = "PLL input clock x11"]
            #[inline(always)]
            pub fn mul11(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL11)
            }
            #[doc = "PLL input clock x12"]
            #[inline(always)]
            pub fn mul12(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL12)
            }
            #[doc = "PLL input clock x13"]
            #[inline(always)]
            pub fn mul13(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL13)
            }
            #[doc = "PLL input clock x14"]
            #[inline(always)]
            pub fn mul14(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL14)
            }
            #[doc = "PLL input clock x15"]
            #[inline(always)]
            pub fn mul15(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL15)
            }
            #[doc = "PLL input clock x16"]
            #[inline(always)]
            pub fn mul16(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL16)
            }
            #[doc = "PLL input clock x16"]
            #[inline(always)]
            pub fn mul16x(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL16X)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 18)) | (((value as u32) & 0x0f) << 18);
                self.w
            }
        }
        #[doc = "Microcontroller clock output\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MCO_A {
            #[doc = "0: MCO output disabled, no clock on MCO"]
            NOMCO = 0,
            #[doc = "4: System clock selected"]
            SYSCLK = 4,
            #[doc = "5: HSI oscillator clock selected"]
            HSI = 5,
            #[doc = "6: HSE oscillator clock selected"]
            HSE = 6,
            #[doc = "7: PLL clock selected (divided by 1 or 2, depending en PLLNODIV)"]
            PLL = 7,
        }
        impl From<MCO_A> for u8 {
            #[inline(always)]
            fn from(variant: MCO_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MCO`"]
        pub type MCO_R = crate::R<u8, MCO_A>;
        impl MCO_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MCO_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MCO_A::NOMCO),
                    4 => Val(MCO_A::SYSCLK),
                    5 => Val(MCO_A::HSI),
                    6 => Val(MCO_A::HSE),
                    7 => Val(MCO_A::PLL),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOMCO`"]
            #[inline(always)]
            pub fn is_no_mco(&self) -> bool {
                *self == MCO_A::NOMCO
            }
            #[doc = "Checks if the value of the field is `SYSCLK`"]
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                *self == MCO_A::SYSCLK
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == MCO_A::HSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == MCO_A::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == MCO_A::PLL
            }
        }
        #[doc = "Write proxy for field `MCO`"]
        pub struct MCO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MCO_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MCO_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "MCO output disabled, no clock on MCO"]
            #[inline(always)]
            pub fn no_mco(self) -> &'a mut W {
                self.variant(MCO_A::NOMCO)
            }
            #[doc = "System clock selected"]
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut W {
                self.variant(MCO_A::SYSCLK)
            }
            #[doc = "HSI oscillator clock selected"]
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(MCO_A::HSI)
            }
            #[doc = "HSE oscillator clock selected"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(MCO_A::HSE)
            }
            #[doc = "PLL clock selected (divided by 1 or 2, depending en PLLNODIV)"]
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(MCO_A::PLL)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | (((value as u32) & 0x07) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - System clock Switch"]
            #[inline(always)]
            pub fn sw(&self) -> SW_R {
                SW_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - System Clock Switch Status"]
            #[inline(always)]
            pub fn sws(&self) -> SWS_R {
                SWS_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline(always)]
            pub fn hpre(&self) -> HPRE_R {
                HPRE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
            #[inline(always)]
            pub fn ppre1(&self) -> PPRE1_R {
                PPRE1_R::new(((self.bits >> 8) & 0x07) as u8)
            }
            #[doc = "Bits 11:13 - APB High speed prescaler (APB2)"]
            #[inline(always)]
            pub fn ppre2(&self) -> PPRE2_R {
                PPRE2_R::new(((self.bits >> 11) & 0x07) as u8)
            }
            #[doc = "Bits 14:15 - ADC prescaler"]
            #[inline(always)]
            pub fn adcpre(&self) -> ADCPRE_R {
                ADCPRE_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline(always)]
            pub fn pllsrc(&self) -> PLLSRC_R {
                PLLSRC_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - HSE divider for PLL entry"]
            #[inline(always)]
            pub fn pllxtpre(&self) -> PLLXTPRE_R {
                PLLXTPRE_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bits 18:21 - PLL Multiplication Factor"]
            #[inline(always)]
            pub fn pllmul(&self) -> PLLMUL_R {
                PLLMUL_R::new(((self.bits >> 18) & 0x0f) as u8)
            }
            #[doc = "Bits 24:26 - Microcontroller clock output"]
            #[inline(always)]
            pub fn mco(&self) -> MCO_R {
                MCO_R::new(((self.bits >> 24) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - System clock Switch"]
            #[inline(always)]
            pub fn sw(&mut self) -> SW_W {
                SW_W { w: self }
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline(always)]
            pub fn hpre(&mut self) -> HPRE_W {
                HPRE_W { w: self }
            }
            #[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
            #[inline(always)]
            pub fn ppre1(&mut self) -> PPRE1_W {
                PPRE1_W { w: self }
            }
            #[doc = "Bits 11:13 - APB High speed prescaler (APB2)"]
            #[inline(always)]
            pub fn ppre2(&mut self) -> PPRE2_W {
                PPRE2_W { w: self }
            }
            #[doc = "Bits 14:15 - ADC prescaler"]
            #[inline(always)]
            pub fn adcpre(&mut self) -> ADCPRE_W {
                ADCPRE_W { w: self }
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline(always)]
            pub fn pllsrc(&mut self) -> PLLSRC_W {
                PLLSRC_W { w: self }
            }
            #[doc = "Bit 17 - HSE divider for PLL entry"]
            #[inline(always)]
            pub fn pllxtpre(&mut self) -> PLLXTPRE_W {
                PLLXTPRE_W { w: self }
            }
            #[doc = "Bits 18:21 - PLL Multiplication Factor"]
            #[inline(always)]
            pub fn pllmul(&mut self) -> PLLMUL_W {
                PLLMUL_W { w: self }
            }
            #[doc = "Bits 24:26 - Microcontroller clock output"]
            #[inline(always)]
            pub fn mco(&mut self) -> MCO_W {
                MCO_W { w: self }
            }
        }
    }
    #[doc = "Clock interrupt register (RCC_CIR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cir](cir) module"]
    pub type CIR = crate::Reg<u32, _CIR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CIR;
    #[doc = "`read()` method returns [cir::R](cir::R) reader structure"]
    impl crate::Readable for CIR {}
    #[doc = "`write(|w| ..)` method takes [cir::W](cir::W) writer structure"]
    impl crate::Writable for CIR {}
    #[doc = "Clock interrupt register (RCC_CIR)"]
    pub mod cir {
        #[doc = "Reader of register CIR"]
        pub type R = crate::R<u32, super::CIR>;
        #[doc = "Writer for register CIR"]
        pub type W = crate::W<u32, super::CIR>;
        #[doc = "Register CIR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CIR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "LSI Ready Interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYF_A {
            #[doc = "0: No clock ready interrupt"]
            NOTINTERRUPTED = 0,
            #[doc = "1: Clock ready interrupt"]
            INTERRUPTED = 1,
        }
        impl From<LSIRDYF_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSIRDYF`"]
        pub type LSIRDYF_R = crate::R<bool, LSIRDYF_A>;
        impl LSIRDYF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYF_A {
                match self.bits {
                    false => LSIRDYF_A::NOTINTERRUPTED,
                    true => LSIRDYF_A::INTERRUPTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINTERRUPTED`"]
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == LSIRDYF_A::NOTINTERRUPTED
            }
            #[doc = "Checks if the value of the field is `INTERRUPTED`"]
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == LSIRDYF_A::INTERRUPTED
            }
        }
        #[doc = "LSE Ready Interrupt flag"]
        pub type LSERDYF_A = LSIRDYF_A;
        #[doc = "Reader of field `LSERDYF`"]
        pub type LSERDYF_R = crate::R<bool, LSIRDYF_A>;
        #[doc = "HSI Ready Interrupt flag"]
        pub type HSIRDYF_A = LSIRDYF_A;
        #[doc = "Reader of field `HSIRDYF`"]
        pub type HSIRDYF_R = crate::R<bool, LSIRDYF_A>;
        #[doc = "HSE Ready Interrupt flag"]
        pub type HSERDYF_A = LSIRDYF_A;
        #[doc = "Reader of field `HSERDYF`"]
        pub type HSERDYF_R = crate::R<bool, LSIRDYF_A>;
        #[doc = "PLL Ready Interrupt flag"]
        pub type PLLRDYF_A = LSIRDYF_A;
        #[doc = "Reader of field `PLLRDYF`"]
        pub type PLLRDYF_R = crate::R<bool, LSIRDYF_A>;
        #[doc = "Clock Security System Interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSF_A {
            #[doc = "0: No clock security interrupt caused by HSE clock failure"]
            NOTINTERRUPTED = 0,
            #[doc = "1: Clock security interrupt caused by HSE clock failure"]
            INTERRUPTED = 1,
        }
        impl From<CSSF_A> for bool {
            #[inline(always)]
            fn from(variant: CSSF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSF`"]
        pub type CSSF_R = crate::R<bool, CSSF_A>;
        impl CSSF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSF_A {
                match self.bits {
                    false => CSSF_A::NOTINTERRUPTED,
                    true => CSSF_A::INTERRUPTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINTERRUPTED`"]
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == CSSF_A::NOTINTERRUPTED
            }
            #[doc = "Checks if the value of the field is `INTERRUPTED`"]
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == CSSF_A::INTERRUPTED
            }
        }
        #[doc = "LSI Ready Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYIE_A {
            #[doc = "0: Interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt enabled"]
            ENABLED = 1,
        }
        impl From<LSIRDYIE_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSIRDYIE`"]
        pub type LSIRDYIE_R = crate::R<bool, LSIRDYIE_A>;
        impl LSIRDYIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYIE_A {
                match self.bits {
                    false => LSIRDYIE_A::DISABLED,
                    true => LSIRDYIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LSIRDYIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LSIRDYIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LSIRDYIE`"]
        pub struct LSIRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSIRDYIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSIRDYIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "LSE Ready Interrupt Enable"]
        pub type LSERDYIE_A = LSIRDYIE_A;
        #[doc = "Reader of field `LSERDYIE`"]
        pub type LSERDYIE_R = crate::R<bool, LSIRDYIE_A>;
        #[doc = "Write proxy for field `LSERDYIE`"]
        pub struct LSERDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSERDYIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSERDYIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "HSI Ready Interrupt Enable"]
        pub type HSIRDYIE_A = LSIRDYIE_A;
        #[doc = "Reader of field `HSIRDYIE`"]
        pub type HSIRDYIE_R = crate::R<bool, LSIRDYIE_A>;
        #[doc = "Write proxy for field `HSIRDYIE`"]
        pub struct HSIRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSIRDYIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSIRDYIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "HSE Ready Interrupt Enable"]
        pub type HSERDYIE_A = LSIRDYIE_A;
        #[doc = "Reader of field `HSERDYIE`"]
        pub type HSERDYIE_R = crate::R<bool, LSIRDYIE_A>;
        #[doc = "Write proxy for field `HSERDYIE`"]
        pub struct HSERDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSERDYIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSERDYIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "PLL Ready Interrupt Enable"]
        pub type PLLRDYIE_A = LSIRDYIE_A;
        #[doc = "Reader of field `PLLRDYIE`"]
        pub type PLLRDYIE_R = crate::R<bool, LSIRDYIE_A>;
        #[doc = "Write proxy for field `PLLRDYIE`"]
        pub struct PLLRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLRDYIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLRDYIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "LSI Ready Interrupt Clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYC_AW {
            #[doc = "1: Clear interrupt flag"]
            CLEAR = 1,
        }
        impl From<LSIRDYC_AW> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYC_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `LSIRDYC`"]
        pub struct LSIRDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSIRDYC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSIRDYC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "LSE Ready Interrupt Clear"]
        pub type LSERDYC_AW = LSIRDYC_AW;
        #[doc = "Write proxy for field `LSERDYC`"]
        pub struct LSERDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSERDYC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSERDYC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "HSI Ready Interrupt Clear"]
        pub type HSIRDYC_AW = LSIRDYC_AW;
        #[doc = "Write proxy for field `HSIRDYC`"]
        pub struct HSIRDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSIRDYC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSIRDYC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "HSE Ready Interrupt Clear"]
        pub type HSERDYC_AW = LSIRDYC_AW;
        #[doc = "Write proxy for field `HSERDYC`"]
        pub struct HSERDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSERDYC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSERDYC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "PLL Ready Interrupt Clear"]
        pub type PLLRDYC_AW = LSIRDYC_AW;
        #[doc = "Write proxy for field `PLLRDYC`"]
        pub struct PLLRDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLRDYC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLRDYC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Clock security system interrupt clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSC_AW {
            #[doc = "1: Clear CSSF flag"]
            CLEAR = 1,
        }
        impl From<CSSC_AW> for bool {
            #[inline(always)]
            fn from(variant: CSSC_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CSSC`"]
        pub struct CSSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CSSC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear CSSF flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CSSC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - LSI Ready Interrupt flag"]
            #[inline(always)]
            pub fn lsirdyf(&self) -> LSIRDYF_R {
                LSIRDYF_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - LSE Ready Interrupt flag"]
            #[inline(always)]
            pub fn lserdyf(&self) -> LSERDYF_R {
                LSERDYF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - HSI Ready Interrupt flag"]
            #[inline(always)]
            pub fn hsirdyf(&self) -> HSIRDYF_R {
                HSIRDYF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - HSE Ready Interrupt flag"]
            #[inline(always)]
            pub fn hserdyf(&self) -> HSERDYF_R {
                HSERDYF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - PLL Ready Interrupt flag"]
            #[inline(always)]
            pub fn pllrdyf(&self) -> PLLRDYF_R {
                PLLRDYF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Clock Security System Interrupt flag"]
            #[inline(always)]
            pub fn cssf(&self) -> CSSF_R {
                CSSF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - LSI Ready Interrupt Enable"]
            #[inline(always)]
            pub fn lsirdyie(&self) -> LSIRDYIE_R {
                LSIRDYIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - LSE Ready Interrupt Enable"]
            #[inline(always)]
            pub fn lserdyie(&self) -> LSERDYIE_R {
                LSERDYIE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - HSI Ready Interrupt Enable"]
            #[inline(always)]
            pub fn hsirdyie(&self) -> HSIRDYIE_R {
                HSIRDYIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - HSE Ready Interrupt Enable"]
            #[inline(always)]
            pub fn hserdyie(&self) -> HSERDYIE_R {
                HSERDYIE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - PLL Ready Interrupt Enable"]
            #[inline(always)]
            pub fn pllrdyie(&self) -> PLLRDYIE_R {
                PLLRDYIE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 8 - LSI Ready Interrupt Enable"]
            #[inline(always)]
            pub fn lsirdyie(&mut self) -> LSIRDYIE_W {
                LSIRDYIE_W { w: self }
            }
            #[doc = "Bit 9 - LSE Ready Interrupt Enable"]
            #[inline(always)]
            pub fn lserdyie(&mut self) -> LSERDYIE_W {
                LSERDYIE_W { w: self }
            }
            #[doc = "Bit 10 - HSI Ready Interrupt Enable"]
            #[inline(always)]
            pub fn hsirdyie(&mut self) -> HSIRDYIE_W {
                HSIRDYIE_W { w: self }
            }
            #[doc = "Bit 11 - HSE Ready Interrupt Enable"]
            #[inline(always)]
            pub fn hserdyie(&mut self) -> HSERDYIE_W {
                HSERDYIE_W { w: self }
            }
            #[doc = "Bit 12 - PLL Ready Interrupt Enable"]
            #[inline(always)]
            pub fn pllrdyie(&mut self) -> PLLRDYIE_W {
                PLLRDYIE_W { w: self }
            }
            #[doc = "Bit 16 - LSI Ready Interrupt Clear"]
            #[inline(always)]
            pub fn lsirdyc(&mut self) -> LSIRDYC_W {
                LSIRDYC_W { w: self }
            }
            #[doc = "Bit 17 - LSE Ready Interrupt Clear"]
            #[inline(always)]
            pub fn lserdyc(&mut self) -> LSERDYC_W {
                LSERDYC_W { w: self }
            }
            #[doc = "Bit 18 - HSI Ready Interrupt Clear"]
            #[inline(always)]
            pub fn hsirdyc(&mut self) -> HSIRDYC_W {
                HSIRDYC_W { w: self }
            }
            #[doc = "Bit 19 - HSE Ready Interrupt Clear"]
            #[inline(always)]
            pub fn hserdyc(&mut self) -> HSERDYC_W {
                HSERDYC_W { w: self }
            }
            #[doc = "Bit 20 - PLL Ready Interrupt Clear"]
            #[inline(always)]
            pub fn pllrdyc(&mut self) -> PLLRDYC_W {
                PLLRDYC_W { w: self }
            }
            #[doc = "Bit 23 - Clock security system interrupt clear"]
            #[inline(always)]
            pub fn cssc(&mut self) -> CSSC_W {
                CSSC_W { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral reset register (RCC_APB2RSTR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb2rstr](apb2rstr) module"]
    pub type APB2RSTR = crate::Reg<u32, _APB2RSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB2RSTR;
    #[doc = "`read()` method returns [apb2rstr::R](apb2rstr::R) reader structure"]
    impl crate::Readable for APB2RSTR {}
    #[doc = "`write(|w| ..)` method takes [apb2rstr::W](apb2rstr::W) writer structure"]
    impl crate::Writable for APB2RSTR {}
    #[doc = "APB2 peripheral reset register (RCC_APB2RSTR)"]
    pub mod apb2rstr {
        #[doc = "Reader of register APB2RSTR"]
        pub type R = crate::R<u32, super::APB2RSTR>;
        #[doc = "Writer for register APB2RSTR"]
        pub type W = crate::W<u32, super::APB2RSTR>;
        #[doc = "Register APB2RSTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB2RSTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alternate function I/O reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFIORST_A {
            #[doc = "1: Reset the selected module"]
            RESET = 1,
        }
        impl From<AFIORST_A> for bool {
            #[inline(always)]
            fn from(variant: AFIORST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AFIORST`"]
        pub type AFIORST_R = crate::R<bool, AFIORST_A>;
        impl AFIORST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, AFIORST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(AFIORST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == AFIORST_A::RESET
            }
        }
        #[doc = "Write proxy for field `AFIORST`"]
        pub struct AFIORST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFIORST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFIORST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "IO port A reset"]
        pub type IOPARST_A = AFIORST_A;
        #[doc = "Reader of field `IOPARST`"]
        pub type IOPARST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPARST`"]
        pub struct IOPARST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPARST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPARST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "IO port B reset"]
        pub type IOPBRST_A = AFIORST_A;
        #[doc = "Reader of field `IOPBRST`"]
        pub type IOPBRST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPBRST`"]
        pub struct IOPBRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPBRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "IO port C reset"]
        pub type IOPCRST_A = AFIORST_A;
        #[doc = "Reader of field `IOPCRST`"]
        pub type IOPCRST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPCRST`"]
        pub struct IOPCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPCRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "IO port D reset"]
        pub type IOPDRST_A = AFIORST_A;
        #[doc = "Reader of field `IOPDRST`"]
        pub type IOPDRST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPDRST`"]
        pub struct IOPDRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPDRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "IO port E reset"]
        pub type IOPERST_A = AFIORST_A;
        #[doc = "Reader of field `IOPERST`"]
        pub type IOPERST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPERST`"]
        pub struct IOPERST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPERST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPERST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "IO port F reset"]
        pub type IOPFRST_A = AFIORST_A;
        #[doc = "Reader of field `IOPFRST`"]
        pub type IOPFRST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPFRST`"]
        pub struct IOPFRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPFRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPFRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "IO port G reset"]
        pub type IOPGRST_A = AFIORST_A;
        #[doc = "Reader of field `IOPGRST`"]
        pub type IOPGRST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `IOPGRST`"]
        pub struct IOPGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPGRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPGRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "ADC 1 interface reset"]
        pub type ADC1RST_A = AFIORST_A;
        #[doc = "Reader of field `ADC1RST`"]
        pub type ADC1RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `ADC1RST`"]
        pub struct ADC1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADC1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "TIM1 timer reset"]
        pub type TIM1RST_A = AFIORST_A;
        #[doc = "Reader of field `TIM1RST`"]
        pub type TIM1RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `TIM1RST`"]
        pub struct TIM1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "SPI 1 reset"]
        pub type SPI1RST_A = AFIORST_A;
        #[doc = "Reader of field `SPI1RST`"]
        pub type SPI1RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `SPI1RST`"]
        pub struct SPI1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "USART1 reset"]
        pub type USART1RST_A = AFIORST_A;
        #[doc = "Reader of field `USART1RST`"]
        pub type USART1RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `USART1RST`"]
        pub struct USART1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "TIM15 timer reset"]
        pub type TIM15RST_A = AFIORST_A;
        #[doc = "Reader of field `TIM15RST`"]
        pub type TIM15RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `TIM15RST`"]
        pub struct TIM15RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM15RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM15RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "TIM16 timer reset"]
        pub type TIM16RST_A = AFIORST_A;
        #[doc = "Reader of field `TIM16RST`"]
        pub type TIM16RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `TIM16RST`"]
        pub struct TIM16RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM16RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM16RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "TIM17 timer reset"]
        pub type TIM17RST_A = AFIORST_A;
        #[doc = "Reader of field `TIM17RST`"]
        pub type TIM17RST_R = crate::R<bool, AFIORST_A>;
        #[doc = "Write proxy for field `TIM17RST`"]
        pub struct TIM17RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM17RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM17RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Alternate function I/O reset"]
            #[inline(always)]
            pub fn afiorst(&self) -> AFIORST_R {
                AFIORST_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 2 - IO port A reset"]
            #[inline(always)]
            pub fn ioparst(&self) -> IOPARST_R {
                IOPARST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - IO port B reset"]
            #[inline(always)]
            pub fn iopbrst(&self) -> IOPBRST_R {
                IOPBRST_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IO port C reset"]
            #[inline(always)]
            pub fn iopcrst(&self) -> IOPCRST_R {
                IOPCRST_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - IO port D reset"]
            #[inline(always)]
            pub fn iopdrst(&self) -> IOPDRST_R {
                IOPDRST_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - IO port E reset"]
            #[inline(always)]
            pub fn ioperst(&self) -> IOPERST_R {
                IOPERST_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - IO port F reset"]
            #[inline(always)]
            pub fn iopfrst(&self) -> IOPFRST_R {
                IOPFRST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - IO port G reset"]
            #[inline(always)]
            pub fn iopgrst(&self) -> IOPGRST_R {
                IOPGRST_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - ADC 1 interface reset"]
            #[inline(always)]
            pub fn adc1rst(&self) -> ADC1RST_R {
                ADC1RST_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 11 - TIM1 timer reset"]
            #[inline(always)]
            pub fn tim1rst(&self) -> TIM1RST_R {
                TIM1RST_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline(always)]
            pub fn spi1rst(&self) -> SPI1RST_R {
                SPI1RST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline(always)]
            pub fn usart1rst(&self) -> USART1RST_R {
                USART1RST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 16 - TIM15 timer reset"]
            #[inline(always)]
            pub fn tim15rst(&self) -> TIM15RST_R {
                TIM15RST_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - TIM16 timer reset"]
            #[inline(always)]
            pub fn tim16rst(&self) -> TIM16RST_R {
                TIM16RST_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - TIM17 timer reset"]
            #[inline(always)]
            pub fn tim17rst(&self) -> TIM17RST_R {
                TIM17RST_R::new(((self.bits >> 18) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Alternate function I/O reset"]
            #[inline(always)]
            pub fn afiorst(&mut self) -> AFIORST_W {
                AFIORST_W { w: self }
            }
            #[doc = "Bit 2 - IO port A reset"]
            #[inline(always)]
            pub fn ioparst(&mut self) -> IOPARST_W {
                IOPARST_W { w: self }
            }
            #[doc = "Bit 3 - IO port B reset"]
            #[inline(always)]
            pub fn iopbrst(&mut self) -> IOPBRST_W {
                IOPBRST_W { w: self }
            }
            #[doc = "Bit 4 - IO port C reset"]
            #[inline(always)]
            pub fn iopcrst(&mut self) -> IOPCRST_W {
                IOPCRST_W { w: self }
            }
            #[doc = "Bit 5 - IO port D reset"]
            #[inline(always)]
            pub fn iopdrst(&mut self) -> IOPDRST_W {
                IOPDRST_W { w: self }
            }
            #[doc = "Bit 6 - IO port E reset"]
            #[inline(always)]
            pub fn ioperst(&mut self) -> IOPERST_W {
                IOPERST_W { w: self }
            }
            #[doc = "Bit 7 - IO port F reset"]
            #[inline(always)]
            pub fn iopfrst(&mut self) -> IOPFRST_W {
                IOPFRST_W { w: self }
            }
            #[doc = "Bit 8 - IO port G reset"]
            #[inline(always)]
            pub fn iopgrst(&mut self) -> IOPGRST_W {
                IOPGRST_W { w: self }
            }
            #[doc = "Bit 9 - ADC 1 interface reset"]
            #[inline(always)]
            pub fn adc1rst(&mut self) -> ADC1RST_W {
                ADC1RST_W { w: self }
            }
            #[doc = "Bit 11 - TIM1 timer reset"]
            #[inline(always)]
            pub fn tim1rst(&mut self) -> TIM1RST_W {
                TIM1RST_W { w: self }
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline(always)]
            pub fn spi1rst(&mut self) -> SPI1RST_W {
                SPI1RST_W { w: self }
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline(always)]
            pub fn usart1rst(&mut self) -> USART1RST_W {
                USART1RST_W { w: self }
            }
            #[doc = "Bit 16 - TIM15 timer reset"]
            #[inline(always)]
            pub fn tim15rst(&mut self) -> TIM15RST_W {
                TIM15RST_W { w: self }
            }
            #[doc = "Bit 17 - TIM16 timer reset"]
            #[inline(always)]
            pub fn tim16rst(&mut self) -> TIM16RST_W {
                TIM16RST_W { w: self }
            }
            #[doc = "Bit 18 - TIM17 timer reset"]
            #[inline(always)]
            pub fn tim17rst(&mut self) -> TIM17RST_W {
                TIM17RST_W { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral reset register (RCC_APB1RSTR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb1rstr](apb1rstr) module"]
    pub type APB1RSTR = crate::Reg<u32, _APB1RSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB1RSTR;
    #[doc = "`read()` method returns [apb1rstr::R](apb1rstr::R) reader structure"]
    impl crate::Readable for APB1RSTR {}
    #[doc = "`write(|w| ..)` method takes [apb1rstr::W](apb1rstr::W) writer structure"]
    impl crate::Writable for APB1RSTR {}
    #[doc = "APB1 peripheral reset register (RCC_APB1RSTR)"]
    pub mod apb1rstr {
        #[doc = "Reader of register APB1RSTR"]
        pub type R = crate::R<u32, super::APB1RSTR>;
        #[doc = "Writer for register APB1RSTR"]
        pub type W = crate::W<u32, super::APB1RSTR>;
        #[doc = "Register APB1RSTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB1RSTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Timer 2 reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIM2RST_A {
            #[doc = "1: Reset the selected module"]
            RESET = 1,
        }
        impl From<TIM2RST_A> for bool {
            #[inline(always)]
            fn from(variant: TIM2RST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIM2RST`"]
        pub type TIM2RST_R = crate::R<bool, TIM2RST_A>;
        impl TIM2RST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, TIM2RST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(TIM2RST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == TIM2RST_A::RESET
            }
        }
        #[doc = "Write proxy for field `TIM2RST`"]
        pub struct TIM2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Timer 3 reset"]
        pub type TIM3RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM3RST`"]
        pub type TIM3RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM3RST`"]
        pub struct TIM3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM3RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Timer 4 reset"]
        pub type TIM4RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM4RST`"]
        pub type TIM4RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM4RST`"]
        pub struct TIM4RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM4RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM4RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Timer 5 reset"]
        pub type TIM5RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM5RST`"]
        pub type TIM5RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM5RST`"]
        pub struct TIM5RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM5RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM5RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Timer 6 reset"]
        pub type TIM6RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM6RST`"]
        pub type TIM6RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM6RST`"]
        pub struct TIM6RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM6RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Timer 7 reset"]
        pub type TIM7RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM7RST`"]
        pub type TIM7RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM7RST`"]
        pub struct TIM7RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM7RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Timer 12 reset"]
        pub type TIM12RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM12RST`"]
        pub type TIM12RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM12RST`"]
        pub struct TIM12RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM12RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM12RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Timer 13 reset"]
        pub type TIM13RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM13RST`"]
        pub type TIM13RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM13RST`"]
        pub struct TIM13RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM13RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM13RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Timer 14 reset"]
        pub type TIM14RST_A = TIM2RST_A;
        #[doc = "Reader of field `TIM14RST`"]
        pub type TIM14RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `TIM14RST`"]
        pub struct TIM14RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM14RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM14RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Window watchdog reset"]
        pub type WWDGRST_A = TIM2RST_A;
        #[doc = "Reader of field `WWDGRST`"]
        pub type WWDGRST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `WWDGRST`"]
        pub struct WWDGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "SPI2 reset"]
        pub type SPI2RST_A = TIM2RST_A;
        #[doc = "Reader of field `SPI2RST`"]
        pub type SPI2RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `SPI2RST`"]
        pub struct SPI2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "SPI3 reset"]
        pub type SPI3RST_A = TIM2RST_A;
        #[doc = "Reader of field `SPI3RST`"]
        pub type SPI3RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `SPI3RST`"]
        pub struct SPI3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI3RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "USART 2 reset"]
        pub type USART2RST_A = TIM2RST_A;
        #[doc = "Reader of field `USART2RST`"]
        pub type USART2RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `USART2RST`"]
        pub struct USART2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "USART 3 reset"]
        pub type USART3RST_A = TIM2RST_A;
        #[doc = "Reader of field `USART3RST`"]
        pub type USART3RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `USART3RST`"]
        pub struct USART3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART3RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART3RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "USART 4 reset"]
        pub type UART4RST_A = TIM2RST_A;
        #[doc = "Reader of field `UART4RST`"]
        pub type UART4RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `UART4RST`"]
        pub struct UART4RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART4RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART4RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "USART 5 reset"]
        pub type UART5RST_A = TIM2RST_A;
        #[doc = "Reader of field `UART5RST`"]
        pub type UART5RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `UART5RST`"]
        pub struct UART5RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART5RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART5RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "I2C1 reset"]
        pub type I2C1RST_A = TIM2RST_A;
        #[doc = "Reader of field `I2C1RST`"]
        pub type I2C1RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `I2C1RST`"]
        pub struct I2C1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "I2C2 reset"]
        pub type I2C2RST_A = TIM2RST_A;
        #[doc = "Reader of field `I2C2RST`"]
        pub type I2C2RST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `I2C2RST`"]
        pub struct I2C2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Backup interface reset"]
        pub type BKPRST_A = TIM2RST_A;
        #[doc = "Reader of field `BKPRST`"]
        pub type BKPRST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `BKPRST`"]
        pub struct BKPRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKPRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BKPRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Power interface reset"]
        pub type PWRRST_A = TIM2RST_A;
        #[doc = "Reader of field `PWRRST`"]
        pub type PWRRST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `PWRRST`"]
        pub struct PWRRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PWRRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "DAC interface reset"]
        pub type DACRST_A = TIM2RST_A;
        #[doc = "Reader of field `DACRST`"]
        pub type DACRST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `DACRST`"]
        pub struct DACRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DACRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "CEC reset"]
        pub type CECRST_A = TIM2RST_A;
        #[doc = "Reader of field `CECRST`"]
        pub type CECRST_R = crate::R<bool, TIM2RST_A>;
        #[doc = "Write proxy for field `CECRST`"]
        pub struct CECRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CECRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CECRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline(always)]
            pub fn tim2rst(&self) -> TIM2RST_R {
                TIM2RST_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline(always)]
            pub fn tim3rst(&self) -> TIM3RST_R {
                TIM3RST_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Timer 4 reset"]
            #[inline(always)]
            pub fn tim4rst(&self) -> TIM4RST_R {
                TIM4RST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Timer 5 reset"]
            #[inline(always)]
            pub fn tim5rst(&self) -> TIM5RST_R {
                TIM5RST_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline(always)]
            pub fn tim6rst(&self) -> TIM6RST_R {
                TIM6RST_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Timer 7 reset"]
            #[inline(always)]
            pub fn tim7rst(&self) -> TIM7RST_R {
                TIM7RST_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Timer 12 reset"]
            #[inline(always)]
            pub fn tim12rst(&self) -> TIM12RST_R {
                TIM12RST_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Timer 13 reset"]
            #[inline(always)]
            pub fn tim13rst(&self) -> TIM13RST_R {
                TIM13RST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Timer 14 reset"]
            #[inline(always)]
            pub fn tim14rst(&self) -> TIM14RST_R {
                TIM14RST_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline(always)]
            pub fn wwdgrst(&self) -> WWDGRST_R {
                WWDGRST_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline(always)]
            pub fn spi2rst(&self) -> SPI2RST_R {
                SPI2RST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - SPI3 reset"]
            #[inline(always)]
            pub fn spi3rst(&self) -> SPI3RST_R {
                SPI3RST_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 17 - USART 2 reset"]
            #[inline(always)]
            pub fn usart2rst(&self) -> USART2RST_R {
                USART2RST_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - USART 3 reset"]
            #[inline(always)]
            pub fn usart3rst(&self) -> USART3RST_R {
                USART3RST_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - USART 4 reset"]
            #[inline(always)]
            pub fn uart4rst(&self) -> UART4RST_R {
                UART4RST_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - USART 5 reset"]
            #[inline(always)]
            pub fn uart5rst(&self) -> UART5RST_R {
                UART5RST_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline(always)]
            pub fn i2c1rst(&self) -> I2C1RST_R {
                I2C1RST_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline(always)]
            pub fn i2c2rst(&self) -> I2C2RST_R {
                I2C2RST_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 27 - Backup interface reset"]
            #[inline(always)]
            pub fn bkprst(&self) -> BKPRST_R {
                BKPRST_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline(always)]
            pub fn pwrrst(&self) -> PWRRST_R {
                PWRRST_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29 - DAC interface reset"]
            #[inline(always)]
            pub fn dacrst(&self) -> DACRST_R {
                DACRST_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30 - CEC reset"]
            #[inline(always)]
            pub fn cecrst(&self) -> CECRST_R {
                CECRST_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline(always)]
            pub fn tim2rst(&mut self) -> TIM2RST_W {
                TIM2RST_W { w: self }
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline(always)]
            pub fn tim3rst(&mut self) -> TIM3RST_W {
                TIM3RST_W { w: self }
            }
            #[doc = "Bit 2 - Timer 4 reset"]
            #[inline(always)]
            pub fn tim4rst(&mut self) -> TIM4RST_W {
                TIM4RST_W { w: self }
            }
            #[doc = "Bit 3 - Timer 5 reset"]
            #[inline(always)]
            pub fn tim5rst(&mut self) -> TIM5RST_W {
                TIM5RST_W { w: self }
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline(always)]
            pub fn tim6rst(&mut self) -> TIM6RST_W {
                TIM6RST_W { w: self }
            }
            #[doc = "Bit 5 - Timer 7 reset"]
            #[inline(always)]
            pub fn tim7rst(&mut self) -> TIM7RST_W {
                TIM7RST_W { w: self }
            }
            #[doc = "Bit 6 - Timer 12 reset"]
            #[inline(always)]
            pub fn tim12rst(&mut self) -> TIM12RST_W {
                TIM12RST_W { w: self }
            }
            #[doc = "Bit 7 - Timer 13 reset"]
            #[inline(always)]
            pub fn tim13rst(&mut self) -> TIM13RST_W {
                TIM13RST_W { w: self }
            }
            #[doc = "Bit 8 - Timer 14 reset"]
            #[inline(always)]
            pub fn tim14rst(&mut self) -> TIM14RST_W {
                TIM14RST_W { w: self }
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline(always)]
            pub fn wwdgrst(&mut self) -> WWDGRST_W {
                WWDGRST_W { w: self }
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline(always)]
            pub fn spi2rst(&mut self) -> SPI2RST_W {
                SPI2RST_W { w: self }
            }
            #[doc = "Bit 15 - SPI3 reset"]
            #[inline(always)]
            pub fn spi3rst(&mut self) -> SPI3RST_W {
                SPI3RST_W { w: self }
            }
            #[doc = "Bit 17 - USART 2 reset"]
            #[inline(always)]
            pub fn usart2rst(&mut self) -> USART2RST_W {
                USART2RST_W { w: self }
            }
            #[doc = "Bit 18 - USART 3 reset"]
            #[inline(always)]
            pub fn usart3rst(&mut self) -> USART3RST_W {
                USART3RST_W { w: self }
            }
            #[doc = "Bit 19 - USART 4 reset"]
            #[inline(always)]
            pub fn uart4rst(&mut self) -> UART4RST_W {
                UART4RST_W { w: self }
            }
            #[doc = "Bit 20 - USART 5 reset"]
            #[inline(always)]
            pub fn uart5rst(&mut self) -> UART5RST_W {
                UART5RST_W { w: self }
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline(always)]
            pub fn i2c1rst(&mut self) -> I2C1RST_W {
                I2C1RST_W { w: self }
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline(always)]
            pub fn i2c2rst(&mut self) -> I2C2RST_W {
                I2C2RST_W { w: self }
            }
            #[doc = "Bit 27 - Backup interface reset"]
            #[inline(always)]
            pub fn bkprst(&mut self) -> BKPRST_W {
                BKPRST_W { w: self }
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline(always)]
            pub fn pwrrst(&mut self) -> PWRRST_W {
                PWRRST_W { w: self }
            }
            #[doc = "Bit 29 - DAC interface reset"]
            #[inline(always)]
            pub fn dacrst(&mut self) -> DACRST_W {
                DACRST_W { w: self }
            }
            #[doc = "Bit 30 - CEC reset"]
            #[inline(always)]
            pub fn cecrst(&mut self) -> CECRST_W {
                CECRST_W { w: self }
            }
        }
    }
    #[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ahbenr](ahbenr) module"]
    pub type AHBENR = crate::Reg<u32, _AHBENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AHBENR;
    #[doc = "`read()` method returns [ahbenr::R](ahbenr::R) reader structure"]
    impl crate::Readable for AHBENR {}
    #[doc = "`write(|w| ..)` method takes [ahbenr::W](ahbenr::W) writer structure"]
    impl crate::Writable for AHBENR {}
    #[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)"]
    pub mod ahbenr {
        #[doc = "Reader of register AHBENR"]
        pub type R = crate::R<u32, super::AHBENR>;
        #[doc = "Writer for register AHBENR"]
        pub type W = crate::W<u32, super::AHBENR>;
        #[doc = "Register AHBENR `reset()`'s with value 0x14"]
        impl crate::ResetValue for super::AHBENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x14
            }
        }
        #[doc = "DMA1 clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA1EN_A {
            #[doc = "0: The selected clock is disabled"]
            DISABLED = 0,
            #[doc = "1: The selected clock is enabled"]
            ENABLED = 1,
        }
        impl From<DMA1EN_A> for bool {
            #[inline(always)]
            fn from(variant: DMA1EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMA1EN`"]
        pub type DMA1EN_R = crate::R<bool, DMA1EN_A>;
        impl DMA1EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA1EN_A {
                match self.bits {
                    false => DMA1EN_A::DISABLED,
                    true => DMA1EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMA1EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMA1EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMA1EN`"]
        pub struct DMA1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "DMA2 clock enable"]
        pub type DMA2EN_A = DMA1EN_A;
        #[doc = "Reader of field `DMA2EN`"]
        pub type DMA2EN_R = crate::R<bool, DMA1EN_A>;
        #[doc = "Write proxy for field `DMA2EN`"]
        pub struct DMA2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "SRAM interface clock enable"]
        pub type SRAMEN_A = DMA1EN_A;
        #[doc = "Reader of field `SRAMEN`"]
        pub type SRAMEN_R = crate::R<bool, DMA1EN_A>;
        #[doc = "Write proxy for field `SRAMEN`"]
        pub struct SRAMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRAMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "FLITF clock enable"]
        pub type FLITFEN_A = DMA1EN_A;
        #[doc = "Reader of field `FLITFEN`"]
        pub type FLITFEN_R = crate::R<bool, DMA1EN_A>;
        #[doc = "Write proxy for field `FLITFEN`"]
        pub struct FLITFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FLITFEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLITFEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "CRC clock enable"]
        pub type CRCEN_A = DMA1EN_A;
        #[doc = "Reader of field `CRCEN`"]
        pub type CRCEN_R = crate::R<bool, DMA1EN_A>;
        #[doc = "Write proxy for field `CRCEN`"]
        pub struct CRCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "FSMC clock enable"]
        pub type FSMCEN_A = DMA1EN_A;
        #[doc = "Reader of field `FSMCEN`"]
        pub type FSMCEN_R = crate::R<bool, DMA1EN_A>;
        #[doc = "Write proxy for field `FSMCEN`"]
        pub struct FSMCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FSMCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FSMCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - DMA1 clock enable"]
            #[inline(always)]
            pub fn dma1en(&self) -> DMA1EN_R {
                DMA1EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - DMA2 clock enable"]
            #[inline(always)]
            pub fn dma2en(&self) -> DMA2EN_R {
                DMA2EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - SRAM interface clock enable"]
            #[inline(always)]
            pub fn sramen(&self) -> SRAMEN_R {
                SRAMEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 4 - FLITF clock enable"]
            #[inline(always)]
            pub fn flitfen(&self) -> FLITFEN_R {
                FLITFEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 6 - CRC clock enable"]
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 8 - FSMC clock enable"]
            #[inline(always)]
            pub fn fsmcen(&self) -> FSMCEN_R {
                FSMCEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA1 clock enable"]
            #[inline(always)]
            pub fn dma1en(&mut self) -> DMA1EN_W {
                DMA1EN_W { w: self }
            }
            #[doc = "Bit 1 - DMA2 clock enable"]
            #[inline(always)]
            pub fn dma2en(&mut self) -> DMA2EN_W {
                DMA2EN_W { w: self }
            }
            #[doc = "Bit 2 - SRAM interface clock enable"]
            #[inline(always)]
            pub fn sramen(&mut self) -> SRAMEN_W {
                SRAMEN_W { w: self }
            }
            #[doc = "Bit 4 - FLITF clock enable"]
            #[inline(always)]
            pub fn flitfen(&mut self) -> FLITFEN_W {
                FLITFEN_W { w: self }
            }
            #[doc = "Bit 6 - CRC clock enable"]
            #[inline(always)]
            pub fn crcen(&mut self) -> CRCEN_W {
                CRCEN_W { w: self }
            }
            #[doc = "Bit 8 - FSMC clock enable"]
            #[inline(always)]
            pub fn fsmcen(&mut self) -> FSMCEN_W {
                FSMCEN_W { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb2enr](apb2enr) module"]
    pub type APB2ENR = crate::Reg<u32, _APB2ENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB2ENR;
    #[doc = "`read()` method returns [apb2enr::R](apb2enr::R) reader structure"]
    impl crate::Readable for APB2ENR {}
    #[doc = "`write(|w| ..)` method takes [apb2enr::W](apb2enr::W) writer structure"]
    impl crate::Writable for APB2ENR {}
    #[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)"]
    pub mod apb2enr {
        #[doc = "Reader of register APB2ENR"]
        pub type R = crate::R<u32, super::APB2ENR>;
        #[doc = "Writer for register APB2ENR"]
        pub type W = crate::W<u32, super::APB2ENR>;
        #[doc = "Register APB2ENR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB2ENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alternate function I/O clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFIOEN_A {
            #[doc = "0: The selected clock is disabled"]
            DISABLED = 0,
            #[doc = "1: The selected clock is enabled"]
            ENABLED = 1,
        }
        impl From<AFIOEN_A> for bool {
            #[inline(always)]
            fn from(variant: AFIOEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AFIOEN`"]
        pub type AFIOEN_R = crate::R<bool, AFIOEN_A>;
        impl AFIOEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AFIOEN_A {
                match self.bits {
                    false => AFIOEN_A::DISABLED,
                    true => AFIOEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AFIOEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AFIOEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `AFIOEN`"]
        pub struct AFIOEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFIOEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFIOEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "I/O port A clock enable"]
        pub type IOPAEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPAEN`"]
        pub type IOPAEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPAEN`"]
        pub struct IOPAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "I/O port B clock enable"]
        pub type IOPBEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPBEN`"]
        pub type IOPBEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPBEN`"]
        pub struct IOPBEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPBEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "I/O port C clock enable"]
        pub type IOPCEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPCEN`"]
        pub type IOPCEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPCEN`"]
        pub struct IOPCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "I/O port D clock enable"]
        pub type IOPDEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPDEN`"]
        pub type IOPDEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPDEN`"]
        pub struct IOPDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "I/O port E clock enable"]
        pub type IOPEEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPEEN`"]
        pub type IOPEEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPEEN`"]
        pub struct IOPEEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPEEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPEEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "I/O port F clock enable"]
        pub type IOPFEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPFEN`"]
        pub type IOPFEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPFEN`"]
        pub struct IOPFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPFEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPFEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "I/O port G clock enable"]
        pub type IOPGEN_A = AFIOEN_A;
        #[doc = "Reader of field `IOPGEN`"]
        pub type IOPGEN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `IOPGEN`"]
        pub struct IOPGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPGEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "ADC 1 interface clock enable"]
        pub type ADC1EN_A = AFIOEN_A;
        #[doc = "Reader of field `ADC1EN`"]
        pub type ADC1EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `ADC1EN`"]
        pub struct ADC1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADC1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADC1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "TIM1 Timer clock enable"]
        pub type TIM1EN_A = AFIOEN_A;
        #[doc = "Reader of field `TIM1EN`"]
        pub type TIM1EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `TIM1EN`"]
        pub struct TIM1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "SPI 1 clock enable"]
        pub type SPI1EN_A = AFIOEN_A;
        #[doc = "Reader of field `SPI1EN`"]
        pub type SPI1EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `SPI1EN`"]
        pub struct SPI1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "USART1 clock enable"]
        pub type USART1EN_A = AFIOEN_A;
        #[doc = "Reader of field `USART1EN`"]
        pub type USART1EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `USART1EN`"]
        pub struct USART1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "TIM15 Timer clock enable"]
        pub type TIM15EN_A = AFIOEN_A;
        #[doc = "Reader of field `TIM15EN`"]
        pub type TIM15EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `TIM15EN`"]
        pub struct TIM15EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM15EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM15EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "TIM16 Timer clock enable"]
        pub type TIM16EN_A = AFIOEN_A;
        #[doc = "Reader of field `TIM16EN`"]
        pub type TIM16EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `TIM16EN`"]
        pub struct TIM16EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM16EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM16EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "TIM17 Timer clock enable"]
        pub type TIM17EN_A = AFIOEN_A;
        #[doc = "Reader of field `TIM17EN`"]
        pub type TIM17EN_R = crate::R<bool, AFIOEN_A>;
        #[doc = "Write proxy for field `TIM17EN`"]
        pub struct TIM17EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM17EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM17EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Alternate function I/O clock enable"]
            #[inline(always)]
            pub fn afioen(&self) -> AFIOEN_R {
                AFIOEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 2 - I/O port A clock enable"]
            #[inline(always)]
            pub fn iopaen(&self) -> IOPAEN_R {
                IOPAEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - I/O port B clock enable"]
            #[inline(always)]
            pub fn iopben(&self) -> IOPBEN_R {
                IOPBEN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - I/O port C clock enable"]
            #[inline(always)]
            pub fn iopcen(&self) -> IOPCEN_R {
                IOPCEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - I/O port D clock enable"]
            #[inline(always)]
            pub fn iopden(&self) -> IOPDEN_R {
                IOPDEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - I/O port E clock enable"]
            #[inline(always)]
            pub fn iopeen(&self) -> IOPEEN_R {
                IOPEEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - I/O port F clock enable"]
            #[inline(always)]
            pub fn iopfen(&self) -> IOPFEN_R {
                IOPFEN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - I/O port G clock enable"]
            #[inline(always)]
            pub fn iopgen(&self) -> IOPGEN_R {
                IOPGEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - ADC 1 interface clock enable"]
            #[inline(always)]
            pub fn adc1en(&self) -> ADC1EN_R {
                ADC1EN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 11 - TIM1 Timer clock enable"]
            #[inline(always)]
            pub fn tim1en(&self) -> TIM1EN_R {
                TIM1EN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - SPI 1 clock enable"]
            #[inline(always)]
            pub fn spi1en(&self) -> SPI1EN_R {
                SPI1EN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 14 - USART1 clock enable"]
            #[inline(always)]
            pub fn usart1en(&self) -> USART1EN_R {
                USART1EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 16 - TIM15 Timer clock enable"]
            #[inline(always)]
            pub fn tim15en(&self) -> TIM15EN_R {
                TIM15EN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - TIM16 Timer clock enable"]
            #[inline(always)]
            pub fn tim16en(&self) -> TIM16EN_R {
                TIM16EN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - TIM17 Timer clock enable"]
            #[inline(always)]
            pub fn tim17en(&self) -> TIM17EN_R {
                TIM17EN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Alternate function I/O clock enable"]
            #[inline(always)]
            pub fn afioen(&mut self) -> AFIOEN_W {
                AFIOEN_W { w: self }
            }
            #[doc = "Bit 2 - I/O port A clock enable"]
            #[inline(always)]
            pub fn iopaen(&mut self) -> IOPAEN_W {
                IOPAEN_W { w: self }
            }
            #[doc = "Bit 3 - I/O port B clock enable"]
            #[inline(always)]
            pub fn iopben(&mut self) -> IOPBEN_W {
                IOPBEN_W { w: self }
            }
            #[doc = "Bit 4 - I/O port C clock enable"]
            #[inline(always)]
            pub fn iopcen(&mut self) -> IOPCEN_W {
                IOPCEN_W { w: self }
            }
            #[doc = "Bit 5 - I/O port D clock enable"]
            #[inline(always)]
            pub fn iopden(&mut self) -> IOPDEN_W {
                IOPDEN_W { w: self }
            }
            #[doc = "Bit 6 - I/O port E clock enable"]
            #[inline(always)]
            pub fn iopeen(&mut self) -> IOPEEN_W {
                IOPEEN_W { w: self }
            }
            #[doc = "Bit 7 - I/O port F clock enable"]
            #[inline(always)]
            pub fn iopfen(&mut self) -> IOPFEN_W {
                IOPFEN_W { w: self }
            }
            #[doc = "Bit 8 - I/O port G clock enable"]
            #[inline(always)]
            pub fn iopgen(&mut self) -> IOPGEN_W {
                IOPGEN_W { w: self }
            }
            #[doc = "Bit 9 - ADC 1 interface clock enable"]
            #[inline(always)]
            pub fn adc1en(&mut self) -> ADC1EN_W {
                ADC1EN_W { w: self }
            }
            #[doc = "Bit 11 - TIM1 Timer clock enable"]
            #[inline(always)]
            pub fn tim1en(&mut self) -> TIM1EN_W {
                TIM1EN_W { w: self }
            }
            #[doc = "Bit 12 - SPI 1 clock enable"]
            #[inline(always)]
            pub fn spi1en(&mut self) -> SPI1EN_W {
                SPI1EN_W { w: self }
            }
            #[doc = "Bit 14 - USART1 clock enable"]
            #[inline(always)]
            pub fn usart1en(&mut self) -> USART1EN_W {
                USART1EN_W { w: self }
            }
            #[doc = "Bit 16 - TIM15 Timer clock enable"]
            #[inline(always)]
            pub fn tim15en(&mut self) -> TIM15EN_W {
                TIM15EN_W { w: self }
            }
            #[doc = "Bit 17 - TIM16 Timer clock enable"]
            #[inline(always)]
            pub fn tim16en(&mut self) -> TIM16EN_W {
                TIM16EN_W { w: self }
            }
            #[doc = "Bit 18 - TIM17 Timer clock enable"]
            #[inline(always)]
            pub fn tim17en(&mut self) -> TIM17EN_W {
                TIM17EN_W { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb1enr](apb1enr) module"]
    pub type APB1ENR = crate::Reg<u32, _APB1ENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB1ENR;
    #[doc = "`read()` method returns [apb1enr::R](apb1enr::R) reader structure"]
    impl crate::Readable for APB1ENR {}
    #[doc = "`write(|w| ..)` method takes [apb1enr::W](apb1enr::W) writer structure"]
    impl crate::Writable for APB1ENR {}
    #[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)"]
    pub mod apb1enr {
        #[doc = "Reader of register APB1ENR"]
        pub type R = crate::R<u32, super::APB1ENR>;
        #[doc = "Writer for register APB1ENR"]
        pub type W = crate::W<u32, super::APB1ENR>;
        #[doc = "Register APB1ENR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB1ENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Timer 2 clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIM2EN_A {
            #[doc = "0: The selected clock is disabled"]
            DISABLED = 0,
            #[doc = "1: The selected clock is enabled"]
            ENABLED = 1,
        }
        impl From<TIM2EN_A> for bool {
            #[inline(always)]
            fn from(variant: TIM2EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIM2EN`"]
        pub type TIM2EN_R = crate::R<bool, TIM2EN_A>;
        impl TIM2EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIM2EN_A {
                match self.bits {
                    false => TIM2EN_A::DISABLED,
                    true => TIM2EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIM2EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIM2EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIM2EN`"]
        pub struct TIM2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Timer 3 clock enable"]
        pub type TIM3EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM3EN`"]
        pub type TIM3EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM3EN`"]
        pub struct TIM3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM3EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Timer 4 clock enable"]
        pub type TIM4EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM4EN`"]
        pub type TIM4EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM4EN`"]
        pub struct TIM4EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM4EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM4EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Timer 5 clock enable"]
        pub type TIM5EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM5EN`"]
        pub type TIM5EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM5EN`"]
        pub struct TIM5EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM5EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM5EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Timer 6 clock enable"]
        pub type TIM6EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM6EN`"]
        pub type TIM6EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM6EN`"]
        pub struct TIM6EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM6EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Timer 7 clock enable"]
        pub type TIM7EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM7EN`"]
        pub type TIM7EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM7EN`"]
        pub struct TIM7EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM7EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Timer 12 clock enable"]
        pub type TIM12EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM12EN`"]
        pub type TIM12EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM12EN`"]
        pub struct TIM12EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM12EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM12EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Timer 13 clock enable"]
        pub type TIM13EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM13EN`"]
        pub type TIM13EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM13EN`"]
        pub struct TIM13EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM13EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM13EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Timer 14 clock enable"]
        pub type TIM14EN_A = TIM2EN_A;
        #[doc = "Reader of field `TIM14EN`"]
        pub type TIM14EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `TIM14EN`"]
        pub struct TIM14EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM14EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM14EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Window watchdog clock enable"]
        pub type WWDGEN_A = TIM2EN_A;
        #[doc = "Reader of field `WWDGEN`"]
        pub type WWDGEN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `WWDGEN`"]
        pub struct WWDGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "SPI 2 clock enable"]
        pub type SPI2EN_A = TIM2EN_A;
        #[doc = "Reader of field `SPI2EN`"]
        pub type SPI2EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `SPI2EN`"]
        pub struct SPI2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "SPI 3 clock enable"]
        pub type SPI3EN_A = TIM2EN_A;
        #[doc = "Reader of field `SPI3EN`"]
        pub type SPI3EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `SPI3EN`"]
        pub struct SPI3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI3EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "USART 2 clock enable"]
        pub type USART2EN_A = TIM2EN_A;
        #[doc = "Reader of field `USART2EN`"]
        pub type USART2EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `USART2EN`"]
        pub struct USART2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "USART 3 clock enable"]
        pub type USART3EN_A = TIM2EN_A;
        #[doc = "Reader of field `USART3EN`"]
        pub type USART3EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `USART3EN`"]
        pub struct USART3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART3EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART3EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "UART 4 clock enable"]
        pub type UART4EN_A = TIM2EN_A;
        #[doc = "Reader of field `UART4EN`"]
        pub type UART4EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `UART4EN`"]
        pub struct UART4EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART4EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART4EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "UART 5 clock enable"]
        pub type UART5EN_A = TIM2EN_A;
        #[doc = "Reader of field `UART5EN`"]
        pub type UART5EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `UART5EN`"]
        pub struct UART5EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART5EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART5EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "I2C 1 clock enable"]
        pub type I2C1EN_A = TIM2EN_A;
        #[doc = "Reader of field `I2C1EN`"]
        pub type I2C1EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `I2C1EN`"]
        pub struct I2C1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "I2C 2 clock enable"]
        pub type I2C2EN_A = TIM2EN_A;
        #[doc = "Reader of field `I2C2EN`"]
        pub type I2C2EN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `I2C2EN`"]
        pub struct I2C2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Backup interface clock enable"]
        pub type BKPEN_A = TIM2EN_A;
        #[doc = "Reader of field `BKPEN`"]
        pub type BKPEN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `BKPEN`"]
        pub struct BKPEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKPEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BKPEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Power interface clock enable"]
        pub type PWREN_A = TIM2EN_A;
        #[doc = "Reader of field `PWREN`"]
        pub type PWREN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `PWREN`"]
        pub struct PWREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PWREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "DAC interface clock enable"]
        pub type DACEN_A = TIM2EN_A;
        #[doc = "Reader of field `DACEN`"]
        pub type DACEN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `DACEN`"]
        pub struct DACEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DACEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "CEC clock enable"]
        pub type CECEN_A = TIM2EN_A;
        #[doc = "Reader of field `CECEN`"]
        pub type CECEN_R = crate::R<bool, TIM2EN_A>;
        #[doc = "Write proxy for field `CECEN`"]
        pub struct CECEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CECEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CECEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Timer 2 clock enable"]
            #[inline(always)]
            pub fn tim2en(&self) -> TIM2EN_R {
                TIM2EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Timer 3 clock enable"]
            #[inline(always)]
            pub fn tim3en(&self) -> TIM3EN_R {
                TIM3EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Timer 4 clock enable"]
            #[inline(always)]
            pub fn tim4en(&self) -> TIM4EN_R {
                TIM4EN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Timer 5 clock enable"]
            #[inline(always)]
            pub fn tim5en(&self) -> TIM5EN_R {
                TIM5EN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Timer 6 clock enable"]
            #[inline(always)]
            pub fn tim6en(&self) -> TIM6EN_R {
                TIM6EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Timer 7 clock enable"]
            #[inline(always)]
            pub fn tim7en(&self) -> TIM7EN_R {
                TIM7EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Timer 12 clock enable"]
            #[inline(always)]
            pub fn tim12en(&self) -> TIM12EN_R {
                TIM12EN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Timer 13 clock enable"]
            #[inline(always)]
            pub fn tim13en(&self) -> TIM13EN_R {
                TIM13EN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Timer 14 clock enable"]
            #[inline(always)]
            pub fn tim14en(&self) -> TIM14EN_R {
                TIM14EN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Window watchdog clock enable"]
            #[inline(always)]
            pub fn wwdgen(&self) -> WWDGEN_R {
                WWDGEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 14 - SPI 2 clock enable"]
            #[inline(always)]
            pub fn spi2en(&self) -> SPI2EN_R {
                SPI2EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - SPI 3 clock enable"]
            #[inline(always)]
            pub fn spi3en(&self) -> SPI3EN_R {
                SPI3EN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 17 - USART 2 clock enable"]
            #[inline(always)]
            pub fn usart2en(&self) -> USART2EN_R {
                USART2EN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - USART 3 clock enable"]
            #[inline(always)]
            pub fn usart3en(&self) -> USART3EN_R {
                USART3EN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - UART 4 clock enable"]
            #[inline(always)]
            pub fn uart4en(&self) -> UART4EN_R {
                UART4EN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - UART 5 clock enable"]
            #[inline(always)]
            pub fn uart5en(&self) -> UART5EN_R {
                UART5EN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - I2C 1 clock enable"]
            #[inline(always)]
            pub fn i2c1en(&self) -> I2C1EN_R {
                I2C1EN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - I2C 2 clock enable"]
            #[inline(always)]
            pub fn i2c2en(&self) -> I2C2EN_R {
                I2C2EN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 27 - Backup interface clock enable"]
            #[inline(always)]
            pub fn bkpen(&self) -> BKPEN_R {
                BKPEN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Power interface clock enable"]
            #[inline(always)]
            pub fn pwren(&self) -> PWREN_R {
                PWREN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29 - DAC interface clock enable"]
            #[inline(always)]
            pub fn dacen(&self) -> DACEN_R {
                DACEN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30 - CEC clock enable"]
            #[inline(always)]
            pub fn cecen(&self) -> CECEN_R {
                CECEN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Timer 2 clock enable"]
            #[inline(always)]
            pub fn tim2en(&mut self) -> TIM2EN_W {
                TIM2EN_W { w: self }
            }
            #[doc = "Bit 1 - Timer 3 clock enable"]
            #[inline(always)]
            pub fn tim3en(&mut self) -> TIM3EN_W {
                TIM3EN_W { w: self }
            }
            #[doc = "Bit 2 - Timer 4 clock enable"]
            #[inline(always)]
            pub fn tim4en(&mut self) -> TIM4EN_W {
                TIM4EN_W { w: self }
            }
            #[doc = "Bit 3 - Timer 5 clock enable"]
            #[inline(always)]
            pub fn tim5en(&mut self) -> TIM5EN_W {
                TIM5EN_W { w: self }
            }
            #[doc = "Bit 4 - Timer 6 clock enable"]
            #[inline(always)]
            pub fn tim6en(&mut self) -> TIM6EN_W {
                TIM6EN_W { w: self }
            }
            #[doc = "Bit 5 - Timer 7 clock enable"]
            #[inline(always)]
            pub fn tim7en(&mut self) -> TIM7EN_W {
                TIM7EN_W { w: self }
            }
            #[doc = "Bit 6 - Timer 12 clock enable"]
            #[inline(always)]
            pub fn tim12en(&mut self) -> TIM12EN_W {
                TIM12EN_W { w: self }
            }
            #[doc = "Bit 7 - Timer 13 clock enable"]
            #[inline(always)]
            pub fn tim13en(&mut self) -> TIM13EN_W {
                TIM13EN_W { w: self }
            }
            #[doc = "Bit 8 - Timer 14 clock enable"]
            #[inline(always)]
            pub fn tim14en(&mut self) -> TIM14EN_W {
                TIM14EN_W { w: self }
            }
            #[doc = "Bit 11 - Window watchdog clock enable"]
            #[inline(always)]
            pub fn wwdgen(&mut self) -> WWDGEN_W {
                WWDGEN_W { w: self }
            }
            #[doc = "Bit 14 - SPI 2 clock enable"]
            #[inline(always)]
            pub fn spi2en(&mut self) -> SPI2EN_W {
                SPI2EN_W { w: self }
            }
            #[doc = "Bit 15 - SPI 3 clock enable"]
            #[inline(always)]
            pub fn spi3en(&mut self) -> SPI3EN_W {
                SPI3EN_W { w: self }
            }
            #[doc = "Bit 17 - USART 2 clock enable"]
            #[inline(always)]
            pub fn usart2en(&mut self) -> USART2EN_W {
                USART2EN_W { w: self }
            }
            #[doc = "Bit 18 - USART 3 clock enable"]
            #[inline(always)]
            pub fn usart3en(&mut self) -> USART3EN_W {
                USART3EN_W { w: self }
            }
            #[doc = "Bit 19 - UART 4 clock enable"]
            #[inline(always)]
            pub fn uart4en(&mut self) -> UART4EN_W {
                UART4EN_W { w: self }
            }
            #[doc = "Bit 20 - UART 5 clock enable"]
            #[inline(always)]
            pub fn uart5en(&mut self) -> UART5EN_W {
                UART5EN_W { w: self }
            }
            #[doc = "Bit 21 - I2C 1 clock enable"]
            #[inline(always)]
            pub fn i2c1en(&mut self) -> I2C1EN_W {
                I2C1EN_W { w: self }
            }
            #[doc = "Bit 22 - I2C 2 clock enable"]
            #[inline(always)]
            pub fn i2c2en(&mut self) -> I2C2EN_W {
                I2C2EN_W { w: self }
            }
            #[doc = "Bit 27 - Backup interface clock enable"]
            #[inline(always)]
            pub fn bkpen(&mut self) -> BKPEN_W {
                BKPEN_W { w: self }
            }
            #[doc = "Bit 28 - Power interface clock enable"]
            #[inline(always)]
            pub fn pwren(&mut self) -> PWREN_W {
                PWREN_W { w: self }
            }
            #[doc = "Bit 29 - DAC interface clock enable"]
            #[inline(always)]
            pub fn dacen(&mut self) -> DACEN_W {
                DACEN_W { w: self }
            }
            #[doc = "Bit 30 - CEC clock enable"]
            #[inline(always)]
            pub fn cecen(&mut self) -> CECEN_W {
                CECEN_W { w: self }
            }
        }
    }
    #[doc = "Backup domain control register (RCC_BDCR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bdcr](bdcr) module"]
    pub type BDCR = crate::Reg<u32, _BDCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BDCR;
    #[doc = "`read()` method returns [bdcr::R](bdcr::R) reader structure"]
    impl crate::Readable for BDCR {}
    #[doc = "`write(|w| ..)` method takes [bdcr::W](bdcr::W) writer structure"]
    impl crate::Writable for BDCR {}
    #[doc = "Backup domain control register (RCC_BDCR)"]
    pub mod bdcr {
        #[doc = "Reader of register BDCR"]
        pub type R = crate::R<u32, super::BDCR>;
        #[doc = "Writer for register BDCR"]
        pub type W = crate::W<u32, super::BDCR>;
        #[doc = "Register BDCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BDCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "External Low Speed oscillator enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEON_A {
            #[doc = "0: LSE oscillator Off"]
            OFF = 0,
            #[doc = "1: LSE oscillator On"]
            ON = 1,
        }
        impl From<LSEON_A> for bool {
            #[inline(always)]
            fn from(variant: LSEON_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSEON`"]
        pub type LSEON_R = crate::R<bool, LSEON_A>;
        impl LSEON_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSEON_A {
                match self.bits {
                    false => LSEON_A::OFF,
                    true => LSEON_A::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == LSEON_A::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == LSEON_A::ON
            }
        }
        #[doc = "Write proxy for field `LSEON`"]
        pub struct LSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSEON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LSE oscillator Off"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(LSEON_A::OFF)
            }
            #[doc = "LSE oscillator On"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(LSEON_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "External Low Speed oscillator ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSERDY_A {
            #[doc = "0: LSE oscillator not ready"]
            NOTREADY = 0,
            #[doc = "1: LSE oscillator ready"]
            READY = 1,
        }
        impl From<LSERDY_A> for bool {
            #[inline(always)]
            fn from(variant: LSERDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSERDY`"]
        pub type LSERDY_R = crate::R<bool, LSERDY_A>;
        impl LSERDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSERDY_A {
                match self.bits {
                    false => LSERDY_A::NOTREADY,
                    true => LSERDY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == LSERDY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == LSERDY_A::READY
            }
        }
        #[doc = "External Low Speed oscillator bypass\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEBYP_A {
            #[doc = "0: LSE crystal oscillator not bypassed"]
            NOTBYPASSED = 0,
            #[doc = "1: LSE crystal oscillator bypassed with external clock"]
            BYPASSED = 1,
        }
        impl From<LSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: LSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSEBYP`"]
        pub type LSEBYP_R = crate::R<bool, LSEBYP_A>;
        impl LSEBYP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSEBYP_A {
                match self.bits {
                    false => LSEBYP_A::NOTBYPASSED,
                    true => LSEBYP_A::BYPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBYPASSED`"]
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                *self == LSEBYP_A::NOTBYPASSED
            }
            #[doc = "Checks if the value of the field is `BYPASSED`"]
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                *self == LSEBYP_A::BYPASSED
            }
        }
        #[doc = "Write proxy for field `LSEBYP`"]
        pub struct LSEBYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEBYP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSEBYP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LSE crystal oscillator not bypassed"]
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::NOTBYPASSED)
            }
            #[doc = "LSE crystal oscillator bypassed with external clock"]
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::BYPASSED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "RTC clock source selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum RTCSEL_A {
            #[doc = "0: No clock"]
            NOCLOCK = 0,
            #[doc = "1: LSE oscillator clock used as RTC clock"]
            LSE = 1,
            #[doc = "2: LSI oscillator clock used as RTC clock"]
            LSI = 2,
            #[doc = "3: HSE oscillator clock divided by a prescaler used as RTC clock"]
            HSE = 3,
        }
        impl From<RTCSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: RTCSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `RTCSEL`"]
        pub type RTCSEL_R = crate::R<u8, RTCSEL_A>;
        impl RTCSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTCSEL_A {
                match self.bits {
                    0 => RTCSEL_A::NOCLOCK,
                    1 => RTCSEL_A::LSE,
                    2 => RTCSEL_A::LSI,
                    3 => RTCSEL_A::HSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOCLOCK`"]
            #[inline(always)]
            pub fn is_no_clock(&self) -> bool {
                *self == RTCSEL_A::NOCLOCK
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == RTCSEL_A::LSE
            }
            #[doc = "Checks if the value of the field is `LSI`"]
            #[inline(always)]
            pub fn is_lsi(&self) -> bool {
                *self == RTCSEL_A::LSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == RTCSEL_A::HSE
            }
        }
        #[doc = "Write proxy for field `RTCSEL`"]
        pub struct RTCSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTCSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No clock"]
            #[inline(always)]
            pub fn no_clock(self) -> &'a mut W {
                self.variant(RTCSEL_A::NOCLOCK)
            }
            #[doc = "LSE oscillator clock used as RTC clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(RTCSEL_A::LSE)
            }
            #[doc = "LSI oscillator clock used as RTC clock"]
            #[inline(always)]
            pub fn lsi(self) -> &'a mut W {
                self.variant(RTCSEL_A::LSI)
            }
            #[doc = "HSE oscillator clock divided by a prescaler used as RTC clock"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(RTCSEL_A::HSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "RTC clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTCEN_A {
            #[doc = "0: RTC clock disabled"]
            DISABLED = 0,
            #[doc = "1: RTC clock enabled"]
            ENABLED = 1,
        }
        impl From<RTCEN_A> for bool {
            #[inline(always)]
            fn from(variant: RTCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTCEN`"]
        pub type RTCEN_R = crate::R<bool, RTCEN_A>;
        impl RTCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTCEN_A {
                match self.bits {
                    false => RTCEN_A::DISABLED,
                    true => RTCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTCEN`"]
        pub struct RTCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTCEN_A::DISABLED)
            }
            #[doc = "RTC clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Backup domain software reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BDRST_A {
            #[doc = "0: Reset not activated"]
            DISABLED = 0,
            #[doc = "1: Reset the entire RTC domain"]
            ENABLED = 1,
        }
        impl From<BDRST_A> for bool {
            #[inline(always)]
            fn from(variant: BDRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BDRST`"]
        pub type BDRST_R = crate::R<bool, BDRST_A>;
        impl BDRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BDRST_A {
                match self.bits {
                    false => BDRST_A::DISABLED,
                    true => BDRST_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BDRST_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BDRST_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `BDRST`"]
        pub struct BDRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BDRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BDRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset not activated"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BDRST_A::DISABLED)
            }
            #[doc = "Reset the entire RTC domain"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BDRST_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - External Low Speed oscillator enable"]
            #[inline(always)]
            pub fn lseon(&self) -> LSEON_R {
                LSEON_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - External Low Speed oscillator ready"]
            #[inline(always)]
            pub fn lserdy(&self) -> LSERDY_R {
                LSERDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - External Low Speed oscillator bypass"]
            #[inline(always)]
            pub fn lsebyp(&self) -> LSEBYP_R {
                LSEBYP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - RTC clock source selection"]
            #[inline(always)]
            pub fn rtcsel(&self) -> RTCSEL_R {
                RTCSEL_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 15 - RTC clock enable"]
            #[inline(always)]
            pub fn rtcen(&self) -> RTCEN_R {
                RTCEN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Backup domain software reset"]
            #[inline(always)]
            pub fn bdrst(&self) -> BDRST_R {
                BDRST_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - External Low Speed oscillator enable"]
            #[inline(always)]
            pub fn lseon(&mut self) -> LSEON_W {
                LSEON_W { w: self }
            }
            #[doc = "Bit 2 - External Low Speed oscillator bypass"]
            #[inline(always)]
            pub fn lsebyp(&mut self) -> LSEBYP_W {
                LSEBYP_W { w: self }
            }
            #[doc = "Bits 8:9 - RTC clock source selection"]
            #[inline(always)]
            pub fn rtcsel(&mut self) -> RTCSEL_W {
                RTCSEL_W { w: self }
            }
            #[doc = "Bit 15 - RTC clock enable"]
            #[inline(always)]
            pub fn rtcen(&mut self) -> RTCEN_W {
                RTCEN_W { w: self }
            }
            #[doc = "Bit 16 - Backup domain software reset"]
            #[inline(always)]
            pub fn bdrst(&mut self) -> BDRST_W {
                BDRST_W { w: self }
            }
        }
    }
    #[doc = "Control/status register (RCC_CSR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
    pub type CSR = crate::Reg<u32, _CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSR;
    #[doc = "`read()` method returns [csr::R](csr::R) reader structure"]
    impl crate::Readable for CSR {}
    #[doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
    impl crate::Writable for CSR {}
    #[doc = "Control/status register (RCC_CSR)"]
    pub mod csr {
        #[doc = "Reader of register CSR"]
        pub type R = crate::R<u32, super::CSR>;
        #[doc = "Writer for register CSR"]
        pub type W = crate::W<u32, super::CSR>;
        #[doc = "Register CSR `reset()`'s with value 0x0c00_0000"]
        impl crate::ResetValue for super::CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0c00_0000
            }
        }
        #[doc = "Internal low speed oscillator enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSION_A {
            #[doc = "0: LSI oscillator Off"]
            OFF = 0,
            #[doc = "1: LSI oscillator On"]
            ON = 1,
        }
        impl From<LSION_A> for bool {
            #[inline(always)]
            fn from(variant: LSION_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSION`"]
        pub type LSION_R = crate::R<bool, LSION_A>;
        impl LSION_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSION_A {
                match self.bits {
                    false => LSION_A::OFF,
                    true => LSION_A::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == LSION_A::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == LSION_A::ON
            }
        }
        #[doc = "Write proxy for field `LSION`"]
        pub struct LSION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSION_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSION_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LSI oscillator Off"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(LSION_A::OFF)
            }
            #[doc = "LSI oscillator On"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(LSION_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Internal low speed oscillator ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDY_A {
            #[doc = "0: LSI oscillator not ready"]
            NOTREADY = 0,
            #[doc = "1: LSI oscillator ready"]
            READY = 1,
        }
        impl From<LSIRDY_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSIRDY`"]
        pub type LSIRDY_R = crate::R<bool, LSIRDY_A>;
        impl LSIRDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSIRDY_A {
                match self.bits {
                    false => LSIRDY_A::NOTREADY,
                    true => LSIRDY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == LSIRDY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == LSIRDY_A::READY
            }
        }
        #[doc = "Remove reset flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMVF_A {
            #[doc = "1: Clears the reset flag"]
            CLEAR = 1,
        }
        impl From<RMVF_A> for bool {
            #[inline(always)]
            fn from(variant: RMVF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RMVF`"]
        pub type RMVF_R = crate::R<bool, RMVF_A>;
        impl RMVF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, RMVF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(RMVF_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == RMVF_A::CLEAR
            }
        }
        #[doc = "Write proxy for field `RMVF`"]
        pub struct RMVF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RMVF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RMVF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the reset flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RMVF_A::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "PIN reset flag\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINRSTF_A {
            #[doc = "0: No reset has occured"]
            NORESET = 0,
            #[doc = "1: A reset has occured"]
            RESET = 1,
        }
        impl From<PINRSTF_A> for bool {
            #[inline(always)]
            fn from(variant: PINRSTF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PINRSTF`"]
        pub type PINRSTF_R = crate::R<bool, PINRSTF_A>;
        impl PINRSTF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PINRSTF_A {
                match self.bits {
                    false => PINRSTF_A::NORESET,
                    true => PINRSTF_A::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORESET`"]
            #[inline(always)]
            pub fn is_no_reset(&self) -> bool {
                *self == PINRSTF_A::NORESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == PINRSTF_A::RESET
            }
        }
        #[doc = "Write proxy for field `PINRSTF`"]
        pub struct PINRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PINRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "POR/PDR reset flag"]
        pub type PORRSTF_A = PINRSTF_A;
        #[doc = "Reader of field `PORRSTF`"]
        pub type PORRSTF_R = crate::R<bool, PINRSTF_A>;
        #[doc = "Write proxy for field `PORRSTF`"]
        pub struct PORRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PORRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PORRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Software reset flag"]
        pub type SFTRSTF_A = PINRSTF_A;
        #[doc = "Reader of field `SFTRSTF`"]
        pub type SFTRSTF_R = crate::R<bool, PINRSTF_A>;
        #[doc = "Write proxy for field `SFTRSTF`"]
        pub struct SFTRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SFTRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SFTRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Independent watchdog reset flag"]
        pub type IWDGRSTF_A = PINRSTF_A;
        #[doc = "Reader of field `IWDGRSTF`"]
        pub type IWDGRSTF_R = crate::R<bool, PINRSTF_A>;
        #[doc = "Write proxy for field `IWDGRSTF`"]
        pub struct IWDGRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IWDGRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IWDGRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Window watchdog reset flag"]
        pub type WWDGRSTF_A = PINRSTF_A;
        #[doc = "Reader of field `WWDGRSTF`"]
        pub type WWDGRSTF_R = crate::R<bool, PINRSTF_A>;
        #[doc = "Write proxy for field `WWDGRSTF`"]
        pub struct WWDGRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Low-power reset flag"]
        pub type LPWRRSTF_A = PINRSTF_A;
        #[doc = "Reader of field `LPWRRSTF`"]
        pub type LPWRRSTF_R = crate::R<bool, PINRSTF_A>;
        #[doc = "Write proxy for field `LPWRRSTF`"]
        pub struct LPWRRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPWRRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPWRRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Internal low speed oscillator enable"]
            #[inline(always)]
            pub fn lsion(&self) -> LSION_R {
                LSION_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Internal low speed oscillator ready"]
            #[inline(always)]
            pub fn lsirdy(&self) -> LSIRDY_R {
                LSIRDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Remove reset flag"]
            #[inline(always)]
            pub fn rmvf(&self) -> RMVF_R {
                RMVF_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline(always)]
            pub fn pinrstf(&self) -> PINRSTF_R {
                PINRSTF_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline(always)]
            pub fn porrstf(&self) -> PORRSTF_R {
                PORRSTF_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline(always)]
            pub fn sftrstf(&self) -> SFTRSTF_R {
                SFTRSTF_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline(always)]
            pub fn iwdgrstf(&self) -> IWDGRSTF_R {
                IWDGRSTF_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline(always)]
            pub fn wwdgrstf(&self) -> WWDGRSTF_R {
                WWDGRSTF_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline(always)]
            pub fn lpwrrstf(&self) -> LPWRRSTF_R {
                LPWRRSTF_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Internal low speed oscillator enable"]
            #[inline(always)]
            pub fn lsion(&mut self) -> LSION_W {
                LSION_W { w: self }
            }
            #[doc = "Bit 24 - Remove reset flag"]
            #[inline(always)]
            pub fn rmvf(&mut self) -> RMVF_W {
                RMVF_W { w: self }
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline(always)]
            pub fn pinrstf(&mut self) -> PINRSTF_W {
                PINRSTF_W { w: self }
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline(always)]
            pub fn porrstf(&mut self) -> PORRSTF_W {
                PORRSTF_W { w: self }
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline(always)]
            pub fn sftrstf(&mut self) -> SFTRSTF_W {
                SFTRSTF_W { w: self }
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline(always)]
            pub fn iwdgrstf(&mut self) -> IWDGRSTF_W {
                IWDGRSTF_W { w: self }
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline(always)]
            pub fn wwdgrstf(&mut self) -> WWDGRSTF_W {
                WWDGRSTF_W { w: self }
            }
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline(always)]
            pub fn lpwrrstf(&mut self) -> LPWRRSTF_W {
                LPWRRSTF_W { w: self }
            }
        }
    }
    #[doc = "Clock configuration register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr2](cfgr2) module"]
    pub type CFGR2 = crate::Reg<u32, _CFGR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR2;
    #[doc = "`read()` method returns [cfgr2::R](cfgr2::R) reader structure"]
    impl crate::Readable for CFGR2 {}
    #[doc = "`write(|w| ..)` method takes [cfgr2::W](cfgr2::W) writer structure"]
    impl crate::Writable for CFGR2 {}
    #[doc = "Clock configuration register 2"]
    pub mod cfgr2 {
        #[doc = "Reader of register CFGR2"]
        pub type R = crate::R<u32, super::CFGR2>;
        #[doc = "Writer for register CFGR2"]
        pub type W = crate::W<u32, super::CFGR2>;
        #[doc = "Register CFGR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "PREDIV1 division factor\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PREDIV1_A {
            #[doc = "0: PREDIV input clock not divided"]
            DIV1 = 0,
            #[doc = "1: PREDIV input clock divided by 2"]
            DIV2 = 1,
            #[doc = "2: PREDIV input clock divided by 3"]
            DIV3 = 2,
            #[doc = "3: PREDIV input clock divided by 4"]
            DIV4 = 3,
            #[doc = "4: PREDIV input clock divided by 5"]
            DIV5 = 4,
            #[doc = "5: PREDIV input clock divided by 6"]
            DIV6 = 5,
            #[doc = "6: PREDIV input clock divided by 7"]
            DIV7 = 6,
            #[doc = "7: PREDIV input clock divided by 8"]
            DIV8 = 7,
            #[doc = "8: PREDIV input clock divided by 9"]
            DIV9 = 8,
            #[doc = "9: PREDIV input clock divided by 10"]
            DIV10 = 9,
            #[doc = "10: PREDIV input clock divided by 11"]
            DIV11 = 10,
            #[doc = "11: PREDIV input clock divided by 12"]
            DIV12 = 11,
            #[doc = "12: PREDIV input clock divided by 13"]
            DIV13 = 12,
            #[doc = "13: PREDIV input clock divided by 14"]
            DIV14 = 13,
            #[doc = "14: PREDIV input clock divided by 15"]
            DIV15 = 14,
            #[doc = "15: PREDIV input clock divided by 16"]
            DIV16 = 15,
        }
        impl From<PREDIV1_A> for u8 {
            #[inline(always)]
            fn from(variant: PREDIV1_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PREDIV1`"]
        pub type PREDIV1_R = crate::R<u8, PREDIV1_A>;
        impl PREDIV1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PREDIV1_A {
                match self.bits {
                    0 => PREDIV1_A::DIV1,
                    1 => PREDIV1_A::DIV2,
                    2 => PREDIV1_A::DIV3,
                    3 => PREDIV1_A::DIV4,
                    4 => PREDIV1_A::DIV5,
                    5 => PREDIV1_A::DIV6,
                    6 => PREDIV1_A::DIV7,
                    7 => PREDIV1_A::DIV8,
                    8 => PREDIV1_A::DIV9,
                    9 => PREDIV1_A::DIV10,
                    10 => PREDIV1_A::DIV11,
                    11 => PREDIV1_A::DIV12,
                    12 => PREDIV1_A::DIV13,
                    13 => PREDIV1_A::DIV14,
                    14 => PREDIV1_A::DIV15,
                    15 => PREDIV1_A::DIV16,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PREDIV1_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PREDIV1_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV3`"]
            #[inline(always)]
            pub fn is_div3(&self) -> bool {
                *self == PREDIV1_A::DIV3
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PREDIV1_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV5`"]
            #[inline(always)]
            pub fn is_div5(&self) -> bool {
                *self == PREDIV1_A::DIV5
            }
            #[doc = "Checks if the value of the field is `DIV6`"]
            #[inline(always)]
            pub fn is_div6(&self) -> bool {
                *self == PREDIV1_A::DIV6
            }
            #[doc = "Checks if the value of the field is `DIV7`"]
            #[inline(always)]
            pub fn is_div7(&self) -> bool {
                *self == PREDIV1_A::DIV7
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PREDIV1_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV9`"]
            #[inline(always)]
            pub fn is_div9(&self) -> bool {
                *self == PREDIV1_A::DIV9
            }
            #[doc = "Checks if the value of the field is `DIV10`"]
            #[inline(always)]
            pub fn is_div10(&self) -> bool {
                *self == PREDIV1_A::DIV10
            }
            #[doc = "Checks if the value of the field is `DIV11`"]
            #[inline(always)]
            pub fn is_div11(&self) -> bool {
                *self == PREDIV1_A::DIV11
            }
            #[doc = "Checks if the value of the field is `DIV12`"]
            #[inline(always)]
            pub fn is_div12(&self) -> bool {
                *self == PREDIV1_A::DIV12
            }
            #[doc = "Checks if the value of the field is `DIV13`"]
            #[inline(always)]
            pub fn is_div13(&self) -> bool {
                *self == PREDIV1_A::DIV13
            }
            #[doc = "Checks if the value of the field is `DIV14`"]
            #[inline(always)]
            pub fn is_div14(&self) -> bool {
                *self == PREDIV1_A::DIV14
            }
            #[doc = "Checks if the value of the field is `DIV15`"]
            #[inline(always)]
            pub fn is_div15(&self) -> bool {
                *self == PREDIV1_A::DIV15
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PREDIV1_A::DIV16
            }
        }
        #[doc = "Write proxy for field `PREDIV1`"]
        pub struct PREDIV1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PREDIV1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PREDIV1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "PREDIV input clock not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV1)
            }
            #[doc = "PREDIV input clock divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV2)
            }
            #[doc = "PREDIV input clock divided by 3"]
            #[inline(always)]
            pub fn div3(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV3)
            }
            #[doc = "PREDIV input clock divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV4)
            }
            #[doc = "PREDIV input clock divided by 5"]
            #[inline(always)]
            pub fn div5(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV5)
            }
            #[doc = "PREDIV input clock divided by 6"]
            #[inline(always)]
            pub fn div6(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV6)
            }
            #[doc = "PREDIV input clock divided by 7"]
            #[inline(always)]
            pub fn div7(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV7)
            }
            #[doc = "PREDIV input clock divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV8)
            }
            #[doc = "PREDIV input clock divided by 9"]
            #[inline(always)]
            pub fn div9(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV9)
            }
            #[doc = "PREDIV input clock divided by 10"]
            #[inline(always)]
            pub fn div10(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV10)
            }
            #[doc = "PREDIV input clock divided by 11"]
            #[inline(always)]
            pub fn div11(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV11)
            }
            #[doc = "PREDIV input clock divided by 12"]
            #[inline(always)]
            pub fn div12(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV12)
            }
            #[doc = "PREDIV input clock divided by 13"]
            #[inline(always)]
            pub fn div13(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV13)
            }
            #[doc = "PREDIV input clock divided by 14"]
            #[inline(always)]
            pub fn div14(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV14)
            }
            #[doc = "PREDIV input clock divided by 15"]
            #[inline(always)]
            pub fn div15(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV15)
            }
            #[doc = "PREDIV input clock divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - PREDIV1 division factor"]
            #[inline(always)]
            pub fn prediv1(&self) -> PREDIV1_R {
                PREDIV1_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - PREDIV1 division factor"]
            #[inline(always)]
            pub fn prediv1(&mut self) -> PREDIV1_W {
                PREDIV1_W { w: self }
            }
        }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_0800 as *const _
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOA::ptr() }
    }
}
#[doc = "General purpose I/O"]
pub mod gpioa {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Port configuration register low (GPIOn_CRL)"]
        pub crl: CRL,
        #[doc = "0x04 - Port configuration register high (GPIOn_CRL)"]
        pub crh: CRH,
        #[doc = "0x08 - Port input data register (GPIOn_IDR)"]
        pub idr: IDR,
        #[doc = "0x0c - Port output data register (GPIOn_ODR)"]
        pub odr: ODR,
        #[doc = "0x10 - Port bit set/reset register (GPIOn_BSRR)"]
        pub bsrr: BSRR,
        #[doc = "0x14 - Port bit reset register (GPIOn_BRR)"]
        pub brr: BRR,
        #[doc = "0x18 - Port configuration lock register"]
        pub lckr: LCKR,
    }
    #[doc = "Port configuration register low (GPIOn_CRL)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crl](crl) module"]
    pub type CRL = crate::Reg<u32, _CRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRL;
    #[doc = "`read()` method returns [crl::R](crl::R) reader structure"]
    impl crate::Readable for CRL {}
    #[doc = "`write(|w| ..)` method takes [crl::W](crl::W) writer structure"]
    impl crate::Writable for CRL {}
    #[doc = "Port configuration register low (GPIOn_CRL)"]
    pub mod crl {
        #[doc = "Reader of register CRL"]
        pub type R = crate::R<u32, super::CRL>;
        #[doc = "Writer for register CRL"]
        pub type W = crate::W<u32, super::CRL>;
        #[doc = "Register CRL `reset()`'s with value 0x4444_4444"]
        impl crate::ResetValue for super::CRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x4444_4444
            }
        }
        #[doc = "Port n.0 mode bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE0_A {
            #[doc = "0: Input mode (reset state)"]
            INPUT = 0,
            #[doc = "1: Output mode 10 MHz"]
            OUTPUT = 1,
            #[doc = "2: Output mode 2 MHz"]
            OUTPUT2 = 2,
            #[doc = "3: Output mode 50 MHz"]
            OUTPUT50 = 3,
        }
        impl From<MODE0_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE0_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MODE0`"]
        pub type MODE0_R = crate::R<u8, MODE0_A>;
        impl MODE0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODE0_A {
                match self.bits {
                    0 => MODE0_A::INPUT,
                    1 => MODE0_A::OUTPUT,
                    2 => MODE0_A::OUTPUT2,
                    3 => MODE0_A::OUTPUT50,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == MODE0_A::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == MODE0_A::OUTPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT2`"]
            #[inline(always)]
            pub fn is_output2(&self) -> bool {
                *self == MODE0_A::OUTPUT2
            }
            #[doc = "Checks if the value of the field is `OUTPUT50`"]
            #[inline(always)]
            pub fn is_output50(&self) -> bool {
                *self == MODE0_A::OUTPUT50
            }
        }
        #[doc = "Write proxy for field `MODE0`"]
        pub struct MODE0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Port n.0 configuration bits\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CNF0_A {
            #[doc = "0: Analog mode / Push-Pull mode"]
            PUSHPULL = 0,
            #[doc = "1: Floating input (reset state) / Open Drain-Mode"]
            OPENDRAIN = 1,
            #[doc = "2: Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            ALTPUSHPULL = 2,
            #[doc = "3: Alternate Function Open-Drain Mode"]
            ALTOPENDRAIN = 3,
        }
        impl From<CNF0_A> for u8 {
            #[inline(always)]
            fn from(variant: CNF0_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CNF0`"]
        pub type CNF0_R = crate::R<u8, CNF0_A>;
        impl CNF0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CNF0_A {
                match self.bits {
                    0 => CNF0_A::PUSHPULL,
                    1 => CNF0_A::OPENDRAIN,
                    2 => CNF0_A::ALTPUSHPULL,
                    3 => CNF0_A::ALTOPENDRAIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PUSHPULL`"]
            #[inline(always)]
            pub fn is_push_pull(&self) -> bool {
                *self == CNF0_A::PUSHPULL
            }
            #[doc = "Checks if the value of the field is `OPENDRAIN`"]
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                *self == CNF0_A::OPENDRAIN
            }
            #[doc = "Checks if the value of the field is `ALTPUSHPULL`"]
            #[inline(always)]
            pub fn is_alt_push_pull(&self) -> bool {
                *self == CNF0_A::ALTPUSHPULL
            }
            #[doc = "Checks if the value of the field is `ALTOPENDRAIN`"]
            #[inline(always)]
            pub fn is_alt_open_drain(&self) -> bool {
                *self == CNF0_A::ALTOPENDRAIN
            }
        }
        #[doc = "Write proxy for field `CNF0`"]
        pub struct CNF0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port n.1 mode bits"]
        pub type MODE1_A = MODE0_A;
        #[doc = "Reader of field `MODE1`"]
        pub type MODE1_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE1`"]
        pub struct MODE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port n.1 configuration bits"]
        pub type CNF1_A = CNF0_A;
        #[doc = "Reader of field `CNF1`"]
        pub type CNF1_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF1`"]
        pub struct CNF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port n.2 mode bits"]
        pub type MODE2_A = MODE0_A;
        #[doc = "Reader of field `MODE2`"]
        pub type MODE2_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE2`"]
        pub struct MODE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port n.2 configuration bits"]
        pub type CNF2_A = CNF0_A;
        #[doc = "Reader of field `CNF2`"]
        pub type CNF2_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF2`"]
        pub struct CNF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port n.3 mode bits"]
        pub type MODE3_A = MODE0_A;
        #[doc = "Reader of field `MODE3`"]
        pub type MODE3_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE3`"]
        pub struct MODE3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port n.3 configuration bits"]
        pub type CNF3_A = CNF0_A;
        #[doc = "Reader of field `CNF3`"]
        pub type CNF3_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF3`"]
        pub struct CNF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port n.4 mode bits"]
        pub type MODE4_A = MODE0_A;
        #[doc = "Reader of field `MODE4`"]
        pub type MODE4_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE4`"]
        pub struct MODE4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port n.4 configuration bits"]
        pub type CNF4_A = CNF0_A;
        #[doc = "Reader of field `CNF4`"]
        pub type CNF4_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF4`"]
        pub struct CNF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port n.5 mode bits"]
        pub type MODE5_A = MODE0_A;
        #[doc = "Reader of field `MODE5`"]
        pub type MODE5_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE5`"]
        pub struct MODE5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port n.5 configuration bits"]
        pub type CNF5_A = CNF0_A;
        #[doc = "Reader of field `CNF5`"]
        pub type CNF5_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF5`"]
        pub struct CNF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port n.6 mode bits"]
        pub type MODE6_A = MODE0_A;
        #[doc = "Reader of field `MODE6`"]
        pub type MODE6_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE6`"]
        pub struct MODE6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port n.6 configuration bits"]
        pub type CNF6_A = CNF0_A;
        #[doc = "Reader of field `CNF6`"]
        pub type CNF6_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF6`"]
        pub struct CNF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port n.7 mode bits"]
        pub type MODE7_A = MODE0_A;
        #[doc = "Reader of field `MODE7`"]
        pub type MODE7_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE7`"]
        pub struct MODE7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port n.7 configuration bits"]
        pub type CNF7_A = CNF0_A;
        #[doc = "Reader of field `CNF7`"]
        pub type CNF7_R = crate::R<u8, CNF0_A>;
        #[doc = "Write proxy for field `CNF7`"]
        pub struct CNF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Port n.0 mode bits"]
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port n.0 configuration bits"]
            #[inline(always)]
            pub fn cnf0(&self) -> CNF0_R {
                CNF0_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port n.1 mode bits"]
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port n.1 configuration bits"]
            #[inline(always)]
            pub fn cnf1(&self) -> CNF1_R {
                CNF1_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port n.2 mode bits"]
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port n.2 configuration bits"]
            #[inline(always)]
            pub fn cnf2(&self) -> CNF2_R {
                CNF2_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port n.3 mode bits"]
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port n.3 configuration bits"]
            #[inline(always)]
            pub fn cnf3(&self) -> CNF3_R {
                CNF3_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port n.4 mode bits"]
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port n.4 configuration bits"]
            #[inline(always)]
            pub fn cnf4(&self) -> CNF4_R {
                CNF4_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port n.5 mode bits"]
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port n.5 configuration bits"]
            #[inline(always)]
            pub fn cnf5(&self) -> CNF5_R {
                CNF5_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port n.6 mode bits"]
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port n.6 configuration bits"]
            #[inline(always)]
            pub fn cnf6(&self) -> CNF6_R {
                CNF6_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port n.7 mode bits"]
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 30:31 - Port n.7 configuration bits"]
            #[inline(always)]
            pub fn cnf7(&self) -> CNF7_R {
                CNF7_R::new(((self.bits >> 30) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Port n.0 mode bits"]
            #[inline(always)]
            pub fn mode0(&mut self) -> MODE0_W {
                MODE0_W { w: self }
            }
            #[doc = "Bits 2:3 - Port n.0 configuration bits"]
            #[inline(always)]
            pub fn cnf0(&mut self) -> CNF0_W {
                CNF0_W { w: self }
            }
            #[doc = "Bits 4:5 - Port n.1 mode bits"]
            #[inline(always)]
            pub fn mode1(&mut self) -> MODE1_W {
                MODE1_W { w: self }
            }
            #[doc = "Bits 6:7 - Port n.1 configuration bits"]
            #[inline(always)]
            pub fn cnf1(&mut self) -> CNF1_W {
                CNF1_W { w: self }
            }
            #[doc = "Bits 8:9 - Port n.2 mode bits"]
            #[inline(always)]
            pub fn mode2(&mut self) -> MODE2_W {
                MODE2_W { w: self }
            }
            #[doc = "Bits 10:11 - Port n.2 configuration bits"]
            #[inline(always)]
            pub fn cnf2(&mut self) -> CNF2_W {
                CNF2_W { w: self }
            }
            #[doc = "Bits 12:13 - Port n.3 mode bits"]
            #[inline(always)]
            pub fn mode3(&mut self) -> MODE3_W {
                MODE3_W { w: self }
            }
            #[doc = "Bits 14:15 - Port n.3 configuration bits"]
            #[inline(always)]
            pub fn cnf3(&mut self) -> CNF3_W {
                CNF3_W { w: self }
            }
            #[doc = "Bits 16:17 - Port n.4 mode bits"]
            #[inline(always)]
            pub fn mode4(&mut self) -> MODE4_W {
                MODE4_W { w: self }
            }
            #[doc = "Bits 18:19 - Port n.4 configuration bits"]
            #[inline(always)]
            pub fn cnf4(&mut self) -> CNF4_W {
                CNF4_W { w: self }
            }
            #[doc = "Bits 20:21 - Port n.5 mode bits"]
            #[inline(always)]
            pub fn mode5(&mut self) -> MODE5_W {
                MODE5_W { w: self }
            }
            #[doc = "Bits 22:23 - Port n.5 configuration bits"]
            #[inline(always)]
            pub fn cnf5(&mut self) -> CNF5_W {
                CNF5_W { w: self }
            }
            #[doc = "Bits 24:25 - Port n.6 mode bits"]
            #[inline(always)]
            pub fn mode6(&mut self) -> MODE6_W {
                MODE6_W { w: self }
            }
            #[doc = "Bits 26:27 - Port n.6 configuration bits"]
            #[inline(always)]
            pub fn cnf6(&mut self) -> CNF6_W {
                CNF6_W { w: self }
            }
            #[doc = "Bits 28:29 - Port n.7 mode bits"]
            #[inline(always)]
            pub fn mode7(&mut self) -> MODE7_W {
                MODE7_W { w: self }
            }
            #[doc = "Bits 30:31 - Port n.7 configuration bits"]
            #[inline(always)]
            pub fn cnf7(&mut self) -> CNF7_W {
                CNF7_W { w: self }
            }
        }
    }
    #[doc = "Port configuration register high (GPIOn_CRL)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crh](crh) module"]
    pub type CRH = crate::Reg<u32, _CRH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRH;
    #[doc = "`read()` method returns [crh::R](crh::R) reader structure"]
    impl crate::Readable for CRH {}
    #[doc = "`write(|w| ..)` method takes [crh::W](crh::W) writer structure"]
    impl crate::Writable for CRH {}
    #[doc = "Port configuration register high (GPIOn_CRL)"]
    pub mod crh {
        #[doc = "Reader of register CRH"]
        pub type R = crate::R<u32, super::CRH>;
        #[doc = "Writer for register CRH"]
        pub type W = crate::W<u32, super::CRH>;
        #[doc = "Register CRH `reset()`'s with value 0x4444_4444"]
        impl crate::ResetValue for super::CRH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x4444_4444
            }
        }
        #[doc = "Port n.8 mode bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE8_A {
            #[doc = "0: Input mode (reset state)"]
            INPUT = 0,
            #[doc = "1: Output mode 10 MHz"]
            OUTPUT = 1,
            #[doc = "2: Output mode 2 MHz"]
            OUTPUT2 = 2,
            #[doc = "3: Output mode 50 MHz"]
            OUTPUT50 = 3,
        }
        impl From<MODE8_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE8_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MODE8`"]
        pub type MODE8_R = crate::R<u8, MODE8_A>;
        impl MODE8_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODE8_A {
                match self.bits {
                    0 => MODE8_A::INPUT,
                    1 => MODE8_A::OUTPUT,
                    2 => MODE8_A::OUTPUT2,
                    3 => MODE8_A::OUTPUT50,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == MODE8_A::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == MODE8_A::OUTPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT2`"]
            #[inline(always)]
            pub fn is_output2(&self) -> bool {
                *self == MODE8_A::OUTPUT2
            }
            #[doc = "Checks if the value of the field is `OUTPUT50`"]
            #[inline(always)]
            pub fn is_output50(&self) -> bool {
                *self == MODE8_A::OUTPUT50
            }
        }
        #[doc = "Write proxy for field `MODE8`"]
        pub struct MODE8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Port n.8 configuration bits\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CNF8_A {
            #[doc = "0: Analog mode / Push-Pull mode"]
            PUSHPULL = 0,
            #[doc = "1: Floating input (reset state) / Open Drain-Mode"]
            OPENDRAIN = 1,
            #[doc = "2: Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            ALTPUSHPULL = 2,
            #[doc = "3: Alternate Function Open-Drain Mode"]
            ALTOPENDRAIN = 3,
        }
        impl From<CNF8_A> for u8 {
            #[inline(always)]
            fn from(variant: CNF8_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CNF8`"]
        pub type CNF8_R = crate::R<u8, CNF8_A>;
        impl CNF8_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CNF8_A {
                match self.bits {
                    0 => CNF8_A::PUSHPULL,
                    1 => CNF8_A::OPENDRAIN,
                    2 => CNF8_A::ALTPUSHPULL,
                    3 => CNF8_A::ALTOPENDRAIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `PUSHPULL`"]
            #[inline(always)]
            pub fn is_push_pull(&self) -> bool {
                *self == CNF8_A::PUSHPULL
            }
            #[doc = "Checks if the value of the field is `OPENDRAIN`"]
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                *self == CNF8_A::OPENDRAIN
            }
            #[doc = "Checks if the value of the field is `ALTPUSHPULL`"]
            #[inline(always)]
            pub fn is_alt_push_pull(&self) -> bool {
                *self == CNF8_A::ALTPUSHPULL
            }
            #[doc = "Checks if the value of the field is `ALTOPENDRAIN`"]
            #[inline(always)]
            pub fn is_alt_open_drain(&self) -> bool {
                *self == CNF8_A::ALTOPENDRAIN
            }
        }
        #[doc = "Write proxy for field `CNF8`"]
        pub struct CNF8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port n.9 mode bits"]
        pub type MODE9_A = MODE8_A;
        #[doc = "Reader of field `MODE9`"]
        pub type MODE9_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE9`"]
        pub struct MODE9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port n.9 configuration bits"]
        pub type CNF9_A = CNF8_A;
        #[doc = "Reader of field `CNF9`"]
        pub type CNF9_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF9`"]
        pub struct CNF9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port n.10 mode bits"]
        pub type MODE10_A = MODE8_A;
        #[doc = "Reader of field `MODE10`"]
        pub type MODE10_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE10`"]
        pub struct MODE10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port n.10 configuration bits"]
        pub type CNF10_A = CNF8_A;
        #[doc = "Reader of field `CNF10`"]
        pub type CNF10_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF10`"]
        pub struct CNF10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port n.11 mode bits"]
        pub type MODE11_A = MODE8_A;
        #[doc = "Reader of field `MODE11`"]
        pub type MODE11_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE11`"]
        pub struct MODE11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port n.11 configuration bits"]
        pub type CNF11_A = CNF8_A;
        #[doc = "Reader of field `CNF11`"]
        pub type CNF11_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF11`"]
        pub struct CNF11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port n.12 mode bits"]
        pub type MODE12_A = MODE8_A;
        #[doc = "Reader of field `MODE12`"]
        pub type MODE12_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE12`"]
        pub struct MODE12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port n.12 configuration bits"]
        pub type CNF12_A = CNF8_A;
        #[doc = "Reader of field `CNF12`"]
        pub type CNF12_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF12`"]
        pub struct CNF12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port n.13 mode bits"]
        pub type MODE13_A = MODE8_A;
        #[doc = "Reader of field `MODE13`"]
        pub type MODE13_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE13`"]
        pub struct MODE13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port n.13 configuration bits"]
        pub type CNF13_A = CNF8_A;
        #[doc = "Reader of field `CNF13`"]
        pub type CNF13_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF13`"]
        pub struct CNF13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port n.14 mode bits"]
        pub type MODE14_A = MODE8_A;
        #[doc = "Reader of field `MODE14`"]
        pub type MODE14_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE14`"]
        pub struct MODE14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port n.14 configuration bits"]
        pub type CNF14_A = CNF8_A;
        #[doc = "Reader of field `CNF14`"]
        pub type CNF14_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF14`"]
        pub struct CNF14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port n.15 mode bits"]
        pub type MODE15_A = MODE8_A;
        #[doc = "Reader of field `MODE15`"]
        pub type MODE15_R = crate::R<u8, MODE8_A>;
        #[doc = "Write proxy for field `MODE15`"]
        pub struct MODE15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            #[doc = "Output mode 10 MHz"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            #[doc = "Output mode 2 MHz"]
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            #[doc = "Output mode 50 MHz"]
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port n.15 configuration bits"]
        pub type CNF15_A = CNF8_A;
        #[doc = "Reader of field `CNF15`"]
        pub type CNF15_R = crate::R<u8, CNF8_A>;
        #[doc = "Write proxy for field `CNF15`"]
        pub struct CNF15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNF15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Analog mode / Push-Pull mode"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            #[doc = "Floating input (reset state) / Open Drain-Mode"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            #[doc = "Input with pull-up/pull-down / Alternate Function Push-Pull Mode"]
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            #[doc = "Alternate Function Open-Drain Mode"]
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Port n.8 mode bits"]
            #[inline(always)]
            pub fn mode8(&self) -> MODE8_R {
                MODE8_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port n.8 configuration bits"]
            #[inline(always)]
            pub fn cnf8(&self) -> CNF8_R {
                CNF8_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port n.9 mode bits"]
            #[inline(always)]
            pub fn mode9(&self) -> MODE9_R {
                MODE9_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port n.9 configuration bits"]
            #[inline(always)]
            pub fn cnf9(&self) -> CNF9_R {
                CNF9_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port n.10 mode bits"]
            #[inline(always)]
            pub fn mode10(&self) -> MODE10_R {
                MODE10_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port n.10 configuration bits"]
            #[inline(always)]
            pub fn cnf10(&self) -> CNF10_R {
                CNF10_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port n.11 mode bits"]
            #[inline(always)]
            pub fn mode11(&self) -> MODE11_R {
                MODE11_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port n.11 configuration bits"]
            #[inline(always)]
            pub fn cnf11(&self) -> CNF11_R {
                CNF11_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port n.12 mode bits"]
            #[inline(always)]
            pub fn mode12(&self) -> MODE12_R {
                MODE12_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port n.12 configuration bits"]
            #[inline(always)]
            pub fn cnf12(&self) -> CNF12_R {
                CNF12_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port n.13 mode bits"]
            #[inline(always)]
            pub fn mode13(&self) -> MODE13_R {
                MODE13_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port n.13 configuration bits"]
            #[inline(always)]
            pub fn cnf13(&self) -> CNF13_R {
                CNF13_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port n.14 mode bits"]
            #[inline(always)]
            pub fn mode14(&self) -> MODE14_R {
                MODE14_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port n.14 configuration bits"]
            #[inline(always)]
            pub fn cnf14(&self) -> CNF14_R {
                CNF14_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port n.15 mode bits"]
            #[inline(always)]
            pub fn mode15(&self) -> MODE15_R {
                MODE15_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 30:31 - Port n.15 configuration bits"]
            #[inline(always)]
            pub fn cnf15(&self) -> CNF15_R {
                CNF15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Port n.8 mode bits"]
            #[inline(always)]
            pub fn mode8(&mut self) -> MODE8_W {
                MODE8_W { w: self }
            }
            #[doc = "Bits 2:3 - Port n.8 configuration bits"]
            #[inline(always)]
            pub fn cnf8(&mut self) -> CNF8_W {
                CNF8_W { w: self }
            }
            #[doc = "Bits 4:5 - Port n.9 mode bits"]
            #[inline(always)]
            pub fn mode9(&mut self) -> MODE9_W {
                MODE9_W { w: self }
            }
            #[doc = "Bits 6:7 - Port n.9 configuration bits"]
            #[inline(always)]
            pub fn cnf9(&mut self) -> CNF9_W {
                CNF9_W { w: self }
            }
            #[doc = "Bits 8:9 - Port n.10 mode bits"]
            #[inline(always)]
            pub fn mode10(&mut self) -> MODE10_W {
                MODE10_W { w: self }
            }
            #[doc = "Bits 10:11 - Port n.10 configuration bits"]
            #[inline(always)]
            pub fn cnf10(&mut self) -> CNF10_W {
                CNF10_W { w: self }
            }
            #[doc = "Bits 12:13 - Port n.11 mode bits"]
            #[inline(always)]
            pub fn mode11(&mut self) -> MODE11_W {
                MODE11_W { w: self }
            }
            #[doc = "Bits 14:15 - Port n.11 configuration bits"]
            #[inline(always)]
            pub fn cnf11(&mut self) -> CNF11_W {
                CNF11_W { w: self }
            }
            #[doc = "Bits 16:17 - Port n.12 mode bits"]
            #[inline(always)]
            pub fn mode12(&mut self) -> MODE12_W {
                MODE12_W { w: self }
            }
            #[doc = "Bits 18:19 - Port n.12 configuration bits"]
            #[inline(always)]
            pub fn cnf12(&mut self) -> CNF12_W {
                CNF12_W { w: self }
            }
            #[doc = "Bits 20:21 - Port n.13 mode bits"]
            #[inline(always)]
            pub fn mode13(&mut self) -> MODE13_W {
                MODE13_W { w: self }
            }
            #[doc = "Bits 22:23 - Port n.13 configuration bits"]
            #[inline(always)]
            pub fn cnf13(&mut self) -> CNF13_W {
                CNF13_W { w: self }
            }
            #[doc = "Bits 24:25 - Port n.14 mode bits"]
            #[inline(always)]
            pub fn mode14(&mut self) -> MODE14_W {
                MODE14_W { w: self }
            }
            #[doc = "Bits 26:27 - Port n.14 configuration bits"]
            #[inline(always)]
            pub fn cnf14(&mut self) -> CNF14_W {
                CNF14_W { w: self }
            }
            #[doc = "Bits 28:29 - Port n.15 mode bits"]
            #[inline(always)]
            pub fn mode15(&mut self) -> MODE15_W {
                MODE15_W { w: self }
            }
            #[doc = "Bits 30:31 - Port n.15 configuration bits"]
            #[inline(always)]
            pub fn cnf15(&mut self) -> CNF15_W {
                CNF15_W { w: self }
            }
        }
    }
    #[doc = "Port input data register (GPIOn_IDR)\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "Port input data register (GPIOn_IDR)"]
    pub mod idr {
        #[doc = "Reader of register IDR"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Port input data\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR0_A {
            #[doc = "1: Input is logic high"]
            HIGH = 1,
            #[doc = "0: Input is logic low"]
            LOW = 0,
        }
        impl From<IDR0_A> for bool {
            #[inline(always)]
            fn from(variant: IDR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IDR0`"]
        pub type IDR0_R = crate::R<bool, IDR0_A>;
        impl IDR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDR0_A {
                match self.bits {
                    true => IDR0_A::HIGH,
                    false => IDR0_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IDR0_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IDR0_A::LOW
            }
        }
        #[doc = "Port input data"]
        pub type IDR1_A = IDR0_A;
        #[doc = "Reader of field `IDR1`"]
        pub type IDR1_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR2_A = IDR0_A;
        #[doc = "Reader of field `IDR2`"]
        pub type IDR2_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR3_A = IDR0_A;
        #[doc = "Reader of field `IDR3`"]
        pub type IDR3_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR4_A = IDR0_A;
        #[doc = "Reader of field `IDR4`"]
        pub type IDR4_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR5_A = IDR0_A;
        #[doc = "Reader of field `IDR5`"]
        pub type IDR5_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR6_A = IDR0_A;
        #[doc = "Reader of field `IDR6`"]
        pub type IDR6_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR7_A = IDR0_A;
        #[doc = "Reader of field `IDR7`"]
        pub type IDR7_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR8_A = IDR0_A;
        #[doc = "Reader of field `IDR8`"]
        pub type IDR8_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR9_A = IDR0_A;
        #[doc = "Reader of field `IDR9`"]
        pub type IDR9_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR10_A = IDR0_A;
        #[doc = "Reader of field `IDR10`"]
        pub type IDR10_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR11_A = IDR0_A;
        #[doc = "Reader of field `IDR11`"]
        pub type IDR11_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR12_A = IDR0_A;
        #[doc = "Reader of field `IDR12`"]
        pub type IDR12_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR13_A = IDR0_A;
        #[doc = "Reader of field `IDR13`"]
        pub type IDR13_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR14_A = IDR0_A;
        #[doc = "Reader of field `IDR14`"]
        pub type IDR14_R = crate::R<bool, IDR0_A>;
        #[doc = "Port input data"]
        pub type IDR15_A = IDR0_A;
        #[doc = "Reader of field `IDR15`"]
        pub type IDR15_R = crate::R<bool, IDR0_A>;
        impl R {
            #[doc = "Bit 0 - Port input data"]
            #[inline(always)]
            pub fn idr0(&self) -> IDR0_R {
                IDR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port input data"]
            #[inline(always)]
            pub fn idr1(&self) -> IDR1_R {
                IDR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port input data"]
            #[inline(always)]
            pub fn idr2(&self) -> IDR2_R {
                IDR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port input data"]
            #[inline(always)]
            pub fn idr3(&self) -> IDR3_R {
                IDR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port input data"]
            #[inline(always)]
            pub fn idr4(&self) -> IDR4_R {
                IDR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port input data"]
            #[inline(always)]
            pub fn idr5(&self) -> IDR5_R {
                IDR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port input data"]
            #[inline(always)]
            pub fn idr6(&self) -> IDR6_R {
                IDR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port input data"]
            #[inline(always)]
            pub fn idr7(&self) -> IDR7_R {
                IDR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port input data"]
            #[inline(always)]
            pub fn idr8(&self) -> IDR8_R {
                IDR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port input data"]
            #[inline(always)]
            pub fn idr9(&self) -> IDR9_R {
                IDR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port input data"]
            #[inline(always)]
            pub fn idr10(&self) -> IDR10_R {
                IDR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port input data"]
            #[inline(always)]
            pub fn idr11(&self) -> IDR11_R {
                IDR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port input data"]
            #[inline(always)]
            pub fn idr12(&self) -> IDR12_R {
                IDR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port input data"]
            #[inline(always)]
            pub fn idr13(&self) -> IDR13_R {
                IDR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port input data"]
            #[inline(always)]
            pub fn idr14(&self) -> IDR14_R {
                IDR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Port input data"]
            #[inline(always)]
            pub fn idr15(&self) -> IDR15_R {
                IDR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
    }
    #[doc = "Port output data register (GPIOn_ODR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [odr](odr) module"]
    pub type ODR = crate::Reg<u32, _ODR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ODR;
    #[doc = "`read()` method returns [odr::R](odr::R) reader structure"]
    impl crate::Readable for ODR {}
    #[doc = "`write(|w| ..)` method takes [odr::W](odr::W) writer structure"]
    impl crate::Writable for ODR {}
    #[doc = "Port output data register (GPIOn_ODR)"]
    pub mod odr {
        #[doc = "Reader of register ODR"]
        pub type R = crate::R<u32, super::ODR>;
        #[doc = "Writer for register ODR"]
        pub type W = crate::W<u32, super::ODR>;
        #[doc = "Register ODR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ODR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port output data\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR0_A {
            #[doc = "1: Set output to logic high"]
            HIGH = 1,
            #[doc = "0: Set output to logic low"]
            LOW = 0,
        }
        impl From<ODR0_A> for bool {
            #[inline(always)]
            fn from(variant: ODR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ODR0`"]
        pub type ODR0_R = crate::R<bool, ODR0_A>;
        impl ODR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ODR0_A {
                match self.bits {
                    true => ODR0_A::HIGH,
                    false => ODR0_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == ODR0_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == ODR0_A::LOW
            }
        }
        #[doc = "Write proxy for field `ODR0`"]
        pub struct ODR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR1_A = ODR0_A;
        #[doc = "Reader of field `ODR1`"]
        pub type ODR1_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR1`"]
        pub struct ODR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR2_A = ODR0_A;
        #[doc = "Reader of field `ODR2`"]
        pub type ODR2_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR2`"]
        pub struct ODR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR3_A = ODR0_A;
        #[doc = "Reader of field `ODR3`"]
        pub type ODR3_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR3`"]
        pub struct ODR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR4_A = ODR0_A;
        #[doc = "Reader of field `ODR4`"]
        pub type ODR4_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR4`"]
        pub struct ODR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR5_A = ODR0_A;
        #[doc = "Reader of field `ODR5`"]
        pub type ODR5_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR5`"]
        pub struct ODR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR6_A = ODR0_A;
        #[doc = "Reader of field `ODR6`"]
        pub type ODR6_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR6`"]
        pub struct ODR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR7_A = ODR0_A;
        #[doc = "Reader of field `ODR7`"]
        pub type ODR7_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR7`"]
        pub struct ODR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR8_A = ODR0_A;
        #[doc = "Reader of field `ODR8`"]
        pub type ODR8_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR8`"]
        pub struct ODR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR9_A = ODR0_A;
        #[doc = "Reader of field `ODR9`"]
        pub type ODR9_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR9`"]
        pub struct ODR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR10_A = ODR0_A;
        #[doc = "Reader of field `ODR10`"]
        pub type ODR10_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR10`"]
        pub struct ODR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR11_A = ODR0_A;
        #[doc = "Reader of field `ODR11`"]
        pub type ODR11_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR11`"]
        pub struct ODR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR12_A = ODR0_A;
        #[doc = "Reader of field `ODR12`"]
        pub type ODR12_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR12`"]
        pub struct ODR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR13_A = ODR0_A;
        #[doc = "Reader of field `ODR13`"]
        pub type ODR13_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR13`"]
        pub struct ODR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR14_A = ODR0_A;
        #[doc = "Reader of field `ODR14`"]
        pub type ODR14_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR14`"]
        pub struct ODR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port output data"]
        pub type ODR15_A = ODR0_A;
        #[doc = "Reader of field `ODR15`"]
        pub type ODR15_R = crate::R<bool, ODR0_A>;
        #[doc = "Write proxy for field `ODR15`"]
        pub struct ODR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODR15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Port output data"]
            #[inline(always)]
            pub fn odr0(&self) -> ODR0_R {
                ODR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port output data"]
            #[inline(always)]
            pub fn odr1(&self) -> ODR1_R {
                ODR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port output data"]
            #[inline(always)]
            pub fn odr2(&self) -> ODR2_R {
                ODR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port output data"]
            #[inline(always)]
            pub fn odr3(&self) -> ODR3_R {
                ODR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port output data"]
            #[inline(always)]
            pub fn odr4(&self) -> ODR4_R {
                ODR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port output data"]
            #[inline(always)]
            pub fn odr5(&self) -> ODR5_R {
                ODR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port output data"]
            #[inline(always)]
            pub fn odr6(&self) -> ODR6_R {
                ODR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port output data"]
            #[inline(always)]
            pub fn odr7(&self) -> ODR7_R {
                ODR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port output data"]
            #[inline(always)]
            pub fn odr8(&self) -> ODR8_R {
                ODR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port output data"]
            #[inline(always)]
            pub fn odr9(&self) -> ODR9_R {
                ODR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port output data"]
            #[inline(always)]
            pub fn odr10(&self) -> ODR10_R {
                ODR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port output data"]
            #[inline(always)]
            pub fn odr11(&self) -> ODR11_R {
                ODR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port output data"]
            #[inline(always)]
            pub fn odr12(&self) -> ODR12_R {
                ODR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port output data"]
            #[inline(always)]
            pub fn odr13(&self) -> ODR13_R {
                ODR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port output data"]
            #[inline(always)]
            pub fn odr14(&self) -> ODR14_R {
                ODR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Port output data"]
            #[inline(always)]
            pub fn odr15(&self) -> ODR15_R {
                ODR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Port output data"]
            #[inline(always)]
            pub fn odr0(&mut self) -> ODR0_W {
                ODR0_W { w: self }
            }
            #[doc = "Bit 1 - Port output data"]
            #[inline(always)]
            pub fn odr1(&mut self) -> ODR1_W {
                ODR1_W { w: self }
            }
            #[doc = "Bit 2 - Port output data"]
            #[inline(always)]
            pub fn odr2(&mut self) -> ODR2_W {
                ODR2_W { w: self }
            }
            #[doc = "Bit 3 - Port output data"]
            #[inline(always)]
            pub fn odr3(&mut self) -> ODR3_W {
                ODR3_W { w: self }
            }
            #[doc = "Bit 4 - Port output data"]
            #[inline(always)]
            pub fn odr4(&mut self) -> ODR4_W {
                ODR4_W { w: self }
            }
            #[doc = "Bit 5 - Port output data"]
            #[inline(always)]
            pub fn odr5(&mut self) -> ODR5_W {
                ODR5_W { w: self }
            }
            #[doc = "Bit 6 - Port output data"]
            #[inline(always)]
            pub fn odr6(&mut self) -> ODR6_W {
                ODR6_W { w: self }
            }
            #[doc = "Bit 7 - Port output data"]
            #[inline(always)]
            pub fn odr7(&mut self) -> ODR7_W {
                ODR7_W { w: self }
            }
            #[doc = "Bit 8 - Port output data"]
            #[inline(always)]
            pub fn odr8(&mut self) -> ODR8_W {
                ODR8_W { w: self }
            }
            #[doc = "Bit 9 - Port output data"]
            #[inline(always)]
            pub fn odr9(&mut self) -> ODR9_W {
                ODR9_W { w: self }
            }
            #[doc = "Bit 10 - Port output data"]
            #[inline(always)]
            pub fn odr10(&mut self) -> ODR10_W {
                ODR10_W { w: self }
            }
            #[doc = "Bit 11 - Port output data"]
            #[inline(always)]
            pub fn odr11(&mut self) -> ODR11_W {
                ODR11_W { w: self }
            }
            #[doc = "Bit 12 - Port output data"]
            #[inline(always)]
            pub fn odr12(&mut self) -> ODR12_W {
                ODR12_W { w: self }
            }
            #[doc = "Bit 13 - Port output data"]
            #[inline(always)]
            pub fn odr13(&mut self) -> ODR13_W {
                ODR13_W { w: self }
            }
            #[doc = "Bit 14 - Port output data"]
            #[inline(always)]
            pub fn odr14(&mut self) -> ODR14_W {
                ODR14_W { w: self }
            }
            #[doc = "Bit 15 - Port output data"]
            #[inline(always)]
            pub fn odr15(&mut self) -> ODR15_W {
                ODR15_W { w: self }
            }
        }
    }
    #[doc = "Port bit set/reset register (GPIOn_BSRR)\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bsrr](bsrr) module"]
    pub type BSRR = crate::Reg<u32, _BSRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BSRR;
    #[doc = "`write(|w| ..)` method takes [bsrr::W](bsrr::W) writer structure"]
    impl crate::Writable for BSRR {}
    #[doc = "Port bit set/reset register (GPIOn_BSRR)"]
    pub mod bsrr {
        #[doc = "Writer for register BSRR"]
        pub type W = crate::W<u32, super::BSRR>;
        #[doc = "Register BSRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BSRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Set bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BS0_AW {
            #[doc = "1: Sets the corresponding ODRx bit"]
            SET = 1,
        }
        impl From<BS0_AW> for bool {
            #[inline(always)]
            fn from(variant: BS0_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BS0`"]
        pub struct BS0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Set bit 1"]
        pub type BS1_AW = BS0_AW;
        #[doc = "Write proxy for field `BS1`"]
        pub struct BS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Set bit 1"]
        pub type BS2_AW = BS0_AW;
        #[doc = "Write proxy for field `BS2`"]
        pub struct BS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Set bit 3"]
        pub type BS3_AW = BS0_AW;
        #[doc = "Write proxy for field `BS3`"]
        pub struct BS3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Set bit 4"]
        pub type BS4_AW = BS0_AW;
        #[doc = "Write proxy for field `BS4`"]
        pub struct BS4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Set bit 5"]
        pub type BS5_AW = BS0_AW;
        #[doc = "Write proxy for field `BS5`"]
        pub struct BS5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Set bit 6"]
        pub type BS6_AW = BS0_AW;
        #[doc = "Write proxy for field `BS6`"]
        pub struct BS6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Set bit 7"]
        pub type BS7_AW = BS0_AW;
        #[doc = "Write proxy for field `BS7`"]
        pub struct BS7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Set bit 8"]
        pub type BS8_AW = BS0_AW;
        #[doc = "Write proxy for field `BS8`"]
        pub struct BS8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Set bit 9"]
        pub type BS9_AW = BS0_AW;
        #[doc = "Write proxy for field `BS9`"]
        pub struct BS9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Set bit 10"]
        pub type BS10_AW = BS0_AW;
        #[doc = "Write proxy for field `BS10`"]
        pub struct BS10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Set bit 11"]
        pub type BS11_AW = BS0_AW;
        #[doc = "Write proxy for field `BS11`"]
        pub struct BS11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Set bit 12"]
        pub type BS12_AW = BS0_AW;
        #[doc = "Write proxy for field `BS12`"]
        pub struct BS12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Set bit 13"]
        pub type BS13_AW = BS0_AW;
        #[doc = "Write proxy for field `BS13`"]
        pub struct BS13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Set bit 14"]
        pub type BS14_AW = BS0_AW;
        #[doc = "Write proxy for field `BS14`"]
        pub struct BS14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Set bit 15"]
        pub type BS15_AW = BS0_AW;
        #[doc = "Write proxy for field `BS15`"]
        pub struct BS15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reset bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BR0_AW {
            #[doc = "1: Resets the corresponding ODRx bit"]
            RESET = 1,
        }
        impl From<BR0_AW> for bool {
            #[inline(always)]
            fn from(variant: BR0_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BR0`"]
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reset bit 1"]
        pub type BR1_AW = BR0_AW;
        #[doc = "Write proxy for field `BR1`"]
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Reset bit 2"]
        pub type BR2_AW = BR0_AW;
        #[doc = "Write proxy for field `BR2`"]
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Reset bit 3"]
        pub type BR3_AW = BR0_AW;
        #[doc = "Write proxy for field `BR3`"]
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Reset bit 4"]
        pub type BR4_AW = BR0_AW;
        #[doc = "Write proxy for field `BR4`"]
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reset bit 5"]
        pub type BR5_AW = BR0_AW;
        #[doc = "Write proxy for field `BR5`"]
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reset bit 6"]
        pub type BR6_AW = BR0_AW;
        #[doc = "Write proxy for field `BR6`"]
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reset bit 7"]
        pub type BR7_AW = BR0_AW;
        #[doc = "Write proxy for field `BR7`"]
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reset bit 8"]
        pub type BR8_AW = BR0_AW;
        #[doc = "Write proxy for field `BR8`"]
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reset bit 9"]
        pub type BR9_AW = BR0_AW;
        #[doc = "Write proxy for field `BR9`"]
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Reset bit 10"]
        pub type BR10_AW = BR0_AW;
        #[doc = "Write proxy for field `BR10`"]
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Reset bit 11"]
        pub type BR11_AW = BR0_AW;
        #[doc = "Write proxy for field `BR11`"]
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Reset bit 12"]
        pub type BR12_AW = BR0_AW;
        #[doc = "Write proxy for field `BR12`"]
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Reset bit 13"]
        pub type BR13_AW = BR0_AW;
        #[doc = "Write proxy for field `BR13`"]
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Reset bit 14"]
        pub type BR14_AW = BR0_AW;
        #[doc = "Write proxy for field `BR14`"]
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Reset bit 15"]
        pub type BR15_AW = BR0_AW;
        #[doc = "Write proxy for field `BR15`"]
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - Set bit 0"]
            #[inline(always)]
            pub fn bs0(&mut self) -> BS0_W {
                BS0_W { w: self }
            }
            #[doc = "Bit 1 - Set bit 1"]
            #[inline(always)]
            pub fn bs1(&mut self) -> BS1_W {
                BS1_W { w: self }
            }
            #[doc = "Bit 2 - Set bit 1"]
            #[inline(always)]
            pub fn bs2(&mut self) -> BS2_W {
                BS2_W { w: self }
            }
            #[doc = "Bit 3 - Set bit 3"]
            #[inline(always)]
            pub fn bs3(&mut self) -> BS3_W {
                BS3_W { w: self }
            }
            #[doc = "Bit 4 - Set bit 4"]
            #[inline(always)]
            pub fn bs4(&mut self) -> BS4_W {
                BS4_W { w: self }
            }
            #[doc = "Bit 5 - Set bit 5"]
            #[inline(always)]
            pub fn bs5(&mut self) -> BS5_W {
                BS5_W { w: self }
            }
            #[doc = "Bit 6 - Set bit 6"]
            #[inline(always)]
            pub fn bs6(&mut self) -> BS6_W {
                BS6_W { w: self }
            }
            #[doc = "Bit 7 - Set bit 7"]
            #[inline(always)]
            pub fn bs7(&mut self) -> BS7_W {
                BS7_W { w: self }
            }
            #[doc = "Bit 8 - Set bit 8"]
            #[inline(always)]
            pub fn bs8(&mut self) -> BS8_W {
                BS8_W { w: self }
            }
            #[doc = "Bit 9 - Set bit 9"]
            #[inline(always)]
            pub fn bs9(&mut self) -> BS9_W {
                BS9_W { w: self }
            }
            #[doc = "Bit 10 - Set bit 10"]
            #[inline(always)]
            pub fn bs10(&mut self) -> BS10_W {
                BS10_W { w: self }
            }
            #[doc = "Bit 11 - Set bit 11"]
            #[inline(always)]
            pub fn bs11(&mut self) -> BS11_W {
                BS11_W { w: self }
            }
            #[doc = "Bit 12 - Set bit 12"]
            #[inline(always)]
            pub fn bs12(&mut self) -> BS12_W {
                BS12_W { w: self }
            }
            #[doc = "Bit 13 - Set bit 13"]
            #[inline(always)]
            pub fn bs13(&mut self) -> BS13_W {
                BS13_W { w: self }
            }
            #[doc = "Bit 14 - Set bit 14"]
            #[inline(always)]
            pub fn bs14(&mut self) -> BS14_W {
                BS14_W { w: self }
            }
            #[doc = "Bit 15 - Set bit 15"]
            #[inline(always)]
            pub fn bs15(&mut self) -> BS15_W {
                BS15_W { w: self }
            }
            #[doc = "Bit 16 - Reset bit 0"]
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
            #[doc = "Bit 17 - Reset bit 1"]
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            #[doc = "Bit 18 - Reset bit 2"]
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            #[doc = "Bit 19 - Reset bit 3"]
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            #[doc = "Bit 20 - Reset bit 4"]
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            #[doc = "Bit 21 - Reset bit 5"]
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            #[doc = "Bit 22 - Reset bit 6"]
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            #[doc = "Bit 23 - Reset bit 7"]
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            #[doc = "Bit 24 - Reset bit 8"]
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            #[doc = "Bit 25 - Reset bit 9"]
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            #[doc = "Bit 26 - Reset bit 10"]
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            #[doc = "Bit 27 - Reset bit 11"]
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            #[doc = "Bit 28 - Reset bit 12"]
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            #[doc = "Bit 29 - Reset bit 13"]
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            #[doc = "Bit 30 - Reset bit 14"]
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            #[doc = "Bit 31 - Reset bit 15"]
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
        }
    }
    #[doc = "Port bit reset register (GPIOn_BRR)\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "Port bit reset register (GPIOn_BRR)"]
    pub mod brr {
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reset bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BR0_AW {
            #[doc = "0: No action on the corresponding ODx bit"]
            NOACTION = 0,
            #[doc = "1: Reset the ODx bit"]
            RESET = 1,
        }
        impl From<BR0_AW> for bool {
            #[inline(always)]
            fn from(variant: BR0_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BR0`"]
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reset bit 1"]
        pub type BR1_AW = BR0_AW;
        #[doc = "Write proxy for field `BR1`"]
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reset bit 1"]
        pub type BR2_AW = BR0_AW;
        #[doc = "Write proxy for field `BR2`"]
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reset bit 3"]
        pub type BR3_AW = BR0_AW;
        #[doc = "Write proxy for field `BR3`"]
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reset bit 4"]
        pub type BR4_AW = BR0_AW;
        #[doc = "Write proxy for field `BR4`"]
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reset bit 5"]
        pub type BR5_AW = BR0_AW;
        #[doc = "Write proxy for field `BR5`"]
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reset bit 6"]
        pub type BR6_AW = BR0_AW;
        #[doc = "Write proxy for field `BR6`"]
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reset bit 7"]
        pub type BR7_AW = BR0_AW;
        #[doc = "Write proxy for field `BR7`"]
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reset bit 8"]
        pub type BR8_AW = BR0_AW;
        #[doc = "Write proxy for field `BR8`"]
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reset bit 9"]
        pub type BR9_AW = BR0_AW;
        #[doc = "Write proxy for field `BR9`"]
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reset bit 10"]
        pub type BR10_AW = BR0_AW;
        #[doc = "Write proxy for field `BR10`"]
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reset bit 11"]
        pub type BR11_AW = BR0_AW;
        #[doc = "Write proxy for field `BR11`"]
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reset bit 12"]
        pub type BR12_AW = BR0_AW;
        #[doc = "Write proxy for field `BR12`"]
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reset bit 13"]
        pub type BR13_AW = BR0_AW;
        #[doc = "Write proxy for field `BR13`"]
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reset bit 14"]
        pub type BR14_AW = BR0_AW;
        #[doc = "Write proxy for field `BR14`"]
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reset bit 15"]
        pub type BR15_AW = BR0_AW;
        #[doc = "Write proxy for field `BR15`"]
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - Reset bit 0"]
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
            #[doc = "Bit 1 - Reset bit 1"]
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            #[doc = "Bit 2 - Reset bit 1"]
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            #[doc = "Bit 3 - Reset bit 3"]
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            #[doc = "Bit 4 - Reset bit 4"]
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            #[doc = "Bit 5 - Reset bit 5"]
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            #[doc = "Bit 6 - Reset bit 6"]
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            #[doc = "Bit 7 - Reset bit 7"]
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            #[doc = "Bit 8 - Reset bit 8"]
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            #[doc = "Bit 9 - Reset bit 9"]
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            #[doc = "Bit 10 - Reset bit 10"]
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            #[doc = "Bit 11 - Reset bit 11"]
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            #[doc = "Bit 12 - Reset bit 12"]
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            #[doc = "Bit 13 - Reset bit 13"]
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            #[doc = "Bit 14 - Reset bit 14"]
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            #[doc = "Bit 15 - Reset bit 15"]
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
        }
    }
    #[doc = "Port configuration lock register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lckr](lckr) module"]
    pub type LCKR = crate::Reg<u32, _LCKR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LCKR;
    #[doc = "`read()` method returns [lckr::R](lckr::R) reader structure"]
    impl crate::Readable for LCKR {}
    #[doc = "`write(|w| ..)` method takes [lckr::W](lckr::W) writer structure"]
    impl crate::Writable for LCKR {}
    #[doc = "Port configuration lock register"]
    pub mod lckr {
        #[doc = "Reader of register LCKR"]
        pub type R = crate::R<u32, super::LCKR>;
        #[doc = "Writer for register LCKR"]
        pub type W = crate::W<u32, super::LCKR>;
        #[doc = "Register LCKR `reset()`'s with value 0"]
        impl crate::ResetValue for super::LCKR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port A Lock bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK0_A {
            #[doc = "0: Port configuration not locked"]
            UNLOCKED = 0,
            #[doc = "1: Port configuration locked"]
            LOCKED = 1,
        }
        impl From<LCK0_A> for bool {
            #[inline(always)]
            fn from(variant: LCK0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCK0`"]
        pub type LCK0_R = crate::R<bool, LCK0_A>;
        impl LCK0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCK0_A {
                match self.bits {
                    false => LCK0_A::UNLOCKED,
                    true => LCK0_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK0_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCK0_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `LCK0`"]
        pub struct LCK0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Port A Lock bit 1"]
        pub type LCK1_A = LCK0_A;
        #[doc = "Reader of field `LCK1`"]
        pub type LCK1_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK1`"]
        pub struct LCK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port A Lock bit 2"]
        pub type LCK2_A = LCK0_A;
        #[doc = "Reader of field `LCK2`"]
        pub type LCK2_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK2`"]
        pub struct LCK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port A Lock bit 3"]
        pub type LCK3_A = LCK0_A;
        #[doc = "Reader of field `LCK3`"]
        pub type LCK3_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK3`"]
        pub struct LCK3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port A Lock bit 4"]
        pub type LCK4_A = LCK0_A;
        #[doc = "Reader of field `LCK4`"]
        pub type LCK4_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK4`"]
        pub struct LCK4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port A Lock bit 5"]
        pub type LCK5_A = LCK0_A;
        #[doc = "Reader of field `LCK5`"]
        pub type LCK5_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK5`"]
        pub struct LCK5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port A Lock bit 6"]
        pub type LCK6_A = LCK0_A;
        #[doc = "Reader of field `LCK6`"]
        pub type LCK6_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK6`"]
        pub struct LCK6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port A Lock bit 7"]
        pub type LCK7_A = LCK0_A;
        #[doc = "Reader of field `LCK7`"]
        pub type LCK7_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK7`"]
        pub struct LCK7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port A Lock bit 8"]
        pub type LCK8_A = LCK0_A;
        #[doc = "Reader of field `LCK8`"]
        pub type LCK8_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK8`"]
        pub struct LCK8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port A Lock bit 9"]
        pub type LCK9_A = LCK0_A;
        #[doc = "Reader of field `LCK9`"]
        pub type LCK9_R = crate::R<bool, LCK0_A>;
        #[doc = "Write proxy for field `LCK9`"]
        pub struct LCK9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port A Lock bit 10\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK10_A {
            #[doc = "0: Port configuration not locked"]
            UNLOCKED = 0,
            #[doc = "1: Port configuration locked"]
            LOCKED = 1,
        }
        impl From<LCK10_A> for bool {
            #[inline(always)]
            fn from(variant: LCK10_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCK10`"]
        pub type LCK10_R = crate::R<bool, LCK10_A>;
        impl LCK10_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCK10_A {
                match self.bits {
                    false => LCK10_A::UNLOCKED,
                    true => LCK10_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK10_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCK10_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `LCK10`"]
        pub struct LCK10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port A Lock bit 11"]
        pub type LCK11_A = LCK10_A;
        #[doc = "Reader of field `LCK11`"]
        pub type LCK11_R = crate::R<bool, LCK10_A>;
        #[doc = "Write proxy for field `LCK11`"]
        pub struct LCK11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port A Lock bit 12"]
        pub type LCK12_A = LCK10_A;
        #[doc = "Reader of field `LCK12`"]
        pub type LCK12_R = crate::R<bool, LCK10_A>;
        #[doc = "Write proxy for field `LCK12`"]
        pub struct LCK12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port A Lock bit 13"]
        pub type LCK13_A = LCK10_A;
        #[doc = "Reader of field `LCK13`"]
        pub type LCK13_R = crate::R<bool, LCK10_A>;
        #[doc = "Write proxy for field `LCK13`"]
        pub struct LCK13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port A Lock bit 14"]
        pub type LCK14_A = LCK10_A;
        #[doc = "Reader of field `LCK14`"]
        pub type LCK14_R = crate::R<bool, LCK10_A>;
        #[doc = "Write proxy for field `LCK14`"]
        pub struct LCK14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port A Lock bit 15"]
        pub type LCK15_A = LCK10_A;
        #[doc = "Reader of field `LCK15`"]
        pub type LCK15_R = crate::R<bool, LCK10_A>;
        #[doc = "Write proxy for field `LCK15`"]
        pub struct LCK15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Lock key\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCKK_A {
            #[doc = "0: Port configuration lock key not active"]
            NOTACTIVE = 0,
            #[doc = "1: Port configuration lock key active"]
            ACTIVE = 1,
        }
        impl From<LCKK_A> for bool {
            #[inline(always)]
            fn from(variant: LCKK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCKK`"]
        pub type LCKK_R = crate::R<bool, LCKK_A>;
        impl LCKK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCKK_A {
                match self.bits {
                    false => LCKK_A::NOTACTIVE,
                    true => LCKK_A::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTACTIVE`"]
            #[inline(always)]
            pub fn is_not_active(&self) -> bool {
                *self == LCKK_A::NOTACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == LCKK_A::ACTIVE
            }
        }
        #[doc = "Write proxy for field `LCKK`"]
        pub struct LCKK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCKK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCKK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration lock key not active"]
            #[inline(always)]
            pub fn not_active(self) -> &'a mut W {
                self.variant(LCKK_A::NOTACTIVE)
            }
            #[doc = "Port configuration lock key active"]
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(LCKK_A::ACTIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Port A Lock bit 0"]
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port A Lock bit 1"]
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port A Lock bit 2"]
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port A Lock bit 3"]
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port A Lock bit 4"]
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port A Lock bit 5"]
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port A Lock bit 6"]
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port A Lock bit 7"]
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port A Lock bit 8"]
            #[inline(always)]
            pub fn lck8(&self) -> LCK8_R {
                LCK8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port A Lock bit 9"]
            #[inline(always)]
            pub fn lck9(&self) -> LCK9_R {
                LCK9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port A Lock bit 10"]
            #[inline(always)]
            pub fn lck10(&self) -> LCK10_R {
                LCK10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port A Lock bit 11"]
            #[inline(always)]
            pub fn lck11(&self) -> LCK11_R {
                LCK11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port A Lock bit 12"]
            #[inline(always)]
            pub fn lck12(&self) -> LCK12_R {
                LCK12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port A Lock bit 13"]
            #[inline(always)]
            pub fn lck13(&self) -> LCK13_R {
                LCK13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port A Lock bit 14"]
            #[inline(always)]
            pub fn lck14(&self) -> LCK14_R {
                LCK14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Port A Lock bit 15"]
            #[inline(always)]
            pub fn lck15(&self) -> LCK15_R {
                LCK15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Lock key"]
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Port A Lock bit 0"]
            #[inline(always)]
            pub fn lck0(&mut self) -> LCK0_W {
                LCK0_W { w: self }
            }
            #[doc = "Bit 1 - Port A Lock bit 1"]
            #[inline(always)]
            pub fn lck1(&mut self) -> LCK1_W {
                LCK1_W { w: self }
            }
            #[doc = "Bit 2 - Port A Lock bit 2"]
            #[inline(always)]
            pub fn lck2(&mut self) -> LCK2_W {
                LCK2_W { w: self }
            }
            #[doc = "Bit 3 - Port A Lock bit 3"]
            #[inline(always)]
            pub fn lck3(&mut self) -> LCK3_W {
                LCK3_W { w: self }
            }
            #[doc = "Bit 4 - Port A Lock bit 4"]
            #[inline(always)]
            pub fn lck4(&mut self) -> LCK4_W {
                LCK4_W { w: self }
            }
            #[doc = "Bit 5 - Port A Lock bit 5"]
            #[inline(always)]
            pub fn lck5(&mut self) -> LCK5_W {
                LCK5_W { w: self }
            }
            #[doc = "Bit 6 - Port A Lock bit 6"]
            #[inline(always)]
            pub fn lck6(&mut self) -> LCK6_W {
                LCK6_W { w: self }
            }
            #[doc = "Bit 7 - Port A Lock bit 7"]
            #[inline(always)]
            pub fn lck7(&mut self) -> LCK7_W {
                LCK7_W { w: self }
            }
            #[doc = "Bit 8 - Port A Lock bit 8"]
            #[inline(always)]
            pub fn lck8(&mut self) -> LCK8_W {
                LCK8_W { w: self }
            }
            #[doc = "Bit 9 - Port A Lock bit 9"]
            #[inline(always)]
            pub fn lck9(&mut self) -> LCK9_W {
                LCK9_W { w: self }
            }
            #[doc = "Bit 10 - Port A Lock bit 10"]
            #[inline(always)]
            pub fn lck10(&mut self) -> LCK10_W {
                LCK10_W { w: self }
            }
            #[doc = "Bit 11 - Port A Lock bit 11"]
            #[inline(always)]
            pub fn lck11(&mut self) -> LCK11_W {
                LCK11_W { w: self }
            }
            #[doc = "Bit 12 - Port A Lock bit 12"]
            #[inline(always)]
            pub fn lck12(&mut self) -> LCK12_W {
                LCK12_W { w: self }
            }
            #[doc = "Bit 13 - Port A Lock bit 13"]
            #[inline(always)]
            pub fn lck13(&mut self) -> LCK13_W {
                LCK13_W { w: self }
            }
            #[doc = "Bit 14 - Port A Lock bit 14"]
            #[inline(always)]
            pub fn lck14(&mut self) -> LCK14_W {
                LCK14_W { w: self }
            }
            #[doc = "Bit 15 - Port A Lock bit 15"]
            #[inline(always)]
            pub fn lck15(&mut self) -> LCK15_W {
                LCK15_W { w: self }
            }
            #[doc = "Bit 16 - Lock key"]
            #[inline(always)]
            pub fn lckk(&mut self) -> LCKK_W {
                LCKK_W { w: self }
            }
        }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_0c00 as *const _
    }
}
impl Deref for GPIOB {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOB::ptr() }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1000 as *const _
    }
}
impl Deref for GPIOC {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOC::ptr() }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1400 as *const _
    }
}
impl Deref for GPIOD {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOD::ptr() }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOE {}
impl GPIOE {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1800 as *const _
    }
}
impl Deref for GPIOE {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOE::ptr() }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOF {}
impl GPIOF {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1c00 as *const _
    }
}
impl Deref for GPIOF {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOF::ptr() }
    }
}
#[doc = "General purpose I/O"]
pub struct GPIOG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOG {}
impl GPIOG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_2000 as *const _
    }
}
impl Deref for GPIOG {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOG::ptr() }
    }
}
#[doc = "Alternate function I/O"]
pub struct AFIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AFIO {}
impl AFIO {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const afio::RegisterBlock {
        0x4001_0000 as *const _
    }
}
impl Deref for AFIO {
    type Target = afio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*AFIO::ptr() }
    }
}
#[doc = "Alternate function I/O"]
pub mod afio {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Event Control Register (AFIO_EVCR)"]
        pub evcr: EVCR,
        #[doc = "0x04 - AF remap and debug I/O configuration register (AFIO_MAPR)"]
        pub mapr: MAPR,
        #[doc = "0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)"]
        pub exticr1: EXTICR1,
        #[doc = "0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)"]
        pub exticr2: EXTICR2,
        #[doc = "0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)"]
        pub exticr3: EXTICR3,
        #[doc = "0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)"]
        pub exticr4: EXTICR4,
        _reserved6: [u8; 4usize],
        #[doc = "0x1c - AF remap and debug I/O configuration register"]
        pub mapr2: MAPR2,
    }
    #[doc = "Event Control Register (AFIO_EVCR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evcr](evcr) module"]
    pub type EVCR = crate::Reg<u32, _EVCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EVCR;
    #[doc = "`read()` method returns [evcr::R](evcr::R) reader structure"]
    impl crate::Readable for EVCR {}
    #[doc = "`write(|w| ..)` method takes [evcr::W](evcr::W) writer structure"]
    impl crate::Writable for EVCR {}
    #[doc = "Event Control Register (AFIO_EVCR)"]
    pub mod evcr {
        #[doc = "Reader of register EVCR"]
        pub type R = crate::R<u32, super::EVCR>;
        #[doc = "Writer for register EVCR"]
        pub type W = crate::W<u32, super::EVCR>;
        #[doc = "Register EVCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EVCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PIN`"]
        pub type PIN_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PIN`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `PORT`"]
        pub type PORT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PORT`"]
        pub struct PORT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PORT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `EVOE`"]
        pub type EVOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `EVOE`"]
        pub struct EVOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EVOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Pin selection"]
            #[inline(always)]
            pub fn pin(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:6 - Port selection"]
            #[inline(always)]
            pub fn port(&self) -> PORT_R {
                PORT_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 7 - Event Output Enable"]
            #[inline(always)]
            pub fn evoe(&self) -> EVOE_R {
                EVOE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Pin selection"]
            #[inline(always)]
            pub fn pin(&mut self) -> PIN_W {
                PIN_W { w: self }
            }
            #[doc = "Bits 4:6 - Port selection"]
            #[inline(always)]
            pub fn port(&mut self) -> PORT_W {
                PORT_W { w: self }
            }
            #[doc = "Bit 7 - Event Output Enable"]
            #[inline(always)]
            pub fn evoe(&mut self) -> EVOE_W {
                EVOE_W { w: self }
            }
        }
    }
    #[doc = "AF remap and debug I/O configuration register (AFIO_MAPR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mapr](mapr) module"]
    pub type MAPR = crate::Reg<u32, _MAPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MAPR;
    #[doc = "`read()` method returns [mapr::R](mapr::R) reader structure"]
    impl crate::Readable for MAPR {}
    #[doc = "`write(|w| ..)` method takes [mapr::W](mapr::W) writer structure"]
    impl crate::Writable for MAPR {}
    #[doc = "AF remap and debug I/O configuration register (AFIO_MAPR)"]
    pub mod mapr {
        #[doc = "Reader of register MAPR"]
        pub type R = crate::R<u32, super::MAPR>;
        #[doc = "Writer for register MAPR"]
        pub type W = crate::W<u32, super::MAPR>;
        #[doc = "Register MAPR `reset()`'s with value 0"]
        impl crate::ResetValue for super::MAPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `SPI1_REMAP`"]
        pub type SPI1_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `SPI1_REMAP`"]
        pub struct SPI1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `I2C1_REMAP`"]
        pub type I2C1_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `I2C1_REMAP`"]
        pub struct I2C1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `USART1_REMAP`"]
        pub type USART1_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `USART1_REMAP`"]
        pub struct USART1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `USART2_REMAP`"]
        pub type USART2_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `USART2_REMAP`"]
        pub struct USART2_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `USART3_REMAP`"]
        pub type USART3_REMAP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `USART3_REMAP`"]
        pub struct USART3_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART3_REMAP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `TIM1_REMAP`"]
        pub type TIM1_REMAP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TIM1_REMAP`"]
        pub struct TIM1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1_REMAP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `TIM2_REMAP`"]
        pub type TIM2_REMAP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TIM2_REMAP`"]
        pub struct TIM2_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2_REMAP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `TIM3_REMAP`"]
        pub type TIM3_REMAP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TIM3_REMAP`"]
        pub struct TIM3_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3_REMAP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `TIM4_REMAP`"]
        pub type TIM4_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM4_REMAP`"]
        pub struct TIM4_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM4_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `PD01_REMAP`"]
        pub type PD01_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PD01_REMAP`"]
        pub struct PD01_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PD01_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `TIM5CH4_IREMAP`"]
        pub type TIM5CH4_IREMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM5CH4_IREMAP`"]
        pub struct TIM5CH4_IREMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM5CH4_IREMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Write proxy for field `SWJ_CFG`"]
        pub struct SWJ_CFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWJ_CFG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | (((value as u32) & 0x07) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - SPI1 remapping"]
            #[inline(always)]
            pub fn spi1_remap(&self) -> SPI1_REMAP_R {
                SPI1_REMAP_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - I2C1 remapping"]
            #[inline(always)]
            pub fn i2c1_remap(&self) -> I2C1_REMAP_R {
                I2C1_REMAP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - USART1 remapping"]
            #[inline(always)]
            pub fn usart1_remap(&self) -> USART1_REMAP_R {
                USART1_REMAP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - USART2 remapping"]
            #[inline(always)]
            pub fn usart2_remap(&self) -> USART2_REMAP_R {
                USART2_REMAP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 4:5 - USART3 remapping"]
            #[inline(always)]
            pub fn usart3_remap(&self) -> USART3_REMAP_R {
                USART3_REMAP_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - TIM1 remapping"]
            #[inline(always)]
            pub fn tim1_remap(&self) -> TIM1_REMAP_R {
                TIM1_REMAP_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - TIM2 remapping"]
            #[inline(always)]
            pub fn tim2_remap(&self) -> TIM2_REMAP_R {
                TIM2_REMAP_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - TIM3 remapping"]
            #[inline(always)]
            pub fn tim3_remap(&self) -> TIM3_REMAP_R {
                TIM3_REMAP_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bit 12 - TIM4 remapping"]
            #[inline(always)]
            pub fn tim4_remap(&self) -> TIM4_REMAP_R {
                TIM4_REMAP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT"]
            #[inline(always)]
            pub fn pd01_remap(&self) -> PD01_REMAP_R {
                PD01_REMAP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Set and cleared by software"]
            #[inline(always)]
            pub fn tim5ch4_iremap(&self) -> TIM5CH4_IREMAP_R {
                TIM5CH4_IREMAP_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - SPI1 remapping"]
            #[inline(always)]
            pub fn spi1_remap(&mut self) -> SPI1_REMAP_W {
                SPI1_REMAP_W { w: self }
            }
            #[doc = "Bit 1 - I2C1 remapping"]
            #[inline(always)]
            pub fn i2c1_remap(&mut self) -> I2C1_REMAP_W {
                I2C1_REMAP_W { w: self }
            }
            #[doc = "Bit 2 - USART1 remapping"]
            #[inline(always)]
            pub fn usart1_remap(&mut self) -> USART1_REMAP_W {
                USART1_REMAP_W { w: self }
            }
            #[doc = "Bit 3 - USART2 remapping"]
            #[inline(always)]
            pub fn usart2_remap(&mut self) -> USART2_REMAP_W {
                USART2_REMAP_W { w: self }
            }
            #[doc = "Bits 4:5 - USART3 remapping"]
            #[inline(always)]
            pub fn usart3_remap(&mut self) -> USART3_REMAP_W {
                USART3_REMAP_W { w: self }
            }
            #[doc = "Bits 6:7 - TIM1 remapping"]
            #[inline(always)]
            pub fn tim1_remap(&mut self) -> TIM1_REMAP_W {
                TIM1_REMAP_W { w: self }
            }
            #[doc = "Bits 8:9 - TIM2 remapping"]
            #[inline(always)]
            pub fn tim2_remap(&mut self) -> TIM2_REMAP_W {
                TIM2_REMAP_W { w: self }
            }
            #[doc = "Bits 10:11 - TIM3 remapping"]
            #[inline(always)]
            pub fn tim3_remap(&mut self) -> TIM3_REMAP_W {
                TIM3_REMAP_W { w: self }
            }
            #[doc = "Bit 12 - TIM4 remapping"]
            #[inline(always)]
            pub fn tim4_remap(&mut self) -> TIM4_REMAP_W {
                TIM4_REMAP_W { w: self }
            }
            #[doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT"]
            #[inline(always)]
            pub fn pd01_remap(&mut self) -> PD01_REMAP_W {
                PD01_REMAP_W { w: self }
            }
            #[doc = "Bit 16 - Set and cleared by software"]
            #[inline(always)]
            pub fn tim5ch4_iremap(&mut self) -> TIM5CH4_IREMAP_W {
                TIM5CH4_IREMAP_W { w: self }
            }
            #[doc = "Bits 24:26 - Serial wire JTAG configuration"]
            #[inline(always)]
            pub fn swj_cfg(&mut self) -> SWJ_CFG_W {
                SWJ_CFG_W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 1 (AFIO_EXTICR1)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr1](exticr1) module"]
    pub type EXTICR1 = crate::Reg<u32, _EXTICR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR1;
    #[doc = "`read()` method returns [exticr1::R](exticr1::R) reader structure"]
    impl crate::Readable for EXTICR1 {}
    #[doc = "`write(|w| ..)` method takes [exticr1::W](exticr1::W) writer structure"]
    impl crate::Writable for EXTICR1 {}
    #[doc = "External interrupt configuration register 1 (AFIO_EXTICR1)"]
    pub mod exticr1 {
        #[doc = "Reader of register EXTICR1"]
        pub type R = crate::R<u32, super::EXTICR1>;
        #[doc = "Writer for register EXTICR1"]
        pub type W = crate::W<u32, super::EXTICR1>;
        #[doc = "Register EXTICR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `EXTI0`"]
        pub type EXTI0_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI0`"]
        pub struct EXTI0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI1`"]
        pub type EXTI1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI1`"]
        pub struct EXTI1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI2`"]
        pub type EXTI2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI2`"]
        pub struct EXTI2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI3`"]
        pub type EXTI3_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI3`"]
        pub struct EXTI3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI3_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - EXTI0 configuration"]
            #[inline(always)]
            pub fn exti0(&self) -> EXTI0_R {
                EXTI0_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI1 configuration"]
            #[inline(always)]
            pub fn exti1(&self) -> EXTI1_R {
                EXTI1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI2 configuration"]
            #[inline(always)]
            pub fn exti2(&self) -> EXTI2_R {
                EXTI2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - EXTI3 configuration"]
            #[inline(always)]
            pub fn exti3(&self) -> EXTI3_R {
                EXTI3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - EXTI0 configuration"]
            #[inline(always)]
            pub fn exti0(&mut self) -> EXTI0_W {
                EXTI0_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI1 configuration"]
            #[inline(always)]
            pub fn exti1(&mut self) -> EXTI1_W {
                EXTI1_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI2 configuration"]
            #[inline(always)]
            pub fn exti2(&mut self) -> EXTI2_W {
                EXTI2_W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI3 configuration"]
            #[inline(always)]
            pub fn exti3(&mut self) -> EXTI3_W {
                EXTI3_W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 2 (AFIO_EXTICR2)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr2](exticr2) module"]
    pub type EXTICR2 = crate::Reg<u32, _EXTICR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR2;
    #[doc = "`read()` method returns [exticr2::R](exticr2::R) reader structure"]
    impl crate::Readable for EXTICR2 {}
    #[doc = "`write(|w| ..)` method takes [exticr2::W](exticr2::W) writer structure"]
    impl crate::Writable for EXTICR2 {}
    #[doc = "External interrupt configuration register 2 (AFIO_EXTICR2)"]
    pub mod exticr2 {
        #[doc = "Reader of register EXTICR2"]
        pub type R = crate::R<u32, super::EXTICR2>;
        #[doc = "Writer for register EXTICR2"]
        pub type W = crate::W<u32, super::EXTICR2>;
        #[doc = "Register EXTICR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `EXTI4`"]
        pub type EXTI4_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI4`"]
        pub struct EXTI4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI4_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI5`"]
        pub type EXTI5_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI5`"]
        pub struct EXTI5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI5_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI6`"]
        pub type EXTI6_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI6`"]
        pub struct EXTI6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI6_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI7`"]
        pub type EXTI7_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI7`"]
        pub struct EXTI7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI7_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - EXTI4 configuration"]
            #[inline(always)]
            pub fn exti4(&self) -> EXTI4_R {
                EXTI4_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI5 configuration"]
            #[inline(always)]
            pub fn exti5(&self) -> EXTI5_R {
                EXTI5_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI6 configuration"]
            #[inline(always)]
            pub fn exti6(&self) -> EXTI6_R {
                EXTI6_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - EXTI7 configuration"]
            #[inline(always)]
            pub fn exti7(&self) -> EXTI7_R {
                EXTI7_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - EXTI4 configuration"]
            #[inline(always)]
            pub fn exti4(&mut self) -> EXTI4_W {
                EXTI4_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI5 configuration"]
            #[inline(always)]
            pub fn exti5(&mut self) -> EXTI5_W {
                EXTI5_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI6 configuration"]
            #[inline(always)]
            pub fn exti6(&mut self) -> EXTI6_W {
                EXTI6_W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI7 configuration"]
            #[inline(always)]
            pub fn exti7(&mut self) -> EXTI7_W {
                EXTI7_W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 3 (AFIO_EXTICR3)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr3](exticr3) module"]
    pub type EXTICR3 = crate::Reg<u32, _EXTICR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR3;
    #[doc = "`read()` method returns [exticr3::R](exticr3::R) reader structure"]
    impl crate::Readable for EXTICR3 {}
    #[doc = "`write(|w| ..)` method takes [exticr3::W](exticr3::W) writer structure"]
    impl crate::Writable for EXTICR3 {}
    #[doc = "External interrupt configuration register 3 (AFIO_EXTICR3)"]
    pub mod exticr3 {
        #[doc = "Reader of register EXTICR3"]
        pub type R = crate::R<u32, super::EXTICR3>;
        #[doc = "Writer for register EXTICR3"]
        pub type W = crate::W<u32, super::EXTICR3>;
        #[doc = "Register EXTICR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `EXTI8`"]
        pub type EXTI8_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI8`"]
        pub struct EXTI8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI8_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI9`"]
        pub type EXTI9_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI9`"]
        pub struct EXTI9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI9_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI10`"]
        pub type EXTI10_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI10`"]
        pub struct EXTI10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI10_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI11`"]
        pub type EXTI11_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI11`"]
        pub struct EXTI11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI11_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - EXTI8 configuration"]
            #[inline(always)]
            pub fn exti8(&self) -> EXTI8_R {
                EXTI8_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI9 configuration"]
            #[inline(always)]
            pub fn exti9(&self) -> EXTI9_R {
                EXTI9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI10 configuration"]
            #[inline(always)]
            pub fn exti10(&self) -> EXTI10_R {
                EXTI10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - EXTI11 configuration"]
            #[inline(always)]
            pub fn exti11(&self) -> EXTI11_R {
                EXTI11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - EXTI8 configuration"]
            #[inline(always)]
            pub fn exti8(&mut self) -> EXTI8_W {
                EXTI8_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI9 configuration"]
            #[inline(always)]
            pub fn exti9(&mut self) -> EXTI9_W {
                EXTI9_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI10 configuration"]
            #[inline(always)]
            pub fn exti10(&mut self) -> EXTI10_W {
                EXTI10_W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI11 configuration"]
            #[inline(always)]
            pub fn exti11(&mut self) -> EXTI11_W {
                EXTI11_W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 4 (AFIO_EXTICR4)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr4](exticr4) module"]
    pub type EXTICR4 = crate::Reg<u32, _EXTICR4>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR4;
    #[doc = "`read()` method returns [exticr4::R](exticr4::R) reader structure"]
    impl crate::Readable for EXTICR4 {}
    #[doc = "`write(|w| ..)` method takes [exticr4::W](exticr4::W) writer structure"]
    impl crate::Writable for EXTICR4 {}
    #[doc = "External interrupt configuration register 4 (AFIO_EXTICR4)"]
    pub mod exticr4 {
        #[doc = "Reader of register EXTICR4"]
        pub type R = crate::R<u32, super::EXTICR4>;
        #[doc = "Writer for register EXTICR4"]
        pub type W = crate::W<u32, super::EXTICR4>;
        #[doc = "Register EXTICR4 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR4 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `EXTI12`"]
        pub type EXTI12_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI12`"]
        pub struct EXTI12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI12_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI13`"]
        pub type EXTI13_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI13`"]
        pub struct EXTI13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI13_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI14`"]
        pub type EXTI14_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI14`"]
        pub struct EXTI14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI14_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `EXTI15`"]
        pub type EXTI15_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `EXTI15`"]
        pub struct EXTI15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI15_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - EXTI12 configuration"]
            #[inline(always)]
            pub fn exti12(&self) -> EXTI12_R {
                EXTI12_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI13 configuration"]
            #[inline(always)]
            pub fn exti13(&self) -> EXTI13_R {
                EXTI13_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI14 configuration"]
            #[inline(always)]
            pub fn exti14(&self) -> EXTI14_R {
                EXTI14_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - EXTI15 configuration"]
            #[inline(always)]
            pub fn exti15(&self) -> EXTI15_R {
                EXTI15_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - EXTI12 configuration"]
            #[inline(always)]
            pub fn exti12(&mut self) -> EXTI12_W {
                EXTI12_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI13 configuration"]
            #[inline(always)]
            pub fn exti13(&mut self) -> EXTI13_W {
                EXTI13_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI14 configuration"]
            #[inline(always)]
            pub fn exti14(&mut self) -> EXTI14_W {
                EXTI14_W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI15 configuration"]
            #[inline(always)]
            pub fn exti15(&mut self) -> EXTI15_W {
                EXTI15_W { w: self }
            }
        }
    }
    #[doc = "AF remap and debug I/O configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mapr2](mapr2) module"]
    pub type MAPR2 = crate::Reg<u32, _MAPR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MAPR2;
    #[doc = "`read()` method returns [mapr2::R](mapr2::R) reader structure"]
    impl crate::Readable for MAPR2 {}
    #[doc = "`write(|w| ..)` method takes [mapr2::W](mapr2::W) writer structure"]
    impl crate::Writable for MAPR2 {}
    #[doc = "AF remap and debug I/O configuration register"]
    pub mod mapr2 {
        #[doc = "Reader of register MAPR2"]
        pub type R = crate::R<u32, super::MAPR2>;
        #[doc = "Writer for register MAPR2"]
        pub type W = crate::W<u32, super::MAPR2>;
        #[doc = "Register MAPR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::MAPR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TIM15_REMAP`"]
        pub type TIM15_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM15_REMAP`"]
        pub struct TIM15_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM15_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `TIM16_REMAP`"]
        pub type TIM16_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM16_REMAP`"]
        pub struct TIM16_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM16_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `TIM17_REMAP`"]
        pub type TIM17_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM17_REMAP`"]
        pub struct TIM17_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM17_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `TIM13_REMAP`"]
        pub type TIM13_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM13_REMAP`"]
        pub struct TIM13_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM13_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `TIM14_REMAP`"]
        pub type TIM14_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM14_REMAP`"]
        pub struct TIM14_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM14_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `FSMC_NADV`"]
        pub type FSMC_NADV_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `FSMC_NADV`"]
        pub struct FSMC_NADV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FSMC_NADV_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CEC_REMAP`"]
        pub type CEC_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CEC_REMAP`"]
        pub struct CEC_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEC_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `TIM1_DMA_REMAP`"]
        pub type TIM1_DMA_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM1_DMA_REMAP`"]
        pub struct TIM1_DMA_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1_DMA_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `TIM67_DAC_DMA_REMAP`"]
        pub type TIM67_DAC_DMA_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM67_DAC_DMA_REMAP`"]
        pub struct TIM67_DAC_DMA_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM67_DAC_DMA_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `TIM12_REMAP`"]
        pub type TIM12_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIM12_REMAP`"]
        pub struct TIM12_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM12_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `MISC_REMAP`"]
        pub type MISC_REMAP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MISC_REMAP`"]
        pub struct MISC_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MISC_REMAP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - TIM15 remapping"]
            #[inline(always)]
            pub fn tim15_remap(&self) -> TIM15_REMAP_R {
                TIM15_REMAP_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - TIM16 remapping"]
            #[inline(always)]
            pub fn tim16_remap(&self) -> TIM16_REMAP_R {
                TIM16_REMAP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - TIM17 remapping"]
            #[inline(always)]
            pub fn tim17_remap(&self) -> TIM17_REMAP_R {
                TIM17_REMAP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 8 - TIM13 remapping"]
            #[inline(always)]
            pub fn tim13_remap(&self) -> TIM13_REMAP_R {
                TIM13_REMAP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - TIM14 remapping"]
            #[inline(always)]
            pub fn tim14_remap(&self) -> TIM14_REMAP_R {
                TIM14_REMAP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - NADV connect/disconnect"]
            #[inline(always)]
            pub fn fsmc_nadv(&self) -> FSMC_NADV_R {
                FSMC_NADV_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 3 - CEC remapping"]
            #[inline(always)]
            pub fn cec_remap(&self) -> CEC_REMAP_R {
                CEC_REMAP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - TIM1 DMA remapping"]
            #[inline(always)]
            pub fn tim1_dma_remap(&self) -> TIM1_DMA_REMAP_R {
                TIM1_DMA_REMAP_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 11 - TIM67_DAC DMA remapping"]
            #[inline(always)]
            pub fn tim67_dac_dma_remap(&self) -> TIM67_DAC_DMA_REMAP_R {
                TIM67_DAC_DMA_REMAP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - TIM12 remapping"]
            #[inline(always)]
            pub fn tim12_remap(&self) -> TIM12_REMAP_R {
                TIM12_REMAP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Miscellaneous features remapping"]
            #[inline(always)]
            pub fn misc_remap(&self) -> MISC_REMAP_R {
                MISC_REMAP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - TIM15 remapping"]
            #[inline(always)]
            pub fn tim15_remap(&mut self) -> TIM15_REMAP_W {
                TIM15_REMAP_W { w: self }
            }
            #[doc = "Bit 1 - TIM16 remapping"]
            #[inline(always)]
            pub fn tim16_remap(&mut self) -> TIM16_REMAP_W {
                TIM16_REMAP_W { w: self }
            }
            #[doc = "Bit 2 - TIM17 remapping"]
            #[inline(always)]
            pub fn tim17_remap(&mut self) -> TIM17_REMAP_W {
                TIM17_REMAP_W { w: self }
            }
            #[doc = "Bit 8 - TIM13 remapping"]
            #[inline(always)]
            pub fn tim13_remap(&mut self) -> TIM13_REMAP_W {
                TIM13_REMAP_W { w: self }
            }
            #[doc = "Bit 9 - TIM14 remapping"]
            #[inline(always)]
            pub fn tim14_remap(&mut self) -> TIM14_REMAP_W {
                TIM14_REMAP_W { w: self }
            }
            #[doc = "Bit 10 - NADV connect/disconnect"]
            #[inline(always)]
            pub fn fsmc_nadv(&mut self) -> FSMC_NADV_W {
                FSMC_NADV_W { w: self }
            }
            #[doc = "Bit 3 - CEC remapping"]
            #[inline(always)]
            pub fn cec_remap(&mut self) -> CEC_REMAP_W {
                CEC_REMAP_W { w: self }
            }
            #[doc = "Bit 4 - TIM1 DMA remapping"]
            #[inline(always)]
            pub fn tim1_dma_remap(&mut self) -> TIM1_DMA_REMAP_W {
                TIM1_DMA_REMAP_W { w: self }
            }
            #[doc = "Bit 11 - TIM67_DAC DMA remapping"]
            #[inline(always)]
            pub fn tim67_dac_dma_remap(&mut self) -> TIM67_DAC_DMA_REMAP_W {
                TIM67_DAC_DMA_REMAP_W { w: self }
            }
            #[doc = "Bit 12 - TIM12 remapping"]
            #[inline(always)]
            pub fn tim12_remap(&mut self) -> TIM12_REMAP_W {
                TIM12_REMAP_W { w: self }
            }
            #[doc = "Bit 13 - Miscellaneous features remapping"]
            #[inline(always)]
            pub fn misc_remap(&mut self) -> MISC_REMAP_W {
                MISC_REMAP_W { w: self }
            }
        }
    }
}
#[doc = "EXTI"]
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        0x4001_0400 as *const _
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*EXTI::ptr() }
    }
}
#[doc = "EXTI"]
pub mod exti {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt mask register (EXTI_IMR)"]
        pub imr: IMR,
        #[doc = "0x04 - Event mask register (EXTI_EMR)"]
        pub emr: EMR,
        #[doc = "0x08 - Rising Trigger selection register (EXTI_RTSR)"]
        pub rtsr: RTSR,
        #[doc = "0x0c - Falling Trigger selection register (EXTI_FTSR)"]
        pub ftsr: FTSR,
        #[doc = "0x10 - Software interrupt event register (EXTI_SWIER)"]
        pub swier: SWIER,
        #[doc = "0x14 - Pending register (EXTI_PR)"]
        pub pr: PR,
    }
    #[doc = "Interrupt mask register (EXTI_IMR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [imr](imr) module"]
    pub type IMR = crate::Reg<u32, _IMR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IMR;
    #[doc = "`read()` method returns [imr::R](imr::R) reader structure"]
    impl crate::Readable for IMR {}
    #[doc = "`write(|w| ..)` method takes [imr::W](imr::W) writer structure"]
    impl crate::Writable for IMR {}
    #[doc = "Interrupt mask register (EXTI_IMR)"]
    pub mod imr {
        #[doc = "Reader of register IMR"]
        pub type R = crate::R<u32, super::IMR>;
        #[doc = "Writer for register IMR"]
        pub type W = crate::W<u32, super::IMR>;
        #[doc = "Register IMR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IMR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Interrupt Mask on line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0_A {
            #[doc = "0: Interrupt request line is masked"]
            MASKED = 0,
            #[doc = "1: Interrupt request line is unmasked"]
            UNMASKED = 1,
        }
        impl From<MR0_A> for bool {
            #[inline(always)]
            fn from(variant: MR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MR0`"]
        pub type MR0_R = crate::R<bool, MR0_A>;
        impl MR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MR0_A {
                match self.bits {
                    false => MR0_A::MASKED,
                    true => MR0_A::UNMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == MR0_A::MASKED
            }
            #[doc = "Checks if the value of the field is `UNMASKED`"]
            #[inline(always)]
            pub fn is_unmasked(&self) -> bool {
                *self == MR0_A::UNMASKED
            }
        }
        #[doc = "Write proxy for field `MR0`"]
        pub struct MR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 1"]
        pub type MR1_A = MR0_A;
        #[doc = "Reader of field `MR1`"]
        pub type MR1_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR1`"]
        pub struct MR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 2"]
        pub type MR2_A = MR0_A;
        #[doc = "Reader of field `MR2`"]
        pub type MR2_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR2`"]
        pub struct MR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 3"]
        pub type MR3_A = MR0_A;
        #[doc = "Reader of field `MR3`"]
        pub type MR3_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR3`"]
        pub struct MR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 4"]
        pub type MR4_A = MR0_A;
        #[doc = "Reader of field `MR4`"]
        pub type MR4_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR4`"]
        pub struct MR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 5"]
        pub type MR5_A = MR0_A;
        #[doc = "Reader of field `MR5`"]
        pub type MR5_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR5`"]
        pub struct MR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 6"]
        pub type MR6_A = MR0_A;
        #[doc = "Reader of field `MR6`"]
        pub type MR6_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR6`"]
        pub struct MR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 7"]
        pub type MR7_A = MR0_A;
        #[doc = "Reader of field `MR7`"]
        pub type MR7_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR7`"]
        pub struct MR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 8"]
        pub type MR8_A = MR0_A;
        #[doc = "Reader of field `MR8`"]
        pub type MR8_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR8`"]
        pub struct MR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 9"]
        pub type MR9_A = MR0_A;
        #[doc = "Reader of field `MR9`"]
        pub type MR9_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR9`"]
        pub struct MR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 10"]
        pub type MR10_A = MR0_A;
        #[doc = "Reader of field `MR10`"]
        pub type MR10_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR10`"]
        pub struct MR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 11"]
        pub type MR11_A = MR0_A;
        #[doc = "Reader of field `MR11`"]
        pub type MR11_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR11`"]
        pub struct MR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 12"]
        pub type MR12_A = MR0_A;
        #[doc = "Reader of field `MR12`"]
        pub type MR12_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR12`"]
        pub struct MR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 13"]
        pub type MR13_A = MR0_A;
        #[doc = "Reader of field `MR13`"]
        pub type MR13_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR13`"]
        pub struct MR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 14"]
        pub type MR14_A = MR0_A;
        #[doc = "Reader of field `MR14`"]
        pub type MR14_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR14`"]
        pub struct MR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 15"]
        pub type MR15_A = MR0_A;
        #[doc = "Reader of field `MR15`"]
        pub type MR15_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR15`"]
        pub struct MR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 16"]
        pub type MR16_A = MR0_A;
        #[doc = "Reader of field `MR16`"]
        pub type MR16_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR16`"]
        pub struct MR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 17"]
        pub type MR17_A = MR0_A;
        #[doc = "Reader of field `MR17`"]
        pub type MR17_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR17`"]
        pub struct MR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline(always)]
            pub fn mr0(&mut self) -> MR0_W {
                MR0_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline(always)]
            pub fn mr1(&mut self) -> MR1_W {
                MR1_W { w: self }
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline(always)]
            pub fn mr2(&mut self) -> MR2_W {
                MR2_W { w: self }
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline(always)]
            pub fn mr3(&mut self) -> MR3_W {
                MR3_W { w: self }
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline(always)]
            pub fn mr4(&mut self) -> MR4_W {
                MR4_W { w: self }
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline(always)]
            pub fn mr5(&mut self) -> MR5_W {
                MR5_W { w: self }
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline(always)]
            pub fn mr6(&mut self) -> MR6_W {
                MR6_W { w: self }
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline(always)]
            pub fn mr7(&mut self) -> MR7_W {
                MR7_W { w: self }
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline(always)]
            pub fn mr8(&mut self) -> MR8_W {
                MR8_W { w: self }
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline(always)]
            pub fn mr9(&mut self) -> MR9_W {
                MR9_W { w: self }
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline(always)]
            pub fn mr10(&mut self) -> MR10_W {
                MR10_W { w: self }
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline(always)]
            pub fn mr11(&mut self) -> MR11_W {
                MR11_W { w: self }
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline(always)]
            pub fn mr12(&mut self) -> MR12_W {
                MR12_W { w: self }
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline(always)]
            pub fn mr13(&mut self) -> MR13_W {
                MR13_W { w: self }
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline(always)]
            pub fn mr14(&mut self) -> MR14_W {
                MR14_W { w: self }
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline(always)]
            pub fn mr15(&mut self) -> MR15_W {
                MR15_W { w: self }
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline(always)]
            pub fn mr16(&mut self) -> MR16_W {
                MR16_W { w: self }
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline(always)]
            pub fn mr17(&mut self) -> MR17_W {
                MR17_W { w: self }
            }
        }
    }
    #[doc = "Event mask register (EXTI_EMR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [emr](emr) module"]
    pub type EMR = crate::Reg<u32, _EMR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EMR;
    #[doc = "`read()` method returns [emr::R](emr::R) reader structure"]
    impl crate::Readable for EMR {}
    #[doc = "`write(|w| ..)` method takes [emr::W](emr::W) writer structure"]
    impl crate::Writable for EMR {}
    #[doc = "Event mask register (EXTI_EMR)"]
    pub mod emr {
        #[doc = "Reader of register EMR"]
        pub type R = crate::R<u32, super::EMR>;
        #[doc = "Writer for register EMR"]
        pub type W = crate::W<u32, super::EMR>;
        #[doc = "Register EMR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EMR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Event Mask on line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0_A {
            #[doc = "0: Interrupt request line is masked"]
            MASKED = 0,
            #[doc = "1: Interrupt request line is unmasked"]
            UNMASKED = 1,
        }
        impl From<MR0_A> for bool {
            #[inline(always)]
            fn from(variant: MR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MR0`"]
        pub type MR0_R = crate::R<bool, MR0_A>;
        impl MR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MR0_A {
                match self.bits {
                    false => MR0_A::MASKED,
                    true => MR0_A::UNMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == MR0_A::MASKED
            }
            #[doc = "Checks if the value of the field is `UNMASKED`"]
            #[inline(always)]
            pub fn is_unmasked(&self) -> bool {
                *self == MR0_A::UNMASKED
            }
        }
        #[doc = "Write proxy for field `MR0`"]
        pub struct MR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Event Mask on line 1"]
        pub type MR1_A = MR0_A;
        #[doc = "Reader of field `MR1`"]
        pub type MR1_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR1`"]
        pub struct MR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Event Mask on line 2"]
        pub type MR2_A = MR0_A;
        #[doc = "Reader of field `MR2`"]
        pub type MR2_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR2`"]
        pub struct MR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Event Mask on line 3"]
        pub type MR3_A = MR0_A;
        #[doc = "Reader of field `MR3`"]
        pub type MR3_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR3`"]
        pub struct MR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Event Mask on line 4"]
        pub type MR4_A = MR0_A;
        #[doc = "Reader of field `MR4`"]
        pub type MR4_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR4`"]
        pub struct MR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Event Mask on line 5"]
        pub type MR5_A = MR0_A;
        #[doc = "Reader of field `MR5`"]
        pub type MR5_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR5`"]
        pub struct MR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Event Mask on line 6"]
        pub type MR6_A = MR0_A;
        #[doc = "Reader of field `MR6`"]
        pub type MR6_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR6`"]
        pub struct MR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Event Mask on line 7"]
        pub type MR7_A = MR0_A;
        #[doc = "Reader of field `MR7`"]
        pub type MR7_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR7`"]
        pub struct MR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Event Mask on line 8"]
        pub type MR8_A = MR0_A;
        #[doc = "Reader of field `MR8`"]
        pub type MR8_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR8`"]
        pub struct MR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Event Mask on line 9"]
        pub type MR9_A = MR0_A;
        #[doc = "Reader of field `MR9`"]
        pub type MR9_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR9`"]
        pub struct MR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Event Mask on line 10"]
        pub type MR10_A = MR0_A;
        #[doc = "Reader of field `MR10`"]
        pub type MR10_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR10`"]
        pub struct MR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Event Mask on line 11"]
        pub type MR11_A = MR0_A;
        #[doc = "Reader of field `MR11`"]
        pub type MR11_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR11`"]
        pub struct MR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Event Mask on line 12"]
        pub type MR12_A = MR0_A;
        #[doc = "Reader of field `MR12`"]
        pub type MR12_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR12`"]
        pub struct MR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Event Mask on line 13"]
        pub type MR13_A = MR0_A;
        #[doc = "Reader of field `MR13`"]
        pub type MR13_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR13`"]
        pub struct MR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Event Mask on line 14"]
        pub type MR14_A = MR0_A;
        #[doc = "Reader of field `MR14`"]
        pub type MR14_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR14`"]
        pub struct MR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Event Mask on line 15"]
        pub type MR15_A = MR0_A;
        #[doc = "Reader of field `MR15`"]
        pub type MR15_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR15`"]
        pub struct MR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Event Mask on line 16"]
        pub type MR16_A = MR0_A;
        #[doc = "Reader of field `MR16`"]
        pub type MR16_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR16`"]
        pub struct MR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Event Mask on line 17"]
        pub type MR17_A = MR0_A;
        #[doc = "Reader of field `MR17`"]
        pub type MR17_R = crate::R<bool, MR0_A>;
        #[doc = "Write proxy for field `MR17`"]
        pub struct MR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MR17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline(always)]
            pub fn mr0(&mut self) -> MR0_W {
                MR0_W { w: self }
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline(always)]
            pub fn mr1(&mut self) -> MR1_W {
                MR1_W { w: self }
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline(always)]
            pub fn mr2(&mut self) -> MR2_W {
                MR2_W { w: self }
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline(always)]
            pub fn mr3(&mut self) -> MR3_W {
                MR3_W { w: self }
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline(always)]
            pub fn mr4(&mut self) -> MR4_W {
                MR4_W { w: self }
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline(always)]
            pub fn mr5(&mut self) -> MR5_W {
                MR5_W { w: self }
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline(always)]
            pub fn mr6(&mut self) -> MR6_W {
                MR6_W { w: self }
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline(always)]
            pub fn mr7(&mut self) -> MR7_W {
                MR7_W { w: self }
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline(always)]
            pub fn mr8(&mut self) -> MR8_W {
                MR8_W { w: self }
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline(always)]
            pub fn mr9(&mut self) -> MR9_W {
                MR9_W { w: self }
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline(always)]
            pub fn mr10(&mut self) -> MR10_W {
                MR10_W { w: self }
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline(always)]
            pub fn mr11(&mut self) -> MR11_W {
                MR11_W { w: self }
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline(always)]
            pub fn mr12(&mut self) -> MR12_W {
                MR12_W { w: self }
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline(always)]
            pub fn mr13(&mut self) -> MR13_W {
                MR13_W { w: self }
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline(always)]
            pub fn mr14(&mut self) -> MR14_W {
                MR14_W { w: self }
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline(always)]
            pub fn mr15(&mut self) -> MR15_W {
                MR15_W { w: self }
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline(always)]
            pub fn mr16(&mut self) -> MR16_W {
                MR16_W { w: self }
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline(always)]
            pub fn mr17(&mut self) -> MR17_W {
                MR17_W { w: self }
            }
        }
    }
    #[doc = "Rising Trigger selection register (EXTI_RTSR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtsr](rtsr) module"]
    pub type RTSR = crate::Reg<u32, _RTSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RTSR;
    #[doc = "`read()` method returns [rtsr::R](rtsr::R) reader structure"]
    impl crate::Readable for RTSR {}
    #[doc = "`write(|w| ..)` method takes [rtsr::W](rtsr::W) writer structure"]
    impl crate::Writable for RTSR {}
    #[doc = "Rising Trigger selection register (EXTI_RTSR)"]
    pub mod rtsr {
        #[doc = "Reader of register RTSR"]
        pub type R = crate::R<u32, super::RTSR>;
        #[doc = "Writer for register RTSR"]
        pub type W = crate::W<u32, super::RTSR>;
        #[doc = "Register RTSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RTSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Rising trigger event configuration of line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TR0_A {
            #[doc = "0: Rising edge trigger is disabled"]
            DISABLED = 0,
            #[doc = "1: Rising edge trigger is enabled"]
            ENABLED = 1,
        }
        impl From<TR0_A> for bool {
            #[inline(always)]
            fn from(variant: TR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TR0`"]
        pub type TR0_R = crate::R<bool, TR0_A>;
        impl TR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TR0_A {
                match self.bits {
                    false => TR0_A::DISABLED,
                    true => TR0_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TR0_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TR0_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TR0`"]
        pub struct TR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 1"]
        pub type TR1_A = TR0_A;
        #[doc = "Reader of field `TR1`"]
        pub type TR1_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR1`"]
        pub struct TR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 2"]
        pub type TR2_A = TR0_A;
        #[doc = "Reader of field `TR2`"]
        pub type TR2_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR2`"]
        pub struct TR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 3"]
        pub type TR3_A = TR0_A;
        #[doc = "Reader of field `TR3`"]
        pub type TR3_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR3`"]
        pub struct TR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 4"]
        pub type TR4_A = TR0_A;
        #[doc = "Reader of field `TR4`"]
        pub type TR4_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR4`"]
        pub struct TR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 5"]
        pub type TR5_A = TR0_A;
        #[doc = "Reader of field `TR5`"]
        pub type TR5_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR5`"]
        pub struct TR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 6"]
        pub type TR6_A = TR0_A;
        #[doc = "Reader of field `TR6`"]
        pub type TR6_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR6`"]
        pub struct TR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 7"]
        pub type TR7_A = TR0_A;
        #[doc = "Reader of field `TR7`"]
        pub type TR7_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR7`"]
        pub struct TR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 8"]
        pub type TR8_A = TR0_A;
        #[doc = "Reader of field `TR8`"]
        pub type TR8_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR8`"]
        pub struct TR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 9"]
        pub type TR9_A = TR0_A;
        #[doc = "Reader of field `TR9`"]
        pub type TR9_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR9`"]
        pub struct TR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 10"]
        pub type TR10_A = TR0_A;
        #[doc = "Reader of field `TR10`"]
        pub type TR10_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR10`"]
        pub struct TR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 11"]
        pub type TR11_A = TR0_A;
        #[doc = "Reader of field `TR11`"]
        pub type TR11_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR11`"]
        pub struct TR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 12"]
        pub type TR12_A = TR0_A;
        #[doc = "Reader of field `TR12`"]
        pub type TR12_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR12`"]
        pub struct TR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 13"]
        pub type TR13_A = TR0_A;
        #[doc = "Reader of field `TR13`"]
        pub type TR13_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR13`"]
        pub struct TR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 14"]
        pub type TR14_A = TR0_A;
        #[doc = "Reader of field `TR14`"]
        pub type TR14_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR14`"]
        pub struct TR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 15"]
        pub type TR15_A = TR0_A;
        #[doc = "Reader of field `TR15`"]
        pub type TR15_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR15`"]
        pub struct TR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 16"]
        pub type TR16_A = TR0_A;
        #[doc = "Reader of field `TR16`"]
        pub type TR16_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR16`"]
        pub struct TR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 17"]
        pub type TR17_A = TR0_A;
        #[doc = "Reader of field `TR17`"]
        pub type TR17_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR17`"]
        pub struct TR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline(always)]
            pub fn tr0(&mut self) -> TR0_W {
                TR0_W { w: self }
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline(always)]
            pub fn tr1(&mut self) -> TR1_W {
                TR1_W { w: self }
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline(always)]
            pub fn tr2(&mut self) -> TR2_W {
                TR2_W { w: self }
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline(always)]
            pub fn tr3(&mut self) -> TR3_W {
                TR3_W { w: self }
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline(always)]
            pub fn tr4(&mut self) -> TR4_W {
                TR4_W { w: self }
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline(always)]
            pub fn tr5(&mut self) -> TR5_W {
                TR5_W { w: self }
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline(always)]
            pub fn tr6(&mut self) -> TR6_W {
                TR6_W { w: self }
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline(always)]
            pub fn tr7(&mut self) -> TR7_W {
                TR7_W { w: self }
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline(always)]
            pub fn tr8(&mut self) -> TR8_W {
                TR8_W { w: self }
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline(always)]
            pub fn tr9(&mut self) -> TR9_W {
                TR9_W { w: self }
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline(always)]
            pub fn tr10(&mut self) -> TR10_W {
                TR10_W { w: self }
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline(always)]
            pub fn tr11(&mut self) -> TR11_W {
                TR11_W { w: self }
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline(always)]
            pub fn tr12(&mut self) -> TR12_W {
                TR12_W { w: self }
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline(always)]
            pub fn tr13(&mut self) -> TR13_W {
                TR13_W { w: self }
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline(always)]
            pub fn tr14(&mut self) -> TR14_W {
                TR14_W { w: self }
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline(always)]
            pub fn tr15(&mut self) -> TR15_W {
                TR15_W { w: self }
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline(always)]
            pub fn tr16(&mut self) -> TR16_W {
                TR16_W { w: self }
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline(always)]
            pub fn tr17(&mut self) -> TR17_W {
                TR17_W { w: self }
            }
        }
    }
    #[doc = "Falling Trigger selection register (EXTI_FTSR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ftsr](ftsr) module"]
    pub type FTSR = crate::Reg<u32, _FTSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FTSR;
    #[doc = "`read()` method returns [ftsr::R](ftsr::R) reader structure"]
    impl crate::Readable for FTSR {}
    #[doc = "`write(|w| ..)` method takes [ftsr::W](ftsr::W) writer structure"]
    impl crate::Writable for FTSR {}
    #[doc = "Falling Trigger selection register (EXTI_FTSR)"]
    pub mod ftsr {
        #[doc = "Reader of register FTSR"]
        pub type R = crate::R<u32, super::FTSR>;
        #[doc = "Writer for register FTSR"]
        pub type W = crate::W<u32, super::FTSR>;
        #[doc = "Register FTSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::FTSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Falling trigger event configuration of line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TR0_A {
            #[doc = "0: Falling edge trigger is disabled"]
            DISABLED = 0,
            #[doc = "1: Falling edge trigger is enabled"]
            ENABLED = 1,
        }
        impl From<TR0_A> for bool {
            #[inline(always)]
            fn from(variant: TR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TR0`"]
        pub type TR0_R = crate::R<bool, TR0_A>;
        impl TR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TR0_A {
                match self.bits {
                    false => TR0_A::DISABLED,
                    true => TR0_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TR0_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TR0_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TR0`"]
        pub struct TR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 1"]
        pub type TR1_A = TR0_A;
        #[doc = "Reader of field `TR1`"]
        pub type TR1_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR1`"]
        pub struct TR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 2"]
        pub type TR2_A = TR0_A;
        #[doc = "Reader of field `TR2`"]
        pub type TR2_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR2`"]
        pub struct TR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 3"]
        pub type TR3_A = TR0_A;
        #[doc = "Reader of field `TR3`"]
        pub type TR3_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR3`"]
        pub struct TR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 4"]
        pub type TR4_A = TR0_A;
        #[doc = "Reader of field `TR4`"]
        pub type TR4_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR4`"]
        pub struct TR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 5"]
        pub type TR5_A = TR0_A;
        #[doc = "Reader of field `TR5`"]
        pub type TR5_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR5`"]
        pub struct TR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 6"]
        pub type TR6_A = TR0_A;
        #[doc = "Reader of field `TR6`"]
        pub type TR6_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR6`"]
        pub struct TR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 7"]
        pub type TR7_A = TR0_A;
        #[doc = "Reader of field `TR7`"]
        pub type TR7_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR7`"]
        pub struct TR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 8"]
        pub type TR8_A = TR0_A;
        #[doc = "Reader of field `TR8`"]
        pub type TR8_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR8`"]
        pub struct TR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 9"]
        pub type TR9_A = TR0_A;
        #[doc = "Reader of field `TR9`"]
        pub type TR9_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR9`"]
        pub struct TR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 10"]
        pub type TR10_A = TR0_A;
        #[doc = "Reader of field `TR10`"]
        pub type TR10_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR10`"]
        pub struct TR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 11"]
        pub type TR11_A = TR0_A;
        #[doc = "Reader of field `TR11`"]
        pub type TR11_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR11`"]
        pub struct TR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 12"]
        pub type TR12_A = TR0_A;
        #[doc = "Reader of field `TR12`"]
        pub type TR12_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR12`"]
        pub struct TR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 13"]
        pub type TR13_A = TR0_A;
        #[doc = "Reader of field `TR13`"]
        pub type TR13_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR13`"]
        pub struct TR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 14"]
        pub type TR14_A = TR0_A;
        #[doc = "Reader of field `TR14`"]
        pub type TR14_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR14`"]
        pub struct TR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 15"]
        pub type TR15_A = TR0_A;
        #[doc = "Reader of field `TR15`"]
        pub type TR15_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR15`"]
        pub struct TR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 16"]
        pub type TR16_A = TR0_A;
        #[doc = "Reader of field `TR16`"]
        pub type TR16_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR16`"]
        pub struct TR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 17"]
        pub type TR17_A = TR0_A;
        #[doc = "Reader of field `TR17`"]
        pub type TR17_R = crate::R<bool, TR0_A>;
        #[doc = "Write proxy for field `TR17`"]
        pub struct TR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TR17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline(always)]
            pub fn tr0(&mut self) -> TR0_W {
                TR0_W { w: self }
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline(always)]
            pub fn tr1(&mut self) -> TR1_W {
                TR1_W { w: self }
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline(always)]
            pub fn tr2(&mut self) -> TR2_W {
                TR2_W { w: self }
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline(always)]
            pub fn tr3(&mut self) -> TR3_W {
                TR3_W { w: self }
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline(always)]
            pub fn tr4(&mut self) -> TR4_W {
                TR4_W { w: self }
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline(always)]
            pub fn tr5(&mut self) -> TR5_W {
                TR5_W { w: self }
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline(always)]
            pub fn tr6(&mut self) -> TR6_W {
                TR6_W { w: self }
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline(always)]
            pub fn tr7(&mut self) -> TR7_W {
                TR7_W { w: self }
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline(always)]
            pub fn tr8(&mut self) -> TR8_W {
                TR8_W { w: self }
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline(always)]
            pub fn tr9(&mut self) -> TR9_W {
                TR9_W { w: self }
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline(always)]
            pub fn tr10(&mut self) -> TR10_W {
                TR10_W { w: self }
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline(always)]
            pub fn tr11(&mut self) -> TR11_W {
                TR11_W { w: self }
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline(always)]
            pub fn tr12(&mut self) -> TR12_W {
                TR12_W { w: self }
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline(always)]
            pub fn tr13(&mut self) -> TR13_W {
                TR13_W { w: self }
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline(always)]
            pub fn tr14(&mut self) -> TR14_W {
                TR14_W { w: self }
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline(always)]
            pub fn tr15(&mut self) -> TR15_W {
                TR15_W { w: self }
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline(always)]
            pub fn tr16(&mut self) -> TR16_W {
                TR16_W { w: self }
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline(always)]
            pub fn tr17(&mut self) -> TR17_W {
                TR17_W { w: self }
            }
        }
    }
    #[doc = "Software interrupt event register (EXTI_SWIER)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swier](swier) module"]
    pub type SWIER = crate::Reg<u32, _SWIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SWIER;
    #[doc = "`read()` method returns [swier::R](swier::R) reader structure"]
    impl crate::Readable for SWIER {}
    #[doc = "`write(|w| ..)` method takes [swier::W](swier::W) writer structure"]
    impl crate::Writable for SWIER {}
    #[doc = "Software interrupt event register (EXTI_SWIER)"]
    pub mod swier {
        #[doc = "Reader of register SWIER"]
        pub type R = crate::R<u32, super::SWIER>;
        #[doc = "Writer for register SWIER"]
        pub type W = crate::W<u32, super::SWIER>;
        #[doc = "Register SWIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::SWIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Software Interrupt on line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWIER0_A {
            #[doc = "1: Generates an interrupt request"]
            PEND = 1,
        }
        impl From<SWIER0_A> for bool {
            #[inline(always)]
            fn from(variant: SWIER0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SWIER0`"]
        pub type SWIER0_R = crate::R<bool, SWIER0_A>;
        impl SWIER0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, SWIER0_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(SWIER0_A::PEND),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PEND`"]
            #[inline(always)]
            pub fn is_pend(&self) -> bool {
                *self == SWIER0_A::PEND
            }
        }
        #[doc = "Write proxy for field `SWIER0`"]
        pub struct SWIER0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 1"]
        pub type SWIER1_A = SWIER0_A;
        #[doc = "Reader of field `SWIER1`"]
        pub type SWIER1_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER1`"]
        pub struct SWIER1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 2"]
        pub type SWIER2_A = SWIER0_A;
        #[doc = "Reader of field `SWIER2`"]
        pub type SWIER2_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER2`"]
        pub struct SWIER2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 3"]
        pub type SWIER3_A = SWIER0_A;
        #[doc = "Reader of field `SWIER3`"]
        pub type SWIER3_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER3`"]
        pub struct SWIER3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 4"]
        pub type SWIER4_A = SWIER0_A;
        #[doc = "Reader of field `SWIER4`"]
        pub type SWIER4_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER4`"]
        pub struct SWIER4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 5"]
        pub type SWIER5_A = SWIER0_A;
        #[doc = "Reader of field `SWIER5`"]
        pub type SWIER5_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER5`"]
        pub struct SWIER5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 6"]
        pub type SWIER6_A = SWIER0_A;
        #[doc = "Reader of field `SWIER6`"]
        pub type SWIER6_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER6`"]
        pub struct SWIER6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 7"]
        pub type SWIER7_A = SWIER0_A;
        #[doc = "Reader of field `SWIER7`"]
        pub type SWIER7_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER7`"]
        pub struct SWIER7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 8"]
        pub type SWIER8_A = SWIER0_A;
        #[doc = "Reader of field `SWIER8`"]
        pub type SWIER8_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER8`"]
        pub struct SWIER8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 9"]
        pub type SWIER9_A = SWIER0_A;
        #[doc = "Reader of field `SWIER9`"]
        pub type SWIER9_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER9`"]
        pub struct SWIER9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 10"]
        pub type SWIER10_A = SWIER0_A;
        #[doc = "Reader of field `SWIER10`"]
        pub type SWIER10_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER10`"]
        pub struct SWIER10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 11"]
        pub type SWIER11_A = SWIER0_A;
        #[doc = "Reader of field `SWIER11`"]
        pub type SWIER11_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER11`"]
        pub struct SWIER11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 12"]
        pub type SWIER12_A = SWIER0_A;
        #[doc = "Reader of field `SWIER12`"]
        pub type SWIER12_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER12`"]
        pub struct SWIER12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 13"]
        pub type SWIER13_A = SWIER0_A;
        #[doc = "Reader of field `SWIER13`"]
        pub type SWIER13_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER13`"]
        pub struct SWIER13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 14"]
        pub type SWIER14_A = SWIER0_A;
        #[doc = "Reader of field `SWIER14`"]
        pub type SWIER14_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER14`"]
        pub struct SWIER14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 15"]
        pub type SWIER15_A = SWIER0_A;
        #[doc = "Reader of field `SWIER15`"]
        pub type SWIER15_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER15`"]
        pub struct SWIER15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 16"]
        pub type SWIER16_A = SWIER0_A;
        #[doc = "Reader of field `SWIER16`"]
        pub type SWIER16_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER16`"]
        pub struct SWIER16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 17"]
        pub type SWIER17_A = SWIER0_A;
        #[doc = "Reader of field `SWIER17`"]
        pub type SWIER17_R = crate::R<bool, SWIER0_A>;
        #[doc = "Write proxy for field `SWIER17`"]
        pub struct SWIER17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWIER17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline(always)]
            pub fn swier0(&self) -> SWIER0_R {
                SWIER0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline(always)]
            pub fn swier1(&self) -> SWIER1_R {
                SWIER1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline(always)]
            pub fn swier2(&self) -> SWIER2_R {
                SWIER2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline(always)]
            pub fn swier3(&self) -> SWIER3_R {
                SWIER3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline(always)]
            pub fn swier4(&self) -> SWIER4_R {
                SWIER4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline(always)]
            pub fn swier5(&self) -> SWIER5_R {
                SWIER5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline(always)]
            pub fn swier6(&self) -> SWIER6_R {
                SWIER6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline(always)]
            pub fn swier7(&self) -> SWIER7_R {
                SWIER7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline(always)]
            pub fn swier8(&self) -> SWIER8_R {
                SWIER8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline(always)]
            pub fn swier9(&self) -> SWIER9_R {
                SWIER9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline(always)]
            pub fn swier10(&self) -> SWIER10_R {
                SWIER10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline(always)]
            pub fn swier11(&self) -> SWIER11_R {
                SWIER11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline(always)]
            pub fn swier12(&self) -> SWIER12_R {
                SWIER12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline(always)]
            pub fn swier13(&self) -> SWIER13_R {
                SWIER13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline(always)]
            pub fn swier14(&self) -> SWIER14_R {
                SWIER14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline(always)]
            pub fn swier15(&self) -> SWIER15_R {
                SWIER15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline(always)]
            pub fn swier16(&self) -> SWIER16_R {
                SWIER16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline(always)]
            pub fn swier17(&self) -> SWIER17_R {
                SWIER17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline(always)]
            pub fn swier0(&mut self) -> SWIER0_W {
                SWIER0_W { w: self }
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline(always)]
            pub fn swier1(&mut self) -> SWIER1_W {
                SWIER1_W { w: self }
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline(always)]
            pub fn swier2(&mut self) -> SWIER2_W {
                SWIER2_W { w: self }
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline(always)]
            pub fn swier3(&mut self) -> SWIER3_W {
                SWIER3_W { w: self }
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline(always)]
            pub fn swier4(&mut self) -> SWIER4_W {
                SWIER4_W { w: self }
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline(always)]
            pub fn swier5(&mut self) -> SWIER5_W {
                SWIER5_W { w: self }
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline(always)]
            pub fn swier6(&mut self) -> SWIER6_W {
                SWIER6_W { w: self }
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline(always)]
            pub fn swier7(&mut self) -> SWIER7_W {
                SWIER7_W { w: self }
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline(always)]
            pub fn swier8(&mut self) -> SWIER8_W {
                SWIER8_W { w: self }
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline(always)]
            pub fn swier9(&mut self) -> SWIER9_W {
                SWIER9_W { w: self }
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline(always)]
            pub fn swier10(&mut self) -> SWIER10_W {
                SWIER10_W { w: self }
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline(always)]
            pub fn swier11(&mut self) -> SWIER11_W {
                SWIER11_W { w: self }
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline(always)]
            pub fn swier12(&mut self) -> SWIER12_W {
                SWIER12_W { w: self }
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline(always)]
            pub fn swier13(&mut self) -> SWIER13_W {
                SWIER13_W { w: self }
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline(always)]
            pub fn swier14(&mut self) -> SWIER14_W {
                SWIER14_W { w: self }
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline(always)]
            pub fn swier15(&mut self) -> SWIER15_W {
                SWIER15_W { w: self }
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline(always)]
            pub fn swier16(&mut self) -> SWIER16_W {
                SWIER16_W { w: self }
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline(always)]
            pub fn swier17(&mut self) -> SWIER17_W {
                SWIER17_W { w: self }
            }
        }
    }
    #[doc = "Pending register (EXTI_PR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pr](pr) module"]
    pub type PR = crate::Reg<u32, _PR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PR;
    #[doc = "`read()` method returns [pr::R](pr::R) reader structure"]
    impl crate::Readable for PR {}
    #[doc = "`write(|w| ..)` method takes [pr::W](pr::W) writer structure"]
    impl crate::Writable for PR {}
    #[doc = "Pending register (EXTI_PR)"]
    pub mod pr {
        #[doc = "Reader of register PR"]
        pub type R = crate::R<u32, super::PR>;
        #[doc = "Writer for register PR"]
        pub type W = crate::W<u32, super::PR>;
        #[doc = "Register PR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Pending bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PR0_A {
            #[doc = "0: No trigger request occurred"]
            NOTPENDING = 0,
            #[doc = "1: Selected trigger request occurred"]
            PENDING = 1,
        }
        impl From<PR0_A> for bool {
            #[inline(always)]
            fn from(variant: PR0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PR0`"]
        pub type PR0_R = crate::R<bool, PR0_A>;
        impl PR0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PR0_A {
                match self.bits {
                    false => PR0_A::NOTPENDING,
                    true => PR0_A::PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPENDING`"]
            #[inline(always)]
            pub fn is_not_pending(&self) -> bool {
                *self == PR0_A::NOTPENDING
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                *self == PR0_A::PENDING
            }
        }
        #[doc = "Pending bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PR0_AW {
            #[doc = "1: Clears pending bit"]
            CLEAR = 1,
        }
        impl From<PR0_AW> for bool {
            #[inline(always)]
            fn from(variant: PR0_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `PR0`"]
        pub struct PR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Pending bit 1"]
        pub type PR1_A = PR0_A;
        #[doc = "Reader of field `PR1`"]
        pub type PR1_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 1"]
        pub type PR1_AW = PR0_AW;
        #[doc = "Write proxy for field `PR1`"]
        pub struct PR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Pending bit 2"]
        pub type PR2_A = PR0_A;
        #[doc = "Reader of field `PR2`"]
        pub type PR2_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 2"]
        pub type PR2_AW = PR0_AW;
        #[doc = "Write proxy for field `PR2`"]
        pub struct PR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Pending bit 3"]
        pub type PR3_A = PR0_A;
        #[doc = "Reader of field `PR3`"]
        pub type PR3_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 3"]
        pub type PR3_AW = PR0_AW;
        #[doc = "Write proxy for field `PR3`"]
        pub struct PR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Pending bit 4"]
        pub type PR4_A = PR0_A;
        #[doc = "Reader of field `PR4`"]
        pub type PR4_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 4"]
        pub type PR4_AW = PR0_AW;
        #[doc = "Write proxy for field `PR4`"]
        pub struct PR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Pending bit 5"]
        pub type PR5_A = PR0_A;
        #[doc = "Reader of field `PR5`"]
        pub type PR5_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 5"]
        pub type PR5_AW = PR0_AW;
        #[doc = "Write proxy for field `PR5`"]
        pub struct PR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Pending bit 6"]
        pub type PR6_A = PR0_A;
        #[doc = "Reader of field `PR6`"]
        pub type PR6_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 6"]
        pub type PR6_AW = PR0_AW;
        #[doc = "Write proxy for field `PR6`"]
        pub struct PR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Pending bit 7"]
        pub type PR7_A = PR0_A;
        #[doc = "Reader of field `PR7`"]
        pub type PR7_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 7"]
        pub type PR7_AW = PR0_AW;
        #[doc = "Write proxy for field `PR7`"]
        pub struct PR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Pending bit 8"]
        pub type PR8_A = PR0_A;
        #[doc = "Reader of field `PR8`"]
        pub type PR8_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 8"]
        pub type PR8_AW = PR0_AW;
        #[doc = "Write proxy for field `PR8`"]
        pub struct PR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Pending bit 9"]
        pub type PR9_A = PR0_A;
        #[doc = "Reader of field `PR9`"]
        pub type PR9_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 9"]
        pub type PR9_AW = PR0_AW;
        #[doc = "Write proxy for field `PR9`"]
        pub struct PR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Pending bit 10"]
        pub type PR10_A = PR0_A;
        #[doc = "Reader of field `PR10`"]
        pub type PR10_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 10"]
        pub type PR10_AW = PR0_AW;
        #[doc = "Write proxy for field `PR10`"]
        pub struct PR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Pending bit 11"]
        pub type PR11_A = PR0_A;
        #[doc = "Reader of field `PR11`"]
        pub type PR11_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 11"]
        pub type PR11_AW = PR0_AW;
        #[doc = "Write proxy for field `PR11`"]
        pub struct PR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Pending bit 12"]
        pub type PR12_A = PR0_A;
        #[doc = "Reader of field `PR12`"]
        pub type PR12_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 12"]
        pub type PR12_AW = PR0_AW;
        #[doc = "Write proxy for field `PR12`"]
        pub struct PR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Pending bit 13"]
        pub type PR13_A = PR0_A;
        #[doc = "Reader of field `PR13`"]
        pub type PR13_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 13"]
        pub type PR13_AW = PR0_AW;
        #[doc = "Write proxy for field `PR13`"]
        pub struct PR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Pending bit 14"]
        pub type PR14_A = PR0_A;
        #[doc = "Reader of field `PR14`"]
        pub type PR14_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 14"]
        pub type PR14_AW = PR0_AW;
        #[doc = "Write proxy for field `PR14`"]
        pub struct PR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Pending bit 15"]
        pub type PR15_A = PR0_A;
        #[doc = "Reader of field `PR15`"]
        pub type PR15_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 15"]
        pub type PR15_AW = PR0_AW;
        #[doc = "Write proxy for field `PR15`"]
        pub struct PR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Pending bit 16"]
        pub type PR16_A = PR0_A;
        #[doc = "Reader of field `PR16`"]
        pub type PR16_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 16"]
        pub type PR16_AW = PR0_AW;
        #[doc = "Write proxy for field `PR16`"]
        pub struct PR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR16_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Pending bit 17"]
        pub type PR17_A = PR0_A;
        #[doc = "Reader of field `PR17`"]
        pub type PR17_R = crate::R<bool, PR0_A>;
        #[doc = "Pending bit 17"]
        pub type PR17_AW = PR0_AW;
        #[doc = "Write proxy for field `PR17`"]
        pub struct PR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR17_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline(always)]
            pub fn pr0(&self) -> PR0_R {
                PR0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline(always)]
            pub fn pr1(&self) -> PR1_R {
                PR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline(always)]
            pub fn pr2(&self) -> PR2_R {
                PR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline(always)]
            pub fn pr3(&self) -> PR3_R {
                PR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline(always)]
            pub fn pr4(&self) -> PR4_R {
                PR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline(always)]
            pub fn pr5(&self) -> PR5_R {
                PR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline(always)]
            pub fn pr6(&self) -> PR6_R {
                PR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline(always)]
            pub fn pr7(&self) -> PR7_R {
                PR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline(always)]
            pub fn pr8(&self) -> PR8_R {
                PR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline(always)]
            pub fn pr9(&self) -> PR9_R {
                PR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline(always)]
            pub fn pr10(&self) -> PR10_R {
                PR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline(always)]
            pub fn pr11(&self) -> PR11_R {
                PR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline(always)]
            pub fn pr12(&self) -> PR12_R {
                PR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline(always)]
            pub fn pr13(&self) -> PR13_R {
                PR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline(always)]
            pub fn pr14(&self) -> PR14_R {
                PR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline(always)]
            pub fn pr15(&self) -> PR15_R {
                PR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline(always)]
            pub fn pr16(&self) -> PR16_R {
                PR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline(always)]
            pub fn pr17(&self) -> PR17_R {
                PR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline(always)]
            pub fn pr0(&mut self) -> PR0_W {
                PR0_W { w: self }
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline(always)]
            pub fn pr1(&mut self) -> PR1_W {
                PR1_W { w: self }
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline(always)]
            pub fn pr2(&mut self) -> PR2_W {
                PR2_W { w: self }
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline(always)]
            pub fn pr3(&mut self) -> PR3_W {
                PR3_W { w: self }
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline(always)]
            pub fn pr4(&mut self) -> PR4_W {
                PR4_W { w: self }
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline(always)]
            pub fn pr5(&mut self) -> PR5_W {
                PR5_W { w: self }
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline(always)]
            pub fn pr6(&mut self) -> PR6_W {
                PR6_W { w: self }
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline(always)]
            pub fn pr7(&mut self) -> PR7_W {
                PR7_W { w: self }
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline(always)]
            pub fn pr8(&mut self) -> PR8_W {
                PR8_W { w: self }
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline(always)]
            pub fn pr9(&mut self) -> PR9_W {
                PR9_W { w: self }
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline(always)]
            pub fn pr10(&mut self) -> PR10_W {
                PR10_W { w: self }
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline(always)]
            pub fn pr11(&mut self) -> PR11_W {
                PR11_W { w: self }
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline(always)]
            pub fn pr12(&mut self) -> PR12_W {
                PR12_W { w: self }
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline(always)]
            pub fn pr13(&mut self) -> PR13_W {
                PR13_W { w: self }
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline(always)]
            pub fn pr14(&mut self) -> PR14_W {
                PR14_W { w: self }
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline(always)]
            pub fn pr15(&mut self) -> PR15_W {
                PR15_W { w: self }
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline(always)]
            pub fn pr16(&mut self) -> PR16_W {
                PR16_W { w: self }
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline(always)]
            pub fn pr17(&mut self) -> PR17_W {
                PR17_W { w: self }
            }
        }
    }
}
#[doc = "DMA controller"]
pub struct DMA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA1 {}
impl DMA1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma1::RegisterBlock {
        0x4002_0000 as *const _
    }
}
impl Deref for DMA1 {
    type Target = dma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DMA1::ptr() }
    }
}
#[doc = "DMA controller"]
pub mod dma1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - DMA interrupt status register (DMA_ISR)"]
        pub isr: ISR,
        #[doc = "0x04 - DMA interrupt flag clear register (DMA_IFCR)"]
        pub ifcr: IFCR,
        #[doc = "0x08 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch1: CH,
        _reserved3: [u8; 4usize],
        #[doc = "0x1c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch2: CH,
        _reserved4: [u8; 4usize],
        #[doc = "0x30 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch3: CH,
        _reserved5: [u8; 4usize],
        #[doc = "0x44 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch4: CH,
        _reserved6: [u8; 4usize],
        #[doc = "0x58 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch5: CH,
        _reserved7: [u8; 4usize],
        #[doc = "0x6c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch6: CH,
        _reserved8: [u8; 4usize],
        #[doc = "0x80 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch7: CH,
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct CH {
        #[doc = "0x00 - DMA channel configuration register (DMA_CCR)"]
        pub cr: self::ch::CR,
        #[doc = "0x04 - DMA channel 1 number of data register"]
        pub ndtr: self::ch::NDTR,
        #[doc = "0x08 - DMA channel 1 peripheral address register"]
        pub par: self::ch::PAR,
        #[doc = "0x0c - DMA channel 1 memory address register"]
        pub mar: self::ch::MAR,
    }
    #[doc = r"Register block"]
    #[doc = "Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
    pub mod ch {
        #[doc = "DMA channel configuration register (DMA_CCR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
        pub type CR = crate::Reg<u32, _CR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CR;
        #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
        impl crate::Readable for CR {}
        #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
        impl crate::Writable for CR {}
        #[doc = "DMA channel configuration register (DMA_CCR)"]
        pub mod cr {
            #[doc = "Reader of register CR"]
            pub type R = crate::R<u32, super::CR>;
            #[doc = "Writer for register CR"]
            pub type W = crate::W<u32, super::CR>;
            #[doc = "Register CR `reset()`'s with value 0"]
            impl crate::ResetValue for super::CR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Channel enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum EN_A {
                #[doc = "0: Channel disabled"]
                DISABLED = 0,
                #[doc = "1: Channel enabled"]
                ENABLED = 1,
            }
            impl From<EN_A> for bool {
                #[inline(always)]
                fn from(variant: EN_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `EN`"]
            pub type EN_R = crate::R<bool, EN_A>;
            impl EN_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> EN_A {
                    match self.bits {
                        false => EN_A::DISABLED,
                        true => EN_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == EN_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == EN_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `EN`"]
            pub struct EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> EN_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: EN_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Channel disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(EN_A::DISABLED)
                }
                #[doc = "Channel enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(EN_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            #[doc = "Transfer complete interrupt enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TCIE_A {
                #[doc = "0: Transfer Complete interrupt disabled"]
                DISABLED = 0,
                #[doc = "1: Transfer Complete interrupt enabled"]
                ENABLED = 1,
            }
            impl From<TCIE_A> for bool {
                #[inline(always)]
                fn from(variant: TCIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `TCIE`"]
            pub type TCIE_R = crate::R<bool, TCIE_A>;
            impl TCIE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> TCIE_A {
                    match self.bits {
                        false => TCIE_A::DISABLED,
                        true => TCIE_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == TCIE_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == TCIE_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `TCIE`"]
            pub struct TCIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TCIE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Transfer Complete interrupt disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TCIE_A::DISABLED)
                }
                #[doc = "Transfer Complete interrupt enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TCIE_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Half Transfer interrupt enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HTIE_A {
                #[doc = "0: Half Transfer interrupt disabled"]
                DISABLED = 0,
                #[doc = "1: Half Transfer interrupt enabled"]
                ENABLED = 1,
            }
            impl From<HTIE_A> for bool {
                #[inline(always)]
                fn from(variant: HTIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `HTIE`"]
            pub type HTIE_R = crate::R<bool, HTIE_A>;
            impl HTIE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> HTIE_A {
                    match self.bits {
                        false => HTIE_A::DISABLED,
                        true => HTIE_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == HTIE_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == HTIE_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `HTIE`"]
            pub struct HTIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> HTIE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: HTIE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Half Transfer interrupt disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(HTIE_A::DISABLED)
                }
                #[doc = "Half Transfer interrupt enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(HTIE_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                    self.w
                }
            }
            #[doc = "Transfer error interrupt enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TEIE_A {
                #[doc = "0: Transfer Error interrupt disabled"]
                DISABLED = 0,
                #[doc = "1: Transfer Error interrupt enabled"]
                ENABLED = 1,
            }
            impl From<TEIE_A> for bool {
                #[inline(always)]
                fn from(variant: TEIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `TEIE`"]
            pub type TEIE_R = crate::R<bool, TEIE_A>;
            impl TEIE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> TEIE_A {
                    match self.bits {
                        false => TEIE_A::DISABLED,
                        true => TEIE_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == TEIE_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == TEIE_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `TEIE`"]
            pub struct TEIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TEIE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: TEIE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Transfer Error interrupt disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TEIE_A::DISABLED)
                }
                #[doc = "Transfer Error interrupt enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TEIE_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Data transfer direction\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum DIR_A {
                #[doc = "0: Read from peripheral"]
                FROMPERIPHERAL = 0,
                #[doc = "1: Read from memory"]
                FROMMEMORY = 1,
            }
            impl From<DIR_A> for bool {
                #[inline(always)]
                fn from(variant: DIR_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `DIR`"]
            pub type DIR_R = crate::R<bool, DIR_A>;
            impl DIR_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> DIR_A {
                    match self.bits {
                        false => DIR_A::FROMPERIPHERAL,
                        true => DIR_A::FROMMEMORY,
                    }
                }
                #[doc = "Checks if the value of the field is `FROMPERIPHERAL`"]
                #[inline(always)]
                pub fn is_from_peripheral(&self) -> bool {
                    *self == DIR_A::FROMPERIPHERAL
                }
                #[doc = "Checks if the value of the field is `FROMMEMORY`"]
                #[inline(always)]
                pub fn is_from_memory(&self) -> bool {
                    *self == DIR_A::FROMMEMORY
                }
            }
            #[doc = "Write proxy for field `DIR`"]
            pub struct DIR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DIR_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DIR_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Read from peripheral"]
                #[inline(always)]
                pub fn from_peripheral(self) -> &'a mut W {
                    self.variant(DIR_A::FROMPERIPHERAL)
                }
                #[doc = "Read from memory"]
                #[inline(always)]
                pub fn from_memory(self) -> &'a mut W {
                    self.variant(DIR_A::FROMMEMORY)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Circular mode\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum CIRC_A {
                #[doc = "0: Circular buffer disabled"]
                DISABLED = 0,
                #[doc = "1: Circular buffer enabled"]
                ENABLED = 1,
            }
            impl From<CIRC_A> for bool {
                #[inline(always)]
                fn from(variant: CIRC_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `CIRC`"]
            pub type CIRC_R = crate::R<bool, CIRC_A>;
            impl CIRC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> CIRC_A {
                    match self.bits {
                        false => CIRC_A::DISABLED,
                        true => CIRC_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == CIRC_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == CIRC_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `CIRC`"]
            pub struct CIRC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> CIRC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: CIRC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Circular buffer disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(CIRC_A::DISABLED)
                }
                #[doc = "Circular buffer enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(CIRC_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                    self.w
                }
            }
            #[doc = "Peripheral increment mode\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PINC_A {
                #[doc = "0: Increment mode disabled"]
                DISABLED = 0,
                #[doc = "1: Increment mode enabled"]
                ENABLED = 1,
            }
            impl From<PINC_A> for bool {
                #[inline(always)]
                fn from(variant: PINC_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `PINC`"]
            pub type PINC_R = crate::R<bool, PINC_A>;
            impl PINC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> PINC_A {
                    match self.bits {
                        false => PINC_A::DISABLED,
                        true => PINC_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == PINC_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == PINC_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `PINC`"]
            pub struct PINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PINC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PINC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Increment mode disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(PINC_A::DISABLED)
                }
                #[doc = "Increment mode enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(PINC_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Memory increment mode"]
            pub type MINC_A = PINC_A;
            #[doc = "Reader of field `MINC`"]
            pub type MINC_R = crate::R<bool, PINC_A>;
            #[doc = "Write proxy for field `MINC`"]
            pub struct MINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MINC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MINC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Increment mode disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(PINC_A::DISABLED)
                }
                #[doc = "Increment mode enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(PINC_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                    self.w
                }
            }
            #[doc = "Peripheral size\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum PSIZE_A {
                #[doc = "0: 8-bit size"]
                BITS8 = 0,
                #[doc = "1: 16-bit size"]
                BITS16 = 1,
                #[doc = "2: 32-bit size"]
                BITS32 = 2,
            }
            impl From<PSIZE_A> for u8 {
                #[inline(always)]
                fn from(variant: PSIZE_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `PSIZE`"]
            pub type PSIZE_R = crate::R<u8, PSIZE_A>;
            impl PSIZE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> crate::Variant<u8, PSIZE_A> {
                    use crate::Variant::*;
                    match self.bits {
                        0 => Val(PSIZE_A::BITS8),
                        1 => Val(PSIZE_A::BITS16),
                        2 => Val(PSIZE_A::BITS32),
                        i => Res(i),
                    }
                }
                #[doc = "Checks if the value of the field is `BITS8`"]
                #[inline(always)]
                pub fn is_bits8(&self) -> bool {
                    *self == PSIZE_A::BITS8
                }
                #[doc = "Checks if the value of the field is `BITS16`"]
                #[inline(always)]
                pub fn is_bits16(&self) -> bool {
                    *self == PSIZE_A::BITS16
                }
                #[doc = "Checks if the value of the field is `BITS32`"]
                #[inline(always)]
                pub fn is_bits32(&self) -> bool {
                    *self == PSIZE_A::BITS32
                }
            }
            #[doc = "Write proxy for field `PSIZE`"]
            pub struct PSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PSIZE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "8-bit size"]
                #[inline(always)]
                pub fn bits8(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS8)
                }
                #[doc = "16-bit size"]
                #[inline(always)]
                pub fn bits16(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS16)
                }
                #[doc = "32-bit size"]
                #[inline(always)]
                pub fn bits32(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS32)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                    self.w
                }
            }
            #[doc = "Memory size"]
            pub type MSIZE_A = PSIZE_A;
            #[doc = "Reader of field `MSIZE`"]
            pub type MSIZE_R = crate::R<u8, PSIZE_A>;
            #[doc = "Write proxy for field `MSIZE`"]
            pub struct MSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MSIZE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "8-bit size"]
                #[inline(always)]
                pub fn bits8(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS8)
                }
                #[doc = "16-bit size"]
                #[inline(always)]
                pub fn bits16(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS16)
                }
                #[doc = "32-bit size"]
                #[inline(always)]
                pub fn bits32(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS32)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                    self.w
                }
            }
            #[doc = "Channel Priority level\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum PL_A {
                #[doc = "0: Low priority"]
                LOW = 0,
                #[doc = "1: Medium priority"]
                MEDIUM = 1,
                #[doc = "2: High priority"]
                HIGH = 2,
                #[doc = "3: Very high priority"]
                VERYHIGH = 3,
            }
            impl From<PL_A> for u8 {
                #[inline(always)]
                fn from(variant: PL_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `PL`"]
            pub type PL_R = crate::R<u8, PL_A>;
            impl PL_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> PL_A {
                    match self.bits {
                        0 => PL_A::LOW,
                        1 => PL_A::MEDIUM,
                        2 => PL_A::HIGH,
                        3 => PL_A::VERYHIGH,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `LOW`"]
                #[inline(always)]
                pub fn is_low(&self) -> bool {
                    *self == PL_A::LOW
                }
                #[doc = "Checks if the value of the field is `MEDIUM`"]
                #[inline(always)]
                pub fn is_medium(&self) -> bool {
                    *self == PL_A::MEDIUM
                }
                #[doc = "Checks if the value of the field is `HIGH`"]
                #[inline(always)]
                pub fn is_high(&self) -> bool {
                    *self == PL_A::HIGH
                }
                #[doc = "Checks if the value of the field is `VERYHIGH`"]
                #[inline(always)]
                pub fn is_very_high(&self) -> bool {
                    *self == PL_A::VERYHIGH
                }
            }
            #[doc = "Write proxy for field `PL`"]
            pub struct PL_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PL_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PL_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Low priority"]
                #[inline(always)]
                pub fn low(self) -> &'a mut W {
                    self.variant(PL_A::LOW)
                }
                #[doc = "Medium priority"]
                #[inline(always)]
                pub fn medium(self) -> &'a mut W {
                    self.variant(PL_A::MEDIUM)
                }
                #[doc = "High priority"]
                #[inline(always)]
                pub fn high(self) -> &'a mut W {
                    self.variant(PL_A::HIGH)
                }
                #[doc = "Very high priority"]
                #[inline(always)]
                pub fn very_high(self) -> &'a mut W {
                    self.variant(PL_A::VERYHIGH)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                    self.w
                }
            }
            #[doc = "Memory to memory mode\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MEM2MEM_A {
                #[doc = "0: Memory to memory mode disabled"]
                DISABLED = 0,
                #[doc = "1: Memory to memory mode enabled"]
                ENABLED = 1,
            }
            impl From<MEM2MEM_A> for bool {
                #[inline(always)]
                fn from(variant: MEM2MEM_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `MEM2MEM`"]
            pub type MEM2MEM_R = crate::R<bool, MEM2MEM_A>;
            impl MEM2MEM_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> MEM2MEM_A {
                    match self.bits {
                        false => MEM2MEM_A::DISABLED,
                        true => MEM2MEM_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == MEM2MEM_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == MEM2MEM_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `MEM2MEM`"]
            pub struct MEM2MEM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MEM2MEM_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MEM2MEM_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Memory to memory mode disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MEM2MEM_A::DISABLED)
                }
                #[doc = "Memory to memory mode enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MEM2MEM_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Channel enable"]
                #[inline(always)]
                pub fn en(&self) -> EN_R {
                    EN_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Transfer complete interrupt enable"]
                #[inline(always)]
                pub fn tcie(&self) -> TCIE_R {
                    TCIE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 2 - Half Transfer interrupt enable"]
                #[inline(always)]
                pub fn htie(&self) -> HTIE_R {
                    HTIE_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Transfer error interrupt enable"]
                #[inline(always)]
                pub fn teie(&self) -> TEIE_R {
                    TEIE_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Data transfer direction"]
                #[inline(always)]
                pub fn dir(&self) -> DIR_R {
                    DIR_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Circular mode"]
                #[inline(always)]
                pub fn circ(&self) -> CIRC_R {
                    CIRC_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Peripheral increment mode"]
                #[inline(always)]
                pub fn pinc(&self) -> PINC_R {
                    PINC_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bit 7 - Memory increment mode"]
                #[inline(always)]
                pub fn minc(&self) -> MINC_R {
                    MINC_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                #[doc = "Bits 8:9 - Peripheral size"]
                #[inline(always)]
                pub fn psize(&self) -> PSIZE_R {
                    PSIZE_R::new(((self.bits >> 8) & 0x03) as u8)
                }
                #[doc = "Bits 10:11 - Memory size"]
                #[inline(always)]
                pub fn msize(&self) -> MSIZE_R {
                    MSIZE_R::new(((self.bits >> 10) & 0x03) as u8)
                }
                #[doc = "Bits 12:13 - Channel Priority level"]
                #[inline(always)]
                pub fn pl(&self) -> PL_R {
                    PL_R::new(((self.bits >> 12) & 0x03) as u8)
                }
                #[doc = "Bit 14 - Memory to memory mode"]
                #[inline(always)]
                pub fn mem2mem(&self) -> MEM2MEM_R {
                    MEM2MEM_R::new(((self.bits >> 14) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Channel enable"]
                #[inline(always)]
                pub fn en(&mut self) -> EN_W {
                    EN_W { w: self }
                }
                #[doc = "Bit 1 - Transfer complete interrupt enable"]
                #[inline(always)]
                pub fn tcie(&mut self) -> TCIE_W {
                    TCIE_W { w: self }
                }
                #[doc = "Bit 2 - Half Transfer interrupt enable"]
                #[inline(always)]
                pub fn htie(&mut self) -> HTIE_W {
                    HTIE_W { w: self }
                }
                #[doc = "Bit 3 - Transfer error interrupt enable"]
                #[inline(always)]
                pub fn teie(&mut self) -> TEIE_W {
                    TEIE_W { w: self }
                }
                #[doc = "Bit 4 - Data transfer direction"]
                #[inline(always)]
                pub fn dir(&mut self) -> DIR_W {
                    DIR_W { w: self }
                }
                #[doc = "Bit 5 - Circular mode"]
                #[inline(always)]
                pub fn circ(&mut self) -> CIRC_W {
                    CIRC_W { w: self }
                }
                #[doc = "Bit 6 - Peripheral increment mode"]
                #[inline(always)]
                pub fn pinc(&mut self) -> PINC_W {
                    PINC_W { w: self }
                }
                #[doc = "Bit 7 - Memory increment mode"]
                #[inline(always)]
                pub fn minc(&mut self) -> MINC_W {
                    MINC_W { w: self }
                }
                #[doc = "Bits 8:9 - Peripheral size"]
                #[inline(always)]
                pub fn psize(&mut self) -> PSIZE_W {
                    PSIZE_W { w: self }
                }
                #[doc = "Bits 10:11 - Memory size"]
                #[inline(always)]
                pub fn msize(&mut self) -> MSIZE_W {
                    MSIZE_W { w: self }
                }
                #[doc = "Bits 12:13 - Channel Priority level"]
                #[inline(always)]
                pub fn pl(&mut self) -> PL_W {
                    PL_W { w: self }
                }
                #[doc = "Bit 14 - Memory to memory mode"]
                #[inline(always)]
                pub fn mem2mem(&mut self) -> MEM2MEM_W {
                    MEM2MEM_W { w: self }
                }
            }
        }
        #[doc = "DMA channel 1 number of data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ndtr](ndtr) module"]
        pub type NDTR = crate::Reg<u32, _NDTR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _NDTR;
        #[doc = "`read()` method returns [ndtr::R](ndtr::R) reader structure"]
        impl crate::Readable for NDTR {}
        #[doc = "`write(|w| ..)` method takes [ndtr::W](ndtr::W) writer structure"]
        impl crate::Writable for NDTR {}
        #[doc = "DMA channel 1 number of data register"]
        pub mod ndtr {
            #[doc = "Reader of register NDTR"]
            pub type R = crate::R<u32, super::NDTR>;
            #[doc = "Writer for register NDTR"]
            pub type W = crate::W<u32, super::NDTR>;
            #[doc = "Register NDTR `reset()`'s with value 0"]
            impl crate::ResetValue for super::NDTR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `NDT`"]
            pub type NDT_R = crate::R<u16, u16>;
            #[doc = "Write proxy for field `NDT`"]
            pub struct NDT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> NDT_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u16) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:15 - Number of data to transfer"]
                #[inline(always)]
                pub fn ndt(&self) -> NDT_R {
                    NDT_R::new((self.bits & 0xffff) as u16)
                }
            }
            impl W {
                #[doc = "Bits 0:15 - Number of data to transfer"]
                #[inline(always)]
                pub fn ndt(&mut self) -> NDT_W {
                    NDT_W { w: self }
                }
            }
        }
        #[doc = "DMA channel 1 peripheral address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [par](par) module"]
        pub type PAR = crate::Reg<u32, _PAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _PAR;
        #[doc = "`read()` method returns [par::R](par::R) reader structure"]
        impl crate::Readable for PAR {}
        #[doc = "`write(|w| ..)` method takes [par::W](par::W) writer structure"]
        impl crate::Writable for PAR {}
        #[doc = "DMA channel 1 peripheral address register"]
        pub mod par {
            #[doc = "Reader of register PAR"]
            pub type R = crate::R<u32, super::PAR>;
            #[doc = "Writer for register PAR"]
            pub type W = crate::W<u32, super::PAR>;
            #[doc = "Register PAR `reset()`'s with value 0"]
            impl crate::ResetValue for super::PAR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `PA`"]
            pub type PA_R = crate::R<u32, u32>;
            #[doc = "Write proxy for field `PA`"]
            pub struct PA_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PA_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:31 - Peripheral address"]
                #[inline(always)]
                pub fn pa(&self) -> PA_R {
                    PA_R::new((self.bits & 0xffff_ffff) as u32)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - Peripheral address"]
                #[inline(always)]
                pub fn pa(&mut self) -> PA_W {
                    PA_W { w: self }
                }
            }
        }
        #[doc = "DMA channel 1 memory address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mar](mar) module"]
        pub type MAR = crate::Reg<u32, _MAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _MAR;
        #[doc = "`read()` method returns [mar::R](mar::R) reader structure"]
        impl crate::Readable for MAR {}
        #[doc = "`write(|w| ..)` method takes [mar::W](mar::W) writer structure"]
        impl crate::Writable for MAR {}
        #[doc = "DMA channel 1 memory address register"]
        pub mod mar {
            #[doc = "Reader of register MAR"]
            pub type R = crate::R<u32, super::MAR>;
            #[doc = "Writer for register MAR"]
            pub type W = crate::W<u32, super::MAR>;
            #[doc = "Register MAR `reset()`'s with value 0"]
            impl crate::ResetValue for super::MAR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `MA`"]
            pub type MA_R = crate::R<u32, u32>;
            #[doc = "Write proxy for field `MA`"]
            pub struct MA_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MA_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:31 - Memory address"]
                #[inline(always)]
                pub fn ma(&self) -> MA_R {
                    MA_R::new((self.bits & 0xffff_ffff) as u32)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - Memory address"]
                #[inline(always)]
                pub fn ma(&mut self) -> MA_W {
                    MA_W { w: self }
                }
            }
        }
    }
    #[doc = "DMA interrupt status register (DMA_ISR)\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "DMA interrupt status register (DMA_ISR)"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Channel 1 Global interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GIF1_A {
            #[doc = "0: No transfer error, half event, complete event"]
            NOEVENT = 0,
            #[doc = "1: A transfer error, half event or complete event has occured"]
            EVENT = 1,
        }
        impl From<GIF1_A> for bool {
            #[inline(always)]
            fn from(variant: GIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `GIF1`"]
        pub type GIF1_R = crate::R<bool, GIF1_A>;
        impl GIF1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> GIF1_A {
                match self.bits {
                    false => GIF1_A::NOEVENT,
                    true => GIF1_A::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == GIF1_A::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                *self == GIF1_A::EVENT
            }
        }
        #[doc = "Channel 1 Transfer Complete flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIF1_A {
            #[doc = "0: No transfer complete event"]
            NOTCOMPLETE = 0,
            #[doc = "1: A transfer complete event has occured"]
            COMPLETE = 1,
        }
        impl From<TCIF1_A> for bool {
            #[inline(always)]
            fn from(variant: TCIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIF1`"]
        pub type TCIF1_R = crate::R<bool, TCIF1_A>;
        impl TCIF1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIF1_A {
                match self.bits {
                    false => TCIF1_A::NOTCOMPLETE,
                    true => TCIF1_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == TCIF1_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == TCIF1_A::COMPLETE
            }
        }
        #[doc = "Channel 1 Half Transfer Complete flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HTIF1_A {
            #[doc = "0: No half transfer event"]
            NOTHALF = 0,
            #[doc = "1: A half transfer event has occured"]
            HALF = 1,
        }
        impl From<HTIF1_A> for bool {
            #[inline(always)]
            fn from(variant: HTIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HTIF1`"]
        pub type HTIF1_R = crate::R<bool, HTIF1_A>;
        impl HTIF1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HTIF1_A {
                match self.bits {
                    false => HTIF1_A::NOTHALF,
                    true => HTIF1_A::HALF,
                }
            }
            #[doc = "Checks if the value of the field is `NOTHALF`"]
            #[inline(always)]
            pub fn is_not_half(&self) -> bool {
                *self == HTIF1_A::NOTHALF
            }
            #[doc = "Checks if the value of the field is `HALF`"]
            #[inline(always)]
            pub fn is_half(&self) -> bool {
                *self == HTIF1_A::HALF
            }
        }
        #[doc = "Channel 1 Transfer Error flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEIF1_A {
            #[doc = "0: No transfer error"]
            NOERROR = 0,
            #[doc = "1: A transfer error has occured"]
            ERROR = 1,
        }
        impl From<TEIF1_A> for bool {
            #[inline(always)]
            fn from(variant: TEIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TEIF1`"]
        pub type TEIF1_R = crate::R<bool, TEIF1_A>;
        impl TEIF1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TEIF1_A {
                match self.bits {
                    false => TEIF1_A::NOERROR,
                    true => TEIF1_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == TEIF1_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == TEIF1_A::ERROR
            }
        }
        #[doc = "Channel 2 Global interrupt flag"]
        pub type GIF2_A = GIF1_A;
        #[doc = "Reader of field `GIF2`"]
        pub type GIF2_R = crate::R<bool, GIF1_A>;
        #[doc = "Channel 2 Transfer Complete flag"]
        pub type TCIF2_A = TCIF1_A;
        #[doc = "Reader of field `TCIF2`"]
        pub type TCIF2_R = crate::R<bool, TCIF1_A>;
        #[doc = "Channel 2 Half Transfer Complete flag"]
        pub type HTIF2_A = HTIF1_A;
        #[doc = "Reader of field `HTIF2`"]
        pub type HTIF2_R = crate::R<bool, HTIF1_A>;
        #[doc = "Channel 2 Transfer Error flag"]
        pub type TEIF2_A = TEIF1_A;
        #[doc = "Reader of field `TEIF2`"]
        pub type TEIF2_R = crate::R<bool, TEIF1_A>;
        #[doc = "Channel 3 Global interrupt flag"]
        pub type GIF3_A = GIF1_A;
        #[doc = "Reader of field `GIF3`"]
        pub type GIF3_R = crate::R<bool, GIF1_A>;
        #[doc = "Channel 3 Transfer Complete flag"]
        pub type TCIF3_A = TCIF1_A;
        #[doc = "Reader of field `TCIF3`"]
        pub type TCIF3_R = crate::R<bool, TCIF1_A>;
        #[doc = "Channel 3 Half Transfer Complete flag"]
        pub type HTIF3_A = HTIF1_A;
        #[doc = "Reader of field `HTIF3`"]
        pub type HTIF3_R = crate::R<bool, HTIF1_A>;
        #[doc = "Channel 3 Transfer Error flag"]
        pub type TEIF3_A = TEIF1_A;
        #[doc = "Reader of field `TEIF3`"]
        pub type TEIF3_R = crate::R<bool, TEIF1_A>;
        #[doc = "Channel 4 Global interrupt flag"]
        pub type GIF4_A = GIF1_A;
        #[doc = "Reader of field `GIF4`"]
        pub type GIF4_R = crate::R<bool, GIF1_A>;
        #[doc = "Channel 4 Transfer Complete flag"]
        pub type TCIF4_A = TCIF1_A;
        #[doc = "Reader of field `TCIF4`"]
        pub type TCIF4_R = crate::R<bool, TCIF1_A>;
        #[doc = "Channel 4 Half Transfer Complete flag"]
        pub type HTIF4_A = HTIF1_A;
        #[doc = "Reader of field `HTIF4`"]
        pub type HTIF4_R = crate::R<bool, HTIF1_A>;
        #[doc = "Channel 4 Transfer Error flag"]
        pub type TEIF4_A = TEIF1_A;
        #[doc = "Reader of field `TEIF4`"]
        pub type TEIF4_R = crate::R<bool, TEIF1_A>;
        #[doc = "Channel 5 Global interrupt flag"]
        pub type GIF5_A = GIF1_A;
        #[doc = "Reader of field `GIF5`"]
        pub type GIF5_R = crate::R<bool, GIF1_A>;
        #[doc = "Channel 5 Transfer Complete flag"]
        pub type TCIF5_A = TCIF1_A;
        #[doc = "Reader of field `TCIF5`"]
        pub type TCIF5_R = crate::R<bool, TCIF1_A>;
        #[doc = "Channel 5 Half Transfer Complete flag"]
        pub type HTIF5_A = HTIF1_A;
        #[doc = "Reader of field `HTIF5`"]
        pub type HTIF5_R = crate::R<bool, HTIF1_A>;
        #[doc = "Channel 5 Transfer Error flag"]
        pub type TEIF5_A = TEIF1_A;
        #[doc = "Reader of field `TEIF5`"]
        pub type TEIF5_R = crate::R<bool, TEIF1_A>;
        #[doc = "Channel 6 Global interrupt flag"]
        pub type GIF6_A = GIF1_A;
        #[doc = "Reader of field `GIF6`"]
        pub type GIF6_R = crate::R<bool, GIF1_A>;
        #[doc = "Channel 6 Transfer Complete flag"]
        pub type TCIF6_A = TCIF1_A;
        #[doc = "Reader of field `TCIF6`"]
        pub type TCIF6_R = crate::R<bool, TCIF1_A>;
        #[doc = "Channel 6 Half Transfer Complete flag"]
        pub type HTIF6_A = HTIF1_A;
        #[doc = "Reader of field `HTIF6`"]
        pub type HTIF6_R = crate::R<bool, HTIF1_A>;
        #[doc = "Channel 6 Transfer Error flag"]
        pub type TEIF6_A = TEIF1_A;
        #[doc = "Reader of field `TEIF6`"]
        pub type TEIF6_R = crate::R<bool, TEIF1_A>;
        #[doc = "Channel 7 Global interrupt flag"]
        pub type GIF7_A = GIF1_A;
        #[doc = "Reader of field `GIF7`"]
        pub type GIF7_R = crate::R<bool, GIF1_A>;
        #[doc = "Channel 7 Transfer Complete flag"]
        pub type TCIF7_A = TCIF1_A;
        #[doc = "Reader of field `TCIF7`"]
        pub type TCIF7_R = crate::R<bool, TCIF1_A>;
        #[doc = "Channel 7 Half Transfer Complete flag"]
        pub type HTIF7_A = HTIF1_A;
        #[doc = "Reader of field `HTIF7`"]
        pub type HTIF7_R = crate::R<bool, HTIF1_A>;
        #[doc = "Channel 7 Transfer Error flag"]
        pub type TEIF7_A = TEIF1_A;
        #[doc = "Reader of field `TEIF7`"]
        pub type TEIF7_R = crate::R<bool, TEIF1_A>;
        impl R {
            #[doc = "Bit 0 - Channel 1 Global interrupt flag"]
            #[inline(always)]
            pub fn gif1(&self) -> GIF1_R {
                GIF1_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Channel 1 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif1(&self) -> TCIF1_R {
                TCIF1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Channel 1 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif1(&self) -> HTIF1_R {
                HTIF1_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Channel 1 Transfer Error flag"]
            #[inline(always)]
            pub fn teif1(&self) -> TEIF1_R {
                TEIF1_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Channel 2 Global interrupt flag"]
            #[inline(always)]
            pub fn gif2(&self) -> GIF2_R {
                GIF2_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Channel 2 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif2(&self) -> TCIF2_R {
                TCIF2_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Channel 2 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif2(&self) -> HTIF2_R {
                HTIF2_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Channel 2 Transfer Error flag"]
            #[inline(always)]
            pub fn teif2(&self) -> TEIF2_R {
                TEIF2_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Channel 3 Global interrupt flag"]
            #[inline(always)]
            pub fn gif3(&self) -> GIF3_R {
                GIF3_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Channel 3 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif3(&self) -> TCIF3_R {
                TCIF3_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Channel 3 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif3(&self) -> HTIF3_R {
                HTIF3_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Channel 3 Transfer Error flag"]
            #[inline(always)]
            pub fn teif3(&self) -> TEIF3_R {
                TEIF3_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Channel 4 Global interrupt flag"]
            #[inline(always)]
            pub fn gif4(&self) -> GIF4_R {
                GIF4_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Channel 4 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif4(&self) -> TCIF4_R {
                TCIF4_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Channel 4 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif4(&self) -> HTIF4_R {
                HTIF4_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Channel 4 Transfer Error flag"]
            #[inline(always)]
            pub fn teif4(&self) -> TEIF4_R {
                TEIF4_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Channel 5 Global interrupt flag"]
            #[inline(always)]
            pub fn gif5(&self) -> GIF5_R {
                GIF5_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Channel 5 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif5(&self) -> TCIF5_R {
                TCIF5_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Channel 5 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif5(&self) -> HTIF5_R {
                HTIF5_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Channel 5 Transfer Error flag"]
            #[inline(always)]
            pub fn teif5(&self) -> TEIF5_R {
                TEIF5_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Channel 6 Global interrupt flag"]
            #[inline(always)]
            pub fn gif6(&self) -> GIF6_R {
                GIF6_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Channel 6 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif6(&self) -> TCIF6_R {
                TCIF6_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Channel 6 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif6(&self) -> HTIF6_R {
                HTIF6_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Channel 6 Transfer Error flag"]
            #[inline(always)]
            pub fn teif6(&self) -> TEIF6_R {
                TEIF6_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Channel 7 Global interrupt flag"]
            #[inline(always)]
            pub fn gif7(&self) -> GIF7_R {
                GIF7_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Channel 7 Transfer Complete flag"]
            #[inline(always)]
            pub fn tcif7(&self) -> TCIF7_R {
                TCIF7_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26 - Channel 7 Half Transfer Complete flag"]
            #[inline(always)]
            pub fn htif7(&self) -> HTIF7_R {
                HTIF7_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27 - Channel 7 Transfer Error flag"]
            #[inline(always)]
            pub fn teif7(&self) -> TEIF7_R {
                TEIF7_R::new(((self.bits >> 27) & 0x01) != 0)
            }
        }
    }
    #[doc = "DMA interrupt flag clear register (DMA_IFCR)\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ifcr](ifcr) module"]
    pub type IFCR = crate::Reg<u32, _IFCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IFCR;
    #[doc = "`write(|w| ..)` method takes [ifcr::W](ifcr::W) writer structure"]
    impl crate::Writable for IFCR {}
    #[doc = "DMA interrupt flag clear register (DMA_IFCR)"]
    pub mod ifcr {
        #[doc = "Writer for register IFCR"]
        pub type W = crate::W<u32, super::IFCR>;
        #[doc = "Register IFCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IFCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Channel 1 Global interrupt clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CGIF1_AW {
            #[doc = "1: Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            CLEAR = 1,
        }
        impl From<CGIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CGIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CGIF1`"]
        pub struct CGIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Channel 2 Global interrupt clear"]
        pub type CGIF2_AW = CGIF1_AW;
        #[doc = "Write proxy for field `CGIF2`"]
        pub struct CGIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Channel 3 Global interrupt clear"]
        pub type CGIF3_AW = CGIF1_AW;
        #[doc = "Write proxy for field `CGIF3`"]
        pub struct CGIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Channel 4 Global interrupt clear"]
        pub type CGIF4_AW = CGIF1_AW;
        #[doc = "Write proxy for field `CGIF4`"]
        pub struct CGIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Channel 5 Global interrupt clear"]
        pub type CGIF5_AW = CGIF1_AW;
        #[doc = "Write proxy for field `CGIF5`"]
        pub struct CGIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Channel 6 Global interrupt clear"]
        pub type CGIF6_AW = CGIF1_AW;
        #[doc = "Write proxy for field `CGIF6`"]
        pub struct CGIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Channel 7 Global interrupt clear"]
        pub type CGIF7_AW = CGIF1_AW;
        #[doc = "Write proxy for field `CGIF7`"]
        pub struct CGIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Channel 1 Transfer Complete clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTCIF1_AW {
            #[doc = "1: Clears the TCIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CTCIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CTCIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTCIF1`"]
        pub struct CTCIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Channel 2 Transfer Complete clear"]
        pub type CTCIF2_AW = CTCIF1_AW;
        #[doc = "Write proxy for field `CTCIF2`"]
        pub struct CTCIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Channel 3 Transfer Complete clear"]
        pub type CTCIF3_AW = CTCIF1_AW;
        #[doc = "Write proxy for field `CTCIF3`"]
        pub struct CTCIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Channel 4 Transfer Complete clear"]
        pub type CTCIF4_AW = CTCIF1_AW;
        #[doc = "Write proxy for field `CTCIF4`"]
        pub struct CTCIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Channel 5 Transfer Complete clear"]
        pub type CTCIF5_AW = CTCIF1_AW;
        #[doc = "Write proxy for field `CTCIF5`"]
        pub struct CTCIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Channel 6 Transfer Complete clear"]
        pub type CTCIF6_AW = CTCIF1_AW;
        #[doc = "Write proxy for field `CTCIF6`"]
        pub struct CTCIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Channel 7 Transfer Complete clear"]
        pub type CTCIF7_AW = CTCIF1_AW;
        #[doc = "Write proxy for field `CTCIF7`"]
        pub struct CTCIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Channel 1 Half Transfer clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHTIF1_AW {
            #[doc = "1: Clears the HTIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CHTIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CHTIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CHTIF1`"]
        pub struct CHTIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Channel 2 Half Transfer clear"]
        pub type CHTIF2_AW = CHTIF1_AW;
        #[doc = "Write proxy for field `CHTIF2`"]
        pub struct CHTIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Channel 3 Half Transfer clear"]
        pub type CHTIF3_AW = CHTIF1_AW;
        #[doc = "Write proxy for field `CHTIF3`"]
        pub struct CHTIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Channel 4 Half Transfer clear"]
        pub type CHTIF4_AW = CHTIF1_AW;
        #[doc = "Write proxy for field `CHTIF4`"]
        pub struct CHTIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Channel 5 Half Transfer clear"]
        pub type CHTIF5_AW = CHTIF1_AW;
        #[doc = "Write proxy for field `CHTIF5`"]
        pub struct CHTIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Channel 6 Half Transfer clear"]
        pub type CHTIF6_AW = CHTIF1_AW;
        #[doc = "Write proxy for field `CHTIF6`"]
        pub struct CHTIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Channel 7 Half Transfer clear"]
        pub type CHTIF7_AW = CHTIF1_AW;
        #[doc = "Write proxy for field `CHTIF7`"]
        pub struct CHTIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Channel 1 Transfer Error clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTEIF1_AW {
            #[doc = "1: Clears the TEIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CTEIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CTEIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTEIF1`"]
        pub struct CTEIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Channel 2 Transfer Error clear"]
        pub type CTEIF2_AW = CTEIF1_AW;
        #[doc = "Write proxy for field `CTEIF2`"]
        pub struct CTEIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Channel 3 Transfer Error clear"]
        pub type CTEIF3_AW = CTEIF1_AW;
        #[doc = "Write proxy for field `CTEIF3`"]
        pub struct CTEIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Channel 4 Transfer Error clear"]
        pub type CTEIF4_AW = CTEIF1_AW;
        #[doc = "Write proxy for field `CTEIF4`"]
        pub struct CTEIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Channel 5 Transfer Error clear"]
        pub type CTEIF5_AW = CTEIF1_AW;
        #[doc = "Write proxy for field `CTEIF5`"]
        pub struct CTEIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Channel 6 Transfer Error clear"]
        pub type CTEIF6_AW = CTEIF1_AW;
        #[doc = "Write proxy for field `CTEIF6`"]
        pub struct CTEIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Channel 7 Transfer Error clear"]
        pub type CTEIF7_AW = CTEIF1_AW;
        #[doc = "Write proxy for field `CTEIF7`"]
        pub struct CTEIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - Channel 1 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif1(&mut self) -> CGIF1_W {
                CGIF1_W { w: self }
            }
            #[doc = "Bit 4 - Channel 2 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif2(&mut self) -> CGIF2_W {
                CGIF2_W { w: self }
            }
            #[doc = "Bit 8 - Channel 3 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif3(&mut self) -> CGIF3_W {
                CGIF3_W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif4(&mut self) -> CGIF4_W {
                CGIF4_W { w: self }
            }
            #[doc = "Bit 16 - Channel 5 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif5(&mut self) -> CGIF5_W {
                CGIF5_W { w: self }
            }
            #[doc = "Bit 20 - Channel 6 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif6(&mut self) -> CGIF6_W {
                CGIF6_W { w: self }
            }
            #[doc = "Bit 24 - Channel 7 Global interrupt clear"]
            #[inline(always)]
            pub fn cgif7(&mut self) -> CGIF7_W {
                CGIF7_W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif1(&mut self) -> CTCIF1_W {
                CTCIF1_W { w: self }
            }
            #[doc = "Bit 5 - Channel 2 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif2(&mut self) -> CTCIF2_W {
                CTCIF2_W { w: self }
            }
            #[doc = "Bit 9 - Channel 3 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif3(&mut self) -> CTCIF3_W {
                CTCIF3_W { w: self }
            }
            #[doc = "Bit 13 - Channel 4 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif4(&mut self) -> CTCIF4_W {
                CTCIF4_W { w: self }
            }
            #[doc = "Bit 17 - Channel 5 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif5(&mut self) -> CTCIF5_W {
                CTCIF5_W { w: self }
            }
            #[doc = "Bit 21 - Channel 6 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif6(&mut self) -> CTCIF6_W {
                CTCIF6_W { w: self }
            }
            #[doc = "Bit 25 - Channel 7 Transfer Complete clear"]
            #[inline(always)]
            pub fn ctcif7(&mut self) -> CTCIF7_W {
                CTCIF7_W { w: self }
            }
            #[doc = "Bit 2 - Channel 1 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif1(&mut self) -> CHTIF1_W {
                CHTIF1_W { w: self }
            }
            #[doc = "Bit 6 - Channel 2 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif2(&mut self) -> CHTIF2_W {
                CHTIF2_W { w: self }
            }
            #[doc = "Bit 10 - Channel 3 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif3(&mut self) -> CHTIF3_W {
                CHTIF3_W { w: self }
            }
            #[doc = "Bit 14 - Channel 4 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif4(&mut self) -> CHTIF4_W {
                CHTIF4_W { w: self }
            }
            #[doc = "Bit 18 - Channel 5 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif5(&mut self) -> CHTIF5_W {
                CHTIF5_W { w: self }
            }
            #[doc = "Bit 22 - Channel 6 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif6(&mut self) -> CHTIF6_W {
                CHTIF6_W { w: self }
            }
            #[doc = "Bit 26 - Channel 7 Half Transfer clear"]
            #[inline(always)]
            pub fn chtif7(&mut self) -> CHTIF7_W {
                CHTIF7_W { w: self }
            }
            #[doc = "Bit 3 - Channel 1 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif1(&mut self) -> CTEIF1_W {
                CTEIF1_W { w: self }
            }
            #[doc = "Bit 7 - Channel 2 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif2(&mut self) -> CTEIF2_W {
                CTEIF2_W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif3(&mut self) -> CTEIF3_W {
                CTEIF3_W { w: self }
            }
            #[doc = "Bit 15 - Channel 4 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif4(&mut self) -> CTEIF4_W {
                CTEIF4_W { w: self }
            }
            #[doc = "Bit 19 - Channel 5 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif5(&mut self) -> CTEIF5_W {
                CTEIF5_W { w: self }
            }
            #[doc = "Bit 23 - Channel 6 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif6(&mut self) -> CTEIF6_W {
                CTEIF6_W { w: self }
            }
            #[doc = "Bit 27 - Channel 7 Transfer Error clear"]
            #[inline(always)]
            pub fn cteif7(&mut self) -> CTEIF7_W {
                CTEIF7_W { w: self }
            }
        }
    }
}
#[doc = "DMA controller"]
pub struct DMA2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA2 {}
impl DMA2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma1::RegisterBlock {
        0x4002_0400 as *const _
    }
}
impl Deref for DMA2 {
    type Target = dma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DMA2::ptr() }
    }
}
#[doc = "Real time clock"]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        0x4000_2800 as *const _
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*RTC::ptr() }
    }
}
#[doc = "Real time clock"]
pub mod rtc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - RTC Control Register High"]
        pub crh: CRH,
        #[doc = "0x04 - RTC Control Register Low"]
        pub crl: CRL,
        #[doc = "0x08 - RTC Prescaler Load Register High"]
        pub prlh: PRLH,
        #[doc = "0x0c - RTC Prescaler Load Register Low"]
        pub prll: PRLL,
        #[doc = "0x10 - RTC Prescaler Divider Register High"]
        pub divh: DIVH,
        #[doc = "0x14 - RTC Prescaler Divider Register Low"]
        pub divl: DIVL,
        #[doc = "0x18 - RTC Counter Register High"]
        pub cnth: CNTH,
        #[doc = "0x1c - RTC Counter Register Low"]
        pub cntl: CNTL,
        #[doc = "0x20 - RTC Alarm Register High"]
        pub alrh: ALRH,
        #[doc = "0x24 - RTC Alarm Register Low"]
        pub alrl: ALRL,
    }
    #[doc = "RTC Control Register High\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crh](crh) module"]
    pub type CRH = crate::Reg<u32, _CRH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRH;
    #[doc = "`read()` method returns [crh::R](crh::R) reader structure"]
    impl crate::Readable for CRH {}
    #[doc = "`write(|w| ..)` method takes [crh::W](crh::W) writer structure"]
    impl crate::Writable for CRH {}
    #[doc = "RTC Control Register High"]
    pub mod crh {
        #[doc = "Reader of register CRH"]
        pub type R = crate::R<u32, super::CRH>;
        #[doc = "Writer for register CRH"]
        pub type W = crate::W<u32, super::CRH>;
        #[doc = "Register CRH `reset()`'s with value 0"]
        impl crate::ResetValue for super::CRH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `SECIE`"]
        pub type SECIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `SECIE`"]
        pub struct SECIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SECIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `ALRIE`"]
        pub type ALRIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ALRIE`"]
        pub struct ALRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `OWIE`"]
        pub type OWIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OWIE`"]
        pub struct OWIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OWIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Second interrupt Enable"]
            #[inline(always)]
            pub fn secie(&self) -> SECIE_R {
                SECIE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Alarm interrupt Enable"]
            #[inline(always)]
            pub fn alrie(&self) -> ALRIE_R {
                ALRIE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Overflow interrupt Enable"]
            #[inline(always)]
            pub fn owie(&self) -> OWIE_R {
                OWIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Second interrupt Enable"]
            #[inline(always)]
            pub fn secie(&mut self) -> SECIE_W {
                SECIE_W { w: self }
            }
            #[doc = "Bit 1 - Alarm interrupt Enable"]
            #[inline(always)]
            pub fn alrie(&mut self) -> ALRIE_W {
                ALRIE_W { w: self }
            }
            #[doc = "Bit 2 - Overflow interrupt Enable"]
            #[inline(always)]
            pub fn owie(&mut self) -> OWIE_W {
                OWIE_W { w: self }
            }
        }
    }
    #[doc = "RTC Control Register Low\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crl](crl) module"]
    pub type CRL = crate::Reg<u32, _CRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRL;
    #[doc = "`read()` method returns [crl::R](crl::R) reader structure"]
    impl crate::Readable for CRL {}
    #[doc = "`write(|w| ..)` method takes [crl::W](crl::W) writer structure"]
    impl crate::Writable for CRL {}
    #[doc = "RTC Control Register Low"]
    pub mod crl {
        #[doc = "Reader of register CRL"]
        pub type R = crate::R<u32, super::CRL>;
        #[doc = "Writer for register CRL"]
        pub type W = crate::W<u32, super::CRL>;
        #[doc = "Register CRL `reset()`'s with value 0x20"]
        impl crate::ResetValue for super::CRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x20
            }
        }
        #[doc = "Reader of field `SECF`"]
        pub type SECF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `SECF`"]
        pub struct SECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SECF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `ALRF`"]
        pub type ALRF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ALRF`"]
        pub struct ALRF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `OWF`"]
        pub type OWF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OWF`"]
        pub struct OWF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OWF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `RSF`"]
        pub type RSF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RSF`"]
        pub struct RSF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CNF`"]
        pub type CNF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CNF`"]
        pub struct CNF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `RTOFF`"]
        pub type RTOFF_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - Second Flag"]
            #[inline(always)]
            pub fn secf(&self) -> SECF_R {
                SECF_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Alarm Flag"]
            #[inline(always)]
            pub fn alrf(&self) -> ALRF_R {
                ALRF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Overflow Flag"]
            #[inline(always)]
            pub fn owf(&self) -> OWF_R {
                OWF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Registers Synchronized Flag"]
            #[inline(always)]
            pub fn rsf(&self) -> RSF_R {
                RSF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Configuration Flag"]
            #[inline(always)]
            pub fn cnf(&self) -> CNF_R {
                CNF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RTC operation OFF"]
            #[inline(always)]
            pub fn rtoff(&self) -> RTOFF_R {
                RTOFF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Second Flag"]
            #[inline(always)]
            pub fn secf(&mut self) -> SECF_W {
                SECF_W { w: self }
            }
            #[doc = "Bit 1 - Alarm Flag"]
            #[inline(always)]
            pub fn alrf(&mut self) -> ALRF_W {
                ALRF_W { w: self }
            }
            #[doc = "Bit 2 - Overflow Flag"]
            #[inline(always)]
            pub fn owf(&mut self) -> OWF_W {
                OWF_W { w: self }
            }
            #[doc = "Bit 3 - Registers Synchronized Flag"]
            #[inline(always)]
            pub fn rsf(&mut self) -> RSF_W {
                RSF_W { w: self }
            }
            #[doc = "Bit 4 - Configuration Flag"]
            #[inline(always)]
            pub fn cnf(&mut self) -> CNF_W {
                CNF_W { w: self }
            }
        }
    }
    #[doc = "RTC Prescaler Load Register High\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prlh](prlh) module"]
    pub type PRLH = crate::Reg<u32, _PRLH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRLH;
    #[doc = "`write(|w| ..)` method takes [prlh::W](prlh::W) writer structure"]
    impl crate::Writable for PRLH {}
    #[doc = "RTC Prescaler Load Register High"]
    pub mod prlh {
        #[doc = "Writer for register PRLH"]
        pub type W = crate::W<u32, super::PRLH>;
        #[doc = "Register PRLH `reset()`'s with value 0"]
        impl crate::ResetValue for super::PRLH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `PRLH`"]
        pub struct PRLH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRLH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:3 - RTC Prescaler Load Register High"]
            #[inline(always)]
            pub fn prlh(&mut self) -> PRLH_W {
                PRLH_W { w: self }
            }
        }
    }
    #[doc = "RTC Prescaler Load Register Low\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prll](prll) module"]
    pub type PRLL = crate::Reg<u32, _PRLL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRLL;
    #[doc = "`write(|w| ..)` method takes [prll::W](prll::W) writer structure"]
    impl crate::Writable for PRLL {}
    #[doc = "RTC Prescaler Load Register Low"]
    pub mod prll {
        #[doc = "Writer for register PRLL"]
        pub type W = crate::W<u32, super::PRLL>;
        #[doc = "Register PRLL `reset()`'s with value 0x8000"]
        impl crate::ResetValue for super::PRLL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x8000
            }
        }
        #[doc = "Write proxy for field `PRLL`"]
        pub struct PRLL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRLL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RTC Prescaler Divider Register Low"]
            #[inline(always)]
            pub fn prll(&mut self) -> PRLL_W {
                PRLL_W { w: self }
            }
        }
    }
    #[doc = "RTC Prescaler Divider Register High\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [divh](divh) module"]
    pub type DIVH = crate::Reg<u32, _DIVH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIVH;
    #[doc = "`read()` method returns [divh::R](divh::R) reader structure"]
    impl crate::Readable for DIVH {}
    #[doc = "RTC Prescaler Divider Register High"]
    pub mod divh {
        #[doc = "Reader of register DIVH"]
        pub type R = crate::R<u32, super::DIVH>;
        #[doc = "Reader of field `DIVH`"]
        pub type DIVH_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 0:3 - RTC prescaler divider register high"]
            #[inline(always)]
            pub fn divh(&self) -> DIVH_R {
                DIVH_R::new((self.bits & 0x0f) as u8)
            }
        }
    }
    #[doc = "RTC Prescaler Divider Register Low\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [divl](divl) module"]
    pub type DIVL = crate::Reg<u32, _DIVL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIVL;
    #[doc = "`read()` method returns [divl::R](divl::R) reader structure"]
    impl crate::Readable for DIVL {}
    #[doc = "RTC Prescaler Divider Register Low"]
    pub mod divl {
        #[doc = "Reader of register DIVL"]
        pub type R = crate::R<u32, super::DIVL>;
        #[doc = "Reader of field `DIVL`"]
        pub type DIVL_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RTC prescaler divider register Low"]
            #[inline(always)]
            pub fn divl(&self) -> DIVL_R {
                DIVL_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "RTC Counter Register High\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnth](cnth) module"]
    pub type CNTH = crate::Reg<u32, _CNTH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNTH;
    #[doc = "`read()` method returns [cnth::R](cnth::R) reader structure"]
    impl crate::Readable for CNTH {}
    #[doc = "`write(|w| ..)` method takes [cnth::W](cnth::W) writer structure"]
    impl crate::Writable for CNTH {}
    #[doc = "RTC Counter Register High"]
    pub mod cnth {
        #[doc = "Reader of register CNTH"]
        pub type R = crate::R<u32, super::CNTH>;
        #[doc = "Writer for register CNTH"]
        pub type W = crate::W<u32, super::CNTH>;
        #[doc = "Register CNTH `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNTH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNTH`"]
        pub type CNTH_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNTH`"]
        pub struct CNTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - RTC counter register high"]
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RTC counter register high"]
            #[inline(always)]
            pub fn cnth(&mut self) -> CNTH_W {
                CNTH_W { w: self }
            }
        }
    }
    #[doc = "RTC Counter Register Low\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cntl](cntl) module"]
    pub type CNTL = crate::Reg<u32, _CNTL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNTL;
    #[doc = "`read()` method returns [cntl::R](cntl::R) reader structure"]
    impl crate::Readable for CNTL {}
    #[doc = "`write(|w| ..)` method takes [cntl::W](cntl::W) writer structure"]
    impl crate::Writable for CNTL {}
    #[doc = "RTC Counter Register Low"]
    pub mod cntl {
        #[doc = "Reader of register CNTL"]
        pub type R = crate::R<u32, super::CNTL>;
        #[doc = "Writer for register CNTL"]
        pub type W = crate::W<u32, super::CNTL>;
        #[doc = "Register CNTL `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNTL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNTL`"]
        pub type CNTL_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNTL`"]
        pub struct CNTL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNTL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - RTC counter register Low"]
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RTC counter register Low"]
            #[inline(always)]
            pub fn cntl(&mut self) -> CNTL_W {
                CNTL_W { w: self }
            }
        }
    }
    #[doc = "RTC Alarm Register High\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alrh](alrh) module"]
    pub type ALRH = crate::Reg<u32, _ALRH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALRH;
    #[doc = "`write(|w| ..)` method takes [alrh::W](alrh::W) writer structure"]
    impl crate::Writable for ALRH {}
    #[doc = "RTC Alarm Register High"]
    pub mod alrh {
        #[doc = "Writer for register ALRH"]
        pub type W = crate::W<u32, super::ALRH>;
        #[doc = "Register ALRH `reset()`'s with value 0xffff"]
        impl crate::ResetValue for super::ALRH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff
            }
        }
        #[doc = "Write proxy for field `ALRH`"]
        pub struct ALRH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RTC alarm register high"]
            #[inline(always)]
            pub fn alrh(&mut self) -> ALRH_W {
                ALRH_W { w: self }
            }
        }
    }
    #[doc = "RTC Alarm Register Low\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alrl](alrl) module"]
    pub type ALRL = crate::Reg<u32, _ALRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALRL;
    #[doc = "`write(|w| ..)` method takes [alrl::W](alrl::W) writer structure"]
    impl crate::Writable for ALRL {}
    #[doc = "RTC Alarm Register Low"]
    pub mod alrl {
        #[doc = "Writer for register ALRL"]
        pub type W = crate::W<u32, super::ALRL>;
        #[doc = "Register ALRL `reset()`'s with value 0xffff"]
        impl crate::ResetValue for super::ALRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff
            }
        }
        #[doc = "Write proxy for field `ALRL`"]
        pub struct ALRL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RTC alarm register low"]
            #[inline(always)]
            pub fn alrl(&mut self) -> ALRL_W {
                ALRL_W { w: self }
            }
        }
    }
}
#[doc = "Backup registers"]
pub struct BKP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BKP {}
impl BKP {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bkp::RegisterBlock {
        0x4000_6c04 as *const _
    }
}
impl Deref for BKP {
    type Target = bkp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*BKP::ptr() }
    }
}
#[doc = "Backup registers"]
pub mod bkp {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Backup data register (BKP_DR)"]
        pub dr: [DR; 10],
        #[doc = "0x28 - RTC clock calibration register (BKP_RTCCR)"]
        pub rtccr: RTCCR,
        #[doc = "0x2c - Backup control register (BKP_CR)"]
        pub cr: CR,
        #[doc = "0x30 - BKP_CSR control/status register (BKP_CSR)"]
        pub csr: CSR,
        _reserved4: [u8; 8usize],
        #[doc = "0x3c - Backup data register (BKP_DR)"]
        pub bkp_dr: [BKP_DR; 32],
    }
    #[doc = "Backup data register (BKP_DR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr {
        #[doc = "Reader of register DR%s"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR%s"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `D`"]
        pub type D_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `D`"]
        pub struct D_W<'a> {
            w: &'a mut W,
        }
        impl<'a> D_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Backup data"]
            #[inline(always)]
            pub fn d(&self) -> D_R {
                D_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Backup data"]
            #[inline(always)]
            pub fn d(&mut self) -> D_W {
                D_W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bkp_dr](bkp_dr) module"]
    pub type BKP_DR = crate::Reg<u32, _BKP_DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BKP_DR;
    #[doc = "`read()` method returns [bkp_dr::R](bkp_dr::R) reader structure"]
    impl crate::Readable for BKP_DR {}
    #[doc = "`write(|w| ..)` method takes [bkp_dr::W](bkp_dr::W) writer structure"]
    impl crate::Writable for BKP_DR {}
    #[doc = "Backup data register (BKP_DR)"]
    pub mod bkp_dr {
        #[doc = "Reader of register BKP_DR%s"]
        pub type R = crate::R<u32, super::BKP_DR>;
        #[doc = "Writer for register BKP_DR%s"]
        pub type W = crate::W<u32, super::BKP_DR>;
        #[doc = "Register BKP_DR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::BKP_DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `D`"]
        pub type D_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `D`"]
        pub struct D_W<'a> {
            w: &'a mut W,
        }
        impl<'a> D_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Backup data"]
            #[inline(always)]
            pub fn d(&self) -> D_R {
                D_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Backup data"]
            #[inline(always)]
            pub fn d(&mut self) -> D_W {
                D_W { w: self }
            }
        }
    }
    #[doc = "RTC clock calibration register (BKP_RTCCR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtccr](rtccr) module"]
    pub type RTCCR = crate::Reg<u32, _RTCCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RTCCR;
    #[doc = "`read()` method returns [rtccr::R](rtccr::R) reader structure"]
    impl crate::Readable for RTCCR {}
    #[doc = "`write(|w| ..)` method takes [rtccr::W](rtccr::W) writer structure"]
    impl crate::Writable for RTCCR {}
    #[doc = "RTC clock calibration register (BKP_RTCCR)"]
    pub mod rtccr {
        #[doc = "Reader of register RTCCR"]
        pub type R = crate::R<u32, super::RTCCR>;
        #[doc = "Writer for register RTCCR"]
        pub type W = crate::W<u32, super::RTCCR>;
        #[doc = "Register RTCCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RTCCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CAL`"]
        pub type CAL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CAL`"]
        pub struct CAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CAL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | ((value as u32) & 0x7f);
                self.w
            }
        }
        #[doc = "Reader of field `CCO`"]
        pub type CCO_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CCO`"]
        pub struct CCO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCO_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Alarm or second output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASOE_A {
            #[doc = "0: Disabled"]
            DISABLED = 0,
            #[doc = "1: Setting this bit outputs either the RTC Alarm pulse signal or the Second pulse signal on the TAMPER pin depending on the ASOS bit"]
            ENABLED = 1,
        }
        impl From<ASOE_A> for bool {
            #[inline(always)]
            fn from(variant: ASOE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ASOE`"]
        pub type ASOE_R = crate::R<bool, ASOE_A>;
        impl ASOE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ASOE_A {
                match self.bits {
                    false => ASOE_A::DISABLED,
                    true => ASOE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ASOE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ASOE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ASOE`"]
        pub struct ASOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASOE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ASOE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASOE_A::DISABLED)
            }
            #[doc = "Setting this bit outputs either the RTC Alarm pulse signal or the Second pulse signal on the TAMPER pin depending on the ASOS bit"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASOE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Alarm or second output selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASOS_A {
            #[doc = "0: RTC Alarm pulse output selected"]
            ALARM = 0,
            #[doc = "1: RTC Second pulse output selected"]
            SECOND = 1,
        }
        impl From<ASOS_A> for bool {
            #[inline(always)]
            fn from(variant: ASOS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ASOS`"]
        pub type ASOS_R = crate::R<bool, ASOS_A>;
        impl ASOS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ASOS_A {
                match self.bits {
                    false => ASOS_A::ALARM,
                    true => ASOS_A::SECOND,
                }
            }
            #[doc = "Checks if the value of the field is `ALARM`"]
            #[inline(always)]
            pub fn is_alarm(&self) -> bool {
                *self == ASOS_A::ALARM
            }
            #[doc = "Checks if the value of the field is `SECOND`"]
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == ASOS_A::SECOND
            }
        }
        #[doc = "Write proxy for field `ASOS`"]
        pub struct ASOS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASOS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ASOS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC Alarm pulse output selected"]
            #[inline(always)]
            pub fn alarm(self) -> &'a mut W {
                self.variant(ASOS_A::ALARM)
            }
            #[doc = "RTC Second pulse output selected"]
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(ASOS_A::SECOND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:6 - Calibration value"]
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bit 7 - Calibration Clock Output"]
            #[inline(always)]
            pub fn cco(&self) -> CCO_R {
                CCO_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Alarm or second output enable"]
            #[inline(always)]
            pub fn asoe(&self) -> ASOE_R {
                ASOE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Alarm or second output selection"]
            #[inline(always)]
            pub fn asos(&self) -> ASOS_R {
                ASOS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - Calibration value"]
            #[inline(always)]
            pub fn cal(&mut self) -> CAL_W {
                CAL_W { w: self }
            }
            #[doc = "Bit 7 - Calibration Clock Output"]
            #[inline(always)]
            pub fn cco(&mut self) -> CCO_W {
                CCO_W { w: self }
            }
            #[doc = "Bit 8 - Alarm or second output enable"]
            #[inline(always)]
            pub fn asoe(&mut self) -> ASOE_W {
                ASOE_W { w: self }
            }
            #[doc = "Bit 9 - Alarm or second output selection"]
            #[inline(always)]
            pub fn asos(&mut self) -> ASOS_W {
                ASOS_W { w: self }
            }
        }
    }
    #[doc = "Backup control register (BKP_CR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Backup control register (BKP_CR)"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Tamper pin enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TPE_A {
            #[doc = "0: The TAMPER pin is free for general purpose I/O"]
            GENERAL = 0,
            #[doc = "1: Tamper alternate I/O function is activated"]
            ALTERNATE = 1,
        }
        impl From<TPE_A> for bool {
            #[inline(always)]
            fn from(variant: TPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TPE`"]
        pub type TPE_R = crate::R<bool, TPE_A>;
        impl TPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TPE_A {
                match self.bits {
                    false => TPE_A::GENERAL,
                    true => TPE_A::ALTERNATE,
                }
            }
            #[doc = "Checks if the value of the field is `GENERAL`"]
            #[inline(always)]
            pub fn is_general(&self) -> bool {
                *self == TPE_A::GENERAL
            }
            #[doc = "Checks if the value of the field is `ALTERNATE`"]
            #[inline(always)]
            pub fn is_alternate(&self) -> bool {
                *self == TPE_A::ALTERNATE
            }
        }
        #[doc = "Write proxy for field `TPE`"]
        pub struct TPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TAMPER pin is free for general purpose I/O"]
            #[inline(always)]
            pub fn general(self) -> &'a mut W {
                self.variant(TPE_A::GENERAL)
            }
            #[doc = "Tamper alternate I/O function is activated"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(TPE_A::ALTERNATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Tamper pin active level\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TPAL_A {
            #[doc = "0: A high level on the TAMPER pin resets all data backup registers (if TPE bit is set)"]
            HIGH = 0,
            #[doc = "1: A low level on the TAMPER pin resets all data backup registers (if TPE bit is set)"]
            LOW = 1,
        }
        impl From<TPAL_A> for bool {
            #[inline(always)]
            fn from(variant: TPAL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TPAL`"]
        pub type TPAL_R = crate::R<bool, TPAL_A>;
        impl TPAL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TPAL_A {
                match self.bits {
                    false => TPAL_A::HIGH,
                    true => TPAL_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == TPAL_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == TPAL_A::LOW
            }
        }
        #[doc = "Write proxy for field `TPAL`"]
        pub struct TPAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TPAL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TPAL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "A high level on the TAMPER pin resets all data backup registers (if TPE bit is set)"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(TPAL_A::HIGH)
            }
            #[doc = "A low level on the TAMPER pin resets all data backup registers (if TPE bit is set)"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(TPAL_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Tamper pin enable"]
            #[inline(always)]
            pub fn tpe(&self) -> TPE_R {
                TPE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Tamper pin active level"]
            #[inline(always)]
            pub fn tpal(&self) -> TPAL_R {
                TPAL_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Tamper pin enable"]
            #[inline(always)]
            pub fn tpe(&mut self) -> TPE_W {
                TPE_W { w: self }
            }
            #[doc = "Bit 1 - Tamper pin active level"]
            #[inline(always)]
            pub fn tpal(&mut self) -> TPAL_W {
                TPAL_W { w: self }
            }
        }
    }
    #[doc = "BKP_CSR control/status register (BKP_CSR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
    pub type CSR = crate::Reg<u32, _CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSR;
    #[doc = "`read()` method returns [csr::R](csr::R) reader structure"]
    impl crate::Readable for CSR {}
    #[doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
    impl crate::Writable for CSR {}
    #[doc = "BKP_CSR control/status register (BKP_CSR)"]
    pub mod csr {
        #[doc = "Reader of register CSR"]
        pub type R = crate::R<u32, super::CSR>;
        #[doc = "Writer for register CSR"]
        pub type W = crate::W<u32, super::CSR>;
        #[doc = "Register CSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clear Tamper event\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTE_AW {
            #[doc = "1: Reset the TEF Tamper event flag (and the Tamper detector)"]
            RESET = 1,
        }
        impl From<CTE_AW> for bool {
            #[inline(always)]
            fn from(variant: CTE_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTE`"]
        pub struct CTE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTE_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the TEF Tamper event flag (and the Tamper detector)"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CTE_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Clear Tamper Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTI_AW {
            #[doc = "1: Clear the Tamper interrupt and the TIF Tamper interrupt flag"]
            CLEAR = 1,
        }
        impl From<CTI_AW> for bool {
            #[inline(always)]
            fn from(variant: CTI_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTI`"]
        pub struct CTI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTI_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTI_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the Tamper interrupt and the TIF Tamper interrupt flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTI_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Tamper Pin interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TPIE_A {
            #[doc = "0: Tamper interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Tamper interrupt enabled (the TPE bit must also be set in the BKP_CR register"]
            ENABLED = 1,
        }
        impl From<TPIE_A> for bool {
            #[inline(always)]
            fn from(variant: TPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TPIE`"]
        pub type TPIE_R = crate::R<bool, TPIE_A>;
        impl TPIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TPIE_A {
                match self.bits {
                    false => TPIE_A::DISABLED,
                    true => TPIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TPIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TPIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TPIE`"]
        pub struct TPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TPIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TPIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TPIE_A::DISABLED)
            }
            #[doc = "Tamper interrupt enabled (the TPE bit must also be set in the BKP_CR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TPIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `TEF`"]
        pub type TEF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 2 - Tamper Pin interrupt enable"]
            #[inline(always)]
            pub fn tpie(&self) -> TPIE_R {
                TPIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Tamper Event Flag"]
            #[inline(always)]
            pub fn tef(&self) -> TEF_R {
                TEF_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Tamper Interrupt Flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Clear Tamper event"]
            #[inline(always)]
            pub fn cte(&mut self) -> CTE_W {
                CTE_W { w: self }
            }
            #[doc = "Bit 1 - Clear Tamper Interrupt"]
            #[inline(always)]
            pub fn cti(&mut self) -> CTI_W {
                CTI_W { w: self }
            }
            #[doc = "Bit 2 - Tamper Pin interrupt enable"]
            #[inline(always)]
            pub fn tpie(&mut self) -> TPIE_W {
                TPIE_W { w: self }
            }
        }
    }
}
#[doc = "Independent watchdog"]
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IWDG {}
impl IWDG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iwdg::RegisterBlock {
        0x4000_3000 as *const _
    }
}
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*IWDG::ptr() }
    }
}
#[doc = "Independent watchdog"]
pub mod iwdg {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Key register (IWDG_KR)"]
        pub kr: KR,
        #[doc = "0x04 - Prescaler register (IWDG_PR)"]
        pub pr: PR,
        #[doc = "0x08 - Reload register (IWDG_RLR)"]
        pub rlr: RLR,
        #[doc = "0x0c - Status register (IWDG_SR)"]
        pub sr: SR,
    }
    #[doc = "Key register (IWDG_KR)\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [kr](kr) module"]
    pub type KR = crate::Reg<u32, _KR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KR;
    #[doc = "`write(|w| ..)` method takes [kr::W](kr::W) writer structure"]
    impl crate::Writable for KR {}
    #[doc = "Key register (IWDG_KR)"]
    pub mod kr {
        #[doc = "Writer for register KR"]
        pub type W = crate::W<u32, super::KR>;
        #[doc = "Register KR `reset()`'s with value 0"]
        impl crate::ResetValue for super::KR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Key value\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u16)]
        pub enum KEY_AW {
            #[doc = "21845: Enable access to PR, RLR and WINR registers (0x5555)"]
            ENABLE = 21845,
            #[doc = "43690: Reset the watchdog value (0xAAAA)"]
            RESET = 43690,
            #[doc = "52428: Start the watchdog (0xCCCC)"]
            START = 52428,
        }
        impl From<KEY_AW> for u16 {
            #[inline(always)]
            fn from(variant: KEY_AW) -> Self {
                variant as _
            }
        }
        #[doc = "Write proxy for field `KEY`"]
        pub struct KEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: KEY_AW) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Enable access to PR, RLR and WINR registers (0x5555)"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(KEY_AW::ENABLE)
            }
            #[doc = "Reset the watchdog value (0xAAAA)"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(KEY_AW::RESET)
            }
            #[doc = "Start the watchdog (0xCCCC)"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(KEY_AW::START)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Key value"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W {
                KEY_W { w: self }
            }
        }
    }
    #[doc = "Prescaler register (IWDG_PR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pr](pr) module"]
    pub type PR = crate::Reg<u32, _PR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PR;
    #[doc = "`read()` method returns [pr::R](pr::R) reader structure"]
    impl crate::Readable for PR {}
    #[doc = "`write(|w| ..)` method takes [pr::W](pr::W) writer structure"]
    impl crate::Writable for PR {}
    #[doc = "Prescaler register (IWDG_PR)"]
    pub mod pr {
        #[doc = "Reader of register PR"]
        pub type R = crate::R<u32, super::PR>;
        #[doc = "Writer for register PR"]
        pub type W = crate::W<u32, super::PR>;
        #[doc = "Register PR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Prescaler divider\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PR_A {
            #[doc = "0: Divider /4"]
            DIVIDEBY4 = 0,
            #[doc = "1: Divider /8"]
            DIVIDEBY8 = 1,
            #[doc = "2: Divider /16"]
            DIVIDEBY16 = 2,
            #[doc = "3: Divider /32"]
            DIVIDEBY32 = 3,
            #[doc = "4: Divider /64"]
            DIVIDEBY64 = 4,
            #[doc = "5: Divider /128"]
            DIVIDEBY128 = 5,
            #[doc = "6: Divider /256"]
            DIVIDEBY256 = 6,
            #[doc = "7: Divider /256"]
            DIVIDEBY256BIS = 7,
        }
        impl From<PR_A> for u8 {
            #[inline(always)]
            fn from(variant: PR_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PR`"]
        pub type PR_R = crate::R<u8, PR_A>;
        impl PR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PR_A {
                match self.bits {
                    0 => PR_A::DIVIDEBY4,
                    1 => PR_A::DIVIDEBY8,
                    2 => PR_A::DIVIDEBY16,
                    3 => PR_A::DIVIDEBY32,
                    4 => PR_A::DIVIDEBY64,
                    5 => PR_A::DIVIDEBY128,
                    6 => PR_A::DIVIDEBY256,
                    7 => PR_A::DIVIDEBY256BIS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY4`"]
            #[inline(always)]
            pub fn is_divide_by4(&self) -> bool {
                *self == PR_A::DIVIDEBY4
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY8`"]
            #[inline(always)]
            pub fn is_divide_by8(&self) -> bool {
                *self == PR_A::DIVIDEBY8
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY16`"]
            #[inline(always)]
            pub fn is_divide_by16(&self) -> bool {
                *self == PR_A::DIVIDEBY16
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY32`"]
            #[inline(always)]
            pub fn is_divide_by32(&self) -> bool {
                *self == PR_A::DIVIDEBY32
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY64`"]
            #[inline(always)]
            pub fn is_divide_by64(&self) -> bool {
                *self == PR_A::DIVIDEBY64
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY128`"]
            #[inline(always)]
            pub fn is_divide_by128(&self) -> bool {
                *self == PR_A::DIVIDEBY128
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY256`"]
            #[inline(always)]
            pub fn is_divide_by256(&self) -> bool {
                *self == PR_A::DIVIDEBY256
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY256BIS`"]
            #[inline(always)]
            pub fn is_divide_by256bis(&self) -> bool {
                *self == PR_A::DIVIDEBY256BIS
            }
        }
        #[doc = "Write proxy for field `PR`"]
        pub struct PR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Divider /4"]
            #[inline(always)]
            pub fn divide_by4(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY4)
            }
            #[doc = "Divider /8"]
            #[inline(always)]
            pub fn divide_by8(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY8)
            }
            #[doc = "Divider /16"]
            #[inline(always)]
            pub fn divide_by16(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY16)
            }
            #[doc = "Divider /32"]
            #[inline(always)]
            pub fn divide_by32(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY32)
            }
            #[doc = "Divider /64"]
            #[inline(always)]
            pub fn divide_by64(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY64)
            }
            #[doc = "Divider /128"]
            #[inline(always)]
            pub fn divide_by128(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY128)
            }
            #[doc = "Divider /256"]
            #[inline(always)]
            pub fn divide_by256(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY256)
            }
            #[doc = "Divider /256"]
            #[inline(always)]
            pub fn divide_by256bis(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY256BIS)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline(always)]
            pub fn pr(&self) -> PR_R {
                PR_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline(always)]
            pub fn pr(&mut self) -> PR_W {
                PR_W { w: self }
            }
        }
    }
    #[doc = "Reload register (IWDG_RLR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rlr](rlr) module"]
    pub type RLR = crate::Reg<u32, _RLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RLR;
    #[doc = "`read()` method returns [rlr::R](rlr::R) reader structure"]
    impl crate::Readable for RLR {}
    #[doc = "`write(|w| ..)` method takes [rlr::W](rlr::W) writer structure"]
    impl crate::Writable for RLR {}
    #[doc = "Reload register (IWDG_RLR)"]
    pub mod rlr {
        #[doc = "Reader of register RLR"]
        pub type R = crate::R<u32, super::RLR>;
        #[doc = "Writer for register RLR"]
        pub type W = crate::W<u32, super::RLR>;
        #[doc = "Register RLR `reset()`'s with value 0x0fff"]
        impl crate::ResetValue for super::RLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0fff
            }
        }
        #[doc = "Reader of field `RL`"]
        pub type RL_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `RL`"]
        pub struct RL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline(always)]
            pub fn rl(&self) -> RL_R {
                RL_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline(always)]
            pub fn rl(&mut self) -> RL_W {
                RL_W { w: self }
            }
        }
    }
    #[doc = "Status register (IWDG_SR)\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "Status register (IWDG_SR)"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Reader of field `PVU`"]
        pub type PVU_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RVU`"]
        pub type RVU_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - Watchdog prescaler value update"]
            #[inline(always)]
            pub fn pvu(&self) -> PVU_R {
                PVU_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Watchdog counter reload value update"]
            #[inline(always)]
            pub fn rvu(&self) -> RVU_R {
                RVU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
    }
}
#[doc = "Window watchdog"]
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDG {}
impl WWDG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wwdg::RegisterBlock {
        0x4000_2c00 as *const _
    }
}
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*WWDG::ptr() }
    }
}
#[doc = "Window watchdog"]
pub mod wwdg {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register (WWDG_CR)"]
        pub cr: CR,
        #[doc = "0x04 - Configuration register (WWDG_CFR)"]
        pub cfr: CFR,
        #[doc = "0x08 - Status register (WWDG_SR)"]
        pub sr: SR,
    }
    #[doc = "Control register (WWDG_CR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control register (WWDG_CR)"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0x7f"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x7f
            }
        }
        #[doc = "Reader of field `T`"]
        pub type T_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `T`"]
        pub struct T_W<'a> {
            w: &'a mut W,
        }
        impl<'a> T_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | ((value as u32) & 0x7f);
                self.w
            }
        }
        #[doc = "Activation bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDGA_A {
            #[doc = "0: Watchdog disabled"]
            DISABLED = 0,
            #[doc = "1: Watchdog enabled"]
            ENABLED = 1,
        }
        impl From<WDGA_A> for bool {
            #[inline(always)]
            fn from(variant: WDGA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WDGA`"]
        pub type WDGA_R = crate::R<bool, WDGA_A>;
        impl WDGA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WDGA_A {
                match self.bits {
                    false => WDGA_A::DISABLED,
                    true => WDGA_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WDGA_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WDGA_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WDGA`"]
        pub struct WDGA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDGA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDGA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Watchdog disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WDGA_A::DISABLED)
            }
            #[doc = "Watchdog enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WDGA_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
            #[inline(always)]
            pub fn t(&self) -> T_R {
                T_R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bit 7 - Activation bit"]
            #[inline(always)]
            pub fn wdga(&self) -> WDGA_R {
                WDGA_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
            #[inline(always)]
            pub fn t(&mut self) -> T_W {
                T_W { w: self }
            }
            #[doc = "Bit 7 - Activation bit"]
            #[inline(always)]
            pub fn wdga(&mut self) -> WDGA_W {
                WDGA_W { w: self }
            }
        }
    }
    #[doc = "Configuration register (WWDG_CFR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfr](cfr) module"]
    pub type CFR = crate::Reg<u32, _CFR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFR;
    #[doc = "`read()` method returns [cfr::R](cfr::R) reader structure"]
    impl crate::Readable for CFR {}
    #[doc = "`write(|w| ..)` method takes [cfr::W](cfr::W) writer structure"]
    impl crate::Writable for CFR {}
    #[doc = "Configuration register (WWDG_CFR)"]
    pub mod cfr {
        #[doc = "Reader of register CFR"]
        pub type R = crate::R<u32, super::CFR>;
        #[doc = "Writer for register CFR"]
        pub type W = crate::W<u32, super::CFR>;
        #[doc = "Register CFR `reset()`'s with value 0x7f"]
        impl crate::ResetValue for super::CFR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x7f
            }
        }
        #[doc = "Reader of field `W`"]
        pub type W_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `W`"]
        pub struct W_W<'a> {
            w: &'a mut W,
        }
        impl<'a> W_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | ((value as u32) & 0x7f);
                self.w
            }
        }
        #[doc = "Early Wakeup Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWI_A {
            #[doc = "1: interrupt occurs whenever the counter reaches the value 0x40"]
            ENABLE = 1,
        }
        impl From<EWI_A> for bool {
            #[inline(always)]
            fn from(variant: EWI_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWI`"]
        pub type EWI_R = crate::R<bool, EWI_A>;
        impl EWI_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, EWI_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(EWI_A::ENABLE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == EWI_A::ENABLE
            }
        }
        #[doc = "Write proxy for field `EWI`"]
        pub struct EWI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWI_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWI_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "interrupt occurs whenever the counter reaches the value 0x40"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EWI_A::ENABLE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Timer Base\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WDGTB_A {
            #[doc = "0: Counter clock (PCLK1 div 4096) div 1"]
            DIV1 = 0,
            #[doc = "1: Counter clock (PCLK1 div 4096) div 2"]
            DIV2 = 1,
            #[doc = "2: Counter clock (PCLK1 div 4096) div 4"]
            DIV4 = 2,
            #[doc = "3: Counter clock (PCLK1 div 4096) div 8"]
            DIV8 = 3,
        }
        impl From<WDGTB_A> for u8 {
            #[inline(always)]
            fn from(variant: WDGTB_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WDGTB`"]
        pub type WDGTB_R = crate::R<u8, WDGTB_A>;
        impl WDGTB_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WDGTB_A {
                match self.bits {
                    0 => WDGTB_A::DIV1,
                    1 => WDGTB_A::DIV2,
                    2 => WDGTB_A::DIV4,
                    3 => WDGTB_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == WDGTB_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == WDGTB_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == WDGTB_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == WDGTB_A::DIV8
            }
        }
        #[doc = "Write proxy for field `WDGTB`"]
        pub struct WDGTB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDGTB_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDGTB_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV1)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV2)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV4)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 7)) | (((value as u32) & 0x03) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline(always)]
            pub fn w(&self) -> W_R {
                W_R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bit 9 - Early Wakeup Interrupt"]
            #[inline(always)]
            pub fn ewi(&self) -> EWI_R {
                EWI_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bits 7:8 - Timer Base"]
            #[inline(always)]
            pub fn wdgtb(&self) -> WDGTB_R {
                WDGTB_R::new(((self.bits >> 7) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline(always)]
            pub fn w(&mut self) -> W_W {
                W_W { w: self }
            }
            #[doc = "Bit 9 - Early Wakeup Interrupt"]
            #[inline(always)]
            pub fn ewi(&mut self) -> EWI_W {
                EWI_W { w: self }
            }
            #[doc = "Bits 7:8 - Timer Base"]
            #[inline(always)]
            pub fn wdgtb(&mut self) -> WDGTB_W {
                WDGTB_W { w: self }
            }
        }
    }
    #[doc = "Status register (WWDG_SR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status register (WWDG_SR)"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Early Wakeup Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIF_A {
            #[doc = "1: The EWI Interrupt Service Routine has been triggered"]
            PENDING = 1,
            #[doc = "0: The EWI Interrupt Service Routine has been serviced"]
            FINISHED = 0,
        }
        impl From<EWIF_A> for bool {
            #[inline(always)]
            fn from(variant: EWIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWIF`"]
        pub type EWIF_R = crate::R<bool, EWIF_A>;
        impl EWIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EWIF_A {
                match self.bits {
                    true => EWIF_A::PENDING,
                    false => EWIF_A::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                *self == EWIF_A::PENDING
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                *self == EWIF_A::FINISHED
            }
        }
        #[doc = "Early Wakeup Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIF_AW {
            #[doc = "0: The EWI Interrupt Service Routine has been serviced"]
            FINISHED = 0,
        }
        impl From<EWIF_AW> for bool {
            #[inline(always)]
            fn from(variant: EWIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EWIF`"]
        pub struct EWIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The EWI Interrupt Service Routine has been serviced"]
            #[inline(always)]
            pub fn finished(self) -> &'a mut W {
                self.variant(EWIF_AW::FINISHED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Early Wakeup Interrupt"]
            #[inline(always)]
            pub fn ewif(&self) -> EWIF_R {
                EWIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Early Wakeup Interrupt"]
            #[inline(always)]
            pub fn ewif(&mut self) -> EWIF_W {
                EWIF_W { w: self }
            }
        }
    }
}
#[doc = "Advanced timer"]
pub struct TIM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM1 {}
impl TIM1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim1::RegisterBlock {
        0x4001_2c00 as *const _
    }
}
impl Deref for TIM1 {
    type Target = tim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM1::ptr() }
    }
}
#[doc = "Advanced timer"]
pub mod tim1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved_7_ccmr2: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: RCR,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR,
        #[doc = "0x38 - capture/compare register 1"]
        pub ccr2: CCR,
        #[doc = "0x3c - capture/compare register 1"]
        pub ccr3: CCR,
        #[doc = "0x40 - capture/compare register 1"]
        pub ccr4: CCR,
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: BDTR,
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (input mode)"]
        #[inline(always)]
        pub fn ccmr2_input(&self) -> &CCMR2_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(28usize) as *const CCMR2_INPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (input mode)"]
        #[inline(always)]
        pub fn ccmr2_input_mut(&self) -> &mut CCMR2_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(28usize) as *mut CCMR2_INPUT) }
        }
        #[doc = "0x1c - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr2_output(&self) -> &CCMR2_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(28usize) as *const CCMR2_OUTPUT) }
        }
        #[doc = "0x1c - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr2_output_mut(&self) -> &mut CCMR2_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(28usize) as *mut CCMR2_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Center-aligned mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            #[doc = "0: The counter counts up or down depending on the direction bit"]
            EDGEALIGNED = 0,
            #[doc = "1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            CENTERALIGNED1 = 1,
            #[doc = "2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            CENTERALIGNED2 = 2,
            #[doc = "3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CMS`"]
        pub type CMS_R = crate::R<u8, CMS_A>;
        impl CMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `EDGEALIGNED`"]
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                *self == CMS_A::EDGEALIGNED
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED1`"]
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                *self == CMS_A::CENTERALIGNED1
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED2`"]
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                *self == CMS_A::CENTERALIGNED2
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED3`"]
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                *self == CMS_A::CENTERALIGNED3
            }
        }
        #[doc = "Write proxy for field `CMS`"]
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The counter counts up or down depending on the direction bit"]
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "Direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            #[doc = "0: Counter used as upcounter"]
            UP = 0,
            #[doc = "1: Counter used as downcounter"]
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DIR`"]
        pub type DIR_R = crate::R<bool, DIR_A>;
        impl DIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                *self == DIR_A::UP
            }
            #[doc = "Checks if the value of the field is `DOWN`"]
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                *self == DIR_A::DOWN
            }
        }
        #[doc = "Write proxy for field `DIR`"]
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter used as upcounter"]
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            #[doc = "Counter used as downcounter"]
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped at update event"]
            DISABLED = 0,
            #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OIS4`"]
        pub type OIS4_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS4`"]
        pub struct OIS4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS4_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `OIS3N`"]
        pub type OIS3N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS3N`"]
        pub struct OIS3N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS3N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `OIS3`"]
        pub type OIS3_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS3`"]
        pub struct OIS3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS3_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `OIS2N`"]
        pub type OIS2N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS2N`"]
        pub struct OIS2N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS2N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OIS2`"]
        pub type OIS2_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS2`"]
        pub struct OIS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `OIS1N`"]
        pub type OIS1N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS1N`"]
        pub struct OIS1N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `OIS1`"]
        pub type OIS1_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS1`"]
        pub struct OIS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "TI1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI1S_A {
            #[doc = "0: The TIMx_CH1 pin is connected to TI1 input"]
            NORMAL = 0,
            #[doc = "1: The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            XOR = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TI1S`"]
        pub type TI1S_R = crate::R<bool, TI1S_A>;
        impl TI1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::NORMAL,
                    true => TI1S_A::XOR,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == TI1S_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `XOR`"]
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                *self == TI1S_A::XOR
            }
        }
        #[doc = "Write proxy for field `TI1S`"]
        pub struct TI1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI1S_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIMx_CH1 pin is connected to TI1 input"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(TI1S_A::NORMAL)
            }
            #[doc = "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::XOR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: The UG bit from the TIMx_EGR register is used as trigger output"]
            RESET = 0,
            #[doc = "1: The counter enable signal, CNT_EN, is used as trigger output"]
            ENABLE = 1,
            #[doc = "2: The update event is selected as trigger output"]
            UPDATE = 2,
            #[doc = "3: The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            COMPAREPULSE = 3,
            #[doc = "4: OC1REF signal is used as trigger output"]
            COMPAREOC1 = 4,
            #[doc = "5: OC2REF signal is used as trigger output"]
            COMPAREOC2 = 5,
            #[doc = "6: OC3REF signal is used as trigger output"]
            COMPAREOC3 = 6,
            #[doc = "7: OC4REF signal is used as trigger output"]
            COMPAREOC4 = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::RESET,
                    1 => MMS_A::ENABLE,
                    2 => MMS_A::UPDATE,
                    3 => MMS_A::COMPAREPULSE,
                    4 => MMS_A::COMPAREOC1,
                    5 => MMS_A::COMPAREOC2,
                    6 => MMS_A::COMPAREOC3,
                    7 => MMS_A::COMPAREOC4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
            #[doc = "Checks if the value of the field is `COMPAREPULSE`"]
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                *self == MMS_A::COMPAREPULSE
            }
            #[doc = "Checks if the value of the field is `COMPAREOC1`"]
            #[inline(always)]
            pub fn is_compare_oc1(&self) -> bool {
                *self == MMS_A::COMPAREOC1
            }
            #[doc = "Checks if the value of the field is `COMPAREOC2`"]
            #[inline(always)]
            pub fn is_compare_oc2(&self) -> bool {
                *self == MMS_A::COMPAREOC2
            }
            #[doc = "Checks if the value of the field is `COMPAREOC3`"]
            #[inline(always)]
            pub fn is_compare_oc3(&self) -> bool {
                *self == MMS_A::COMPAREOC3
            }
            #[doc = "Checks if the value of the field is `COMPAREOC4`"]
            #[inline(always)]
            pub fn is_compare_oc4(&self) -> bool {
                *self == MMS_A::COMPAREOC4
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The UG bit from the TIMx_EGR register is used as trigger output"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "The counter enable signal, CNT_EN, is used as trigger output"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "The update event is selected as trigger output"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            #[doc = "OC1REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc1(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC1)
            }
            #[doc = "OC2REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc2(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC2)
            }
            #[doc = "OC3REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc3(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC3)
            }
            #[doc = "OC4REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc4(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Capture/compare DMA selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            #[doc = "0: CCx DMA request sent when CCx event occurs"]
            ONCOMPARE = 0,
            #[doc = "1: CCx DMA request sent when update event occurs"]
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCDS`"]
        pub type CCDS_R = crate::R<bool, CCDS_A>;
        impl CCDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            #[doc = "Checks if the value of the field is `ONCOMPARE`"]
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                *self == CCDS_A::ONCOMPARE
            }
            #[doc = "Checks if the value of the field is `ONUPDATE`"]
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                *self == CCDS_A::ONUPDATE
            }
        }
        #[doc = "Write proxy for field `CCDS`"]
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request sent when CCx event occurs"]
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            #[doc = "CCx DMA request sent when update event occurs"]
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CCUS`"]
        pub type CCUS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CCUS`"]
        pub struct CCUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCUS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CCPC`"]
        pub type CCPC_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CCPC`"]
        pub struct CCPC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCPC_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - Output Idle state 4"]
            #[inline(always)]
            pub fn ois4(&self) -> OIS4_R {
                OIS4_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Output Idle state 3"]
            #[inline(always)]
            pub fn ois3n(&self) -> OIS3N_R {
                OIS3N_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Output Idle state 3"]
            #[inline(always)]
            pub fn ois3(&self) -> OIS3_R {
                OIS3_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Output Idle state 2"]
            #[inline(always)]
            pub fn ois2n(&self) -> OIS2N_R {
                OIS2N_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 14 - Output Idle state 4"]
            #[inline(always)]
            pub fn ois4(&mut self) -> OIS4_W {
                OIS4_W { w: self }
            }
            #[doc = "Bit 13 - Output Idle state 3"]
            #[inline(always)]
            pub fn ois3n(&mut self) -> OIS3N_W {
                OIS3N_W { w: self }
            }
            #[doc = "Bit 12 - Output Idle state 3"]
            #[inline(always)]
            pub fn ois3(&mut self) -> OIS3_W {
                OIS3_W { w: self }
            }
            #[doc = "Bit 11 - Output Idle state 2"]
            #[inline(always)]
            pub fn ois2n(&mut self) -> OIS2N_W {
                OIS2N_W { w: self }
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline(always)]
            pub fn ois2(&mut self) -> OIS2_W {
                OIS2_W { w: self }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1n(&mut self) -> OIS1N_W {
                OIS1N_W { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1(&mut self) -> OIS1_W {
                OIS1_W { w: self }
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline(always)]
            pub fn ti1s(&mut self) -> TI1S_W {
                TI1S_W { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline(always)]
            pub fn ccus(&mut self) -> CCUS_W {
                CCUS_W { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline(always)]
            pub fn ccpc(&mut self) -> CCPC_W {
                CCPC_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "External trigger polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            #[doc = "0: ETR is noninverted, active at high level or rising edge"]
            NOTINVERTED = 0,
            #[doc = "1: ETR is inverted, active at low level or falling edge"]
            INVERTED = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ETP`"]
        pub type ETP_R = crate::R<bool, ETP_A>;
        impl ETP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::NOTINVERTED,
                    true => ETP_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINVERTED`"]
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                *self == ETP_A::NOTINVERTED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == ETP_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `ETP`"]
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ETR is noninverted, active at high level or rising edge"]
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(ETP_A::NOTINVERTED)
            }
            #[doc = "ETR is inverted, active at low level or falling edge"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(ETP_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "External clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            #[doc = "0: External clock mode 2 disabled"]
            DISABLED = 0,
            #[doc = "1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ECE`"]
        pub type ECE_R = crate::R<bool, ECE_A>;
        impl ECE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ECE`"]
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "External clock mode 2 disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            #[doc = "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "External trigger prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            #[doc = "0: Prescaler OFF"]
            DIV1 = 0,
            #[doc = "1: ETRP frequency divided by 2"]
            DIV2 = 1,
            #[doc = "2: ETRP frequency divided by 4"]
            DIV4 = 2,
            #[doc = "3: ETRP frequency divided by 8"]
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETPS`"]
        pub type ETPS_R = crate::R<u8, ETPS_A>;
        impl ETPS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ETPS_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::DIV8
            }
        }
        #[doc = "Write proxy for field `ETPS`"]
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Prescaler OFF"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            #[doc = "ETRP frequency divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            #[doc = "ETRP frequency divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            #[doc = "ETRP frequency divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "External trigger filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETF`"]
        pub type ETF_R = crate::R<u8, ETF_A>;
        impl ETF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == ETF_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == ETF_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == ETF_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `ETF`"]
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Master/Slave mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            #[doc = "0: No action"]
            NOSYNC = 0,
            #[doc = "1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, MSM_A>;
        impl MSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `NOSYNC`"]
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                *self == MSM_A::NOSYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                *self == MSM_A::SYNC
            }
        }
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            #[doc = "0: Internal Trigger 0 (ITR0)"]
            ITR0 = 0,
            #[doc = "1: Internal Trigger 1 (ITR1)"]
            ITR1 = 1,
            #[doc = "2: Internal Trigger 2 (ITR2)"]
            ITR2 = 2,
            #[doc = "4: TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED = 4,
            #[doc = "5: Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1 = 5,
            #[doc = "6: Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2 = 6,
            #[doc = "7: External Trigger input (ETRF)"]
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, TS_A>;
        impl TS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TS_A::ITR0),
                    1 => Val(TS_A::ITR1),
                    2 => Val(TS_A::ITR2),
                    4 => Val(TS_A::TI1F_ED),
                    5 => Val(TS_A::TI1FP1),
                    6 => Val(TS_A::TI2FP2),
                    7 => Val(TS_A::ETRF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ITR0`"]
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                *self == TS_A::ITR0
            }
            #[doc = "Checks if the value of the field is `ITR1`"]
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                *self == TS_A::ITR1
            }
            #[doc = "Checks if the value of the field is `ITR2`"]
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                *self == TS_A::ITR2
            }
            #[doc = "Checks if the value of the field is `TI1F_ED`"]
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                *self == TS_A::TI1F_ED
            }
            #[doc = "Checks if the value of the field is `TI1FP1`"]
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::TI1FP1
            }
            #[doc = "Checks if the value of the field is `TI2FP2`"]
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::TI2FP2
            }
            #[doc = "Checks if the value of the field is `ETRF`"]
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                *self == TS_A::ETRF
            }
        }
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Internal Trigger 0 (ITR0)"]
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            #[doc = "Internal Trigger 1 (ITR1)"]
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            #[doc = "Internal Trigger 2 (ITR2)"]
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            #[doc = "External Trigger input (ETRF)"]
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Slave mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            #[doc = "0: Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            DISABLED = 0,
            #[doc = "1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1 = 1,
            #[doc = "2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2 = 2,
            #[doc = "3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3 = 3,
            #[doc = "4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE = 4,
            #[doc = "5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE = 5,
            #[doc = "6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE = 6,
            #[doc = "7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, SMS_A>;
        impl SMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMS_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_1`"]
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_1
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_2`"]
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_2
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_3`"]
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_3
            }
            #[doc = "Checks if the value of the field is `RESET_MODE`"]
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                *self == SMS_A::RESET_MODE
            }
            #[doc = "Checks if the value of the field is `GATED_MODE`"]
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                *self == SMS_A::GATED_MODE
            }
            #[doc = "Checks if the value of the field is `TRIGGER_MODE`"]
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                *self == SMS_A::TRIGGER_MODE
            }
            #[doc = "Checks if the value of the field is `EXT_CLOCK_MODE`"]
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                *self == SMS_A::EXT_CLOCK_MODE
            }
        }
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1IE_A {
            #[doc = "0: CCx interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CCx interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CC1IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, CC1IE_A>;
        impl CC1IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC1IE_A {
                match self.bits {
                    false => CC1IE_A::DISABLED,
                    true => CC1IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC1IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC1IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt enable"]
        pub type CC2IE_A = CC1IE_A;
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, CC1IE_A>;
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 interrupt enable"]
        pub type CC3IE_A = CC1IE_A;
        #[doc = "Reader of field `CC3IE`"]
        pub type CC3IE_R = crate::R<bool, CC1IE_A>;
        #[doc = "Write proxy for field `CC3IE`"]
        pub struct CC3IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 interrupt enable"]
        pub type CC4IE_A = CC1IE_A;
        #[doc = "Reader of field `CC4IE`"]
        pub type CC4IE_R = crate::R<bool, CC1IE_A>;
        #[doc = "Write proxy for field `CC4IE`"]
        pub struct CC4IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `COMIE`"]
        pub type COMIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COMIE`"]
        pub struct COMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Trigger interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            #[doc = "0: Trigger interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, TIE_A>;
        impl TIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            #[doc = "Trigger interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `BIE`"]
        pub type BIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BIE`"]
        pub struct BIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Update DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            #[doc = "0: Update DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Update DMA request enabled"]
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, UDE_A>;
        impl UDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1DE_A {
            #[doc = "0: CCx DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: CCx DMA request enabled"]
            ENABLED = 1,
        }
        impl From<CC1DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1DE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC1DE`"]
        pub type CC1DE_R = crate::R<bool, CC1DE_A>;
        impl CC1DE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC1DE_A {
                match self.bits {
                    false => CC1DE_A::DISABLED,
                    true => CC1DE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC1DE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC1DE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC1DE`"]
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 DMA request enable"]
        pub type CC2DE_A = CC1DE_A;
        #[doc = "Reader of field `CC2DE`"]
        pub type CC2DE_R = crate::R<bool, CC1DE_A>;
        #[doc = "Write proxy for field `CC2DE`"]
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 DMA request enable"]
        pub type CC3DE_A = CC1DE_A;
        #[doc = "Reader of field `CC3DE`"]
        pub type CC3DE_R = crate::R<bool, CC1DE_A>;
        #[doc = "Write proxy for field `CC3DE`"]
        pub struct CC3DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 DMA request enable"]
        pub type CC4DE_A = CC1DE_A;
        #[doc = "Reader of field `CC4DE`"]
        pub type CC4DE_R = crate::R<bool, CC1DE_A>;
        #[doc = "Write proxy for field `CC4DE`"]
        pub struct CC4DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `COMDE`"]
        pub type COMDE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COMDE`"]
        pub struct COMDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMDE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Trigger DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TDE_A {
            #[doc = "0: Trigger DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger DMA request enabled"]
            ENABLED = 1,
        }
        impl From<TDE_A> for bool {
            #[inline(always)]
            fn from(variant: TDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TDE`"]
        pub type TDE_R = crate::R<bool, TDE_A>;
        impl TDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TDE_A {
                match self.bits {
                    false => TDE_A::DISABLED,
                    true => TDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TDE`"]
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TDE_A::DISABLED)
            }
            #[doc = "Trigger DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - COM DMA request enable"]
            #[inline(always)]
            pub fn comde(&self) -> COMDE_R {
                COMDE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline(always)]
            pub fn cc3ie(&mut self) -> CC3IE_W {
                CC3IE_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline(always)]
            pub fn cc4ie(&mut self) -> CC4IE_W {
                CC4IE_W { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline(always)]
            pub fn comie(&mut self) -> COMIE_W {
                COMIE_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline(always)]
            pub fn bie(&mut self) -> BIE_W {
                BIE_W { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline(always)]
            pub fn cc3de(&mut self) -> CC3DE_W {
                CC3DE_W { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline(always)]
            pub fn cc4de(&mut self) -> CC4DE_W {
                CC4DE_W { w: self }
            }
            #[doc = "Bit 13 - COM DMA request enable"]
            #[inline(always)]
            pub fn comde(&mut self) -> COMDE_W {
                COMDE_W { w: self }
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/Compare 4 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_A {
            #[doc = "1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
            OVERCAPTURE = 1,
        }
        impl From<CC4OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4OF`"]
        pub type CC4OF_R = crate::R<bool, CC4OF_A>;
        impl CC4OF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC4OF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC4OF_A::OVERCAPTURE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERCAPTURE`"]
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                *self == CC4OF_A::OVERCAPTURE
            }
        }
        #[doc = "Capture/Compare 4 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC4OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4OF`"]
        pub struct CC4OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 overcapture flag"]
        pub type CC3OF_A = CC4OF_A;
        #[doc = "Reader of field `CC3OF`"]
        pub type CC3OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/Compare 3 overcapture flag"]
        pub type CC3OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC3OF`"]
        pub struct CC3OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/compare 2 overcapture flag"]
        pub type CC2OF_A = CC4OF_A;
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/compare 2 overcapture flag"]
        pub type CC2OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_A = CC4OF_A;
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `BIF`"]
        pub type BIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BIF`"]
        pub struct BIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            #[doc = "0: No trigger event occurred"]
            NOTRIGGER = 0,
            #[doc = "1: Trigger interrupt pending"]
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, TIF_A>;
        impl TIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRIGGER`"]
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                *self == TIF_A::NOTRIGGER
            }
            #[doc = "Checks if the value of the field is `TRIGGER`"]
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == TIF_A::TRIGGER
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `COMIF`"]
        pub type COMIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COMIF`"]
        pub struct COMIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_A {
            #[doc = "1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
            MATCH = 1,
        }
        impl From<CC4IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4IF`"]
        pub type CC4IF_R = crate::R<bool, CC4IF_A>;
        impl CC4IF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC4IF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC4IF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CC4IF_A::MATCH
            }
        }
        #[doc = "Capture/Compare 4 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC4IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4IF`"]
        pub struct CC4IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 interrupt flag"]
        pub type CC3IF_A = CC4IF_A;
        #[doc = "Reader of field `CC3IF`"]
        pub type CC3IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/Compare 3 interrupt flag"]
        pub type CC3IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC3IF`"]
        pub struct CC3IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag"]
        pub type CC2IF_A = CC4IF_A;
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/Compare 2 interrupt flag"]
        pub type CC2IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_A = CC4IF_A;
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline(always)]
            pub fn cc4of(&mut self) -> CC4OF_W {
                CC4OF_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline(always)]
            pub fn cc3of(&mut self) -> CC3OF_W {
                CC3OF_W { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline(always)]
            pub fn bif(&mut self) -> BIF_W {
                BIF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline(always)]
            pub fn comif(&mut self) -> COMIF_W {
                COMIF_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline(always)]
            pub fn cc4if(&mut self) -> CC4IF_W {
                CC4IF_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline(always)]
            pub fn cc3if(&mut self) -> CC3IF_W {
                CC3IF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `BG`"]
        pub struct BG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Trigger generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            #[doc = "1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `COMG`"]
        pub struct COMG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Capture/compare 4 generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4G_AW {
            #[doc = "1: If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            TRIGGER = 1,
        }
        impl From<CC4G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4G_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4G`"]
        pub struct CC4G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/compare 3 generation"]
        pub type CC3G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC3G`"]
        pub struct CC3G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/compare 2 generation"]
        pub type CC2G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 generation"]
        pub type CC1G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 7 - Break generation"]
            #[inline(always)]
            pub fn bg(&mut self) -> BG_W {
                BG_W { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline(always)]
            pub fn comg(&mut self) -> COMG_W {
                COMG_W { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline(always)]
            pub fn cc4g(&mut self) -> CC4G_W {
                CC4G_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline(always)]
            pub fn cc3g(&mut self) -> CC3G_W {
                CC3G_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC2CE`"]
        pub type OC2CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2CE`"]
        pub struct OC2CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output Compare 2 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, OC2M_A>;
        impl OC2M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC2M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC2M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC2M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC2M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC2M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC2M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC2M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output Compare 2 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            #[doc = "0: Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR2 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, OC2PE_A>;
        impl OC2PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC2PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC2PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR2 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CC2 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC2S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC2 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC1CE`"]
        pub type OC1CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1CE`"]
        pub struct OC1CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output Compare 1 mode"]
        pub type OC1M_A = OC2M_A;
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, OC2M_A>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output Compare 1 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC1PE_A {
            #[doc = "0: Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, OC1PE_A>;
        impl OC1PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::DISABLED,
                    true => OC1PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            #[doc = "0: CC1 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC1S_A>;
        impl CC1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC1S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC1S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC1S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC1 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Output Compare 2 clear enable"]
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Output Compare 1 clear enable"]
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Output Compare 2 clear enable"]
            #[inline(always)]
            pub fn oc2ce(&mut self) -> OC2CE_W {
                OC2CE_W { w: self }
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bit 7 - Output Compare 1 clear enable"]
            #[inline(always)]
            pub fn oc1ce(&mut self) -> OC1CE_W {
                OC1CE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 15)) | (((value as u32) & 0x0f) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "1: CC2 channel is configured as input, IC2 is mapped on TI2"]
            TI2 = 1,
            #[doc = "2: CC2 channel is configured as input, IC2 is mapped on TI1"]
            TI1 = 2,
            #[doc = "3: CC2 channel is configured as input, IC2 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC2S_A::TI2),
                    2 => Val(CC2S_A::TI1),
                    3 => Val(CC2S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC2S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC2S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC2S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Input capture 1 filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC1F_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, IC1F_A>;
        impl IC1F_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NOFILTER,
                    1 => IC1F_A::FCK_INT_N2,
                    2 => IC1F_A::FCK_INT_N4,
                    3 => IC1F_A::FCK_INT_N8,
                    4 => IC1F_A::FDTS_DIV2_N6,
                    5 => IC1F_A::FDTS_DIV2_N8,
                    6 => IC1F_A::FDTS_DIV4_N6,
                    7 => IC1F_A::FDTS_DIV4_N8,
                    8 => IC1F_A::FDTS_DIV8_N6,
                    9 => IC1F_A::FDTS_DIV8_N8,
                    10 => IC1F_A::FDTS_DIV16_N5,
                    11 => IC1F_A::FDTS_DIV16_N6,
                    12 => IC1F_A::FDTS_DIV16_N8,
                    13 => IC1F_A::FDTS_DIV32_N5,
                    14 => IC1F_A::FDTS_DIV32_N6,
                    15 => IC1F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC1F_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == IC1F_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == IC1F_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == IC1F_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            #[doc = "1: CC1 channel is configured as input, IC1 is mapped on TI1"]
            TI1 = 1,
            #[doc = "2: CC1 channel is configured as input, IC1 is mapped on TI2"]
            TI2 = 2,
            #[doc = "3: CC1 channel is configured as input, IC1 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC1S_A>;
        impl CC1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC1S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC1S_A::TI1),
                    2 => Val(CC1S_A::TI2),
                    3 => Val(CC1S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC1S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC1S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC1S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC1S_A::TI1)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC1S_A::TI2)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC1S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 15:18 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 15) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 15:18 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr2_output](ccmr2_output) module"]
    pub type CCMR2_OUTPUT = crate::Reg<u32, _CCMR2_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR2_OUTPUT;
    #[doc = "`read()` method returns [ccmr2_output::R](ccmr2_output::R) reader structure"]
    impl crate::Readable for CCMR2_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr2_output::W](ccmr2_output::W) writer structure"]
    impl crate::Writable for CCMR2_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr2_output {
        #[doc = "Reader of register CCMR2_Output"]
        pub type R = crate::R<u32, super::CCMR2_OUTPUT>;
        #[doc = "Writer for register CCMR2_Output"]
        pub type W = crate::W<u32, super::CCMR2_OUTPUT>;
        #[doc = "Register CCMR2_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR2_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC4CE`"]
        pub type OC4CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC4CE`"]
        pub struct OC4CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output compare 4 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC4M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC4M`"]
        pub type OC4M_R = crate::R<u8, OC4M_A>;
        impl OC4M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::FROZEN,
                    1 => OC4M_A::ACTIVEONMATCH,
                    2 => OC4M_A::INACTIVEONMATCH,
                    3 => OC4M_A::TOGGLE,
                    4 => OC4M_A::FORCEINACTIVE,
                    5 => OC4M_A::FORCEACTIVE,
                    6 => OC4M_A::PWMMODE1,
                    7 => OC4M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC4M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC4M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC4M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC4M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC4M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC4M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC4M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC4M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC4M`"]
        pub struct OC4M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC4M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output compare 4 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC4PE_A {
            #[doc = "0: Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR4 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC4PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC4PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC4PE`"]
        pub type OC4PE_R = crate::R<bool, OC4PE_A>;
        impl OC4PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC4PE_A {
                match self.bits {
                    false => OC4PE_A::DISABLED,
                    true => OC4PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC4PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC4PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC4PE`"]
        pub struct OC4PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC4PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC4PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR4 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC4PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC4FE`"]
        pub type OC4FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC4FE`"]
        pub struct OC4FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            #[doc = "0: CC4 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC4S`"]
        pub type CC4S_R = crate::R<u8, CC4S_A>;
        impl CC4S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC4S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC4S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC4S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC4S`"]
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC4 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC3CE`"]
        pub type OC3CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC3CE`"]
        pub struct OC3CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output compare 3 mode"]
        pub type OC3M_A = OC4M_A;
        #[doc = "Reader of field `OC3M`"]
        pub type OC3M_R = crate::R<u8, OC4M_A>;
        #[doc = "Write proxy for field `OC3M`"]
        pub struct OC3M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC3M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output compare 3 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC3PE_A {
            #[doc = "0: Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR3 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC3PE`"]
        pub type OC3PE_R = crate::R<bool, OC3PE_A>;
        impl OC3PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::DISABLED,
                    true => OC3PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC3PE`"]
        pub struct OC3PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC3PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR3 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC3FE`"]
        pub type OC3FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC3FE`"]
        pub struct OC3FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            #[doc = "0: CC3 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC3S`"]
        pub type CC3S_R = crate::R<u8, CC3S_A>;
        impl CC3S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC3S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC3S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC3S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC3S`"]
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC3 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline(always)]
            pub fn oc4ce(&mut self) -> OC4CE_W {
                OC4CE_W { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline(always)]
            pub fn oc4m(&mut self) -> OC4M_W {
                OC4M_W { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline(always)]
            pub fn oc4pe(&mut self) -> OC4PE_W {
                OC4PE_W { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline(always)]
            pub fn oc4fe(&mut self) -> OC4FE_W {
                OC4FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline(always)]
            pub fn oc3ce(&mut self) -> OC3CE_W {
                OC3CE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline(always)]
            pub fn oc3m(&mut self) -> OC3M_W {
                OC3M_W { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline(always)]
            pub fn oc3pe(&mut self) -> OC3PE_W {
                OC3PE_W { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline(always)]
            pub fn oc3fe(&mut self) -> OC3FE_W {
                OC3FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr2_input](ccmr2_input) module"]
    pub type CCMR2_INPUT = crate::Reg<u32, _CCMR2_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR2_INPUT;
    #[doc = "`read()` method returns [ccmr2_input::R](ccmr2_input::R) reader structure"]
    impl crate::Readable for CCMR2_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr2_input::W](ccmr2_input::W) writer structure"]
    impl crate::Writable for CCMR2_INPUT {}
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = "Reader of register CCMR2_Input"]
        pub type R = crate::R<u32, super::CCMR2_INPUT>;
        #[doc = "Writer for register CCMR2_Input"]
        pub type W = crate::W<u32, super::CCMR2_INPUT>;
        #[doc = "Register CCMR2_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR2_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC4F`"]
        pub type IC4F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC4F`"]
        pub struct IC4F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 15)) | (((value as u32) & 0x0f) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `IC4PSC`"]
        pub type IC4PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC4PSC`"]
        pub struct IC4PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            #[doc = "1: CC4 channel is configured as input, IC4 is mapped on TI4"]
            TI4 = 1,
            #[doc = "2: CC4 channel is configured as input, IC4 is mapped on TI3"]
            TI3 = 2,
            #[doc = "3: CC4 channel is configured as input, IC4 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC4S`"]
        pub type CC4S_R = crate::R<u8, CC4S_A>;
        impl CC4S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC4S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC4S_A::TI4),
                    2 => Val(CC4S_A::TI3),
                    3 => Val(CC4S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                *self == CC4S_A::TI4
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                *self == CC4S_A::TI3
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC4S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC4S`"]
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI4"]
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC4S_A::TI4)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI3"]
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC4S_A::TI3)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC4S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `IC3F`"]
        pub type IC3F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC3F`"]
        pub struct IC3F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC3PSC`"]
        pub type IC3PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC3PSC`"]
        pub struct IC3PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 3 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            #[doc = "1: CC3 channel is configured as input, IC3 is mapped on TI3"]
            TI3 = 1,
            #[doc = "2: CC3 channel is configured as input, IC3 is mapped on TI4"]
            TI4 = 2,
            #[doc = "3: CC3 channel is configured as input, IC3 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC3S`"]
        pub type CC3S_R = crate::R<u8, CC3S_A>;
        impl CC3S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC3S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC3S_A::TI3),
                    2 => Val(CC3S_A::TI4),
                    3 => Val(CC3S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                *self == CC3S_A::TI3
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                *self == CC3S_A::TI4
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC3S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC3S`"]
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI3"]
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC3S_A::TI3)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI4"]
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC3S_A::TI4)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC3S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 15:18 - Input capture 4 filter"]
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 15) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 15:18 - Input capture 4 filter"]
            #[inline(always)]
            pub fn ic4f(&mut self) -> IC4F_W {
                IC4F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline(always)]
            pub fn ic4psc(&mut self) -> IC4PSC_W {
                IC4PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline(always)]
            pub fn ic3f(&mut self) -> IC3F_W {
                IC3F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline(always)]
            pub fn ic3psc(&mut self) -> IC3PSC_W {
                IC3PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC4P`"]
        pub type CC4P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC4P`"]
        pub struct CC4P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `CC4E`"]
        pub type CC4E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC4E`"]
        pub struct CC4E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `CC3NP`"]
        pub type CC3NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC3NP`"]
        pub struct CC3NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `CC3NE`"]
        pub type CC3NE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC3NE`"]
        pub struct CC3NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3NE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC3P`"]
        pub type CC3P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC3P`"]
        pub struct CC3P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `CC3E`"]
        pub type CC3E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC3E`"]
        pub struct CC3E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `CC2NP`"]
        pub type CC2NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2NP`"]
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `CC2NE`"]
        pub type CC2NE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2NE`"]
        pub struct CC2NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CC1NE`"]
        pub type CC1NE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NE`"]
        pub struct CC1NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
            #[inline(always)]
            pub fn cc3ne(&self) -> CC3NE_R {
                CC3NE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
            #[inline(always)]
            pub fn cc2ne(&self) -> CC2NE_R {
                CC2NE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc4p(&mut self) -> CC4P_W {
                CC4P_W { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline(always)]
            pub fn cc4e(&mut self) -> CC4E_W {
                CC4E_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3np(&mut self) -> CC3NP_W {
                CC3NP_W { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
            #[inline(always)]
            pub fn cc3ne(&mut self) -> CC3NE_W {
                CC3NE_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3p(&mut self) -> CC3P_W {
                CC3P_W { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline(always)]
            pub fn cc3e(&mut self) -> CC3E_W {
                CC3E_W { w: self }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            #[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
            #[inline(always)]
            pub fn cc2ne(&mut self) -> CC2NE_W {
                CC2NE_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline(always)]
            pub fn cc1ne(&mut self) -> CC1NE_W {
                CC1NE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
    #[doc = "DMA control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dcr](dcr) module"]
    pub type DCR = crate::Reg<u32, _DCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DCR;
    #[doc = "`read()` method returns [dcr::R](dcr::R) reader structure"]
    impl crate::Readable for DCR {}
    #[doc = "`write(|w| ..)` method takes [dcr::W](dcr::W) writer structure"]
    impl crate::Writable for DCR {}
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = "Reader of register DCR"]
        pub type R = crate::R<u32, super::DCR>;
        #[doc = "Writer for register DCR"]
        pub type W = crate::W<u32, super::DCR>;
        #[doc = "Register DCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DBL`"]
        pub type DBL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBL`"]
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DBA`"]
        pub type DBA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBA`"]
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmar](dmar) module"]
    pub type DMAR = crate::Reg<u32, _DMAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMAR;
    #[doc = "`read()` method returns [dmar::R](dmar::R) reader structure"]
    impl crate::Readable for DMAR {}
    #[doc = "`write(|w| ..)` method takes [dmar::W](dmar::W) writer structure"]
    impl crate::Writable for DMAR {}
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = "Reader of register DMAR"]
        pub type R = crate::R<u32, super::DMAR>;
        #[doc = "Writer for register DMAR"]
        pub type W = crate::W<u32, super::DMAR>;
        #[doc = "Register DMAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DMAB`"]
        pub type DMAB_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DMAB`"]
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
        }
    }
    #[doc = "repetition counter register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcr](rcr) module"]
    pub type RCR = crate::Reg<u32, _RCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RCR;
    #[doc = "`read()` method returns [rcr::R](rcr::R) reader structure"]
    impl crate::Readable for RCR {}
    #[doc = "`write(|w| ..)` method takes [rcr::W](rcr::W) writer structure"]
    impl crate::Writable for RCR {}
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = "Reader of register RCR"]
        pub type R = crate::R<u32, super::RCR>;
        #[doc = "Writer for register RCR"]
        pub type W = crate::W<u32, super::RCR>;
        #[doc = "Register RCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `REP`"]
        pub type REP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `REP`"]
        pub struct REP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline(always)]
            pub fn rep(&mut self) -> REP_W {
                REP_W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bdtr](bdtr) module"]
    pub type BDTR = crate::Reg<u32, _BDTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BDTR;
    #[doc = "`read()` method returns [bdtr::R](bdtr::R) reader structure"]
    impl crate::Readable for BDTR {}
    #[doc = "`write(|w| ..)` method takes [bdtr::W](bdtr::W) writer structure"]
    impl crate::Writable for BDTR {}
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = "Reader of register BDTR"]
        pub type R = crate::R<u32, super::BDTR>;
        #[doc = "Writer for register BDTR"]
        pub type W = crate::W<u32, super::BDTR>;
        #[doc = "Register BDTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BDTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Main output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOE_A {
            #[doc = "0: OC/OCN are disabled or forced idle depending on OSSI"]
            DISABLEDIDLE = 0,
            #[doc = "1: OC/OCN are enabled if CCxE/CCxNE are set"]
            ENABLED = 1,
        }
        impl From<MOE_A> for bool {
            #[inline(always)]
            fn from(variant: MOE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MOE`"]
        pub type MOE_R = crate::R<bool, MOE_A>;
        impl MOE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MOE_A {
                match self.bits {
                    false => MOE_A::DISABLEDIDLE,
                    true => MOE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDIDLE`"]
            #[inline(always)]
            pub fn is_disabled_idle(&self) -> bool {
                *self == MOE_A::DISABLEDIDLE
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MOE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MOE`"]
        pub struct MOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MOE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MOE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "OC/OCN are disabled or forced idle depending on OSSI"]
            #[inline(always)]
            pub fn disabled_idle(self) -> &'a mut W {
                self.variant(MOE_A::DISABLEDIDLE)
            }
            #[doc = "OC/OCN are enabled if CCxE/CCxNE are set"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MOE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `AOE`"]
        pub type AOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `AOE`"]
        pub struct AOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `BKP`"]
        pub type BKP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BKP`"]
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `BKE`"]
        pub type BKE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BKE`"]
        pub struct BKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Off-state selection for Run mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OSSR_A {
            #[doc = "0: When inactive, OC/OCN outputs are disabled"]
            DISABLED = 0,
            #[doc = "1: When inactive, OC/OCN outputs are enabled with their inactive level"]
            IDLELEVEL = 1,
        }
        impl From<OSSR_A> for bool {
            #[inline(always)]
            fn from(variant: OSSR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OSSR`"]
        pub type OSSR_R = crate::R<bool, OSSR_A>;
        impl OSSR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OSSR_A {
                match self.bits {
                    false => OSSR_A::DISABLED,
                    true => OSSR_A::IDLELEVEL,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OSSR_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `IDLELEVEL`"]
            #[inline(always)]
            pub fn is_idle_level(&self) -> bool {
                *self == OSSR_A::IDLELEVEL
            }
        }
        #[doc = "Write proxy for field `OSSR`"]
        pub struct OSSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSSR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "When inactive, OC/OCN outputs are disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OSSR_A::DISABLED)
            }
            #[doc = "When inactive, OC/OCN outputs are enabled with their inactive level"]
            #[inline(always)]
            pub fn idle_level(self) -> &'a mut W {
                self.variant(OSSR_A::IDLELEVEL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Off-state selection for Idle mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OSSI_A {
            #[doc = "0: When inactive, OC/OCN outputs are disabled"]
            DISABLED = 0,
            #[doc = "1: When inactive, OC/OCN outputs are forced to idle level"]
            IDLELEVEL = 1,
        }
        impl From<OSSI_A> for bool {
            #[inline(always)]
            fn from(variant: OSSI_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OSSI`"]
        pub type OSSI_R = crate::R<bool, OSSI_A>;
        impl OSSI_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OSSI_A {
                match self.bits {
                    false => OSSI_A::DISABLED,
                    true => OSSI_A::IDLELEVEL,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OSSI_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `IDLELEVEL`"]
            #[inline(always)]
            pub fn is_idle_level(&self) -> bool {
                *self == OSSI_A::IDLELEVEL
            }
        }
        #[doc = "Write proxy for field `OSSI`"]
        pub struct OSSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSI_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSSI_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "When inactive, OC/OCN outputs are disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OSSI_A::DISABLED)
            }
            #[doc = "When inactive, OC/OCN outputs are forced to idle level"]
            #[inline(always)]
            pub fn idle_level(self) -> &'a mut W {
                self.variant(OSSI_A::IDLELEVEL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `LOCK`"]
        pub type LOCK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `LOCK`"]
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DTG`"]
        pub type DTG_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DTG`"]
        pub struct DTG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DTG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Main output enable"]
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Main output enable"]
            #[inline(always)]
            pub fn moe(&mut self) -> MOE_W {
                MOE_W { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline(always)]
            pub fn aoe(&mut self) -> AOE_W {
                AOE_W { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline(always)]
            pub fn bke(&mut self) -> BKE_W {
                BKE_W { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline(always)]
            pub fn ossr(&mut self) -> OSSR_W {
                OSSR_W { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline(always)]
            pub fn ossi(&mut self) -> OSSI_W {
                OSSI_W { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline(always)]
            pub fn dtg(&mut self) -> DTG_W {
                DTG_W { w: self }
            }
        }
    }
}
#[doc = "General purpose timer"]
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM2 {}
impl TIM2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0000 as *const _
    }
}
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM2::ptr() }
    }
}
#[doc = "General purpose timer"]
pub mod tim2 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved_7_ccmr2: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved12: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR,
        #[doc = "0x38 - capture/compare register 1"]
        pub ccr2: CCR,
        #[doc = "0x3c - capture/compare register 1"]
        pub ccr3: CCR,
        #[doc = "0x40 - capture/compare register 1"]
        pub ccr4: CCR,
        _reserved16: [u8; 4usize],
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (input mode)"]
        #[inline(always)]
        pub fn ccmr2_input(&self) -> &CCMR2_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(28usize) as *const CCMR2_INPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (input mode)"]
        #[inline(always)]
        pub fn ccmr2_input_mut(&self) -> &mut CCMR2_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(28usize) as *mut CCMR2_INPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (output mode)"]
        #[inline(always)]
        pub fn ccmr2_output(&self) -> &CCMR2_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(28usize) as *const CCMR2_OUTPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (output mode)"]
        #[inline(always)]
        pub fn ccmr2_output_mut(&self) -> &mut CCMR2_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(28usize) as *mut CCMR2_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Center-aligned mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            #[doc = "0: The counter counts up or down depending on the direction bit"]
            EDGEALIGNED = 0,
            #[doc = "1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            CENTERALIGNED1 = 1,
            #[doc = "2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            CENTERALIGNED2 = 2,
            #[doc = "3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CMS`"]
        pub type CMS_R = crate::R<u8, CMS_A>;
        impl CMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `EDGEALIGNED`"]
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                *self == CMS_A::EDGEALIGNED
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED1`"]
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                *self == CMS_A::CENTERALIGNED1
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED2`"]
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                *self == CMS_A::CENTERALIGNED2
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED3`"]
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                *self == CMS_A::CENTERALIGNED3
            }
        }
        #[doc = "Write proxy for field `CMS`"]
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The counter counts up or down depending on the direction bit"]
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "Direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            #[doc = "0: Counter used as upcounter"]
            UP = 0,
            #[doc = "1: Counter used as downcounter"]
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DIR`"]
        pub type DIR_R = crate::R<bool, DIR_A>;
        impl DIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                *self == DIR_A::UP
            }
            #[doc = "Checks if the value of the field is `DOWN`"]
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                *self == DIR_A::DOWN
            }
        }
        #[doc = "Write proxy for field `DIR`"]
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter used as upcounter"]
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            #[doc = "Counter used as downcounter"]
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped at update event"]
            DISABLED = 0,
            #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "TI1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI1S_A {
            #[doc = "0: The TIMx_CH1 pin is connected to TI1 input"]
            NORMAL = 0,
            #[doc = "1: The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            XOR = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TI1S`"]
        pub type TI1S_R = crate::R<bool, TI1S_A>;
        impl TI1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::NORMAL,
                    true => TI1S_A::XOR,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == TI1S_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `XOR`"]
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                *self == TI1S_A::XOR
            }
        }
        #[doc = "Write proxy for field `TI1S`"]
        pub struct TI1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI1S_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIMx_CH1 pin is connected to TI1 input"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(TI1S_A::NORMAL)
            }
            #[doc = "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::XOR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: The UG bit from the TIMx_EGR register is used as trigger output"]
            RESET = 0,
            #[doc = "1: The counter enable signal, CNT_EN, is used as trigger output"]
            ENABLE = 1,
            #[doc = "2: The update event is selected as trigger output"]
            UPDATE = 2,
            #[doc = "3: The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            COMPAREPULSE = 3,
            #[doc = "4: OC1REF signal is used as trigger output"]
            COMPAREOC1 = 4,
            #[doc = "5: OC2REF signal is used as trigger output"]
            COMPAREOC2 = 5,
            #[doc = "6: OC3REF signal is used as trigger output"]
            COMPAREOC3 = 6,
            #[doc = "7: OC4REF signal is used as trigger output"]
            COMPAREOC4 = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::RESET,
                    1 => MMS_A::ENABLE,
                    2 => MMS_A::UPDATE,
                    3 => MMS_A::COMPAREPULSE,
                    4 => MMS_A::COMPAREOC1,
                    5 => MMS_A::COMPAREOC2,
                    6 => MMS_A::COMPAREOC3,
                    7 => MMS_A::COMPAREOC4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
            #[doc = "Checks if the value of the field is `COMPAREPULSE`"]
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                *self == MMS_A::COMPAREPULSE
            }
            #[doc = "Checks if the value of the field is `COMPAREOC1`"]
            #[inline(always)]
            pub fn is_compare_oc1(&self) -> bool {
                *self == MMS_A::COMPAREOC1
            }
            #[doc = "Checks if the value of the field is `COMPAREOC2`"]
            #[inline(always)]
            pub fn is_compare_oc2(&self) -> bool {
                *self == MMS_A::COMPAREOC2
            }
            #[doc = "Checks if the value of the field is `COMPAREOC3`"]
            #[inline(always)]
            pub fn is_compare_oc3(&self) -> bool {
                *self == MMS_A::COMPAREOC3
            }
            #[doc = "Checks if the value of the field is `COMPAREOC4`"]
            #[inline(always)]
            pub fn is_compare_oc4(&self) -> bool {
                *self == MMS_A::COMPAREOC4
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The UG bit from the TIMx_EGR register is used as trigger output"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "The counter enable signal, CNT_EN, is used as trigger output"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "The update event is selected as trigger output"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            #[doc = "OC1REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc1(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC1)
            }
            #[doc = "OC2REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc2(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC2)
            }
            #[doc = "OC3REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc3(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC3)
            }
            #[doc = "OC4REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc4(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Capture/compare DMA selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            #[doc = "0: CCx DMA request sent when CCx event occurs"]
            ONCOMPARE = 0,
            #[doc = "1: CCx DMA request sent when update event occurs"]
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCDS`"]
        pub type CCDS_R = crate::R<bool, CCDS_A>;
        impl CCDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            #[doc = "Checks if the value of the field is `ONCOMPARE`"]
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                *self == CCDS_A::ONCOMPARE
            }
            #[doc = "Checks if the value of the field is `ONUPDATE`"]
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                *self == CCDS_A::ONUPDATE
            }
        }
        #[doc = "Write proxy for field `CCDS`"]
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request sent when CCx event occurs"]
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            #[doc = "CCx DMA request sent when update event occurs"]
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - TI1 selection"]
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - TI1 selection"]
            #[inline(always)]
            pub fn ti1s(&mut self) -> TI1S_W {
                TI1S_W { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "External trigger polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            #[doc = "0: ETR is noninverted, active at high level or rising edge"]
            NOTINVERTED = 0,
            #[doc = "1: ETR is inverted, active at low level or falling edge"]
            INVERTED = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ETP`"]
        pub type ETP_R = crate::R<bool, ETP_A>;
        impl ETP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::NOTINVERTED,
                    true => ETP_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINVERTED`"]
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                *self == ETP_A::NOTINVERTED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == ETP_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `ETP`"]
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ETR is noninverted, active at high level or rising edge"]
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(ETP_A::NOTINVERTED)
            }
            #[doc = "ETR is inverted, active at low level or falling edge"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(ETP_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "External clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            #[doc = "0: External clock mode 2 disabled"]
            DISABLED = 0,
            #[doc = "1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ECE`"]
        pub type ECE_R = crate::R<bool, ECE_A>;
        impl ECE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ECE`"]
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "External clock mode 2 disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            #[doc = "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "External trigger prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            #[doc = "0: Prescaler OFF"]
            DIV1 = 0,
            #[doc = "1: ETRP frequency divided by 2"]
            DIV2 = 1,
            #[doc = "2: ETRP frequency divided by 4"]
            DIV4 = 2,
            #[doc = "3: ETRP frequency divided by 8"]
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETPS`"]
        pub type ETPS_R = crate::R<u8, ETPS_A>;
        impl ETPS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ETPS_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::DIV8
            }
        }
        #[doc = "Write proxy for field `ETPS`"]
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Prescaler OFF"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            #[doc = "ETRP frequency divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            #[doc = "ETRP frequency divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            #[doc = "ETRP frequency divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "External trigger filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETF`"]
        pub type ETF_R = crate::R<u8, ETF_A>;
        impl ETF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == ETF_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == ETF_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == ETF_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `ETF`"]
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Master/Slave mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            #[doc = "0: No action"]
            NOSYNC = 0,
            #[doc = "1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, MSM_A>;
        impl MSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `NOSYNC`"]
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                *self == MSM_A::NOSYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                *self == MSM_A::SYNC
            }
        }
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            #[doc = "0: Internal Trigger 0 (ITR0)"]
            ITR0 = 0,
            #[doc = "1: Internal Trigger 1 (ITR1)"]
            ITR1 = 1,
            #[doc = "2: Internal Trigger 2 (ITR2)"]
            ITR2 = 2,
            #[doc = "4: TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED = 4,
            #[doc = "5: Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1 = 5,
            #[doc = "6: Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2 = 6,
            #[doc = "7: External Trigger input (ETRF)"]
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, TS_A>;
        impl TS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TS_A::ITR0),
                    1 => Val(TS_A::ITR1),
                    2 => Val(TS_A::ITR2),
                    4 => Val(TS_A::TI1F_ED),
                    5 => Val(TS_A::TI1FP1),
                    6 => Val(TS_A::TI2FP2),
                    7 => Val(TS_A::ETRF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ITR0`"]
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                *self == TS_A::ITR0
            }
            #[doc = "Checks if the value of the field is `ITR1`"]
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                *self == TS_A::ITR1
            }
            #[doc = "Checks if the value of the field is `ITR2`"]
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                *self == TS_A::ITR2
            }
            #[doc = "Checks if the value of the field is `TI1F_ED`"]
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                *self == TS_A::TI1F_ED
            }
            #[doc = "Checks if the value of the field is `TI1FP1`"]
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::TI1FP1
            }
            #[doc = "Checks if the value of the field is `TI2FP2`"]
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::TI2FP2
            }
            #[doc = "Checks if the value of the field is `ETRF`"]
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                *self == TS_A::ETRF
            }
        }
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Internal Trigger 0 (ITR0)"]
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            #[doc = "Internal Trigger 1 (ITR1)"]
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            #[doc = "Internal Trigger 2 (ITR2)"]
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            #[doc = "External Trigger input (ETRF)"]
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Slave mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            #[doc = "0: Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            DISABLED = 0,
            #[doc = "1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1 = 1,
            #[doc = "2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2 = 2,
            #[doc = "3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3 = 3,
            #[doc = "4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE = 4,
            #[doc = "5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE = 5,
            #[doc = "6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE = 6,
            #[doc = "7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, SMS_A>;
        impl SMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMS_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_1`"]
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_1
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_2`"]
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_2
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_3`"]
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_3
            }
            #[doc = "Checks if the value of the field is `RESET_MODE`"]
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                *self == SMS_A::RESET_MODE
            }
            #[doc = "Checks if the value of the field is `GATED_MODE`"]
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                *self == SMS_A::GATED_MODE
            }
            #[doc = "Checks if the value of the field is `TRIGGER_MODE`"]
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                *self == SMS_A::TRIGGER_MODE
            }
            #[doc = "Checks if the value of the field is `EXT_CLOCK_MODE`"]
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                *self == SMS_A::EXT_CLOCK_MODE
            }
        }
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Reader of field `OCCS`"]
        pub type OCCS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OCCS`"]
        pub struct OCCS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OCCS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bit 3 - OCREF clear selection"]
            #[inline(always)]
            pub fn occs(&self) -> OCCS_R {
                OCCS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            #[doc = "Bit 3 - OCREF clear selection"]
            #[inline(always)]
            pub fn occs(&mut self) -> OCCS_W {
                OCCS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TDE_A {
            #[doc = "0: Trigger DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger DMA request enabled"]
            ENABLED = 1,
        }
        impl From<TDE_A> for bool {
            #[inline(always)]
            fn from(variant: TDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TDE`"]
        pub type TDE_R = crate::R<bool, TDE_A>;
        impl TDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TDE_A {
                match self.bits {
                    false => TDE_A::DISABLED,
                    true => TDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TDE`"]
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TDE_A::DISABLED)
            }
            #[doc = "Trigger DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4DE_A {
            #[doc = "0: CCx DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: CCx DMA request enabled"]
            ENABLED = 1,
        }
        impl From<CC4DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC4DE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4DE`"]
        pub type CC4DE_R = crate::R<bool, CC4DE_A>;
        impl CC4DE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4DE_A {
                match self.bits {
                    false => CC4DE_A::DISABLED,
                    true => CC4DE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC4DE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC4DE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC4DE`"]
        pub struct CC4DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 DMA request enable"]
        pub type CC3DE_A = CC4DE_A;
        #[doc = "Reader of field `CC3DE`"]
        pub type CC3DE_R = crate::R<bool, CC4DE_A>;
        #[doc = "Write proxy for field `CC3DE`"]
        pub struct CC3DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 DMA request enable"]
        pub type CC2DE_A = CC4DE_A;
        #[doc = "Reader of field `CC2DE`"]
        pub type CC2DE_R = crate::R<bool, CC4DE_A>;
        #[doc = "Write proxy for field `CC2DE`"]
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 DMA request enable"]
        pub type CC1DE_A = CC4DE_A;
        #[doc = "Reader of field `CC1DE`"]
        pub type CC1DE_R = crate::R<bool, CC4DE_A>;
        #[doc = "Write proxy for field `CC1DE`"]
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Update DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            #[doc = "0: Update DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Update DMA request enabled"]
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, UDE_A>;
        impl UDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Trigger interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            #[doc = "0: Trigger interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, TIE_A>;
        impl TIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            #[doc = "Trigger interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IE_A {
            #[doc = "0: CCx interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CCx interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CC4IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4IE`"]
        pub type CC4IE_R = crate::R<bool, CC4IE_A>;
        impl CC4IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4IE_A {
                match self.bits {
                    false => CC4IE_A::DISABLED,
                    true => CC4IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC4IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC4IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC4IE`"]
        pub struct CC4IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 interrupt enable"]
        pub type CC3IE_A = CC4IE_A;
        #[doc = "Reader of field `CC3IE`"]
        pub type CC3IE_R = crate::R<bool, CC4IE_A>;
        #[doc = "Write proxy for field `CC3IE`"]
        pub struct CC3IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt enable"]
        pub type CC2IE_A = CC4IE_A;
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, CC4IE_A>;
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 interrupt enable"]
        pub type CC1IE_A = CC4IE_A;
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, CC4IE_A>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline(always)]
            pub fn cc4de(&mut self) -> CC4DE_W {
                CC4DE_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline(always)]
            pub fn cc3de(&mut self) -> CC3DE_W {
                CC3DE_W { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline(always)]
            pub fn cc4ie(&mut self) -> CC4IE_W {
                CC4IE_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline(always)]
            pub fn cc3ie(&mut self) -> CC3IE_W {
                CC3IE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/Compare 4 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_A {
            #[doc = "1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
            OVERCAPTURE = 1,
        }
        impl From<CC4OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4OF`"]
        pub type CC4OF_R = crate::R<bool, CC4OF_A>;
        impl CC4OF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC4OF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC4OF_A::OVERCAPTURE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERCAPTURE`"]
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                *self == CC4OF_A::OVERCAPTURE
            }
        }
        #[doc = "Capture/Compare 4 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC4OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4OF`"]
        pub struct CC4OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 overcapture flag"]
        pub type CC3OF_A = CC4OF_A;
        #[doc = "Reader of field `CC3OF`"]
        pub type CC3OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/Compare 3 overcapture flag"]
        pub type CC3OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC3OF`"]
        pub struct CC3OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/compare 2 overcapture flag"]
        pub type CC2OF_A = CC4OF_A;
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/compare 2 overcapture flag"]
        pub type CC2OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_A = CC4OF_A;
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            #[doc = "0: No trigger event occurred"]
            NOTRIGGER = 0,
            #[doc = "1: Trigger interrupt pending"]
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, TIF_A>;
        impl TIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRIGGER`"]
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                *self == TIF_A::NOTRIGGER
            }
            #[doc = "Checks if the value of the field is `TRIGGER`"]
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == TIF_A::TRIGGER
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_A {
            #[doc = "1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
            MATCH = 1,
        }
        impl From<CC4IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4IF`"]
        pub type CC4IF_R = crate::R<bool, CC4IF_A>;
        impl CC4IF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC4IF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC4IF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CC4IF_A::MATCH
            }
        }
        #[doc = "Capture/Compare 4 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC4IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4IF`"]
        pub struct CC4IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 interrupt flag"]
        pub type CC3IF_A = CC4IF_A;
        #[doc = "Reader of field `CC3IF`"]
        pub type CC3IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/Compare 3 interrupt flag"]
        pub type CC3IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC3IF`"]
        pub struct CC3IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag"]
        pub type CC2IF_A = CC4IF_A;
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/Compare 2 interrupt flag"]
        pub type CC2IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_A = CC4IF_A;
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline(always)]
            pub fn cc4of(&mut self) -> CC4OF_W {
                CC4OF_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline(always)]
            pub fn cc3of(&mut self) -> CC3OF_W {
                CC3OF_W { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline(always)]
            pub fn cc4if(&mut self) -> CC4IF_W {
                CC4IF_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline(always)]
            pub fn cc3if(&mut self) -> CC3IF_W {
                CC3IF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            #[doc = "1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/compare 4 generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4G_AW {
            #[doc = "1: If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            TRIGGER = 1,
        }
        impl From<CC4G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4G_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4G`"]
        pub struct CC4G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/compare 3 generation"]
        pub type CC3G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC3G`"]
        pub struct CC3G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/compare 2 generation"]
        pub type CC2G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 generation"]
        pub type CC1G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline(always)]
            pub fn cc4g(&mut self) -> CC4G_W {
                CC4G_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline(always)]
            pub fn cc3g(&mut self) -> CC3G_W {
                CC3G_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC2CE`"]
        pub type OC2CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2CE`"]
        pub struct OC2CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output compare 2 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, OC2M_A>;
        impl OC2M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC2M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC2M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC2M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC2M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC2M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC2M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC2M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output compare 2 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            #[doc = "0: Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR2 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, OC2PE_A>;
        impl OC2PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC2PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC2PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR2 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CC2 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC2S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC2 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC1CE`"]
        pub type OC1CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1CE`"]
        pub struct OC1CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output compare 1 mode"]
        pub type OC1M_A = OC2M_A;
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, OC2M_A>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output compare 1 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC1PE_A {
            #[doc = "0: Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, OC1PE_A>;
        impl OC1PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::DISABLED,
                    true => OC1PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            #[doc = "0: CC1 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC1S_A>;
        impl CC1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC1S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC1S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC1S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC1 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline(always)]
            pub fn oc2ce(&mut self) -> OC2CE_W {
                OC2CE_W { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline(always)]
            pub fn oc1ce(&mut self) -> OC1CE_W {
                OC1CE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "1: CC2 channel is configured as input, IC2 is mapped on TI2"]
            TI2 = 1,
            #[doc = "2: CC2 channel is configured as input, IC2 is mapped on TI1"]
            TI1 = 2,
            #[doc = "3: CC2 channel is configured as input, IC2 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC2S_A::TI2),
                    2 => Val(CC2S_A::TI1),
                    3 => Val(CC2S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC2S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC2S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC2S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Input capture 1 filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC1F_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, IC1F_A>;
        impl IC1F_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NOFILTER,
                    1 => IC1F_A::FCK_INT_N2,
                    2 => IC1F_A::FCK_INT_N4,
                    3 => IC1F_A::FCK_INT_N8,
                    4 => IC1F_A::FDTS_DIV2_N6,
                    5 => IC1F_A::FDTS_DIV2_N8,
                    6 => IC1F_A::FDTS_DIV4_N6,
                    7 => IC1F_A::FDTS_DIV4_N8,
                    8 => IC1F_A::FDTS_DIV8_N6,
                    9 => IC1F_A::FDTS_DIV8_N8,
                    10 => IC1F_A::FDTS_DIV16_N5,
                    11 => IC1F_A::FDTS_DIV16_N6,
                    12 => IC1F_A::FDTS_DIV16_N8,
                    13 => IC1F_A::FDTS_DIV32_N5,
                    14 => IC1F_A::FDTS_DIV32_N6,
                    15 => IC1F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC1F_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == IC1F_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == IC1F_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == IC1F_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            #[doc = "1: CC1 channel is configured as input, IC1 is mapped on TI1"]
            TI1 = 1,
            #[doc = "2: CC1 channel is configured as input, IC1 is mapped on TI2"]
            TI2 = 2,
            #[doc = "3: CC1 channel is configured as input, IC1 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC1S_A>;
        impl CC1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC1S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC1S_A::TI1),
                    2 => Val(CC1S_A::TI2),
                    3 => Val(CC1S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC1S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC1S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC1S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC1S_A::TI1)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC1S_A::TI2)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC1S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr2_output](ccmr2_output) module"]
    pub type CCMR2_OUTPUT = crate::Reg<u32, _CCMR2_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR2_OUTPUT;
    #[doc = "`read()` method returns [ccmr2_output::R](ccmr2_output::R) reader structure"]
    impl crate::Readable for CCMR2_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr2_output::W](ccmr2_output::W) writer structure"]
    impl crate::Writable for CCMR2_OUTPUT {}
    #[doc = "capture/compare mode register 2 (output mode)"]
    pub mod ccmr2_output {
        #[doc = "Reader of register CCMR2_Output"]
        pub type R = crate::R<u32, super::CCMR2_OUTPUT>;
        #[doc = "Writer for register CCMR2_Output"]
        pub type W = crate::W<u32, super::CCMR2_OUTPUT>;
        #[doc = "Register CCMR2_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR2_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC4CE`"]
        pub type OC4CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC4CE`"]
        pub struct OC4CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output compare 4 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC4M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC4M`"]
        pub type OC4M_R = crate::R<u8, OC4M_A>;
        impl OC4M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::FROZEN,
                    1 => OC4M_A::ACTIVEONMATCH,
                    2 => OC4M_A::INACTIVEONMATCH,
                    3 => OC4M_A::TOGGLE,
                    4 => OC4M_A::FORCEINACTIVE,
                    5 => OC4M_A::FORCEACTIVE,
                    6 => OC4M_A::PWMMODE1,
                    7 => OC4M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC4M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC4M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC4M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC4M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC4M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC4M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC4M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC4M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC4M`"]
        pub struct OC4M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC4M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output compare 4 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC4PE_A {
            #[doc = "0: Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR4 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC4PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC4PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC4PE`"]
        pub type OC4PE_R = crate::R<bool, OC4PE_A>;
        impl OC4PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC4PE_A {
                match self.bits {
                    false => OC4PE_A::DISABLED,
                    true => OC4PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC4PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC4PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC4PE`"]
        pub struct OC4PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC4PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC4PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR4 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC4PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC4FE`"]
        pub type OC4FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC4FE`"]
        pub struct OC4FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            #[doc = "0: CC4 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC4S`"]
        pub type CC4S_R = crate::R<u8, CC4S_A>;
        impl CC4S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC4S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC4S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC4S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC4S`"]
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC4 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC3CE`"]
        pub type OC3CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC3CE`"]
        pub struct OC3CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output compare 3 mode"]
        pub type OC3M_A = OC4M_A;
        #[doc = "Reader of field `OC3M`"]
        pub type OC3M_R = crate::R<u8, OC4M_A>;
        #[doc = "Write proxy for field `OC3M`"]
        pub struct OC3M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC3M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output compare 3 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC3PE_A {
            #[doc = "0: Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR3 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC3PE`"]
        pub type OC3PE_R = crate::R<bool, OC3PE_A>;
        impl OC3PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::DISABLED,
                    true => OC3PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC3PE`"]
        pub struct OC3PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC3PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR3 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC3FE`"]
        pub type OC3FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC3FE`"]
        pub struct OC3FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            #[doc = "0: CC3 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC3S`"]
        pub type CC3S_R = crate::R<u8, CC3S_A>;
        impl CC3S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC3S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC3S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC3S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC3S`"]
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC3 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline(always)]
            pub fn oc4ce(&mut self) -> OC4CE_W {
                OC4CE_W { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline(always)]
            pub fn oc4m(&mut self) -> OC4M_W {
                OC4M_W { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline(always)]
            pub fn oc4pe(&mut self) -> OC4PE_W {
                OC4PE_W { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline(always)]
            pub fn oc4fe(&mut self) -> OC4FE_W {
                OC4FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline(always)]
            pub fn oc3ce(&mut self) -> OC3CE_W {
                OC3CE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline(always)]
            pub fn oc3m(&mut self) -> OC3M_W {
                OC3M_W { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline(always)]
            pub fn oc3pe(&mut self) -> OC3PE_W {
                OC3PE_W { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline(always)]
            pub fn oc3fe(&mut self) -> OC3FE_W {
                OC3FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr2_input](ccmr2_input) module"]
    pub type CCMR2_INPUT = crate::Reg<u32, _CCMR2_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR2_INPUT;
    #[doc = "`read()` method returns [ccmr2_input::R](ccmr2_input::R) reader structure"]
    impl crate::Readable for CCMR2_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr2_input::W](ccmr2_input::W) writer structure"]
    impl crate::Writable for CCMR2_INPUT {}
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = "Reader of register CCMR2_Input"]
        pub type R = crate::R<u32, super::CCMR2_INPUT>;
        #[doc = "Writer for register CCMR2_Input"]
        pub type W = crate::W<u32, super::CCMR2_INPUT>;
        #[doc = "Register CCMR2_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR2_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC4F`"]
        pub type IC4F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC4F`"]
        pub struct IC4F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC4PSC`"]
        pub type IC4PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC4PSC`"]
        pub struct IC4PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            #[doc = "1: CC4 channel is configured as input, IC4 is mapped on TI4"]
            TI4 = 1,
            #[doc = "2: CC4 channel is configured as input, IC4 is mapped on TI3"]
            TI3 = 2,
            #[doc = "3: CC4 channel is configured as input, IC4 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC4S`"]
        pub type CC4S_R = crate::R<u8, CC4S_A>;
        impl CC4S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC4S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC4S_A::TI4),
                    2 => Val(CC4S_A::TI3),
                    3 => Val(CC4S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                *self == CC4S_A::TI4
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                *self == CC4S_A::TI3
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC4S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC4S`"]
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI4"]
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC4S_A::TI4)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI3"]
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC4S_A::TI3)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC4S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `IC3F`"]
        pub type IC3F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC3F`"]
        pub struct IC3F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC3PSC`"]
        pub type IC3PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC3PSC`"]
        pub struct IC3PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            #[doc = "1: CC3 channel is configured as input, IC3 is mapped on TI3"]
            TI3 = 1,
            #[doc = "2: CC3 channel is configured as input, IC3 is mapped on TI4"]
            TI4 = 2,
            #[doc = "3: CC3 channel is configured as input, IC3 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC3S`"]
        pub type CC3S_R = crate::R<u8, CC3S_A>;
        impl CC3S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC3S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC3S_A::TI3),
                    2 => Val(CC3S_A::TI4),
                    3 => Val(CC3S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                *self == CC3S_A::TI3
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                *self == CC3S_A::TI4
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC3S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC3S`"]
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI3"]
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC3S_A::TI3)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI4"]
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC3S_A::TI4)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC3S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline(always)]
            pub fn ic4f(&mut self) -> IC4F_W {
                IC4F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline(always)]
            pub fn ic4psc(&mut self) -> IC4PSC_W {
                IC4PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline(always)]
            pub fn ic3f(&mut self) -> IC3F_W {
                IC3F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline(always)]
            pub fn ic3psc(&mut self) -> IC3PSC_W {
                IC3PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC4P`"]
        pub type CC4P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC4P`"]
        pub struct CC4P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `CC4E`"]
        pub type CC4E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC4E`"]
        pub struct CC4E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `CC3P`"]
        pub type CC3P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC3P`"]
        pub struct CC3P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `CC3E`"]
        pub type CC3E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC3E`"]
        pub struct CC3E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc4p(&mut self) -> CC4P_W {
                CC4P_W { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline(always)]
            pub fn cc4e(&mut self) -> CC4E_W {
                CC4E_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3p(&mut self) -> CC3P_W {
                CC3P_W { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline(always)]
            pub fn cc3e(&mut self) -> CC3E_W {
                CC3E_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
    #[doc = "DMA control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dcr](dcr) module"]
    pub type DCR = crate::Reg<u32, _DCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DCR;
    #[doc = "`read()` method returns [dcr::R](dcr::R) reader structure"]
    impl crate::Readable for DCR {}
    #[doc = "`write(|w| ..)` method takes [dcr::W](dcr::W) writer structure"]
    impl crate::Writable for DCR {}
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = "Reader of register DCR"]
        pub type R = crate::R<u32, super::DCR>;
        #[doc = "Writer for register DCR"]
        pub type W = crate::W<u32, super::DCR>;
        #[doc = "Register DCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DBL`"]
        pub type DBL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBL`"]
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DBA`"]
        pub type DBA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBA`"]
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmar](dmar) module"]
    pub type DMAR = crate::Reg<u32, _DMAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMAR;
    #[doc = "`read()` method returns [dmar::R](dmar::R) reader structure"]
    impl crate::Readable for DMAR {}
    #[doc = "`write(|w| ..)` method takes [dmar::W](dmar::W) writer structure"]
    impl crate::Writable for DMAR {}
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = "Reader of register DMAR"]
        pub type R = crate::R<u32, super::DMAR>;
        #[doc = "Writer for register DMAR"]
        pub type W = crate::W<u32, super::DMAR>;
        #[doc = "Register DMAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DMAB`"]
        pub type DMAB_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DMAB`"]
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
        }
    }
}
#[doc = "General purpose timer"]
pub struct TIM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM3 {}
impl TIM3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0400 as *const _
    }
}
impl Deref for TIM3 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM3::ptr() }
    }
}
#[doc = "General purpose timer"]
pub struct TIM4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM4 {}
impl TIM4 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0800 as *const _
    }
}
impl Deref for TIM4 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM4::ptr() }
    }
}
#[doc = "General purpose timer"]
pub struct TIM5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM5 {}
impl TIM5 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0c00 as *const _
    }
}
impl Deref for TIM5 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM5::ptr() }
    }
}
#[doc = "General purpose timer"]
pub struct TIM12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM12 {}
impl TIM12 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim12::RegisterBlock {
        0x4000_1800 as *const _
    }
}
impl Deref for TIM12 {
    type Target = tim12::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM12::ptr() }
    }
}
#[doc = "General purpose timer"]
pub mod tim12 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved7: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved11: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR,
        #[doc = "0x38 - capture/compare register 1"]
        pub ccr2: CCR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped at update event"]
            DISABLED = 0,
            #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:14 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:14 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC2NP`"]
        pub type CC2NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2NP`"]
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
}
#[doc = "General purpose timer"]
pub struct TIM13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM13 {}
impl TIM13 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim13::RegisterBlock {
        0x4000_1c00 as *const _
    }
}
impl Deref for TIM13 {
    type Target = tim13::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM13::ptr() }
    }
}
#[doc = "General purpose timer"]
pub mod tim13 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        _reserved1: [u8; 8usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_4_ccmr1: [u8; 4usize],
        _reserved5: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved9: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
}
#[doc = "General purpose timer"]
pub struct TIM14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM14 {}
impl TIM14 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim13::RegisterBlock {
        0x4000_2000 as *const _
    }
}
impl Deref for TIM14 {
    type Target = tim13::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM14::ptr() }
    }
}
#[doc = "Basic timer"]
pub struct TIM6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM6 {}
impl TIM6 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim6::RegisterBlock {
        0x4000_1000 as *const _
    }
}
impl Deref for TIM6 {
    type Target = tim6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM6::ptr() }
    }
}
#[doc = "Basic timer"]
pub mod tim6 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        _reserved2: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved5: [u8; 12usize],
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped at update event"]
            DISABLED = 0,
            #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: Use UG bit from TIMx_EGR register"]
            RESET = 0,
            #[doc = "1: Use CNT bit from TIMx_CEN register"]
            ENABLE = 1,
            #[doc = "2: Use the update event"]
            UPDATE = 2,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MMS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MMS_A::RESET),
                    1 => Val(MMS_A::ENABLE),
                    2 => Val(MMS_A::UPDATE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Use UG bit from TIMx_EGR register"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "Use CNT bit from TIMx_CEN register"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "Use the update event"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            #[doc = "0: Update DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Update DMA request enabled"]
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, UDE_A>;
        impl UDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
}
#[doc = "Basic timer"]
pub struct TIM7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM7 {}
impl TIM7 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim6::RegisterBlock {
        0x4000_1400 as *const _
    }
}
impl Deref for TIM7 {
    type Target = tim6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM7::ptr() }
    }
}
#[doc = "Inter integrated circuit"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_5400 as *const _
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C1::ptr() }
    }
}
#[doc = "Inter integrated circuit"]
pub mod i2c1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - Own address register 1"]
        pub oar1: OAR1,
        #[doc = "0x0c - Own address register 2"]
        pub oar2: OAR2,
        #[doc = "0x10 - Data register"]
        pub dr: DR,
        #[doc = "0x14 - Status register 1"]
        pub sr1: SR1,
        #[doc = "0x18 - Status register 2"]
        pub sr2: SR2,
        #[doc = "0x1c - Clock control register"]
        pub ccr: CCR,
        #[doc = "0x20 - TRISE register"]
        pub trise: TRISE,
    }
    #[doc = "Control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Software reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWRST_A {
            #[doc = "0: I2C peripheral not under reset"]
            NOTRESET = 0,
            #[doc = "1: I2C peripheral under reset"]
            RESET = 1,
        }
        impl From<SWRST_A> for bool {
            #[inline(always)]
            fn from(variant: SWRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SWRST`"]
        pub type SWRST_R = crate::R<bool, SWRST_A>;
        impl SWRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SWRST_A {
                match self.bits {
                    false => SWRST_A::NOTRESET,
                    true => SWRST_A::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRESET`"]
            #[inline(always)]
            pub fn is_not_reset(&self) -> bool {
                *self == SWRST_A::NOTRESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == SWRST_A::RESET
            }
        }
        #[doc = "Write proxy for field `SWRST`"]
        pub struct SWRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "I2C peripheral not under reset"]
            #[inline(always)]
            pub fn not_reset(self) -> &'a mut W {
                self.variant(SWRST_A::NOTRESET)
            }
            #[doc = "I2C peripheral under reset"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SWRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "SMBus alert\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALERT_A {
            #[doc = "0: SMBA pin released high"]
            RELEASE = 0,
            #[doc = "1: SMBA pin driven low"]
            DRIVE = 1,
        }
        impl From<ALERT_A> for bool {
            #[inline(always)]
            fn from(variant: ALERT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALERT`"]
        pub type ALERT_R = crate::R<bool, ALERT_A>;
        impl ALERT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALERT_A {
                match self.bits {
                    false => ALERT_A::RELEASE,
                    true => ALERT_A::DRIVE,
                }
            }
            #[doc = "Checks if the value of the field is `RELEASE`"]
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == ALERT_A::RELEASE
            }
            #[doc = "Checks if the value of the field is `DRIVE`"]
            #[inline(always)]
            pub fn is_drive(&self) -> bool {
                *self == ALERT_A::DRIVE
            }
        }
        #[doc = "Write proxy for field `ALERT`"]
        pub struct ALERT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALERT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALERT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "SMBA pin released high"]
            #[inline(always)]
            pub fn release(self) -> &'a mut W {
                self.variant(ALERT_A::RELEASE)
            }
            #[doc = "SMBA pin driven low"]
            #[inline(always)]
            pub fn drive(self) -> &'a mut W {
                self.variant(ALERT_A::DRIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Packet error checking\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEC_A {
            #[doc = "0: No PEC transfer"]
            DISABLED = 0,
            #[doc = "1: PEC transfer"]
            ENABLED = 1,
        }
        impl From<PEC_A> for bool {
            #[inline(always)]
            fn from(variant: PEC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PEC`"]
        pub type PEC_R = crate::R<bool, PEC_A>;
        impl PEC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PEC_A {
                match self.bits {
                    false => PEC_A::DISABLED,
                    true => PEC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PEC`"]
        pub struct PEC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PEC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No PEC transfer"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEC_A::DISABLED)
            }
            #[doc = "PEC transfer"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Acknowledge/PEC Position (for data reception)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POS_A {
            #[doc = "0: ACK bit controls the (N)ACK of the current byte being received"]
            CURRENT = 0,
            #[doc = "1: ACK bit controls the (N)ACK of the next byte to be received"]
            NEXT = 1,
        }
        impl From<POS_A> for bool {
            #[inline(always)]
            fn from(variant: POS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `POS`"]
        pub type POS_R = crate::R<bool, POS_A>;
        impl POS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> POS_A {
                match self.bits {
                    false => POS_A::CURRENT,
                    true => POS_A::NEXT,
                }
            }
            #[doc = "Checks if the value of the field is `CURRENT`"]
            #[inline(always)]
            pub fn is_current(&self) -> bool {
                *self == POS_A::CURRENT
            }
            #[doc = "Checks if the value of the field is `NEXT`"]
            #[inline(always)]
            pub fn is_next(&self) -> bool {
                *self == POS_A::NEXT
            }
        }
        #[doc = "Write proxy for field `POS`"]
        pub struct POS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: POS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ACK bit controls the (N)ACK of the current byte being received"]
            #[inline(always)]
            pub fn current(self) -> &'a mut W {
                self.variant(POS_A::CURRENT)
            }
            #[doc = "ACK bit controls the (N)ACK of the next byte to be received"]
            #[inline(always)]
            pub fn next(self) -> &'a mut W {
                self.variant(POS_A::NEXT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Acknowledge enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACK_A {
            #[doc = "0: No acknowledge returned"]
            NAK = 0,
            #[doc = "1: Acknowledge returned after a byte is received"]
            ACK = 1,
        }
        impl From<ACK_A> for bool {
            #[inline(always)]
            fn from(variant: ACK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ACK`"]
        pub type ACK_R = crate::R<bool, ACK_A>;
        impl ACK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ACK_A {
                match self.bits {
                    false => ACK_A::NAK,
                    true => ACK_A::ACK,
                }
            }
            #[doc = "Checks if the value of the field is `NAK`"]
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == ACK_A::NAK
            }
            #[doc = "Checks if the value of the field is `ACK`"]
            #[inline(always)]
            pub fn is_ack(&self) -> bool {
                *self == ACK_A::ACK
            }
        }
        #[doc = "Write proxy for field `ACK`"]
        pub struct ACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No acknowledge returned"]
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(ACK_A::NAK)
            }
            #[doc = "Acknowledge returned after a byte is received"]
            #[inline(always)]
            pub fn ack(self) -> &'a mut W {
                self.variant(ACK_A::ACK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Stop generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOP_A {
            #[doc = "0: No Stop generation"]
            NOSTOP = 0,
            #[doc = "1: In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"]
            STOP = 1,
        }
        impl From<STOP_A> for bool {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STOP`"]
        pub type STOP_R = crate::R<bool, STOP_A>;
        impl STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    false => STOP_A::NOSTOP,
                    true => STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTOP`"]
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                *self == STOP_A::NOSTOP
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `STOP`"]
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No Stop generation"]
            #[inline(always)]
            pub fn no_stop(self) -> &'a mut W {
                self.variant(STOP_A::NOSTOP)
            }
            #[doc = "In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Start generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum START_A {
            #[doc = "0: No Start generation"]
            NOSTART = 0,
            #[doc = "1: In master mode: repeated start generation, in slave mode: start generation when bus is free"]
            START = 1,
        }
        impl From<START_A> for bool {
            #[inline(always)]
            fn from(variant: START_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `START`"]
        pub type START_R = crate::R<bool, START_A>;
        impl START_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> START_A {
                match self.bits {
                    false => START_A::NOSTART,
                    true => START_A::START,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTART`"]
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                *self == START_A::NOSTART
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == START_A::START
            }
        }
        #[doc = "Write proxy for field `START`"]
        pub struct START_W<'a> {
            w: &'a mut W,
        }
        impl<'a> START_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: START_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No Start generation"]
            #[inline(always)]
            pub fn no_start(self) -> &'a mut W {
                self.variant(START_A::NOSTART)
            }
            #[doc = "In master mode: repeated start generation, in slave mode: start generation when bus is free"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(START_A::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Clock stretching disable (Slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOSTRETCH_A {
            #[doc = "0: Clock stretching enabled"]
            ENABLED = 0,
            #[doc = "1: Clock stretching disabled"]
            DISABLED = 1,
        }
        impl From<NOSTRETCH_A> for bool {
            #[inline(always)]
            fn from(variant: NOSTRETCH_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NOSTRETCH`"]
        pub type NOSTRETCH_R = crate::R<bool, NOSTRETCH_A>;
        impl NOSTRETCH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NOSTRETCH_A {
                match self.bits {
                    false => NOSTRETCH_A::ENABLED,
                    true => NOSTRETCH_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NOSTRETCH_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NOSTRETCH_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `NOSTRETCH`"]
        pub struct NOSTRETCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NOSTRETCH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NOSTRETCH_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock stretching enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::ENABLED)
            }
            #[doc = "Clock stretching disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "General call enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENGC_A {
            #[doc = "0: General call disabled"]
            DISABLED = 0,
            #[doc = "1: General call enabled"]
            ENABLED = 1,
        }
        impl From<ENGC_A> for bool {
            #[inline(always)]
            fn from(variant: ENGC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENGC`"]
        pub type ENGC_R = crate::R<bool, ENGC_A>;
        impl ENGC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENGC_A {
                match self.bits {
                    false => ENGC_A::DISABLED,
                    true => ENGC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENGC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENGC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENGC`"]
        pub struct ENGC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENGC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENGC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "General call disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENGC_A::DISABLED)
            }
            #[doc = "General call enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENGC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "PEC enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENPEC_A {
            #[doc = "0: PEC calculation disabled"]
            DISABLED = 0,
            #[doc = "1: PEC calculation enabled"]
            ENABLED = 1,
        }
        impl From<ENPEC_A> for bool {
            #[inline(always)]
            fn from(variant: ENPEC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENPEC`"]
        pub type ENPEC_R = crate::R<bool, ENPEC_A>;
        impl ENPEC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENPEC_A {
                match self.bits {
                    false => ENPEC_A::DISABLED,
                    true => ENPEC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENPEC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENPEC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENPEC`"]
        pub struct ENPEC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENPEC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENPEC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PEC calculation disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENPEC_A::DISABLED)
            }
            #[doc = "PEC calculation enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENPEC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "ARP enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENARP_A {
            #[doc = "0: ARP disabled"]
            DISABLED = 0,
            #[doc = "1: ARP enabled"]
            ENABLED = 1,
        }
        impl From<ENARP_A> for bool {
            #[inline(always)]
            fn from(variant: ENARP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENARP`"]
        pub type ENARP_R = crate::R<bool, ENARP_A>;
        impl ENARP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENARP_A {
                match self.bits {
                    false => ENARP_A::DISABLED,
                    true => ENARP_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENARP_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENARP_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENARP`"]
        pub struct ENARP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENARP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENARP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ARP disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENARP_A::DISABLED)
            }
            #[doc = "ARP enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENARP_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "SMBus type\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBTYPE_A {
            #[doc = "0: SMBus Device"]
            DEVICE = 0,
            #[doc = "1: SMBus Host"]
            HOST = 1,
        }
        impl From<SMBTYPE_A> for bool {
            #[inline(always)]
            fn from(variant: SMBTYPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SMBTYPE`"]
        pub type SMBTYPE_R = crate::R<bool, SMBTYPE_A>;
        impl SMBTYPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMBTYPE_A {
                match self.bits {
                    false => SMBTYPE_A::DEVICE,
                    true => SMBTYPE_A::HOST,
                }
            }
            #[doc = "Checks if the value of the field is `DEVICE`"]
            #[inline(always)]
            pub fn is_device(&self) -> bool {
                *self == SMBTYPE_A::DEVICE
            }
            #[doc = "Checks if the value of the field is `HOST`"]
            #[inline(always)]
            pub fn is_host(&self) -> bool {
                *self == SMBTYPE_A::HOST
            }
        }
        #[doc = "Write proxy for field `SMBTYPE`"]
        pub struct SMBTYPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBTYPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMBTYPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "SMBus Device"]
            #[inline(always)]
            pub fn device(self) -> &'a mut W {
                self.variant(SMBTYPE_A::DEVICE)
            }
            #[doc = "SMBus Host"]
            #[inline(always)]
            pub fn host(self) -> &'a mut W {
                self.variant(SMBTYPE_A::HOST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "SMBus mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBUS_A {
            #[doc = "0: I2C Mode"]
            I2C = 0,
            #[doc = "1: SMBus"]
            SMBUS = 1,
        }
        impl From<SMBUS_A> for bool {
            #[inline(always)]
            fn from(variant: SMBUS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SMBUS`"]
        pub type SMBUS_R = crate::R<bool, SMBUS_A>;
        impl SMBUS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMBUS_A {
                match self.bits {
                    false => SMBUS_A::I2C,
                    true => SMBUS_A::SMBUS,
                }
            }
            #[doc = "Checks if the value of the field is `I2C`"]
            #[inline(always)]
            pub fn is_i2c(&self) -> bool {
                *self == SMBUS_A::I2C
            }
            #[doc = "Checks if the value of the field is `SMBUS`"]
            #[inline(always)]
            pub fn is_smbus(&self) -> bool {
                *self == SMBUS_A::SMBUS
            }
        }
        #[doc = "Write proxy for field `SMBUS`"]
        pub struct SMBUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBUS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMBUS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "I2C Mode"]
            #[inline(always)]
            pub fn i2c(self) -> &'a mut W {
                self.variant(SMBUS_A::I2C)
            }
            #[doc = "SMBus"]
            #[inline(always)]
            pub fn smbus(self) -> &'a mut W {
                self.variant(SMBUS_A::SMBUS)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Peripheral enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PE_A {
            #[doc = "0: Peripheral disabled"]
            DISABLED = 0,
            #[doc = "1: Peripheral enabled"]
            ENABLED = 1,
        }
        impl From<PE_A> for bool {
            #[inline(always)]
            fn from(variant: PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, PE_A>;
        impl PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PE_A {
                match self.bits {
                    false => PE_A::DISABLED,
                    true => PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PE`"]
        pub struct PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Peripheral disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PE_A::DISABLED)
            }
            #[doc = "Peripheral enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Software reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 13 - SMBus alert"]
            #[inline(always)]
            pub fn alert(&self) -> ALERT_R {
                ALERT_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Packet error checking"]
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"]
            #[inline(always)]
            pub fn pos(&self) -> POS_R {
                POS_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Acknowledge enable"]
            #[inline(always)]
            pub fn ack(&self) -> ACK_R {
                ACK_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Stop generation"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Start generation"]
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Clock stretching disable (Slave mode)"]
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - General call enable"]
            #[inline(always)]
            pub fn engc(&self) -> ENGC_R {
                ENGC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - PEC enable"]
            #[inline(always)]
            pub fn enpec(&self) -> ENPEC_R {
                ENPEC_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - ARP enable"]
            #[inline(always)]
            pub fn enarp(&self) -> ENARP_R {
                ENARP_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - SMBus type"]
            #[inline(always)]
            pub fn smbtype(&self) -> SMBTYPE_R {
                SMBTYPE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 1 - SMBus mode"]
            #[inline(always)]
            pub fn smbus(&self) -> SMBUS_R {
                SMBUS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Software reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> SWRST_W {
                SWRST_W { w: self }
            }
            #[doc = "Bit 13 - SMBus alert"]
            #[inline(always)]
            pub fn alert(&mut self) -> ALERT_W {
                ALERT_W { w: self }
            }
            #[doc = "Bit 12 - Packet error checking"]
            #[inline(always)]
            pub fn pec(&mut self) -> PEC_W {
                PEC_W { w: self }
            }
            #[doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"]
            #[inline(always)]
            pub fn pos(&mut self) -> POS_W {
                POS_W { w: self }
            }
            #[doc = "Bit 10 - Acknowledge enable"]
            #[inline(always)]
            pub fn ack(&mut self) -> ACK_W {
                ACK_W { w: self }
            }
            #[doc = "Bit 9 - Stop generation"]
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            #[doc = "Bit 8 - Start generation"]
            #[inline(always)]
            pub fn start(&mut self) -> START_W {
                START_W { w: self }
            }
            #[doc = "Bit 7 - Clock stretching disable (Slave mode)"]
            #[inline(always)]
            pub fn nostretch(&mut self) -> NOSTRETCH_W {
                NOSTRETCH_W { w: self }
            }
            #[doc = "Bit 6 - General call enable"]
            #[inline(always)]
            pub fn engc(&mut self) -> ENGC_W {
                ENGC_W { w: self }
            }
            #[doc = "Bit 5 - PEC enable"]
            #[inline(always)]
            pub fn enpec(&mut self) -> ENPEC_W {
                ENPEC_W { w: self }
            }
            #[doc = "Bit 4 - ARP enable"]
            #[inline(always)]
            pub fn enarp(&mut self) -> ENARP_W {
                ENARP_W { w: self }
            }
            #[doc = "Bit 3 - SMBus type"]
            #[inline(always)]
            pub fn smbtype(&mut self) -> SMBTYPE_W {
                SMBTYPE_W { w: self }
            }
            #[doc = "Bit 1 - SMBus mode"]
            #[inline(always)]
            pub fn smbus(&mut self) -> SMBUS_W {
                SMBUS_W { w: self }
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W {
                PE_W { w: self }
            }
        }
    }
    #[doc = "Control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DMA last transfer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LAST_A {
            #[doc = "0: Next DMA EOT is not the last transfer"]
            NOTLAST = 0,
            #[doc = "1: Next DMA EOT is the last transfer"]
            LAST = 1,
        }
        impl From<LAST_A> for bool {
            #[inline(always)]
            fn from(variant: LAST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LAST`"]
        pub type LAST_R = crate::R<bool, LAST_A>;
        impl LAST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LAST_A {
                match self.bits {
                    false => LAST_A::NOTLAST,
                    true => LAST_A::LAST,
                }
            }
            #[doc = "Checks if the value of the field is `NOTLAST`"]
            #[inline(always)]
            pub fn is_not_last(&self) -> bool {
                *self == LAST_A::NOTLAST
            }
            #[doc = "Checks if the value of the field is `LAST`"]
            #[inline(always)]
            pub fn is_last(&self) -> bool {
                *self == LAST_A::LAST
            }
        }
        #[doc = "Write proxy for field `LAST`"]
        pub struct LAST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LAST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Next DMA EOT is not the last transfer"]
            #[inline(always)]
            pub fn not_last(self) -> &'a mut W {
                self.variant(LAST_A::NOTLAST)
            }
            #[doc = "Next DMA EOT is the last transfer"]
            #[inline(always)]
            pub fn last(self) -> &'a mut W {
                self.variant(LAST_A::LAST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "DMA requests enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN_A {
            #[doc = "0: DMA requests disabled"]
            DISABLED = 0,
            #[doc = "1: DMA request enabled when TxE=1 or RxNE=1"]
            ENABLED = 1,
        }
        impl From<DMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAEN`"]
        pub type DMAEN_R = crate::R<bool, DMAEN_A>;
        impl DMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAEN_A {
                match self.bits {
                    false => DMAEN_A::DISABLED,
                    true => DMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAEN`"]
        pub struct DMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA requests disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN_A::DISABLED)
            }
            #[doc = "DMA request enabled when TxE=1 or RxNE=1"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Buffer interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITBUFEN_A {
            #[doc = "0: TxE=1 or RxNE=1 does not generate any interrupt"]
            DISABLED = 0,
            #[doc = "1: TxE=1 or RxNE=1 generates Event interrupt"]
            ENABLED = 1,
        }
        impl From<ITBUFEN_A> for bool {
            #[inline(always)]
            fn from(variant: ITBUFEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ITBUFEN`"]
        pub type ITBUFEN_R = crate::R<bool, ITBUFEN_A>;
        impl ITBUFEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ITBUFEN_A {
                match self.bits {
                    false => ITBUFEN_A::DISABLED,
                    true => ITBUFEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ITBUFEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ITBUFEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ITBUFEN`"]
        pub struct ITBUFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ITBUFEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ITBUFEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TxE=1 or RxNE=1 does not generate any interrupt"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITBUFEN_A::DISABLED)
            }
            #[doc = "TxE=1 or RxNE=1 generates Event interrupt"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITBUFEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Event interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITEVTEN_A {
            #[doc = "0: Event interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Event interrupt enabled"]
            ENABLED = 1,
        }
        impl From<ITEVTEN_A> for bool {
            #[inline(always)]
            fn from(variant: ITEVTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ITEVTEN`"]
        pub type ITEVTEN_R = crate::R<bool, ITEVTEN_A>;
        impl ITEVTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ITEVTEN_A {
                match self.bits {
                    false => ITEVTEN_A::DISABLED,
                    true => ITEVTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ITEVTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ITEVTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ITEVTEN`"]
        pub struct ITEVTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ITEVTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ITEVTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Event interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITEVTEN_A::DISABLED)
            }
            #[doc = "Event interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITEVTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITERREN_A {
            #[doc = "0: Error interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Error interrupt enabled"]
            ENABLED = 1,
        }
        impl From<ITERREN_A> for bool {
            #[inline(always)]
            fn from(variant: ITERREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ITERREN`"]
        pub type ITERREN_R = crate::R<bool, ITERREN_A>;
        impl ITERREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ITERREN_A {
                match self.bits {
                    false => ITERREN_A::DISABLED,
                    true => ITERREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ITERREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ITERREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ITERREN`"]
        pub struct ITERREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ITERREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ITERREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITERREN_A::DISABLED)
            }
            #[doc = "Error interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITERREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `FREQ`"]
        pub type FREQ_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `FREQ`"]
        pub struct FREQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FREQ_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | ((value as u32) & 0x3f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 12 - DMA last transfer"]
            #[inline(always)]
            pub fn last(&self) -> LAST_R {
                LAST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - DMA requests enable"]
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Buffer interrupt enable"]
            #[inline(always)]
            pub fn itbufen(&self) -> ITBUFEN_R {
                ITBUFEN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Event interrupt enable"]
            #[inline(always)]
            pub fn itevten(&self) -> ITEVTEN_R {
                ITEVTEN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Error interrupt enable"]
            #[inline(always)]
            pub fn iterren(&self) -> ITERREN_R {
                ITERREN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bits 0:5 - Peripheral clock frequency"]
            #[inline(always)]
            pub fn freq(&self) -> FREQ_R {
                FREQ_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 12 - DMA last transfer"]
            #[inline(always)]
            pub fn last(&mut self) -> LAST_W {
                LAST_W { w: self }
            }
            #[doc = "Bit 11 - DMA requests enable"]
            #[inline(always)]
            pub fn dmaen(&mut self) -> DMAEN_W {
                DMAEN_W { w: self }
            }
            #[doc = "Bit 10 - Buffer interrupt enable"]
            #[inline(always)]
            pub fn itbufen(&mut self) -> ITBUFEN_W {
                ITBUFEN_W { w: self }
            }
            #[doc = "Bit 9 - Event interrupt enable"]
            #[inline(always)]
            pub fn itevten(&mut self) -> ITEVTEN_W {
                ITEVTEN_W { w: self }
            }
            #[doc = "Bit 8 - Error interrupt enable"]
            #[inline(always)]
            pub fn iterren(&mut self) -> ITERREN_W {
                ITERREN_W { w: self }
            }
            #[doc = "Bits 0:5 - Peripheral clock frequency"]
            #[inline(always)]
            pub fn freq(&mut self) -> FREQ_W {
                FREQ_W { w: self }
            }
        }
    }
    #[doc = "Own address register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [oar1](oar1) module"]
    pub type OAR1 = crate::Reg<u32, _OAR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OAR1;
    #[doc = "`read()` method returns [oar1::R](oar1::R) reader structure"]
    impl crate::Readable for OAR1 {}
    #[doc = "`write(|w| ..)` method takes [oar1::W](oar1::W) writer structure"]
    impl crate::Writable for OAR1 {}
    #[doc = "Own address register 1"]
    pub mod oar1 {
        #[doc = "Reader of register OAR1"]
        pub type R = crate::R<u32, super::OAR1>;
        #[doc = "Writer for register OAR1"]
        pub type W = crate::W<u32, super::OAR1>;
        #[doc = "Register OAR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::OAR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Addressing mode (slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDMODE_A {
            #[doc = "0: 7-bit slave address"]
            ADD7 = 0,
            #[doc = "1: 10-bit slave address"]
            ADD10 = 1,
        }
        impl From<ADDMODE_A> for bool {
            #[inline(always)]
            fn from(variant: ADDMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDMODE`"]
        pub type ADDMODE_R = crate::R<bool, ADDMODE_A>;
        impl ADDMODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDMODE_A {
                match self.bits {
                    false => ADDMODE_A::ADD7,
                    true => ADDMODE_A::ADD10,
                }
            }
            #[doc = "Checks if the value of the field is `ADD7`"]
            #[inline(always)]
            pub fn is_add7(&self) -> bool {
                *self == ADDMODE_A::ADD7
            }
            #[doc = "Checks if the value of the field is `ADD10`"]
            #[inline(always)]
            pub fn is_add10(&self) -> bool {
                *self == ADDMODE_A::ADD10
            }
        }
        #[doc = "Write proxy for field `ADDMODE`"]
        pub struct ADDMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDMODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDMODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "7-bit slave address"]
            #[inline(always)]
            pub fn add7(self) -> &'a mut W {
                self.variant(ADDMODE_A::ADD7)
            }
            #[doc = "10-bit slave address"]
            #[inline(always)]
            pub fn add10(self) -> &'a mut W {
                self.variant(ADDMODE_A::ADD10)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03ff) | ((value as u32) & 0x03ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Addressing mode (slave mode)"]
            #[inline(always)]
            pub fn addmode(&self) -> ADDMODE_R {
                ADDMODE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 0:9 - Interface address"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bit 15 - Addressing mode (slave mode)"]
            #[inline(always)]
            pub fn addmode(&mut self) -> ADDMODE_W {
                ADDMODE_W { w: self }
            }
            #[doc = "Bits 0:9 - Interface address"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
        }
    }
    #[doc = "Own address register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [oar2](oar2) module"]
    pub type OAR2 = crate::Reg<u32, _OAR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OAR2;
    #[doc = "`read()` method returns [oar2::R](oar2::R) reader structure"]
    impl crate::Readable for OAR2 {}
    #[doc = "`write(|w| ..)` method takes [oar2::W](oar2::W) writer structure"]
    impl crate::Writable for OAR2 {}
    #[doc = "Own address register 2"]
    pub mod oar2 {
        #[doc = "Reader of register OAR2"]
        pub type R = crate::R<u32, super::OAR2>;
        #[doc = "Writer for register OAR2"]
        pub type W = crate::W<u32, super::OAR2>;
        #[doc = "Register OAR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::OAR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ADD2`"]
        pub type ADD2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADD2`"]
        pub struct ADD2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x7f << 1)) | (((value as u32) & 0x7f) << 1);
                self.w
            }
        }
        #[doc = "Dual addressing mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDUAL_A {
            #[doc = "0: Single addressing mode"]
            SINGLE = 0,
            #[doc = "1: Dual addressing mode"]
            DUAL = 1,
        }
        impl From<ENDUAL_A> for bool {
            #[inline(always)]
            fn from(variant: ENDUAL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENDUAL`"]
        pub type ENDUAL_R = crate::R<bool, ENDUAL_A>;
        impl ENDUAL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENDUAL_A {
                match self.bits {
                    false => ENDUAL_A::SINGLE,
                    true => ENDUAL_A::DUAL,
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == ENDUAL_A::SINGLE
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline(always)]
            pub fn is_dual(&self) -> bool {
                *self == ENDUAL_A::DUAL
            }
        }
        #[doc = "Write proxy for field `ENDUAL`"]
        pub struct ENDUAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENDUAL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENDUAL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Single addressing mode"]
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(ENDUAL_A::SINGLE)
            }
            #[doc = "Dual addressing mode"]
            #[inline(always)]
            pub fn dual(self) -> &'a mut W {
                self.variant(ENDUAL_A::DUAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 1:7 - Interface address"]
            #[inline(always)]
            pub fn add2(&self) -> ADD2_R {
                ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            #[doc = "Bit 0 - Dual addressing mode enable"]
            #[inline(always)]
            pub fn endual(&self) -> ENDUAL_R {
                ENDUAL_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 1:7 - Interface address"]
            #[inline(always)]
            pub fn add2(&mut self) -> ADD2_W {
                ADD2_W { w: self }
            }
            #[doc = "Bit 0 - Dual addressing mode enable"]
            #[inline(always)]
            pub fn endual(&mut self) -> ENDUAL_W {
                ENDUAL_W { w: self }
            }
        }
    }
    #[doc = "Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - 8-bit data register"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - 8-bit data register"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "Status register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr1](sr1) module"]
    pub type SR1 = crate::Reg<u32, _SR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR1;
    #[doc = "`read()` method returns [sr1::R](sr1::R) reader structure"]
    impl crate::Readable for SR1 {}
    #[doc = "`write(|w| ..)` method takes [sr1::W](sr1::W) writer structure"]
    impl crate::Writable for SR1 {}
    #[doc = "Status register 1"]
    pub mod sr1 {
        #[doc = "Reader of register SR1"]
        pub type R = crate::R<u32, super::SR1>;
        #[doc = "Writer for register SR1"]
        pub type W = crate::W<u32, super::SR1>;
        #[doc = "Register SR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "SMBus alert\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBALERT_A {
            #[doc = "0: No SMBALERT occured"]
            NOALERT = 0,
            #[doc = "1: SMBALERT occurred"]
            ALERT = 1,
        }
        impl From<SMBALERT_A> for bool {
            #[inline(always)]
            fn from(variant: SMBALERT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SMBALERT`"]
        pub type SMBALERT_R = crate::R<bool, SMBALERT_A>;
        impl SMBALERT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMBALERT_A {
                match self.bits {
                    false => SMBALERT_A::NOALERT,
                    true => SMBALERT_A::ALERT,
                }
            }
            #[doc = "Checks if the value of the field is `NOALERT`"]
            #[inline(always)]
            pub fn is_no_alert(&self) -> bool {
                *self == SMBALERT_A::NOALERT
            }
            #[doc = "Checks if the value of the field is `ALERT`"]
            #[inline(always)]
            pub fn is_alert(&self) -> bool {
                *self == SMBALERT_A::ALERT
            }
        }
        #[doc = "Write proxy for field `SMBALERT`"]
        pub struct SMBALERT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBALERT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMBALERT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No SMBALERT occured"]
            #[inline(always)]
            pub fn no_alert(self) -> &'a mut W {
                self.variant(SMBALERT_A::NOALERT)
            }
            #[doc = "SMBALERT occurred"]
            #[inline(always)]
            pub fn alert(self) -> &'a mut W {
                self.variant(SMBALERT_A::ALERT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Timeout or Tlow error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUT_A {
            #[doc = "0: No Timeout error"]
            NOTIMEOUT = 0,
            #[doc = "1: SCL remained LOW for 25 ms"]
            TIMEOUT = 1,
        }
        impl From<TIMEOUT_A> for bool {
            #[inline(always)]
            fn from(variant: TIMEOUT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIMEOUT`"]
        pub type TIMEOUT_R = crate::R<bool, TIMEOUT_A>;
        impl TIMEOUT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIMEOUT_A {
                match self.bits {
                    false => TIMEOUT_A::NOTIMEOUT,
                    true => TIMEOUT_A::TIMEOUT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTIMEOUT`"]
            #[inline(always)]
            pub fn is_no_timeout(&self) -> bool {
                *self == TIMEOUT_A::NOTIMEOUT
            }
            #[doc = "Checks if the value of the field is `TIMEOUT`"]
            #[inline(always)]
            pub fn is_timeout(&self) -> bool {
                *self == TIMEOUT_A::TIMEOUT
            }
        }
        #[doc = "Write proxy for field `TIMEOUT`"]
        pub struct TIMEOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMEOUT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIMEOUT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No Timeout error"]
            #[inline(always)]
            pub fn no_timeout(self) -> &'a mut W {
                self.variant(TIMEOUT_A::NOTIMEOUT)
            }
            #[doc = "SCL remained LOW for 25 ms"]
            #[inline(always)]
            pub fn timeout(self) -> &'a mut W {
                self.variant(TIMEOUT_A::TIMEOUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "PEC Error in reception\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECERR_A {
            #[doc = "0: no PEC error: receiver returns ACK after PEC reception (if ACK=1)"]
            NOERROR = 0,
            #[doc = "1: PEC error: receiver returns NACK after PEC reception (whatever ACK)"]
            ERROR = 1,
        }
        impl From<PECERR_A> for bool {
            #[inline(always)]
            fn from(variant: PECERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PECERR`"]
        pub type PECERR_R = crate::R<bool, PECERR_A>;
        impl PECERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PECERR_A {
                match self.bits {
                    false => PECERR_A::NOERROR,
                    true => PECERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == PECERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == PECERR_A::ERROR
            }
        }
        #[doc = "Write proxy for field `PECERR`"]
        pub struct PECERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PECERR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "no PEC error: receiver returns ACK after PEC reception (if ACK=1)"]
            #[inline(always)]
            pub fn no_error(self) -> &'a mut W {
                self.variant(PECERR_A::NOERROR)
            }
            #[doc = "PEC error: receiver returns NACK after PEC reception (whatever ACK)"]
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(PECERR_A::ERROR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Overrun/Underrun\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            #[doc = "0: No overrun/underrun occured"]
            NOOVERRUN = 0,
            #[doc = "1: Overrun/underrun occured"]
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVR`"]
        pub type OVR_R = crate::R<bool, OVR_A>;
        impl OVR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOOVERRUN`"]
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVR_A::NOOVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVR_A::OVERRUN
            }
        }
        #[doc = "Write proxy for field `OVR`"]
        pub struct OVR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No overrun/underrun occured"]
            #[inline(always)]
            pub fn no_overrun(self) -> &'a mut W {
                self.variant(OVR_A::NOOVERRUN)
            }
            #[doc = "Overrun/underrun occured"]
            #[inline(always)]
            pub fn overrun(self) -> &'a mut W {
                self.variant(OVR_A::OVERRUN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Acknowledge failure\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AF_A {
            #[doc = "0: No acknowledge failure"]
            NOFAILURE = 0,
            #[doc = "1: Acknowledge failure"]
            FAILURE = 1,
        }
        impl From<AF_A> for bool {
            #[inline(always)]
            fn from(variant: AF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AF`"]
        pub type AF_R = crate::R<bool, AF_A>;
        impl AF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AF_A {
                match self.bits {
                    false => AF_A::NOFAILURE,
                    true => AF_A::FAILURE,
                }
            }
            #[doc = "Checks if the value of the field is `NOFAILURE`"]
            #[inline(always)]
            pub fn is_no_failure(&self) -> bool {
                *self == AF_A::NOFAILURE
            }
            #[doc = "Checks if the value of the field is `FAILURE`"]
            #[inline(always)]
            pub fn is_failure(&self) -> bool {
                *self == AF_A::FAILURE
            }
        }
        #[doc = "Write proxy for field `AF`"]
        pub struct AF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No acknowledge failure"]
            #[inline(always)]
            pub fn no_failure(self) -> &'a mut W {
                self.variant(AF_A::NOFAILURE)
            }
            #[doc = "Acknowledge failure"]
            #[inline(always)]
            pub fn failure(self) -> &'a mut W {
                self.variant(AF_A::FAILURE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Arbitration lost (master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARLO_A {
            #[doc = "0: No Arbitration Lost detected"]
            NOLOST = 0,
            #[doc = "1: Arbitration Lost detected"]
            LOST = 1,
        }
        impl From<ARLO_A> for bool {
            #[inline(always)]
            fn from(variant: ARLO_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARLO`"]
        pub type ARLO_R = crate::R<bool, ARLO_A>;
        impl ARLO_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARLO_A {
                match self.bits {
                    false => ARLO_A::NOLOST,
                    true => ARLO_A::LOST,
                }
            }
            #[doc = "Checks if the value of the field is `NOLOST`"]
            #[inline(always)]
            pub fn is_no_lost(&self) -> bool {
                *self == ARLO_A::NOLOST
            }
            #[doc = "Checks if the value of the field is `LOST`"]
            #[inline(always)]
            pub fn is_lost(&self) -> bool {
                *self == ARLO_A::LOST
            }
        }
        #[doc = "Write proxy for field `ARLO`"]
        pub struct ARLO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARLO_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARLO_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No Arbitration Lost detected"]
            #[inline(always)]
            pub fn no_lost(self) -> &'a mut W {
                self.variant(ARLO_A::NOLOST)
            }
            #[doc = "Arbitration Lost detected"]
            #[inline(always)]
            pub fn lost(self) -> &'a mut W {
                self.variant(ARLO_A::LOST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Bus error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BERR_A {
            #[doc = "0: No misplaced Start or Stop condition"]
            NOERROR = 0,
            #[doc = "1: Misplaced Start or Stop condition"]
            ERROR = 1,
        }
        impl From<BERR_A> for bool {
            #[inline(always)]
            fn from(variant: BERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BERR`"]
        pub type BERR_R = crate::R<bool, BERR_A>;
        impl BERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BERR_A {
                match self.bits {
                    false => BERR_A::NOERROR,
                    true => BERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == BERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == BERR_A::ERROR
            }
        }
        #[doc = "Write proxy for field `BERR`"]
        pub struct BERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BERR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No misplaced Start or Stop condition"]
            #[inline(always)]
            pub fn no_error(self) -> &'a mut W {
                self.variant(BERR_A::NOERROR)
            }
            #[doc = "Misplaced Start or Stop condition"]
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(BERR_A::ERROR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Data register empty (transmitters)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXE_A {
            #[doc = "0: Data register not empty"]
            NOTEMPTY = 0,
            #[doc = "1: Data register empty"]
            EMPTY = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TxE`"]
        pub type TXE_R = crate::R<bool, TXE_A>;
        impl TXE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NOTEMPTY,
                    true => TXE_A::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TXE_A::NOTEMPTY
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TXE_A::EMPTY
            }
        }
        #[doc = "Data register not empty (receivers)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNE_A {
            #[doc = "0: Data register empty"]
            EMPTY = 0,
            #[doc = "1: Data register not empty"]
            NOTEMPTY = 1,
        }
        impl From<RXNE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RxNE`"]
        pub type RXNE_R = crate::R<bool, RXNE_A>;
        impl RXNE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNE_A {
                match self.bits {
                    false => RXNE_A::EMPTY,
                    true => RXNE_A::NOTEMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RXNE_A::EMPTY
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == RXNE_A::NOTEMPTY
            }
        }
        #[doc = "Stop detection (slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPF_A {
            #[doc = "0: No Stop condition detected"]
            NOSTOP = 0,
            #[doc = "1: Stop condition detected"]
            STOP = 1,
        }
        impl From<STOPF_A> for bool {
            #[inline(always)]
            fn from(variant: STOPF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STOPF`"]
        pub type STOPF_R = crate::R<bool, STOPF_A>;
        impl STOPF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOPF_A {
                match self.bits {
                    false => STOPF_A::NOSTOP,
                    true => STOPF_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTOP`"]
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                *self == STOPF_A::NOSTOP
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == STOPF_A::STOP
            }
        }
        #[doc = "Reader of field `ADD10`"]
        pub type ADD10_R = crate::R<bool, bool>;
        #[doc = "Byte transfer finished\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BTF_A {
            #[doc = "0: Data byte transfer not done"]
            NOTFINISHED = 0,
            #[doc = "1: Data byte transfer successful"]
            FINISHED = 1,
        }
        impl From<BTF_A> for bool {
            #[inline(always)]
            fn from(variant: BTF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BTF`"]
        pub type BTF_R = crate::R<bool, BTF_A>;
        impl BTF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BTF_A {
                match self.bits {
                    false => BTF_A::NOTFINISHED,
                    true => BTF_A::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTFINISHED`"]
            #[inline(always)]
            pub fn is_not_finished(&self) -> bool {
                *self == BTF_A::NOTFINISHED
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                *self == BTF_A::FINISHED
            }
        }
        #[doc = "Address sent (master mode)/matched (slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_A {
            #[doc = "0: Adress mismatched or not received"]
            NOTMATCH = 0,
            #[doc = "1: Received slave address matched with one of the enabled slave addresses"]
            MATCH = 1,
        }
        impl From<ADDR_A> for bool {
            #[inline(always)]
            fn from(variant: ADDR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDR`"]
        pub type ADDR_R = crate::R<bool, ADDR_A>;
        impl ADDR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDR_A {
                match self.bits {
                    false => ADDR_A::NOTMATCH,
                    true => ADDR_A::MATCH,
                }
            }
            #[doc = "Checks if the value of the field is `NOTMATCH`"]
            #[inline(always)]
            pub fn is_not_match(&self) -> bool {
                *self == ADDR_A::NOTMATCH
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == ADDR_A::MATCH
            }
        }
        #[doc = "Start bit (Master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SB_A {
            #[doc = "0: No Start condition"]
            NOSTART = 0,
            #[doc = "1: Start condition generated"]
            START = 1,
        }
        impl From<SB_A> for bool {
            #[inline(always)]
            fn from(variant: SB_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SB`"]
        pub type SB_R = crate::R<bool, SB_A>;
        impl SB_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SB_A {
                match self.bits {
                    false => SB_A::NOSTART,
                    true => SB_A::START,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTART`"]
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                *self == SB_A::NOSTART
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == SB_A::START
            }
        }
        impl R {
            #[doc = "Bit 15 - SMBus alert"]
            #[inline(always)]
            pub fn smbalert(&self) -> SMBALERT_R {
                SMBALERT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Timeout or Tlow error"]
            #[inline(always)]
            pub fn timeout(&self) -> TIMEOUT_R {
                TIMEOUT_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - PEC Error in reception"]
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Overrun/Underrun"]
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Acknowledge failure"]
            #[inline(always)]
            pub fn af(&self) -> AF_R {
                AF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Arbitration lost (master mode)"]
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Data register empty (transmitters)"]
            #[inline(always)]
            pub fn tx_e(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Data register not empty (receivers)"]
            #[inline(always)]
            pub fn rx_ne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Stop detection (slave mode)"]
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - 10-bit header sent (Master mode)"]
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Byte transfer finished"]
            #[inline(always)]
            pub fn btf(&self) -> BTF_R {
                BTF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Address sent (master mode)/matched (slave mode)"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Start bit (Master mode)"]
            #[inline(always)]
            pub fn sb(&self) -> SB_R {
                SB_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - SMBus alert"]
            #[inline(always)]
            pub fn smbalert(&mut self) -> SMBALERT_W {
                SMBALERT_W { w: self }
            }
            #[doc = "Bit 14 - Timeout or Tlow error"]
            #[inline(always)]
            pub fn timeout(&mut self) -> TIMEOUT_W {
                TIMEOUT_W { w: self }
            }
            #[doc = "Bit 12 - PEC Error in reception"]
            #[inline(always)]
            pub fn pecerr(&mut self) -> PECERR_W {
                PECERR_W { w: self }
            }
            #[doc = "Bit 11 - Overrun/Underrun"]
            #[inline(always)]
            pub fn ovr(&mut self) -> OVR_W {
                OVR_W { w: self }
            }
            #[doc = "Bit 10 - Acknowledge failure"]
            #[inline(always)]
            pub fn af(&mut self) -> AF_W {
                AF_W { w: self }
            }
            #[doc = "Bit 9 - Arbitration lost (master mode)"]
            #[inline(always)]
            pub fn arlo(&mut self) -> ARLO_W {
                ARLO_W { w: self }
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline(always)]
            pub fn berr(&mut self) -> BERR_W {
                BERR_W { w: self }
            }
        }
    }
    #[doc = "Status register 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr2](sr2) module"]
    pub type SR2 = crate::Reg<u32, _SR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR2;
    #[doc = "`read()` method returns [sr2::R](sr2::R) reader structure"]
    impl crate::Readable for SR2 {}
    #[doc = "Status register 2"]
    pub mod sr2 {
        #[doc = "Reader of register SR2"]
        pub type R = crate::R<u32, super::SR2>;
        #[doc = "Reader of field `PEC`"]
        pub type PEC_R = crate::R<u8, u8>;
        #[doc = "Reader of field `DUALF`"]
        pub type DUALF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `SMBHOST`"]
        pub type SMBHOST_R = crate::R<bool, bool>;
        #[doc = "Reader of field `SMBDEFAULT`"]
        pub type SMBDEFAULT_R = crate::R<bool, bool>;
        #[doc = "Reader of field `GENCALL`"]
        pub type GENCALL_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TRA`"]
        pub type TRA_R = crate::R<bool, bool>;
        #[doc = "Reader of field `BUSY`"]
        pub type BUSY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `MSL`"]
        pub type MSL_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bits 8:15 - acket error checking register"]
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bit 7 - Dual flag (Slave mode)"]
            #[inline(always)]
            pub fn dualf(&self) -> DUALF_R {
                DUALF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - SMBus host header (Slave mode)"]
            #[inline(always)]
            pub fn smbhost(&self) -> SMBHOST_R {
                SMBHOST_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - SMBus device default address (Slave mode)"]
            #[inline(always)]
            pub fn smbdefault(&self) -> SMBDEFAULT_R {
                SMBDEFAULT_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - General call address (Slave mode)"]
            #[inline(always)]
            pub fn gencall(&self) -> GENCALL_R {
                GENCALL_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Transmitter/receiver"]
            #[inline(always)]
            pub fn tra(&self) -> TRA_R {
                TRA_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Bus busy"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Master/slave"]
            #[inline(always)]
            pub fn msl(&self) -> MSL_R {
                MSL_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clock control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "Clock control register"]
    pub mod ccr {
        #[doc = "Reader of register CCR"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "I2C master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum F_S_A {
            #[doc = "0: Standard mode I2C"]
            STANDARD = 0,
            #[doc = "1: Fast mode I2C"]
            FAST = 1,
        }
        impl From<F_S_A> for bool {
            #[inline(always)]
            fn from(variant: F_S_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `F_S`"]
        pub type F_S_R = crate::R<bool, F_S_A>;
        impl F_S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> F_S_A {
                match self.bits {
                    false => F_S_A::STANDARD,
                    true => F_S_A::FAST,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == F_S_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FAST`"]
            #[inline(always)]
            pub fn is_fast(&self) -> bool {
                *self == F_S_A::FAST
            }
        }
        #[doc = "Write proxy for field `F_S`"]
        pub struct F_S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> F_S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: F_S_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Standard mode I2C"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(F_S_A::STANDARD)
            }
            #[doc = "Fast mode I2C"]
            #[inline(always)]
            pub fn fast(self) -> &'a mut W {
                self.variant(F_S_A::FAST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Fast mode duty cycle\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DUTY_A {
            #[doc = "0: Duty cycle t_low/t_high = 2/1"]
            DUTY2_1 = 0,
            #[doc = "1: Duty cycle t_low/t_high = 16/9"]
            DUTY16_9 = 1,
        }
        impl From<DUTY_A> for bool {
            #[inline(always)]
            fn from(variant: DUTY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DUTY`"]
        pub type DUTY_R = crate::R<bool, DUTY_A>;
        impl DUTY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DUTY_A {
                match self.bits {
                    false => DUTY_A::DUTY2_1,
                    true => DUTY_A::DUTY16_9,
                }
            }
            #[doc = "Checks if the value of the field is `DUTY2_1`"]
            #[inline(always)]
            pub fn is_duty2_1(&self) -> bool {
                *self == DUTY_A::DUTY2_1
            }
            #[doc = "Checks if the value of the field is `DUTY16_9`"]
            #[inline(always)]
            pub fn is_duty16_9(&self) -> bool {
                *self == DUTY_A::DUTY16_9
            }
        }
        #[doc = "Write proxy for field `DUTY`"]
        pub struct DUTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DUTY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DUTY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Duty cycle t_low/t_high = 2/1"]
            #[inline(always)]
            pub fn duty2_1(self) -> &'a mut W {
                self.variant(DUTY_A::DUTY2_1)
            }
            #[doc = "Duty cycle t_low/t_high = 16/9"]
            #[inline(always)]
            pub fn duty16_9(self) -> &'a mut W {
                self.variant(DUTY_A::DUTY16_9)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - I2C master mode selection"]
            #[inline(always)]
            pub fn f_s(&self) -> F_S_R {
                F_S_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Fast mode duty cycle"]
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bit 15 - I2C master mode selection"]
            #[inline(always)]
            pub fn f_s(&mut self) -> F_S_W {
                F_S_W { w: self }
            }
            #[doc = "Bit 14 - Fast mode duty cycle"]
            #[inline(always)]
            pub fn duty(&mut self) -> DUTY_W {
                DUTY_W { w: self }
            }
            #[doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
    #[doc = "TRISE register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trise](trise) module"]
    pub type TRISE = crate::Reg<u32, _TRISE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TRISE;
    #[doc = "`read()` method returns [trise::R](trise::R) reader structure"]
    impl crate::Readable for TRISE {}
    #[doc = "`write(|w| ..)` method takes [trise::W](trise::W) writer structure"]
    impl crate::Writable for TRISE {}
    #[doc = "TRISE register"]
    pub mod trise {
        #[doc = "Reader of register TRISE"]
        pub type R = crate::R<u32, super::TRISE>;
        #[doc = "Writer for register TRISE"]
        pub type W = crate::W<u32, super::TRISE>;
        #[doc = "Register TRISE `reset()`'s with value 0x02"]
        impl crate::ResetValue for super::TRISE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x02
            }
        }
        #[doc = "Reader of field `TRISE`"]
        pub type TRISE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TRISE`"]
        pub struct TRISE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRISE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | ((value as u32) & 0x3f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)"]
            #[inline(always)]
            pub fn trise(&self) -> TRISE_R {
                TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)"]
            #[inline(always)]
            pub fn trise(&mut self) -> TRISE_W {
                TRISE_W { w: self }
            }
        }
    }
}
#[doc = "Inter integrated circuit"]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_5800 as *const _
    }
}
impl Deref for I2C2 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C2::ptr() }
    }
}
#[doc = "Serial peripheral interface"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        0x4001_3000 as *const _
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "Serial peripheral interface"]
pub mod spi1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - status register"]
        pub sr: SR,
        #[doc = "0x0c - data register"]
        pub dr: DR,
        #[doc = "0x10 - CRC polynomial register"]
        pub crcpr: CRCPR,
        #[doc = "0x14 - RX CRC register"]
        pub rxcrcr: RXCRCR,
        #[doc = "0x18 - TX CRC register"]
        pub txcrcr: TXCRCR,
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Bidirectional data mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIMODE_A {
            #[doc = "0: 2-line unidirectional data mode selected"]
            UNIDIRECTIONAL = 0,
            #[doc = "1: 1-line bidirectional data mode selected"]
            BIDIRECTIONAL = 1,
        }
        impl From<BIDIMODE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BIDIMODE`"]
        pub type BIDIMODE_R = crate::R<bool, BIDIMODE_A>;
        impl BIDIMODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BIDIMODE_A {
                match self.bits {
                    false => BIDIMODE_A::UNIDIRECTIONAL,
                    true => BIDIMODE_A::BIDIRECTIONAL,
                }
            }
            #[doc = "Checks if the value of the field is `UNIDIRECTIONAL`"]
            #[inline(always)]
            pub fn is_unidirectional(&self) -> bool {
                *self == BIDIMODE_A::UNIDIRECTIONAL
            }
            #[doc = "Checks if the value of the field is `BIDIRECTIONAL`"]
            #[inline(always)]
            pub fn is_bidirectional(&self) -> bool {
                *self == BIDIMODE_A::BIDIRECTIONAL
            }
        }
        #[doc = "Write proxy for field `BIDIMODE`"]
        pub struct BIDIMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIDIMODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIDIMODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "2-line unidirectional data mode selected"]
            #[inline(always)]
            pub fn unidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::UNIDIRECTIONAL)
            }
            #[doc = "1-line bidirectional data mode selected"]
            #[inline(always)]
            pub fn bidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::BIDIRECTIONAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output enable in bidirectional mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIOE_A {
            #[doc = "0: Output disabled (receive-only mode)"]
            OUTPUTDISABLED = 0,
            #[doc = "1: Output enabled (transmit-only mode)"]
            OUTPUTENABLED = 1,
        }
        impl From<BIDIOE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIOE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BIDIOE`"]
        pub type BIDIOE_R = crate::R<bool, BIDIOE_A>;
        impl BIDIOE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BIDIOE_A {
                match self.bits {
                    false => BIDIOE_A::OUTPUTDISABLED,
                    true => BIDIOE_A::OUTPUTENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUTDISABLED`"]
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                *self == BIDIOE_A::OUTPUTDISABLED
            }
            #[doc = "Checks if the value of the field is `OUTPUTENABLED`"]
            #[inline(always)]
            pub fn is_output_enabled(&self) -> bool {
                *self == BIDIOE_A::OUTPUTENABLED
            }
        }
        #[doc = "Write proxy for field `BIDIOE`"]
        pub struct BIDIOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIDIOE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIDIOE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output disabled (receive-only mode)"]
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OUTPUTDISABLED)
            }
            #[doc = "Output enabled (transmit-only mode)"]
            #[inline(always)]
            pub fn output_enabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OUTPUTENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Hardware CRC calculation enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCEN_A {
            #[doc = "0: CRC calculation disabled"]
            DISABLED = 0,
            #[doc = "1: CRC calculation enabled"]
            ENABLED = 1,
        }
        impl From<CRCEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCEN`"]
        pub type CRCEN_R = crate::R<bool, CRCEN_A>;
        impl CRCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCEN_A {
                match self.bits {
                    false => CRCEN_A::DISABLED,
                    true => CRCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CRCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CRCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CRCEN`"]
        pub struct CRCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CRC calculation disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRCEN_A::DISABLED)
            }
            #[doc = "CRC calculation enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "CRC transfer next\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCNEXT_A {
            #[doc = "0: Next transmit value is from Tx buffer"]
            TXBUFFER = 0,
            #[doc = "1: Next transmit value is from Tx CRC register"]
            CRC = 1,
        }
        impl From<CRCNEXT_A> for bool {
            #[inline(always)]
            fn from(variant: CRCNEXT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCNEXT`"]
        pub type CRCNEXT_R = crate::R<bool, CRCNEXT_A>;
        impl CRCNEXT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCNEXT_A {
                match self.bits {
                    false => CRCNEXT_A::TXBUFFER,
                    true => CRCNEXT_A::CRC,
                }
            }
            #[doc = "Checks if the value of the field is `TXBUFFER`"]
            #[inline(always)]
            pub fn is_tx_buffer(&self) -> bool {
                *self == CRCNEXT_A::TXBUFFER
            }
            #[doc = "Checks if the value of the field is `CRC`"]
            #[inline(always)]
            pub fn is_crc(&self) -> bool {
                *self == CRCNEXT_A::CRC
            }
        }
        #[doc = "Write proxy for field `CRCNEXT`"]
        pub struct CRCNEXT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCNEXT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCNEXT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Next transmit value is from Tx buffer"]
            #[inline(always)]
            pub fn tx_buffer(self) -> &'a mut W {
                self.variant(CRCNEXT_A::TXBUFFER)
            }
            #[doc = "Next transmit value is from Tx CRC register"]
            #[inline(always)]
            pub fn crc(self) -> &'a mut W {
                self.variant(CRCNEXT_A::CRC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Data frame format\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DFF_A {
            #[doc = "0: 8-bit data frame format is selected for transmission/reception"]
            EIGHTBIT = 0,
            #[doc = "1: 16-bit data frame format is selected for transmission/reception"]
            SIXTEENBIT = 1,
        }
        impl From<DFF_A> for bool {
            #[inline(always)]
            fn from(variant: DFF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DFF`"]
        pub type DFF_R = crate::R<bool, DFF_A>;
        impl DFF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DFF_A {
                match self.bits {
                    false => DFF_A::EIGHTBIT,
                    true => DFF_A::SIXTEENBIT,
                }
            }
            #[doc = "Checks if the value of the field is `EIGHTBIT`"]
            #[inline(always)]
            pub fn is_eight_bit(&self) -> bool {
                *self == DFF_A::EIGHTBIT
            }
            #[doc = "Checks if the value of the field is `SIXTEENBIT`"]
            #[inline(always)]
            pub fn is_sixteen_bit(&self) -> bool {
                *self == DFF_A::SIXTEENBIT
            }
        }
        #[doc = "Write proxy for field `DFF`"]
        pub struct DFF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DFF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "8-bit data frame format is selected for transmission/reception"]
            #[inline(always)]
            pub fn eight_bit(self) -> &'a mut W {
                self.variant(DFF_A::EIGHTBIT)
            }
            #[doc = "16-bit data frame format is selected for transmission/reception"]
            #[inline(always)]
            pub fn sixteen_bit(self) -> &'a mut W {
                self.variant(DFF_A::SIXTEENBIT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Receive only\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXONLY_A {
            #[doc = "0: Full duplex (Transmit and receive)"]
            FULLDUPLEX = 0,
            #[doc = "1: Output disabled (Receive-only mode)"]
            OUTPUTDISABLED = 1,
        }
        impl From<RXONLY_A> for bool {
            #[inline(always)]
            fn from(variant: RXONLY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXONLY`"]
        pub type RXONLY_R = crate::R<bool, RXONLY_A>;
        impl RXONLY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXONLY_A {
                match self.bits {
                    false => RXONLY_A::FULLDUPLEX,
                    true => RXONLY_A::OUTPUTDISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `FULLDUPLEX`"]
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                *self == RXONLY_A::FULLDUPLEX
            }
            #[doc = "Checks if the value of the field is `OUTPUTDISABLED`"]
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                *self == RXONLY_A::OUTPUTDISABLED
            }
        }
        #[doc = "Write proxy for field `RXONLY`"]
        pub struct RXONLY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXONLY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXONLY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Full duplex (Transmit and receive)"]
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(RXONLY_A::FULLDUPLEX)
            }
            #[doc = "Output disabled (Receive-only mode)"]
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(RXONLY_A::OUTPUTDISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Software slave management\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSM_A {
            #[doc = "0: Software slave management disabled"]
            DISABLED = 0,
            #[doc = "1: Software slave management enabled"]
            ENABLED = 1,
        }
        impl From<SSM_A> for bool {
            #[inline(always)]
            fn from(variant: SSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SSM`"]
        pub type SSM_R = crate::R<bool, SSM_A>;
        impl SSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SSM_A {
                match self.bits {
                    false => SSM_A::DISABLED,
                    true => SSM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SSM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SSM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SSM`"]
        pub struct SSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Software slave management disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSM_A::DISABLED)
            }
            #[doc = "Software slave management enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Internal slave select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSI_A {
            #[doc = "0: 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            SLAVESELECTED = 0,
            #[doc = "1: 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            SLAVENOTSELECTED = 1,
        }
        impl From<SSI_A> for bool {
            #[inline(always)]
            fn from(variant: SSI_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SSI`"]
        pub type SSI_R = crate::R<bool, SSI_A>;
        impl SSI_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SSI_A {
                match self.bits {
                    false => SSI_A::SLAVESELECTED,
                    true => SSI_A::SLAVENOTSELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVESELECTED`"]
            #[inline(always)]
            pub fn is_slave_selected(&self) -> bool {
                *self == SSI_A::SLAVESELECTED
            }
            #[doc = "Checks if the value of the field is `SLAVENOTSELECTED`"]
            #[inline(always)]
            pub fn is_slave_not_selected(&self) -> bool {
                *self == SSI_A::SLAVENOTSELECTED
            }
        }
        #[doc = "Write proxy for field `SSI`"]
        pub struct SSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSI_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            #[inline(always)]
            pub fn slave_selected(self) -> &'a mut W {
                self.variant(SSI_A::SLAVESELECTED)
            }
            #[doc = "1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            #[inline(always)]
            pub fn slave_not_selected(self) -> &'a mut W {
                self.variant(SSI_A::SLAVENOTSELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Frame format\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSBFIRST_A {
            #[doc = "0: Data is transmitted/received with the MSB first"]
            MSBFIRST = 0,
            #[doc = "1: Data is transmitted/received with the LSB first"]
            LSBFIRST = 1,
        }
        impl From<LSBFIRST_A> for bool {
            #[inline(always)]
            fn from(variant: LSBFIRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSBFIRST`"]
        pub type LSBFIRST_R = crate::R<bool, LSBFIRST_A>;
        impl LSBFIRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSBFIRST_A {
                match self.bits {
                    false => LSBFIRST_A::MSBFIRST,
                    true => LSBFIRST_A::LSBFIRST,
                }
            }
            #[doc = "Checks if the value of the field is `MSBFIRST`"]
            #[inline(always)]
            pub fn is_msbfirst(&self) -> bool {
                *self == LSBFIRST_A::MSBFIRST
            }
            #[doc = "Checks if the value of the field is `LSBFIRST`"]
            #[inline(always)]
            pub fn is_lsbfirst(&self) -> bool {
                *self == LSBFIRST_A::LSBFIRST
            }
        }
        #[doc = "Write proxy for field `LSBFIRST`"]
        pub struct LSBFIRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSBFIRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSBFIRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Data is transmitted/received with the MSB first"]
            #[inline(always)]
            pub fn msbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::MSBFIRST)
            }
            #[doc = "Data is transmitted/received with the LSB first"]
            #[inline(always)]
            pub fn lsbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::LSBFIRST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "SPI enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPE_A {
            #[doc = "0: Peripheral disabled"]
            DISABLED = 0,
            #[doc = "1: Peripheral enabled"]
            ENABLED = 1,
        }
        impl From<SPE_A> for bool {
            #[inline(always)]
            fn from(variant: SPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SPE`"]
        pub type SPE_R = crate::R<bool, SPE_A>;
        impl SPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SPE_A {
                match self.bits {
                    false => SPE_A::DISABLED,
                    true => SPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SPE`"]
        pub struct SPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Peripheral disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPE_A::DISABLED)
            }
            #[doc = "Peripheral enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Baud rate control\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum BR_A {
            #[doc = "0: f_PCLK / 2"]
            DIV2 = 0,
            #[doc = "1: f_PCLK / 4"]
            DIV4 = 1,
            #[doc = "2: f_PCLK / 8"]
            DIV8 = 2,
            #[doc = "3: f_PCLK / 16"]
            DIV16 = 3,
            #[doc = "4: f_PCLK / 32"]
            DIV32 = 4,
            #[doc = "5: f_PCLK / 64"]
            DIV64 = 5,
            #[doc = "6: f_PCLK / 128"]
            DIV128 = 6,
            #[doc = "7: f_PCLK / 256"]
            DIV256 = 7,
        }
        impl From<BR_A> for u8 {
            #[inline(always)]
            fn from(variant: BR_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `BR`"]
        pub type BR_R = crate::R<u8, BR_A>;
        impl BR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BR_A {
                match self.bits {
                    0 => BR_A::DIV2,
                    1 => BR_A::DIV4,
                    2 => BR_A::DIV8,
                    3 => BR_A::DIV16,
                    4 => BR_A::DIV32,
                    5 => BR_A::DIV64,
                    6 => BR_A::DIV128,
                    7 => BR_A::DIV256,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == BR_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == BR_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == BR_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == BR_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == BR_A::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == BR_A::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == BR_A::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == BR_A::DIV256
            }
        }
        #[doc = "Write proxy for field `BR`"]
        pub struct BR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "f_PCLK / 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(BR_A::DIV2)
            }
            #[doc = "f_PCLK / 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(BR_A::DIV4)
            }
            #[doc = "f_PCLK / 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(BR_A::DIV8)
            }
            #[doc = "f_PCLK / 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(BR_A::DIV16)
            }
            #[doc = "f_PCLK / 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(BR_A::DIV32)
            }
            #[doc = "f_PCLK / 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(BR_A::DIV64)
            }
            #[doc = "f_PCLK / 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(BR_A::DIV128)
            }
            #[doc = "f_PCLK / 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(BR_A::DIV256)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | (((value as u32) & 0x07) << 3);
                self.w
            }
        }
        #[doc = "Master selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTR_A {
            #[doc = "0: Slave configuration"]
            SLAVE = 0,
            #[doc = "1: Master configuration"]
            MASTER = 1,
        }
        impl From<MSTR_A> for bool {
            #[inline(always)]
            fn from(variant: MSTR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSTR`"]
        pub type MSTR_R = crate::R<bool, MSTR_A>;
        impl MSTR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSTR_A {
                match self.bits {
                    false => MSTR_A::SLAVE,
                    true => MSTR_A::MASTER,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE`"]
            #[inline(always)]
            pub fn is_slave(&self) -> bool {
                *self == MSTR_A::SLAVE
            }
            #[doc = "Checks if the value of the field is `MASTER`"]
            #[inline(always)]
            pub fn is_master(&self) -> bool {
                *self == MSTR_A::MASTER
            }
        }
        #[doc = "Write proxy for field `MSTR`"]
        pub struct MSTR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSTR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Slave configuration"]
            #[inline(always)]
            pub fn slave(self) -> &'a mut W {
                self.variant(MSTR_A::SLAVE)
            }
            #[doc = "Master configuration"]
            #[inline(always)]
            pub fn master(self) -> &'a mut W {
                self.variant(MSTR_A::MASTER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Clock polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOL_A {
            #[doc = "0: CK to 0 when idle"]
            IDLELOW = 0,
            #[doc = "1: CK to 1 when idle"]
            IDLEHIGH = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPOL`"]
        pub type CPOL_R = crate::R<bool, CPOL_A>;
        impl CPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::IDLELOW,
                    true => CPOL_A::IDLEHIGH,
                }
            }
            #[doc = "Checks if the value of the field is `IDLELOW`"]
            #[inline(always)]
            pub fn is_idle_low(&self) -> bool {
                *self == CPOL_A::IDLELOW
            }
            #[doc = "Checks if the value of the field is `IDLEHIGH`"]
            #[inline(always)]
            pub fn is_idle_high(&self) -> bool {
                *self == CPOL_A::IDLEHIGH
            }
        }
        #[doc = "Write proxy for field `CPOL`"]
        pub struct CPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CK to 0 when idle"]
            #[inline(always)]
            pub fn idle_low(self) -> &'a mut W {
                self.variant(CPOL_A::IDLELOW)
            }
            #[doc = "CK to 1 when idle"]
            #[inline(always)]
            pub fn idle_high(self) -> &'a mut W {
                self.variant(CPOL_A::IDLEHIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Clock phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHA_A {
            #[doc = "0: The first clock transition is the first data capture edge"]
            FIRSTEDGE = 0,
            #[doc = "1: The second clock transition is the first data capture edge"]
            SECONDEDGE = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPHA`"]
        pub type CPHA_R = crate::R<bool, CPHA_A>;
        impl CPHA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FIRSTEDGE,
                    true => CPHA_A::SECONDEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `FIRSTEDGE`"]
            #[inline(always)]
            pub fn is_first_edge(&self) -> bool {
                *self == CPHA_A::FIRSTEDGE
            }
            #[doc = "Checks if the value of the field is `SECONDEDGE`"]
            #[inline(always)]
            pub fn is_second_edge(&self) -> bool {
                *self == CPHA_A::SECONDEDGE
            }
        }
        #[doc = "Write proxy for field `CPHA`"]
        pub struct CPHA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPHA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPHA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The first clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn first_edge(self) -> &'a mut W {
                self.variant(CPHA_A::FIRSTEDGE)
            }
            #[doc = "The second clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn second_edge(self) -> &'a mut W {
                self.variant(CPHA_A::SECONDEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline(always)]
            pub fn bidimode(&self) -> BIDIMODE_R {
                BIDIMODE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline(always)]
            pub fn bidioe(&self) -> BIDIOE_R {
                BIDIOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline(always)]
            pub fn crcnext(&self) -> CRCNEXT_R {
                CRCNEXT_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline(always)]
            pub fn dff(&self) -> DFF_R {
                DFF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline(always)]
            pub fn rxonly(&self) -> RXONLY_R {
                RXONLY_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline(always)]
            pub fn ssm(&self) -> SSM_R {
                SSM_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline(always)]
            pub fn ssi(&self) -> SSI_R {
                SSI_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline(always)]
            pub fn spe(&self) -> SPE_R {
                SPE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline(always)]
            pub fn br(&self) -> BR_R {
                BR_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline(always)]
            pub fn mstr(&self) -> MSTR_R {
                MSTR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline(always)]
            pub fn bidimode(&mut self) -> BIDIMODE_W {
                BIDIMODE_W { w: self }
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline(always)]
            pub fn bidioe(&mut self) -> BIDIOE_W {
                BIDIOE_W { w: self }
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline(always)]
            pub fn crcen(&mut self) -> CRCEN_W {
                CRCEN_W { w: self }
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline(always)]
            pub fn crcnext(&mut self) -> CRCNEXT_W {
                CRCNEXT_W { w: self }
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline(always)]
            pub fn dff(&mut self) -> DFF_W {
                DFF_W { w: self }
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline(always)]
            pub fn rxonly(&mut self) -> RXONLY_W {
                RXONLY_W { w: self }
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline(always)]
            pub fn ssm(&mut self) -> SSM_W {
                SSM_W { w: self }
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline(always)]
            pub fn ssi(&mut self) -> SSI_W {
                SSI_W { w: self }
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline(always)]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W {
                LSBFIRST_W { w: self }
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline(always)]
            pub fn spe(&mut self) -> SPE_W {
                SPE_W { w: self }
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline(always)]
            pub fn br(&mut self) -> BR_W {
                BR_W { w: self }
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline(always)]
            pub fn mstr(&mut self) -> MSTR_W {
                MSTR_W { w: self }
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W {
                CPOL_W { w: self }
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W {
                CPHA_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Tx buffer empty interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            #[doc = "0: TXE interrupt masked"]
            MASKED = 0,
            #[doc = "1: TXE interrupt not masked"]
            NOTMASKED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXEIE`"]
        pub type TXEIE_R = crate::R<bool, TXEIE_A>;
        impl TXEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::MASKED,
                    true => TXEIE_A::NOTMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == TXEIE_A::MASKED
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == TXEIE_A::NOTMASKED
            }
        }
        #[doc = "Write proxy for field `TXEIE`"]
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TXE interrupt masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(TXEIE_A::MASKED)
            }
            #[doc = "TXE interrupt not masked"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(TXEIE_A::NOTMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "RX buffer not empty interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            #[doc = "0: RXE interrupt masked"]
            MASKED = 0,
            #[doc = "1: RXE interrupt not masked"]
            NOTMASKED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNEIE`"]
        pub type RXNEIE_R = crate::R<bool, RXNEIE_A>;
        impl RXNEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::MASKED,
                    true => RXNEIE_A::NOTMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == RXNEIE_A::MASKED
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == RXNEIE_A::NOTMASKED
            }
        }
        #[doc = "Write proxy for field `RXNEIE`"]
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RXE interrupt masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(RXNEIE_A::MASKED)
            }
            #[doc = "RXE interrupt not masked"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(RXNEIE_A::NOTMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRIE_A {
            #[doc = "0: Error interrupt masked"]
            MASKED = 0,
            #[doc = "1: Error interrupt not masked"]
            NOTMASKED = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERRIE`"]
        pub type ERRIE_R = crate::R<bool, ERRIE_A>;
        impl ERRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::MASKED,
                    true => ERRIE_A::NOTMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == ERRIE_A::MASKED
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == ERRIE_A::NOTMASKED
            }
        }
        #[doc = "Write proxy for field `ERRIE`"]
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error interrupt masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(ERRIE_A::MASKED)
            }
            #[doc = "Error interrupt not masked"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(ERRIE_A::NOTMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "SS output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSOE_A {
            #[doc = "0: SS output is disabled in master mode"]
            DISABLED = 0,
            #[doc = "1: SS output is enabled in master mode"]
            ENABLED = 1,
        }
        impl From<SSOE_A> for bool {
            #[inline(always)]
            fn from(variant: SSOE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SSOE`"]
        pub type SSOE_R = crate::R<bool, SSOE_A>;
        impl SSOE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SSOE_A {
                match self.bits {
                    false => SSOE_A::DISABLED,
                    true => SSOE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SSOE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SSOE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SSOE`"]
        pub struct SSOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSOE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSOE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "SS output is disabled in master mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSOE_A::DISABLED)
            }
            #[doc = "SS output is enabled in master mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSOE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Tx buffer DMA enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDMAEN_A {
            #[doc = "0: Tx buffer DMA disabled"]
            DISABLED = 0,
            #[doc = "1: Tx buffer DMA enabled"]
            ENABLED = 1,
        }
        impl From<TXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: TXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXDMAEN`"]
        pub type TXDMAEN_R = crate::R<bool, TXDMAEN_A>;
        impl TXDMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXDMAEN_A {
                match self.bits {
                    false => TXDMAEN_A::DISABLED,
                    true => TXDMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXDMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXDMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXDMAEN`"]
        pub struct TXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXDMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXDMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tx buffer DMA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::DISABLED)
            }
            #[doc = "Tx buffer DMA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Rx buffer DMA enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDMAEN_A {
            #[doc = "0: Rx buffer DMA disabled"]
            DISABLED = 0,
            #[doc = "1: Rx buffer DMA enabled"]
            ENABLED = 1,
        }
        impl From<RXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: RXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXDMAEN`"]
        pub type RXDMAEN_R = crate::R<bool, RXDMAEN_A>;
        impl RXDMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXDMAEN_A {
                match self.bits {
                    false => RXDMAEN_A::DISABLED,
                    true => RXDMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXDMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXDMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXDMAEN`"]
        pub struct RXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXDMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXDMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rx buffer DMA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::DISABLED)
            }
            #[doc = "Rx buffer DMA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline(always)]
            pub fn ssoe(&self) -> SSOE_R {
                SSOE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline(always)]
            pub fn ssoe(&mut self) -> SSOE_W {
                SSOE_W { w: self }
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline(always)]
            pub fn txdmaen(&mut self) -> TXDMAEN_W {
                TXDMAEN_W { w: self }
            }
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline(always)]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W {
                RXDMAEN_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0x02"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x02
            }
        }
        #[doc = "Busy flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BSY_A {
            #[doc = "0: SPI not busy"]
            NOTBUSY = 0,
            #[doc = "1: SPI busy"]
            BUSY = 1,
        }
        impl From<BSY_A> for bool {
            #[inline(always)]
            fn from(variant: BSY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BSY`"]
        pub type BSY_R = crate::R<bool, BSY_A>;
        impl BSY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BSY_A {
                match self.bits {
                    false => BSY_A::NOTBUSY,
                    true => BSY_A::BUSY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBUSY`"]
            #[inline(always)]
            pub fn is_not_busy(&self) -> bool {
                *self == BSY_A::NOTBUSY
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == BSY_A::BUSY
            }
        }
        #[doc = "Overrun flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            #[doc = "0: No overrun occurred"]
            NOOVERRUN = 0,
            #[doc = "1: Overrun occurred"]
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVR`"]
        pub type OVR_R = crate::R<bool, OVR_A>;
        impl OVR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOOVERRUN`"]
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVR_A::NOOVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVR_A::OVERRUN
            }
        }
        #[doc = "Mode fault\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODF_A {
            #[doc = "0: No mode fault occurred"]
            NOFAULT = 0,
            #[doc = "1: Mode fault occurred"]
            FAULT = 1,
        }
        impl From<MODF_A> for bool {
            #[inline(always)]
            fn from(variant: MODF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MODF`"]
        pub type MODF_R = crate::R<bool, MODF_A>;
        impl MODF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODF_A {
                match self.bits {
                    false => MODF_A::NOFAULT,
                    true => MODF_A::FAULT,
                }
            }
            #[doc = "Checks if the value of the field is `NOFAULT`"]
            #[inline(always)]
            pub fn is_no_fault(&self) -> bool {
                *self == MODF_A::NOFAULT
            }
            #[doc = "Checks if the value of the field is `FAULT`"]
            #[inline(always)]
            pub fn is_fault(&self) -> bool {
                *self == MODF_A::FAULT
            }
        }
        #[doc = "CRC error flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCERR_A {
            #[doc = "0: CRC value received matches the SPIx_RXCRCR value"]
            MATCH = 0,
            #[doc = "1: CRC value received does not match the SPIx_RXCRCR value"]
            NOMATCH = 1,
        }
        impl From<CRCERR_A> for bool {
            #[inline(always)]
            fn from(variant: CRCERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCERR`"]
        pub type CRCERR_R = crate::R<bool, CRCERR_A>;
        impl CRCERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCERR_A {
                match self.bits {
                    false => CRCERR_A::MATCH,
                    true => CRCERR_A::NOMATCH,
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CRCERR_A::MATCH
            }
            #[doc = "Checks if the value of the field is `NOMATCH`"]
            #[inline(always)]
            pub fn is_no_match(&self) -> bool {
                *self == CRCERR_A::NOMATCH
            }
        }
        #[doc = "Write proxy for field `CRCERR`"]
        pub struct CRCERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCERR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CRC value received matches the SPIx_RXCRCR value"]
            #[inline(always)]
            pub fn match_(self) -> &'a mut W {
                self.variant(CRCERR_A::MATCH)
            }
            #[doc = "CRC value received does not match the SPIx_RXCRCR value"]
            #[inline(always)]
            pub fn no_match(self) -> &'a mut W {
                self.variant(CRCERR_A::NOMATCH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Transmit buffer empty\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXE_A {
            #[doc = "0: Tx buffer not empty"]
            NOTEMPTY = 0,
            #[doc = "1: Tx buffer empty"]
            EMPTY = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, TXE_A>;
        impl TXE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NOTEMPTY,
                    true => TXE_A::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TXE_A::NOTEMPTY
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TXE_A::EMPTY
            }
        }
        #[doc = "Receive buffer not empty\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNE_A {
            #[doc = "0: Rx buffer empty"]
            EMPTY = 0,
            #[doc = "1: Rx buffer not empty"]
            NOTEMPTY = 1,
        }
        impl From<RXNE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, RXNE_A>;
        impl RXNE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNE_A {
                match self.bits {
                    false => RXNE_A::EMPTY,
                    true => RXNE_A::NOTEMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RXNE_A::EMPTY
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == RXNE_A::NOTEMPTY
            }
        }
        impl R {
            #[doc = "Bit 7 - Busy flag"]
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Overrun flag"]
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Mode fault"]
            #[inline(always)]
            pub fn modf(&self) -> MODF_R {
                MODF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - CRC error flag"]
            #[inline(always)]
            pub fn crcerr(&self) -> CRCERR_R {
                CRCERR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Transmit buffer empty"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Receive buffer not empty"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - CRC error flag"]
            #[inline(always)]
            pub fn crcerr(&mut self) -> CRCERR_W {
                CRCERR_W { w: self }
            }
        }
    }
    #[doc = "data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Data register"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Data register"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "CRC polynomial register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcpr](crcpr) module"]
    pub type CRCPR = crate::Reg<u32, _CRCPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRCPR;
    #[doc = "`read()` method returns [crcpr::R](crcpr::R) reader structure"]
    impl crate::Readable for CRCPR {}
    #[doc = "`write(|w| ..)` method takes [crcpr::W](crcpr::W) writer structure"]
    impl crate::Writable for CRCPR {}
    #[doc = "CRC polynomial register"]
    pub mod crcpr {
        #[doc = "Reader of register CRCPR"]
        pub type R = crate::R<u32, super::CRCPR>;
        #[doc = "Writer for register CRCPR"]
        pub type W = crate::W<u32, super::CRCPR>;
        #[doc = "Register CRCPR `reset()`'s with value 0x07"]
        impl crate::ResetValue for super::CRCPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x07
            }
        }
        #[doc = "Reader of field `CRCPOLY`"]
        pub type CRCPOLY_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CRCPOLY`"]
        pub struct CRCPOLY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCPOLY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLY_R {
                CRCPOLY_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline(always)]
            pub fn crcpoly(&mut self) -> CRCPOLY_W {
                CRCPOLY_W { w: self }
            }
        }
    }
    #[doc = "RX CRC register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxcrcr](rxcrcr) module"]
    pub type RXCRCR = crate::Reg<u32, _RXCRCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXCRCR;
    #[doc = "`read()` method returns [rxcrcr::R](rxcrcr::R) reader structure"]
    impl crate::Readable for RXCRCR {}
    #[doc = "RX CRC register"]
    pub mod rxcrcr {
        #[doc = "Reader of register RXCRCR"]
        pub type R = crate::R<u32, super::RXCRCR>;
        #[doc = "Reader of field `RxCRC`"]
        pub type RXCRC_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Rx CRC register"]
            #[inline(always)]
            pub fn rx_crc(&self) -> RXCRC_R {
                RXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "TX CRC register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txcrcr](txcrcr) module"]
    pub type TXCRCR = crate::Reg<u32, _TXCRCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXCRCR;
    #[doc = "`read()` method returns [txcrcr::R](txcrcr::R) reader structure"]
    impl crate::Readable for TXCRCR {}
    #[doc = "TX CRC register"]
    pub mod txcrcr {
        #[doc = "Reader of register TXCRCR"]
        pub type R = crate::R<u32, super::TXCRCR>;
        #[doc = "Reader of field `TxCRC`"]
        pub type TXCRC_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Tx CRC register"]
            #[inline(always)]
            pub fn tx_crc(&self) -> TXCRC_R {
                TXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
}
#[doc = "Serial peripheral interface"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        0x4000_3800 as *const _
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI2::ptr() }
    }
}
#[doc = "Serial peripheral interface"]
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI3 {}
impl SPI3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        0x4000_3c00 as *const _
    }
}
impl Deref for SPI3 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI3::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4001_3800 as *const _
    }
}
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART1::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub mod usart1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Status register"]
        pub sr: SR,
        #[doc = "0x04 - Data register"]
        pub dr: DR,
        #[doc = "0x08 - Baud rate register"]
        pub brr: BRR,
        #[doc = "0x0c - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x10 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x14 - Control register 3"]
        pub cr3: CR3,
        #[doc = "0x18 - Guard time and prescaler register"]
        pub gtpr: GTPR,
    }
    #[doc = "Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0xc0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xc0
            }
        }
        #[doc = "Reader of field `CTS`"]
        pub type CTS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CTS`"]
        pub struct CTS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `LBD`"]
        pub type LBD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `LBD`"]
        pub struct LBD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TC`"]
        pub type TC_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TC`"]
        pub struct TC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TC_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RXNE`"]
        pub struct RXNE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `IDLE`"]
        pub type IDLE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ORE`"]
        pub type ORE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `NE`"]
        pub type NE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `FE`"]
        pub type FE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 9 - CTS flag"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Transmit data register empty"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE line detected"]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Overrun error"]
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Noise error flag"]
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Framing error"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Parity error"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 9 - CTS flag"]
            #[inline(always)]
            pub fn cts(&mut self) -> CTS_W {
                CTS_W { w: self }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline(always)]
            pub fn lbd(&mut self) -> LBD_W {
                LBD_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline(always)]
            pub fn tc(&mut self) -> TC_W {
                TC_W { w: self }
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline(always)]
            pub fn rxne(&mut self) -> RXNE_W {
                RXNE_W { w: self }
            }
        }
    }
    #[doc = "Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | ((value as u32) & 0x01ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:8 - Data value"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:8 - Data value"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "Baud rate register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`read()` method returns [brr::R](brr::R) reader structure"]
    impl crate::Readable for BRR {}
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = "Reader of register BRR"]
        pub type R = crate::R<u32, super::BRR>;
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DIV_Mantissa`"]
        pub type DIV_MANTISSA_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DIV_Mantissa`"]
        pub struct DIV_MANTISSA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_MANTISSA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | (((value as u32) & 0x0fff) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `DIV_Fraction`"]
        pub type DIV_FRACTION_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DIV_Fraction`"]
        pub struct DIV_FRACTION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_FRACTION_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:15 - mantissa of USARTDIV"]
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
            #[doc = "Bits 0:3 - fraction of USARTDIV"]
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:15 - mantissa of USARTDIV"]
            #[inline(always)]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W {
                DIV_MANTISSA_W { w: self }
            }
            #[doc = "Bits 0:3 - fraction of USARTDIV"]
            #[inline(always)]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W {
                DIV_FRACTION_W { w: self }
            }
        }
    }
    #[doc = "Control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "USART enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UE_A {
            #[doc = "0: USART prescaler and outputs disabled"]
            DISABLED = 0,
            #[doc = "1: USART enabled"]
            ENABLED = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UE`"]
        pub type UE_R = crate::R<bool, UE_A>;
        impl UE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::DISABLED,
                    true => UE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UE`"]
        pub struct UE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "USART prescaler and outputs disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::DISABLED)
            }
            #[doc = "USART enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Word length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M_A {
            #[doc = "0: 8 data bits"]
            M8 = 0,
            #[doc = "1: 9 data bits"]
            M9 = 1,
        }
        impl From<M_A> for bool {
            #[inline(always)]
            fn from(variant: M_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `M`"]
        pub type M_R = crate::R<bool, M_A>;
        impl M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> M_A {
                match self.bits {
                    false => M_A::M8,
                    true => M_A::M9,
                }
            }
            #[doc = "Checks if the value of the field is `M8`"]
            #[inline(always)]
            pub fn is_m8(&self) -> bool {
                *self == M_A::M8
            }
            #[doc = "Checks if the value of the field is `M9`"]
            #[inline(always)]
            pub fn is_m9(&self) -> bool {
                *self == M_A::M9
            }
        }
        #[doc = "Write proxy for field `M`"]
        pub struct M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: M_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "8 data bits"]
            #[inline(always)]
            pub fn m8(self) -> &'a mut W {
                self.variant(M_A::M8)
            }
            #[doc = "9 data bits"]
            #[inline(always)]
            pub fn m9(self) -> &'a mut W {
                self.variant(M_A::M9)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Wakeup method\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKE_A {
            #[doc = "0: USART wakeup on idle line"]
            IDLELINE = 0,
            #[doc = "1: USART wakeup on address mark"]
            ADDRESSMARK = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAKE`"]
        pub type WAKE_R = crate::R<bool, WAKE_A>;
        impl WAKE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IDLELINE,
                    true => WAKE_A::ADDRESSMARK,
                }
            }
            #[doc = "Checks if the value of the field is `IDLELINE`"]
            #[inline(always)]
            pub fn is_idle_line(&self) -> bool {
                *self == WAKE_A::IDLELINE
            }
            #[doc = "Checks if the value of the field is `ADDRESSMARK`"]
            #[inline(always)]
            pub fn is_address_mark(&self) -> bool {
                *self == WAKE_A::ADDRESSMARK
            }
        }
        #[doc = "Write proxy for field `WAKE`"]
        pub struct WAKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAKE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAKE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "USART wakeup on idle line"]
            #[inline(always)]
            pub fn idle_line(self) -> &'a mut W {
                self.variant(WAKE_A::IDLELINE)
            }
            #[doc = "USART wakeup on address mark"]
            #[inline(always)]
            pub fn address_mark(self) -> &'a mut W {
                self.variant(WAKE_A::ADDRESSMARK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Parity control enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PCE_A {
            #[doc = "0: Parity control disabled"]
            DISABLED = 0,
            #[doc = "1: Parity control enabled"]
            ENABLED = 1,
        }
        impl From<PCE_A> for bool {
            #[inline(always)]
            fn from(variant: PCE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PCE`"]
        pub type PCE_R = crate::R<bool, PCE_A>;
        impl PCE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PCE_A {
                match self.bits {
                    false => PCE_A::DISABLED,
                    true => PCE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PCE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PCE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PCE`"]
        pub struct PCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PCE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Parity control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PCE_A::DISABLED)
            }
            #[doc = "Parity control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PCE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Parity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PS_A {
            #[doc = "0: Even parity"]
            EVEN = 0,
            #[doc = "1: Odd parity"]
            ODD = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PS`"]
        pub type PS_R = crate::R<bool, PS_A>;
        impl PS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::EVEN,
                    true => PS_A::ODD,
                }
            }
            #[doc = "Checks if the value of the field is `EVEN`"]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == PS_A::EVEN
            }
            #[doc = "Checks if the value of the field is `ODD`"]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == PS_A::ODD
            }
        }
        #[doc = "Write proxy for field `PS`"]
        pub struct PS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Even parity"]
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::EVEN)
            }
            #[doc = "Odd parity"]
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::ODD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "PE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEIE_A {
            #[doc = "0: PE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: PE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<PEIE_A> for bool {
            #[inline(always)]
            fn from(variant: PEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PEIE`"]
        pub type PEIE_R = crate::R<bool, PEIE_A>;
        impl PEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PEIE_A {
                match self.bits {
                    false => PEIE_A::DISABLED,
                    true => PEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PEIE`"]
        pub struct PEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEIE_A::DISABLED)
            }
            #[doc = "PE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "TXE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            #[doc = "0: TXE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: TXE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXEIE`"]
        pub type TXEIE_R = crate::R<bool, TXEIE_A>;
        impl TXEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::DISABLED,
                    true => TXEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXEIE`"]
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TXE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXEIE_A::DISABLED)
            }
            #[doc = "TXE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Transmission complete interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            #[doc = "0: TC interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: TC interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIE`"]
        pub type TCIE_R = crate::R<bool, TCIE_A>;
        impl TCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TCIE`"]
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TC interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            #[doc = "TC interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "RXNE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            #[doc = "0: RXNE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: RXNE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNEIE`"]
        pub type RXNEIE_R = crate::R<bool, RXNEIE_A>;
        impl RXNEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::DISABLED,
                    true => RXNEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXNEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXNEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXNEIE`"]
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RXNE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::DISABLED)
            }
            #[doc = "RXNE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "IDLE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLEIE_A {
            #[doc = "0: IDLE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: IDLE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IDLEIE`"]
        pub type IDLEIE_R = crate::R<bool, IDLEIE_A>;
        impl IDLEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::DISABLED,
                    true => IDLEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IDLEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IDLEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IDLEIE`"]
        pub struct IDLEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "IDLE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::DISABLED)
            }
            #[doc = "IDLE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Transmitter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TE_A {
            #[doc = "0: Transmitter disabled"]
            DISABLED = 0,
            #[doc = "1: Transmitter enabled"]
            ENABLED = 1,
        }
        impl From<TE_A> for bool {
            #[inline(always)]
            fn from(variant: TE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TE`"]
        pub type TE_R = crate::R<bool, TE_A>;
        impl TE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TE_A {
                match self.bits {
                    false => TE_A::DISABLED,
                    true => TE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TE`"]
        pub struct TE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Transmitter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TE_A::DISABLED)
            }
            #[doc = "Transmitter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Receiver enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RE_A {
            #[doc = "0: Receiver disabled"]
            DISABLED = 0,
            #[doc = "1: Receiver enabled"]
            ENABLED = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RE`"]
        pub type RE_R = crate::R<bool, RE_A>;
        impl RE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::DISABLED,
                    true => RE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RE`"]
        pub struct RE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::DISABLED)
            }
            #[doc = "Receiver enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Receiver wakeup\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RWU_A {
            #[doc = "0: Receiver in active mode"]
            ACTIVE = 0,
            #[doc = "1: Receiver in mute mode"]
            MUTE = 1,
        }
        impl From<RWU_A> for bool {
            #[inline(always)]
            fn from(variant: RWU_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RWU`"]
        pub type RWU_R = crate::R<bool, RWU_A>;
        impl RWU_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RWU_A {
                match self.bits {
                    false => RWU_A::ACTIVE,
                    true => RWU_A::MUTE,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == RWU_A::ACTIVE
            }
            #[doc = "Checks if the value of the field is `MUTE`"]
            #[inline(always)]
            pub fn is_mute(&self) -> bool {
                *self == RWU_A::MUTE
            }
        }
        #[doc = "Write proxy for field `RWU`"]
        pub struct RWU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RWU_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RWU_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver in active mode"]
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(RWU_A::ACTIVE)
            }
            #[doc = "Receiver in mute mode"]
            #[inline(always)]
            pub fn mute(self) -> &'a mut W {
                self.variant(RWU_A::MUTE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Send break\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBK_A {
            #[doc = "0: No break character is transmitted"]
            NOBREAK = 0,
            #[doc = "1: Break character transmitted"]
            BREAK = 1,
        }
        impl From<SBK_A> for bool {
            #[inline(always)]
            fn from(variant: SBK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SBK`"]
        pub type SBK_R = crate::R<bool, SBK_A>;
        impl SBK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SBK_A {
                match self.bits {
                    false => SBK_A::NOBREAK,
                    true => SBK_A::BREAK,
                }
            }
            #[doc = "Checks if the value of the field is `NOBREAK`"]
            #[inline(always)]
            pub fn is_no_break(&self) -> bool {
                *self == SBK_A::NOBREAK
            }
            #[doc = "Checks if the value of the field is `BREAK`"]
            #[inline(always)]
            pub fn is_break_(&self) -> bool {
                *self == SBK_A::BREAK
            }
        }
        #[doc = "Write proxy for field `SBK`"]
        pub struct SBK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SBK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No break character is transmitted"]
            #[inline(always)]
            pub fn no_break(self) -> &'a mut W {
                self.variant(SBK_A::NOBREAK)
            }
            #[doc = "Break character transmitted"]
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBK_A::BREAK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 13 - USART enable"]
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Send break"]
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 13 - USART enable"]
            #[inline(always)]
            pub fn ue(&mut self) -> UE_W {
                UE_W { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m(&mut self) -> M_W {
                M_W { w: self }
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline(always)]
            pub fn wake(&mut self) -> WAKE_W {
                WAKE_W { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&mut self) -> PCE_W {
                PCE_W { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W {
                PS_W { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&mut self) -> PEIE_W {
                PEIE_W { w: self }
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&mut self) -> IDLEIE_W {
                IDLEIE_W { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&mut self) -> TE_W {
                TE_W { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&mut self) -> RE_W {
                RE_W { w: self }
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline(always)]
            pub fn rwu(&mut self) -> RWU_W {
                RWU_W { w: self }
            }
            #[doc = "Bit 0 - Send break"]
            #[inline(always)]
            pub fn sbk(&mut self) -> SBK_W {
                SBK_W { w: self }
            }
        }
    }
    #[doc = "Control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "LIN mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LINEN_A {
            #[doc = "0: LIN mode disabled"]
            DISABLED = 0,
            #[doc = "1: LIN mode enabled"]
            ENABLED = 1,
        }
        impl From<LINEN_A> for bool {
            #[inline(always)]
            fn from(variant: LINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LINEN`"]
        pub type LINEN_R = crate::R<bool, LINEN_A>;
        impl LINEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LINEN_A {
                match self.bits {
                    false => LINEN_A::DISABLED,
                    true => LINEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LINEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LINEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LINEN`"]
        pub struct LINEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LINEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LINEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LIN mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LINEN_A::DISABLED)
            }
            #[doc = "LIN mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LINEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "STOP bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum STOP_A {
            #[doc = "0: 1 stop bit"]
            STOP1 = 0,
            #[doc = "1: 0.5 stop bits"]
            STOP0P5 = 1,
            #[doc = "2: 2 stop bits"]
            STOP2 = 2,
            #[doc = "3: 1.5 stop bits"]
            STOP1P5 = 3,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `STOP`"]
        pub type STOP_R = crate::R<u8, STOP_A>;
        impl STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    0 => STOP_A::STOP1,
                    1 => STOP_A::STOP0P5,
                    2 => STOP_A::STOP2,
                    3 => STOP_A::STOP1P5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STOP1`"]
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                *self == STOP_A::STOP1
            }
            #[doc = "Checks if the value of the field is `STOP0P5`"]
            #[inline(always)]
            pub fn is_stop0p5(&self) -> bool {
                *self == STOP_A::STOP0P5
            }
            #[doc = "Checks if the value of the field is `STOP2`"]
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                *self == STOP_A::STOP2
            }
            #[doc = "Checks if the value of the field is `STOP1P5`"]
            #[inline(always)]
            pub fn is_stop1p5(&self) -> bool {
                *self == STOP_A::STOP1P5
            }
        }
        #[doc = "Write proxy for field `STOP`"]
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1 stop bit"]
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::STOP1)
            }
            #[doc = "0.5 stop bits"]
            #[inline(always)]
            pub fn stop0p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP0P5)
            }
            #[doc = "2 stop bits"]
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::STOP2)
            }
            #[doc = "1.5 stop bits"]
            #[inline(always)]
            pub fn stop1p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP1P5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKEN_A {
            #[doc = "0: CK pin disabled"]
            DISABLED = 0,
            #[doc = "1: CK pin enabled"]
            ENABLED = 1,
        }
        impl From<CLKEN_A> for bool {
            #[inline(always)]
            fn from(variant: CLKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CLKEN`"]
        pub type CLKEN_R = crate::R<bool, CLKEN_A>;
        impl CLKEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CLKEN_A {
                match self.bits {
                    false => CLKEN_A::DISABLED,
                    true => CLKEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CLKEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CLKEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CLKEN`"]
        pub struct CLKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CK pin disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CLKEN_A::DISABLED)
            }
            #[doc = "CK pin enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CLKEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Clock polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOL_A {
            #[doc = "0: Steady low value on CK pin outside transmission window"]
            LOW = 0,
            #[doc = "1: Steady high value on CK pin outside transmission window"]
            HIGH = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPOL`"]
        pub type CPOL_R = crate::R<bool, CPOL_A>;
        impl CPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::LOW,
                    true => CPOL_A::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == CPOL_A::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == CPOL_A::HIGH
            }
        }
        #[doc = "Write proxy for field `CPOL`"]
        pub struct CPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Steady low value on CK pin outside transmission window"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(CPOL_A::LOW)
            }
            #[doc = "Steady high value on CK pin outside transmission window"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(CPOL_A::HIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Clock phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHA_A {
            #[doc = "0: The first clock transition is the first data capture edge"]
            FIRST = 0,
            #[doc = "1: The second clock transition is the first data capture edge"]
            SECOND = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPHA`"]
        pub type CPHA_R = crate::R<bool, CPHA_A>;
        impl CPHA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FIRST,
                    true => CPHA_A::SECOND,
                }
            }
            #[doc = "Checks if the value of the field is `FIRST`"]
            #[inline(always)]
            pub fn is_first(&self) -> bool {
                *self == CPHA_A::FIRST
            }
            #[doc = "Checks if the value of the field is `SECOND`"]
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == CPHA_A::SECOND
            }
        }
        #[doc = "Write proxy for field `CPHA`"]
        pub struct CPHA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPHA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPHA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The first clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn first(self) -> &'a mut W {
                self.variant(CPHA_A::FIRST)
            }
            #[doc = "The second clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(CPHA_A::SECOND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `LBCL`"]
        pub type LBCL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `LBCL`"]
        pub struct LBCL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBCL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "LIN break detection interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDIE_A {
            #[doc = "0: LIN break detection interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: LIN break detection interrupt enabled"]
            ENABLED = 1,
        }
        impl From<LBDIE_A> for bool {
            #[inline(always)]
            fn from(variant: LBDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBDIE`"]
        pub type LBDIE_R = crate::R<bool, LBDIE_A>;
        impl LBDIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBDIE_A {
                match self.bits {
                    false => LBDIE_A::DISABLED,
                    true => LBDIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LBDIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LBDIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LBDIE`"]
        pub struct LBDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LIN break detection interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LBDIE_A::DISABLED)
            }
            #[doc = "LIN break detection interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LBDIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "lin break detection length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDL_A {
            #[doc = "0: 10-bit break detection"]
            LBDL10 = 0,
            #[doc = "1: 11-bit break detection"]
            LBDL11 = 1,
        }
        impl From<LBDL_A> for bool {
            #[inline(always)]
            fn from(variant: LBDL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBDL`"]
        pub type LBDL_R = crate::R<bool, LBDL_A>;
        impl LBDL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBDL_A {
                match self.bits {
                    false => LBDL_A::LBDL10,
                    true => LBDL_A::LBDL11,
                }
            }
            #[doc = "Checks if the value of the field is `LBDL10`"]
            #[inline(always)]
            pub fn is_lbdl10(&self) -> bool {
                *self == LBDL_A::LBDL10
            }
            #[doc = "Checks if the value of the field is `LBDL11`"]
            #[inline(always)]
            pub fn is_lbdl11(&self) -> bool {
                *self == LBDL_A::LBDL11
            }
        }
        #[doc = "Write proxy for field `LBDL`"]
        pub struct LBDL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "10-bit break detection"]
            #[inline(always)]
            pub fn lbdl10(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL10)
            }
            #[doc = "11-bit break detection"]
            #[inline(always)]
            pub fn lbdl11(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL11)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline(always)]
            pub fn lbcl(&self) -> LBCL_R {
                LBCL_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline(always)]
            pub fn linen(&mut self) -> LINEN_W {
                LINEN_W { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline(always)]
            pub fn clken(&mut self) -> CLKEN_W {
                CLKEN_W { w: self }
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W {
                CPOL_W { w: self }
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W {
                CPHA_W { w: self }
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline(always)]
            pub fn lbcl(&mut self) -> LBCL_W {
                LBCL_W { w: self }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline(always)]
            pub fn lbdie(&mut self) -> LBDIE_W {
                LBDIE_W { w: self }
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline(always)]
            pub fn lbdl(&mut self) -> LBDL_W {
                LBDL_W { w: self }
            }
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
        }
    }
    #[doc = "Control register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr3](cr3) module"]
    pub type CR3 = crate::Reg<u32, _CR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR3;
    #[doc = "`read()` method returns [cr3::R](cr3::R) reader structure"]
    impl crate::Readable for CR3 {}
    #[doc = "`write(|w| ..)` method takes [cr3::W](cr3::W) writer structure"]
    impl crate::Writable for CR3 {}
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = "Reader of register CR3"]
        pub type R = crate::R<u32, super::CR3>;
        #[doc = "Writer for register CR3"]
        pub type W = crate::W<u32, super::CR3>;
        #[doc = "Register CR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "CTS interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSIE_A {
            #[doc = "0: CTS interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CTS interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CTSIE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CTSIE`"]
        pub type CTSIE_R = crate::R<bool, CTSIE_A>;
        impl CTSIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTSIE_A {
                match self.bits {
                    false => CTSIE_A::DISABLED,
                    true => CTSIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CTSIE`"]
        pub struct CTSIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CTS interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSIE_A::DISABLED)
            }
            #[doc = "CTS interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "CTS enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSE_A {
            #[doc = "0: CTS hardware flow control disabled"]
            DISABLED = 0,
            #[doc = "1: CTS hardware flow control enabled"]
            ENABLED = 1,
        }
        impl From<CTSE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CTSE`"]
        pub type CTSE_R = crate::R<bool, CTSE_A>;
        impl CTSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTSE_A {
                match self.bits {
                    false => CTSE_A::DISABLED,
                    true => CTSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CTSE`"]
        pub struct CTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CTS hardware flow control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSE_A::DISABLED)
            }
            #[doc = "CTS hardware flow control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "RTS enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTSE_A {
            #[doc = "0: RTS hardware flow control disabled"]
            DISABLED = 0,
            #[doc = "1: RTS hardware flow control enabled"]
            ENABLED = 1,
        }
        impl From<RTSE_A> for bool {
            #[inline(always)]
            fn from(variant: RTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTSE`"]
        pub type RTSE_R = crate::R<bool, RTSE_A>;
        impl RTSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTSE_A {
                match self.bits {
                    false => RTSE_A::DISABLED,
                    true => RTSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTSE`"]
        pub struct RTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTS hardware flow control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTSE_A::DISABLED)
            }
            #[doc = "RTS hardware flow control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "DMA enable transmitter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAT_A {
            #[doc = "0: DMA mode is disabled for transmission"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for transmission"]
            ENABLED = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAT`"]
        pub type DMAT_R = crate::R<bool, DMAT_A>;
        impl DMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::DISABLED,
                    true => DMAT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAT`"]
        pub struct DMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for transmission"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for transmission"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "DMA enable receiver\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR_A {
            #[doc = "0: DMA mode is disabled for reception"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for reception"]
            ENABLED = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAR`"]
        pub type DMAR_R = crate::R<bool, DMAR_A>;
        impl DMAR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::DISABLED,
                    true => DMAR_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAR_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAR_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAR`"]
        pub struct DMAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for reception"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for reception"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Smartcard mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCEN_A {
            #[doc = "0: Smartcard mode disabled"]
            DISABLED = 0,
            #[doc = "1: Smartcard mode enabled"]
            ENABLED = 1,
        }
        impl From<SCEN_A> for bool {
            #[inline(always)]
            fn from(variant: SCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SCEN`"]
        pub type SCEN_R = crate::R<bool, SCEN_A>;
        impl SCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SCEN_A {
                match self.bits {
                    false => SCEN_A::DISABLED,
                    true => SCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SCEN`"]
        pub struct SCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Smartcard mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCEN_A::DISABLED)
            }
            #[doc = "Smartcard mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Smartcard NACK enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACK_A {
            #[doc = "0: NACK transmission in case of parity error is disabled"]
            DISABLED = 0,
            #[doc = "1: NACK transmission during parity error is enabled"]
            ENABLED = 1,
        }
        impl From<NACK_A> for bool {
            #[inline(always)]
            fn from(variant: NACK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NACK`"]
        pub type NACK_R = crate::R<bool, NACK_A>;
        impl NACK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NACK_A {
                match self.bits {
                    false => NACK_A::DISABLED,
                    true => NACK_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NACK_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NACK_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `NACK`"]
        pub struct NACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NACK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NACK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NACK transmission in case of parity error is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NACK_A::DISABLED)
            }
            #[doc = "NACK transmission during parity error is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NACK_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Half-duplex selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HDSEL_A {
            #[doc = "0: Half duplex mode is not selected"]
            FULLDUPLEX = 0,
            #[doc = "1: Half duplex mode is selected"]
            HALFDUPLEX = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HDSEL`"]
        pub type HDSEL_R = crate::R<bool, HDSEL_A>;
        impl HDSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::FULLDUPLEX,
                    true => HDSEL_A::HALFDUPLEX,
                }
            }
            #[doc = "Checks if the value of the field is `FULLDUPLEX`"]
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                *self == HDSEL_A::FULLDUPLEX
            }
            #[doc = "Checks if the value of the field is `HALFDUPLEX`"]
            #[inline(always)]
            pub fn is_half_duplex(&self) -> bool {
                *self == HDSEL_A::HALFDUPLEX
            }
        }
        #[doc = "Write proxy for field `HDSEL`"]
        pub struct HDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HDSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HDSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Half duplex mode is not selected"]
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::FULLDUPLEX)
            }
            #[doc = "Half duplex mode is selected"]
            #[inline(always)]
            pub fn half_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::HALFDUPLEX)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "IrDA low-power\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRLP_A {
            #[doc = "0: Normal mode"]
            NORMAL = 0,
            #[doc = "1: Low-power mode"]
            LOWPOWER = 1,
        }
        impl From<IRLP_A> for bool {
            #[inline(always)]
            fn from(variant: IRLP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IRLP`"]
        pub type IRLP_R = crate::R<bool, IRLP_A>;
        impl IRLP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IRLP_A {
                match self.bits {
                    false => IRLP_A::NORMAL,
                    true => IRLP_A::LOWPOWER,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == IRLP_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `LOWPOWER`"]
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                *self == IRLP_A::LOWPOWER
            }
        }
        #[doc = "Write proxy for field `IRLP`"]
        pub struct IRLP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IRLP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRLP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(IRLP_A::NORMAL)
            }
            #[doc = "Low-power mode"]
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(IRLP_A::LOWPOWER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "IrDA mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IREN_A {
            #[doc = "0: IrDA disabled"]
            DISABLED = 0,
            #[doc = "1: IrDA enabled"]
            ENABLED = 1,
        }
        impl From<IREN_A> for bool {
            #[inline(always)]
            fn from(variant: IREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IREN`"]
        pub type IREN_R = crate::R<bool, IREN_A>;
        impl IREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IREN_A {
                match self.bits {
                    false => IREN_A::DISABLED,
                    true => IREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IREN`"]
        pub struct IREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "IrDA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IREN_A::DISABLED)
            }
            #[doc = "IrDA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EIE_A {
            #[doc = "0: Error interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Error interrupt enabled"]
            ENABLED = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EIE`"]
        pub type EIE_R = crate::R<bool, EIE_A>;
        impl EIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::DISABLED,
                    true => EIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EIE`"]
        pub struct EIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::DISABLED)
            }
            #[doc = "Error interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline(always)]
            pub fn scen(&self) -> SCEN_R {
                SCEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline(always)]
            pub fn ctsie(&mut self) -> CTSIE_W {
                CTSIE_W { w: self }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline(always)]
            pub fn ctse(&mut self) -> CTSE_W {
                CTSE_W { w: self }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline(always)]
            pub fn rtse(&mut self) -> RTSE_W {
                RTSE_W { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&mut self) -> DMAT_W {
                DMAT_W { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&mut self) -> DMAR_W {
                DMAR_W { w: self }
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline(always)]
            pub fn scen(&mut self) -> SCEN_W {
                SCEN_W { w: self }
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline(always)]
            pub fn nack(&mut self) -> NACK_W {
                NACK_W { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&mut self) -> HDSEL_W {
                HDSEL_W { w: self }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline(always)]
            pub fn irlp(&mut self) -> IRLP_W {
                IRLP_W { w: self }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline(always)]
            pub fn iren(&mut self) -> IREN_W {
                IREN_W { w: self }
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&mut self) -> EIE_W {
                EIE_W { w: self }
            }
        }
    }
    #[doc = "Guard time and prescaler register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtpr](gtpr) module"]
    pub type GTPR = crate::Reg<u32, _GTPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _GTPR;
    #[doc = "`read()` method returns [gtpr::R](gtpr::R) reader structure"]
    impl crate::Readable for GTPR {}
    #[doc = "`write(|w| ..)` method takes [gtpr::W](gtpr::W) writer structure"]
    impl crate::Writable for GTPR {}
    #[doc = "Guard time and prescaler register"]
    pub mod gtpr {
        #[doc = "Reader of register GTPR"]
        pub type R = crate::R<u32, super::GTPR>;
        #[doc = "Writer for register GTPR"]
        pub type W = crate::W<u32, super::GTPR>;
        #[doc = "Register GTPR `reset()`'s with value 0"]
        impl crate::ResetValue for super::GTPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `GT`"]
        pub type GT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `GT`"]
        pub struct GT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline(always)]
            pub fn gt(&self) -> GT_R {
                GT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline(always)]
            pub fn gt(&mut self) -> GT_W {
                GT_W { w: self }
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART2 {}
impl USART2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4000_4400 as *const _
    }
}
impl Deref for USART2 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART2::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART3 {}
impl USART3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4000_4800 as *const _
    }
}
impl Deref for USART3 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART3::ptr() }
    }
}
#[doc = "Analog to digital converter"]
pub struct ADC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC1 {}
impl ADC1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc1::RegisterBlock {
        0x4001_2400 as *const _
    }
}
impl Deref for ADC1 {
    type Target = adc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*ADC1::ptr() }
    }
}
#[doc = "Analog to digital converter"]
pub mod adc1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - status register"]
        pub sr: SR,
        #[doc = "0x04 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x08 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x0c - sample time register 1"]
        pub smpr1: SMPR1,
        #[doc = "0x10 - sample time register 2"]
        pub smpr2: SMPR2,
        #[doc = "0x14 - injected channel data offset register x"]
        pub jofr1: JOFR1,
        #[doc = "0x18 - injected channel data offset register x"]
        pub jofr2: JOFR2,
        #[doc = "0x1c - injected channel data offset register x"]
        pub jofr3: JOFR3,
        #[doc = "0x20 - injected channel data offset register x"]
        pub jofr4: JOFR4,
        #[doc = "0x24 - watchdog higher threshold register"]
        pub htr: HTR,
        #[doc = "0x28 - watchdog lower threshold register"]
        pub ltr: LTR,
        #[doc = "0x2c - regular sequence register 1"]
        pub sqr1: SQR1,
        #[doc = "0x30 - regular sequence register 2"]
        pub sqr2: SQR2,
        #[doc = "0x34 - regular sequence register 3"]
        pub sqr3: SQR3,
        #[doc = "0x38 - injected sequence register"]
        pub jsqr: JSQR,
        #[doc = "0x3c - injected data register x"]
        pub jdr1: JDR1,
        #[doc = "0x40 - injected data register x"]
        pub jdr2: JDR2,
        #[doc = "0x44 - injected data register x"]
        pub jdr3: JDR3,
        #[doc = "0x48 - injected data register x"]
        pub jdr4: JDR4,
        #[doc = "0x4c - regular data register"]
        pub dr: DR,
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Regular channel start flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STRT_A {
            #[doc = "0: No regular channel conversion started"]
            NOTSTARTED = 0,
            #[doc = "1: Regular channel conversion has started"]
            STARTED = 1,
        }
        impl From<STRT_A> for bool {
            #[inline(always)]
            fn from(variant: STRT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STRT`"]
        pub type STRT_R = crate::R<bool, STRT_A>;
        impl STRT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STRT_A {
                match self.bits {
                    false => STRT_A::NOTSTARTED,
                    true => STRT_A::STARTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTARTED`"]
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                *self == STRT_A::NOTSTARTED
            }
            #[doc = "Checks if the value of the field is `STARTED`"]
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                *self == STRT_A::STARTED
            }
        }
        #[doc = "Regular channel start flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STRT_AW {
            #[doc = "0: Clear the Regular channel Start flag"]
            CLEAR = 0,
        }
        impl From<STRT_AW> for bool {
            #[inline(always)]
            fn from(variant: STRT_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `STRT`"]
        pub struct STRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STRT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STRT_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the Regular channel Start flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(STRT_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Injected channel start flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSTRT_A {
            #[doc = "0: No injected group conversion started"]
            NOTSTARTED = 0,
            #[doc = "1: Injected group conversion has started"]
            STARTED = 1,
        }
        impl From<JSTRT_A> for bool {
            #[inline(always)]
            fn from(variant: JSTRT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JSTRT`"]
        pub type JSTRT_R = crate::R<bool, JSTRT_A>;
        impl JSTRT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JSTRT_A {
                match self.bits {
                    false => JSTRT_A::NOTSTARTED,
                    true => JSTRT_A::STARTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTARTED`"]
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                *self == JSTRT_A::NOTSTARTED
            }
            #[doc = "Checks if the value of the field is `STARTED`"]
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                *self == JSTRT_A::STARTED
            }
        }
        #[doc = "Injected channel start flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSTRT_AW {
            #[doc = "0: Clear Injected channel Start flag"]
            CLEAR = 0,
        }
        impl From<JSTRT_AW> for bool {
            #[inline(always)]
            fn from(variant: JSTRT_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `JSTRT`"]
        pub struct JSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSTRT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JSTRT_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear Injected channel Start flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(JSTRT_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Injected channel end of conversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEOC_A {
            #[doc = "0: Conversion is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: Conversion complete"]
            COMPLETE = 1,
        }
        impl From<JEOC_A> for bool {
            #[inline(always)]
            fn from(variant: JEOC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JEOC`"]
        pub type JEOC_R = crate::R<bool, JEOC_A>;
        impl JEOC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JEOC_A {
                match self.bits {
                    false => JEOC_A::NOTCOMPLETE,
                    true => JEOC_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == JEOC_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == JEOC_A::COMPLETE
            }
        }
        #[doc = "Injected channel end of conversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEOC_AW {
            #[doc = "0: Clear Injected channel end of conversion flag"]
            CLEAR = 0,
        }
        impl From<JEOC_AW> for bool {
            #[inline(always)]
            fn from(variant: JEOC_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `JEOC`"]
        pub struct JEOC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEOC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JEOC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear Injected channel end of conversion flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(JEOC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Regular channel end of conversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOC_A {
            #[doc = "0: Conversion is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: Conversion complete"]
            COMPLETE = 1,
        }
        impl From<EOC_A> for bool {
            #[inline(always)]
            fn from(variant: EOC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOC`"]
        pub type EOC_R = crate::R<bool, EOC_A>;
        impl EOC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOC_A {
                match self.bits {
                    false => EOC_A::NOTCOMPLETE,
                    true => EOC_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == EOC_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == EOC_A::COMPLETE
            }
        }
        #[doc = "Regular channel end of conversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOC_AW {
            #[doc = "0: Clear End of conversion flag"]
            CLEAR = 0,
        }
        impl From<EOC_AW> for bool {
            #[inline(always)]
            fn from(variant: EOC_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EOC`"]
        pub struct EOC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear End of conversion flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Analog watchdog flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWD_A {
            #[doc = "0: No analog watchdog event occurred"]
            NOEVENT = 0,
            #[doc = "1: Analog watchdog event occurred"]
            EVENT = 1,
        }
        impl From<AWD_A> for bool {
            #[inline(always)]
            fn from(variant: AWD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWD`"]
        pub type AWD_R = crate::R<bool, AWD_A>;
        impl AWD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWD_A {
                match self.bits {
                    false => AWD_A::NOEVENT,
                    true => AWD_A::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == AWD_A::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                *self == AWD_A::EVENT
            }
        }
        #[doc = "Analog watchdog flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWD_AW {
            #[doc = "0: Clear the analog watchdog event flag"]
            CLEAR = 0,
        }
        impl From<AWD_AW> for bool {
            #[inline(always)]
            fn from(variant: AWD_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `AWD`"]
        pub struct AWD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWD_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the analog watchdog event flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(AWD_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 4 - Regular channel start flag"]
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Injected channel start flag"]
            #[inline(always)]
            pub fn jstrt(&self) -> JSTRT_R {
                JSTRT_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Injected channel end of conversion"]
            #[inline(always)]
            pub fn jeoc(&self) -> JEOC_R {
                JEOC_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Regular channel end of conversion"]
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Analog watchdog flag"]
            #[inline(always)]
            pub fn awd(&self) -> AWD_R {
                AWD_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - Regular channel start flag"]
            #[inline(always)]
            pub fn strt(&mut self) -> STRT_W {
                STRT_W { w: self }
            }
            #[doc = "Bit 3 - Injected channel start flag"]
            #[inline(always)]
            pub fn jstrt(&mut self) -> JSTRT_W {
                JSTRT_W { w: self }
            }
            #[doc = "Bit 2 - Injected channel end of conversion"]
            #[inline(always)]
            pub fn jeoc(&mut self) -> JEOC_W {
                JEOC_W { w: self }
            }
            #[doc = "Bit 1 - Regular channel end of conversion"]
            #[inline(always)]
            pub fn eoc(&mut self) -> EOC_W {
                EOC_W { w: self }
            }
            #[doc = "Bit 0 - Analog watchdog flag"]
            #[inline(always)]
            pub fn awd(&mut self) -> AWD_W {
                AWD_W { w: self }
            }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Analog watchdog enable on regular channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDEN_A {
            #[doc = "0: Analog watchdog disabled on regular channels"]
            DISABLED = 0,
            #[doc = "1: Analog watchdog enabled on regular channels"]
            ENABLED = 1,
        }
        impl From<AWDEN_A> for bool {
            #[inline(always)]
            fn from(variant: AWDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWDEN`"]
        pub type AWDEN_R = crate::R<bool, AWDEN_A>;
        impl AWDEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWDEN_A {
                match self.bits {
                    false => AWDEN_A::DISABLED,
                    true => AWDEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AWDEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AWDEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `AWDEN`"]
        pub struct AWDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog disabled on regular channels"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AWDEN_A::DISABLED)
            }
            #[doc = "Analog watchdog enabled on regular channels"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AWDEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Analog watchdog enable on injected channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JAWDEN_A {
            #[doc = "0: Analog watchdog disabled on injected channels"]
            DISABLED = 0,
            #[doc = "1: Analog watchdog enabled on injected channels"]
            ENABLED = 1,
        }
        impl From<JAWDEN_A> for bool {
            #[inline(always)]
            fn from(variant: JAWDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JAWDEN`"]
        pub type JAWDEN_R = crate::R<bool, JAWDEN_A>;
        impl JAWDEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JAWDEN_A {
                match self.bits {
                    false => JAWDEN_A::DISABLED,
                    true => JAWDEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == JAWDEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == JAWDEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `JAWDEN`"]
        pub struct JAWDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JAWDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JAWDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog disabled on injected channels"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JAWDEN_A::DISABLED)
            }
            #[doc = "Analog watchdog enabled on injected channels"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JAWDEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `DISCNUM`"]
        pub type DISCNUM_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DISCNUM`"]
        pub struct DISCNUM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISCNUM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 13)) | (((value as u32) & 0x07) << 13);
                self.w
            }
        }
        #[doc = "Discontinuous mode on injected channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JDISCEN_A {
            #[doc = "0: Discontinuous mode on injected channels disabled"]
            DISABLED = 0,
            #[doc = "1: Discontinuous mode on injected channels enabled"]
            ENABLED = 1,
        }
        impl From<JDISCEN_A> for bool {
            #[inline(always)]
            fn from(variant: JDISCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JDISCEN`"]
        pub type JDISCEN_R = crate::R<bool, JDISCEN_A>;
        impl JDISCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JDISCEN_A {
                match self.bits {
                    false => JDISCEN_A::DISABLED,
                    true => JDISCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == JDISCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == JDISCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `JDISCEN`"]
        pub struct JDISCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JDISCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JDISCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Discontinuous mode on injected channels disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JDISCEN_A::DISABLED)
            }
            #[doc = "Discontinuous mode on injected channels enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JDISCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Discontinuous mode on regular channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISCEN_A {
            #[doc = "0: Discontinuous mode on regular channels disabled"]
            DISABLED = 0,
            #[doc = "1: Discontinuous mode on regular channels enabled"]
            ENABLED = 1,
        }
        impl From<DISCEN_A> for bool {
            #[inline(always)]
            fn from(variant: DISCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DISCEN`"]
        pub type DISCEN_R = crate::R<bool, DISCEN_A>;
        impl DISCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DISCEN_A {
                match self.bits {
                    false => DISCEN_A::DISABLED,
                    true => DISCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DISCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DISCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DISCEN`"]
        pub struct DISCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DISCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Discontinuous mode on regular channels disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISCEN_A::DISABLED)
            }
            #[doc = "Discontinuous mode on regular channels enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Automatic injected group conversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JAUTO_A {
            #[doc = "0: Automatic injected group conversion disabled"]
            DISABLED = 0,
            #[doc = "1: Automatic injected group conversion enabled"]
            ENABLED = 1,
        }
        impl From<JAUTO_A> for bool {
            #[inline(always)]
            fn from(variant: JAUTO_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JAUTO`"]
        pub type JAUTO_R = crate::R<bool, JAUTO_A>;
        impl JAUTO_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JAUTO_A {
                match self.bits {
                    false => JAUTO_A::DISABLED,
                    true => JAUTO_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == JAUTO_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == JAUTO_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `JAUTO`"]
        pub struct JAUTO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JAUTO_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JAUTO_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Automatic injected group conversion disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JAUTO_A::DISABLED)
            }
            #[doc = "Automatic injected group conversion enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JAUTO_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Enable the watchdog on a single channel in scan mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDSGL_A {
            #[doc = "0: Analog watchdog enabled on all channels"]
            ALL = 0,
            #[doc = "1: Analog watchdog enabled on a single channel"]
            SINGLE = 1,
        }
        impl From<AWDSGL_A> for bool {
            #[inline(always)]
            fn from(variant: AWDSGL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWDSGL`"]
        pub type AWDSGL_R = crate::R<bool, AWDSGL_A>;
        impl AWDSGL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWDSGL_A {
                match self.bits {
                    false => AWDSGL_A::ALL,
                    true => AWDSGL_A::SINGLE,
                }
            }
            #[doc = "Checks if the value of the field is `ALL`"]
            #[inline(always)]
            pub fn is_all(&self) -> bool {
                *self == AWDSGL_A::ALL
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == AWDSGL_A::SINGLE
            }
        }
        #[doc = "Write proxy for field `AWDSGL`"]
        pub struct AWDSGL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDSGL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWDSGL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog enabled on all channels"]
            #[inline(always)]
            pub fn all(self) -> &'a mut W {
                self.variant(AWDSGL_A::ALL)
            }
            #[doc = "Analog watchdog enabled on a single channel"]
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(AWDSGL_A::SINGLE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Scan mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCAN_A {
            #[doc = "0: Scan mode disabled"]
            DISABLED = 0,
            #[doc = "1: Scan mode enabled"]
            ENABLED = 1,
        }
        impl From<SCAN_A> for bool {
            #[inline(always)]
            fn from(variant: SCAN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SCAN`"]
        pub type SCAN_R = crate::R<bool, SCAN_A>;
        impl SCAN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SCAN_A {
                match self.bits {
                    false => SCAN_A::DISABLED,
                    true => SCAN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SCAN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SCAN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SCAN`"]
        pub struct SCAN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCAN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCAN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Scan mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCAN_A::DISABLED)
            }
            #[doc = "Scan mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCAN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Interrupt enable for injected channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEOCIE_A {
            #[doc = "0: JEOC interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set"]
            ENABLED = 1,
        }
        impl From<JEOCIE_A> for bool {
            #[inline(always)]
            fn from(variant: JEOCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JEOCIE`"]
        pub type JEOCIE_R = crate::R<bool, JEOCIE_A>;
        impl JEOCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JEOCIE_A {
                match self.bits {
                    false => JEOCIE_A::DISABLED,
                    true => JEOCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == JEOCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == JEOCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `JEOCIE`"]
        pub struct JEOCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEOCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JEOCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "JEOC interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JEOCIE_A::DISABLED)
            }
            #[doc = "JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JEOCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Analog watchdog interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDIE_A {
            #[doc = "0: Analog watchdog interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Analog watchdog interrupt enabled"]
            ENABLED = 1,
        }
        impl From<AWDIE_A> for bool {
            #[inline(always)]
            fn from(variant: AWDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWDIE`"]
        pub type AWDIE_R = crate::R<bool, AWDIE_A>;
        impl AWDIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWDIE_A {
                match self.bits {
                    false => AWDIE_A::DISABLED,
                    true => AWDIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AWDIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AWDIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `AWDIE`"]
        pub struct AWDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWDIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AWDIE_A::DISABLED)
            }
            #[doc = "Analog watchdog interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AWDIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Interrupt enable for EOC\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOCIE_A {
            #[doc = "0: EOC interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set"]
            ENABLED = 1,
        }
        impl From<EOCIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOCIE`"]
        pub type EOCIE_R = crate::R<bool, EOCIE_A>;
        impl EOCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOCIE_A {
                match self.bits {
                    false => EOCIE_A::DISABLED,
                    true => EOCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOCIE`"]
        pub struct EOCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "EOC interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOCIE_A::DISABLED)
            }
            #[doc = "EOC interrupt enabled. An interrupt is generated when the EOC bit is set"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `AWDCH`"]
        pub type AWDCH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `AWDCH`"]
        pub struct AWDCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDCH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 23 - Analog watchdog enable on regular channels"]
            #[inline(always)]
            pub fn awden(&self) -> AWDEN_R {
                AWDEN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Analog watchdog enable on injected channels"]
            #[inline(always)]
            pub fn jawden(&self) -> JAWDEN_R {
                JAWDEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 13:15 - Discontinuous mode channel count"]
            #[inline(always)]
            pub fn discnum(&self) -> DISCNUM_R {
                DISCNUM_R::new(((self.bits >> 13) & 0x07) as u8)
            }
            #[doc = "Bit 12 - Discontinuous mode on injected channels"]
            #[inline(always)]
            pub fn jdiscen(&self) -> JDISCEN_R {
                JDISCEN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Discontinuous mode on regular channels"]
            #[inline(always)]
            pub fn discen(&self) -> DISCEN_R {
                DISCEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Automatic injected group conversion"]
            #[inline(always)]
            pub fn jauto(&self) -> JAUTO_R {
                JAUTO_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
            #[inline(always)]
            pub fn awdsgl(&self) -> AWDSGL_R {
                AWDSGL_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Scan mode"]
            #[inline(always)]
            pub fn scan(&self) -> SCAN_R {
                SCAN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Interrupt enable for injected channels"]
            #[inline(always)]
            pub fn jeocie(&self) -> JEOCIE_R {
                JEOCIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Analog watchdog interrupt enable"]
            #[inline(always)]
            pub fn awdie(&self) -> AWDIE_R {
                AWDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Interrupt enable for EOC"]
            #[inline(always)]
            pub fn eocie(&self) -> EOCIE_R {
                EOCIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bits 0:4 - Analog watchdog channel select bits"]
            #[inline(always)]
            pub fn awdch(&self) -> AWDCH_R {
                AWDCH_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 23 - Analog watchdog enable on regular channels"]
            #[inline(always)]
            pub fn awden(&mut self) -> AWDEN_W {
                AWDEN_W { w: self }
            }
            #[doc = "Bit 22 - Analog watchdog enable on injected channels"]
            #[inline(always)]
            pub fn jawden(&mut self) -> JAWDEN_W {
                JAWDEN_W { w: self }
            }
            #[doc = "Bits 13:15 - Discontinuous mode channel count"]
            #[inline(always)]
            pub fn discnum(&mut self) -> DISCNUM_W {
                DISCNUM_W { w: self }
            }
            #[doc = "Bit 12 - Discontinuous mode on injected channels"]
            #[inline(always)]
            pub fn jdiscen(&mut self) -> JDISCEN_W {
                JDISCEN_W { w: self }
            }
            #[doc = "Bit 11 - Discontinuous mode on regular channels"]
            #[inline(always)]
            pub fn discen(&mut self) -> DISCEN_W {
                DISCEN_W { w: self }
            }
            #[doc = "Bit 10 - Automatic injected group conversion"]
            #[inline(always)]
            pub fn jauto(&mut self) -> JAUTO_W {
                JAUTO_W { w: self }
            }
            #[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
            #[inline(always)]
            pub fn awdsgl(&mut self) -> AWDSGL_W {
                AWDSGL_W { w: self }
            }
            #[doc = "Bit 8 - Scan mode"]
            #[inline(always)]
            pub fn scan(&mut self) -> SCAN_W {
                SCAN_W { w: self }
            }
            #[doc = "Bit 7 - Interrupt enable for injected channels"]
            #[inline(always)]
            pub fn jeocie(&mut self) -> JEOCIE_W {
                JEOCIE_W { w: self }
            }
            #[doc = "Bit 6 - Analog watchdog interrupt enable"]
            #[inline(always)]
            pub fn awdie(&mut self) -> AWDIE_W {
                AWDIE_W { w: self }
            }
            #[doc = "Bit 5 - Interrupt enable for EOC"]
            #[inline(always)]
            pub fn eocie(&mut self) -> EOCIE_W {
                EOCIE_W { w: self }
            }
            #[doc = "Bits 0:4 - Analog watchdog channel select bits"]
            #[inline(always)]
            pub fn awdch(&mut self) -> AWDCH_W {
                AWDCH_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Temperature sensor and VREFINT enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSVREFE_A {
            #[doc = "0: Temperature sensor and V_REFINT channel disabled"]
            DISABLED = 0,
            #[doc = "1: Temperature sensor and V_REFINT channel enabled"]
            ENABLED = 1,
        }
        impl From<TSVREFE_A> for bool {
            #[inline(always)]
            fn from(variant: TSVREFE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSVREFE`"]
        pub type TSVREFE_R = crate::R<bool, TSVREFE_A>;
        impl TSVREFE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TSVREFE_A {
                match self.bits {
                    false => TSVREFE_A::DISABLED,
                    true => TSVREFE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TSVREFE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TSVREFE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TSVREFE`"]
        pub struct TSVREFE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSVREFE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSVREFE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Temperature sensor and V_REFINT channel disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TSVREFE_A::DISABLED)
            }
            #[doc = "Temperature sensor and V_REFINT channel enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TSVREFE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Start conversion of regular channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWSTART_A {
            #[doc = "0: Reset state"]
            STARTED = 0,
            #[doc = "1: Starting conversion of regular channels"]
            NOTSTARTED = 1,
        }
        impl From<SWSTART_A> for bool {
            #[inline(always)]
            fn from(variant: SWSTART_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SWSTART`"]
        pub type SWSTART_R = crate::R<bool, SWSTART_A>;
        impl SWSTART_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SWSTART_A {
                match self.bits {
                    false => SWSTART_A::STARTED,
                    true => SWSTART_A::NOTSTARTED,
                }
            }
            #[doc = "Checks if the value of the field is `STARTED`"]
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                *self == SWSTART_A::STARTED
            }
            #[doc = "Checks if the value of the field is `NOTSTARTED`"]
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                *self == SWSTART_A::NOTSTARTED
            }
        }
        #[doc = "Start conversion of regular channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWSTART_AW {
            #[doc = "1: Start conversion of regular channels"]
            START = 1,
        }
        impl From<SWSTART_AW> for bool {
            #[inline(always)]
            fn from(variant: SWSTART_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `SWSTART`"]
        pub struct SWSTART_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWSTART_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWSTART_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Start conversion of regular channels"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(SWSTART_AW::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Start conversion of injected channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSWSTART_A {
            #[doc = "0: Reset state"]
            STARTED = 0,
            #[doc = "1: Starting conversion of injected channels"]
            NOTSTARTED = 1,
        }
        impl From<JSWSTART_A> for bool {
            #[inline(always)]
            fn from(variant: JSWSTART_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JSWSTART`"]
        pub type JSWSTART_R = crate::R<bool, JSWSTART_A>;
        impl JSWSTART_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JSWSTART_A {
                match self.bits {
                    false => JSWSTART_A::STARTED,
                    true => JSWSTART_A::NOTSTARTED,
                }
            }
            #[doc = "Checks if the value of the field is `STARTED`"]
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                *self == JSWSTART_A::STARTED
            }
            #[doc = "Checks if the value of the field is `NOTSTARTED`"]
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                *self == JSWSTART_A::NOTSTARTED
            }
        }
        #[doc = "Start conversion of injected channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSWSTART_AW {
            #[doc = "1: Start conversion of injected channels"]
            START = 1,
        }
        impl From<JSWSTART_AW> for bool {
            #[inline(always)]
            fn from(variant: JSWSTART_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `JSWSTART`"]
        pub struct JSWSTART_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSWSTART_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JSWSTART_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Start conversion of injected channels"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(JSWSTART_AW::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "External trigger conversion mode for regular channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTTRIG_A {
            #[doc = "0: Conversion on external event disabled"]
            DISABLED = 0,
            #[doc = "1: Conversion on external event enabled"]
            ENABLED = 1,
        }
        impl From<EXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: EXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EXTTRIG`"]
        pub type EXTTRIG_R = crate::R<bool, EXTTRIG_A>;
        impl EXTTRIG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTTRIG_A {
                match self.bits {
                    false => EXTTRIG_A::DISABLED,
                    true => EXTTRIG_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EXTTRIG_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EXTTRIG_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EXTTRIG`"]
        pub struct EXTTRIG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTTRIG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTTRIG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Conversion on external event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTTRIG_A::DISABLED)
            }
            #[doc = "Conversion on external event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTTRIG_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "External event select for regular group\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTSEL_A {
            #[doc = "0: Timer 1 CC1 event"]
            TIM1CC1 = 0,
            #[doc = "1: Timer 1 CC2 event"]
            TIM1CC2 = 1,
            #[doc = "2: Timer 1 CC3 event"]
            TIM1CC3 = 2,
            #[doc = "3: Timer 2 CC2 event"]
            TIM2CC2 = 3,
            #[doc = "4: Timer 3 TRGO event"]
            TIM3TRGO = 4,
            #[doc = "5: Timer 4 CC4 event"]
            TIM4CC4 = 5,
            #[doc = "6: EXTI line 11/TIM8_TRGO event (TIM8_TRGO is available only in high-density and XL-density devices)"]
            EXTI11 = 6,
            #[doc = "7: SWSTART"]
            SWSTART = 7,
        }
        impl From<EXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTSEL`"]
        pub type EXTSEL_R = crate::R<u8, EXTSEL_A>;
        impl EXTSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTSEL_A {
                match self.bits {
                    0 => EXTSEL_A::TIM1CC1,
                    1 => EXTSEL_A::TIM1CC2,
                    2 => EXTSEL_A::TIM1CC3,
                    3 => EXTSEL_A::TIM2CC2,
                    4 => EXTSEL_A::TIM3TRGO,
                    5 => EXTSEL_A::TIM4CC4,
                    6 => EXTSEL_A::EXTI11,
                    7 => EXTSEL_A::SWSTART,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIM1CC1`"]
            #[inline(always)]
            pub fn is_tim1cc1(&self) -> bool {
                *self == EXTSEL_A::TIM1CC1
            }
            #[doc = "Checks if the value of the field is `TIM1CC2`"]
            #[inline(always)]
            pub fn is_tim1cc2(&self) -> bool {
                *self == EXTSEL_A::TIM1CC2
            }
            #[doc = "Checks if the value of the field is `TIM1CC3`"]
            #[inline(always)]
            pub fn is_tim1cc3(&self) -> bool {
                *self == EXTSEL_A::TIM1CC3
            }
            #[doc = "Checks if the value of the field is `TIM2CC2`"]
            #[inline(always)]
            pub fn is_tim2cc2(&self) -> bool {
                *self == EXTSEL_A::TIM2CC2
            }
            #[doc = "Checks if the value of the field is `TIM3TRGO`"]
            #[inline(always)]
            pub fn is_tim3trgo(&self) -> bool {
                *self == EXTSEL_A::TIM3TRGO
            }
            #[doc = "Checks if the value of the field is `TIM4CC4`"]
            #[inline(always)]
            pub fn is_tim4cc4(&self) -> bool {
                *self == EXTSEL_A::TIM4CC4
            }
            #[doc = "Checks if the value of the field is `EXTI11`"]
            #[inline(always)]
            pub fn is_exti11(&self) -> bool {
                *self == EXTSEL_A::EXTI11
            }
            #[doc = "Checks if the value of the field is `SWSTART`"]
            #[inline(always)]
            pub fn is_swstart(&self) -> bool {
                *self == EXTSEL_A::SWSTART
            }
        }
        #[doc = "Write proxy for field `EXTSEL`"]
        pub struct EXTSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Timer 1 CC1 event"]
            #[inline(always)]
            pub fn tim1cc1(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM1CC1)
            }
            #[doc = "Timer 1 CC2 event"]
            #[inline(always)]
            pub fn tim1cc2(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM1CC2)
            }
            #[doc = "Timer 1 CC3 event"]
            #[inline(always)]
            pub fn tim1cc3(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM1CC3)
            }
            #[doc = "Timer 2 CC2 event"]
            #[inline(always)]
            pub fn tim2cc2(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM2CC2)
            }
            #[doc = "Timer 3 TRGO event"]
            #[inline(always)]
            pub fn tim3trgo(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM3TRGO)
            }
            #[doc = "Timer 4 CC4 event"]
            #[inline(always)]
            pub fn tim4cc4(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM4CC4)
            }
            #[doc = "EXTI line 11/TIM8_TRGO event (TIM8_TRGO is available only in high-density and XL-density devices)"]
            #[inline(always)]
            pub fn exti11(self) -> &'a mut W {
                self.variant(EXTSEL_A::EXTI11)
            }
            #[doc = "SWSTART"]
            #[inline(always)]
            pub fn swstart(self) -> &'a mut W {
                self.variant(EXTSEL_A::SWSTART)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 17)) | (((value as u32) & 0x07) << 17);
                self.w
            }
        }
        #[doc = "External trigger conversion mode for injected channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEXTTRIG_A {
            #[doc = "0: Conversion on external event disabled"]
            DISABLED = 0,
            #[doc = "1: Conversion on external event enabled"]
            ENABLED = 1,
        }
        impl From<JEXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: JEXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `JEXTTRIG`"]
        pub type JEXTTRIG_R = crate::R<bool, JEXTTRIG_A>;
        impl JEXTTRIG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JEXTTRIG_A {
                match self.bits {
                    false => JEXTTRIG_A::DISABLED,
                    true => JEXTTRIG_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == JEXTTRIG_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == JEXTTRIG_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `JEXTTRIG`"]
        pub struct JEXTTRIG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEXTTRIG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JEXTTRIG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Conversion on external event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JEXTTRIG_A::DISABLED)
            }
            #[doc = "Conversion on external event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JEXTTRIG_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "External event select for injected group\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum JEXTSEL_A {
            #[doc = "0: Timer 1 TRGO event"]
            TIM1TRGO = 0,
            #[doc = "1: Timer 1 CC4 event"]
            TIM1CC4 = 1,
            #[doc = "2: Timer 2 TRGO event"]
            TIM2TRGO = 2,
            #[doc = "3: Timer 2 CC1 event"]
            TIM2CC1 = 3,
            #[doc = "4: Timer 3 CC4 event"]
            TIM3CC4 = 4,
            #[doc = "5: Timer 4 TRGO event"]
            TIM4TRGO = 5,
            #[doc = "6: EXTI line15/TIM8_CC4 event (TIM8_CC4 is available only in high-density and XL-density devices)"]
            EXTI15 = 6,
            #[doc = "7: JSWSTART"]
            JSWSTART = 7,
        }
        impl From<JEXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: JEXTSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `JEXTSEL`"]
        pub type JEXTSEL_R = crate::R<u8, JEXTSEL_A>;
        impl JEXTSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> JEXTSEL_A {
                match self.bits {
                    0 => JEXTSEL_A::TIM1TRGO,
                    1 => JEXTSEL_A::TIM1CC4,
                    2 => JEXTSEL_A::TIM2TRGO,
                    3 => JEXTSEL_A::TIM2CC1,
                    4 => JEXTSEL_A::TIM3CC4,
                    5 => JEXTSEL_A::TIM4TRGO,
                    6 => JEXTSEL_A::EXTI15,
                    7 => JEXTSEL_A::JSWSTART,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIM1TRGO`"]
            #[inline(always)]
            pub fn is_tim1trgo(&self) -> bool {
                *self == JEXTSEL_A::TIM1TRGO
            }
            #[doc = "Checks if the value of the field is `TIM1CC4`"]
            #[inline(always)]
            pub fn is_tim1cc4(&self) -> bool {
                *self == JEXTSEL_A::TIM1CC4
            }
            #[doc = "Checks if the value of the field is `TIM2TRGO`"]
            #[inline(always)]
            pub fn is_tim2trgo(&self) -> bool {
                *self == JEXTSEL_A::TIM2TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2CC1`"]
            #[inline(always)]
            pub fn is_tim2cc1(&self) -> bool {
                *self == JEXTSEL_A::TIM2CC1
            }
            #[doc = "Checks if the value of the field is `TIM3CC4`"]
            #[inline(always)]
            pub fn is_tim3cc4(&self) -> bool {
                *self == JEXTSEL_A::TIM3CC4
            }
            #[doc = "Checks if the value of the field is `TIM4TRGO`"]
            #[inline(always)]
            pub fn is_tim4trgo(&self) -> bool {
                *self == JEXTSEL_A::TIM4TRGO
            }
            #[doc = "Checks if the value of the field is `EXTI15`"]
            #[inline(always)]
            pub fn is_exti15(&self) -> bool {
                *self == JEXTSEL_A::EXTI15
            }
            #[doc = "Checks if the value of the field is `JSWSTART`"]
            #[inline(always)]
            pub fn is_jswstart(&self) -> bool {
                *self == JEXTSEL_A::JSWSTART
            }
        }
        #[doc = "Write proxy for field `JEXTSEL`"]
        pub struct JEXTSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEXTSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: JEXTSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Timer 1 TRGO event"]
            #[inline(always)]
            pub fn tim1trgo(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM1TRGO)
            }
            #[doc = "Timer 1 CC4 event"]
            #[inline(always)]
            pub fn tim1cc4(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM1CC4)
            }
            #[doc = "Timer 2 TRGO event"]
            #[inline(always)]
            pub fn tim2trgo(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM2TRGO)
            }
            #[doc = "Timer 2 CC1 event"]
            #[inline(always)]
            pub fn tim2cc1(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM2CC1)
            }
            #[doc = "Timer 3 CC4 event"]
            #[inline(always)]
            pub fn tim3cc4(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM3CC4)
            }
            #[doc = "Timer 4 TRGO event"]
            #[inline(always)]
            pub fn tim4trgo(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM4TRGO)
            }
            #[doc = "EXTI line15/TIM8_CC4 event (TIM8_CC4 is available only in high-density and XL-density devices)"]
            #[inline(always)]
            pub fn exti15(self) -> &'a mut W {
                self.variant(JEXTSEL_A::EXTI15)
            }
            #[doc = "JSWSTART"]
            #[inline(always)]
            pub fn jswstart(self) -> &'a mut W {
                self.variant(JEXTSEL_A::JSWSTART)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Data alignment\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALIGN_A {
            #[doc = "0: Right Alignment"]
            RIGHT = 0,
            #[doc = "1: Left Alignment"]
            LEFT = 1,
        }
        impl From<ALIGN_A> for bool {
            #[inline(always)]
            fn from(variant: ALIGN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALIGN`"]
        pub type ALIGN_R = crate::R<bool, ALIGN_A>;
        impl ALIGN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALIGN_A {
                match self.bits {
                    false => ALIGN_A::RIGHT,
                    true => ALIGN_A::LEFT,
                }
            }
            #[doc = "Checks if the value of the field is `RIGHT`"]
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == ALIGN_A::RIGHT
            }
            #[doc = "Checks if the value of the field is `LEFT`"]
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == ALIGN_A::LEFT
            }
        }
        #[doc = "Write proxy for field `ALIGN`"]
        pub struct ALIGN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALIGN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALIGN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Right Alignment"]
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(ALIGN_A::RIGHT)
            }
            #[doc = "Left Alignment"]
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(ALIGN_A::LEFT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Direct memory access mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA_A {
            #[doc = "0: DMA mode disabled"]
            DISABLED = 0,
            #[doc = "1: DMA mode enabled"]
            ENABLED = 1,
        }
        impl From<DMA_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMA`"]
        pub type DMA_R = crate::R<bool, DMA_A>;
        impl DMA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMA_A {
                match self.bits {
                    false => DMA_A::DISABLED,
                    true => DMA_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMA_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMA_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMA`"]
        pub struct DMA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA_A::DISABLED)
            }
            #[doc = "DMA mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reset calibration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSTCAL_A {
            #[doc = "0: Calibration register initialized"]
            INITIALIZED = 0,
            #[doc = "1: Initializing calibration register"]
            NOTINITIALIZED = 1,
        }
        impl From<RSTCAL_A> for bool {
            #[inline(always)]
            fn from(variant: RSTCAL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RSTCAL`"]
        pub type RSTCAL_R = crate::R<bool, RSTCAL_A>;
        impl RSTCAL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RSTCAL_A {
                match self.bits {
                    false => RSTCAL_A::INITIALIZED,
                    true => RSTCAL_A::NOTINITIALIZED,
                }
            }
            #[doc = "Checks if the value of the field is `INITIALIZED`"]
            #[inline(always)]
            pub fn is_initialized(&self) -> bool {
                *self == RSTCAL_A::INITIALIZED
            }
            #[doc = "Checks if the value of the field is `NOTINITIALIZED`"]
            #[inline(always)]
            pub fn is_not_initialized(&self) -> bool {
                *self == RSTCAL_A::NOTINITIALIZED
            }
        }
        #[doc = "Reset calibration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSTCAL_AW {
            #[doc = "1: Initialize calibration register"]
            INITIALIZE = 1,
        }
        impl From<RSTCAL_AW> for bool {
            #[inline(always)]
            fn from(variant: RSTCAL_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RSTCAL`"]
        pub struct RSTCAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSTCAL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSTCAL_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Initialize calibration register"]
            #[inline(always)]
            pub fn initialize(self) -> &'a mut W {
                self.variant(RSTCAL_AW::INITIALIZE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "A/D calibration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAL_A {
            #[doc = "0: Calibration completed"]
            COMPLETE = 0,
            #[doc = "1: Calibrating"]
            NOTCOMPLETE = 1,
        }
        impl From<CAL_A> for bool {
            #[inline(always)]
            fn from(variant: CAL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CAL`"]
        pub type CAL_R = crate::R<bool, CAL_A>;
        impl CAL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CAL_A {
                match self.bits {
                    false => CAL_A::COMPLETE,
                    true => CAL_A::NOTCOMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == CAL_A::COMPLETE
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == CAL_A::NOTCOMPLETE
            }
        }
        #[doc = "A/D calibration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAL_AW {
            #[doc = "1: Enable calibration"]
            START = 1,
        }
        impl From<CAL_AW> for bool {
            #[inline(always)]
            fn from(variant: CAL_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CAL`"]
        pub struct CAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CAL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CAL_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Enable calibration"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(CAL_AW::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Continuous conversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CONT_A {
            #[doc = "0: Single conversion mode"]
            SINGLE = 0,
            #[doc = "1: Continuous conversion mode"]
            CONTINUOUS = 1,
        }
        impl From<CONT_A> for bool {
            #[inline(always)]
            fn from(variant: CONT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CONT`"]
        pub type CONT_R = crate::R<bool, CONT_A>;
        impl CONT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CONT_A {
                match self.bits {
                    false => CONT_A::SINGLE,
                    true => CONT_A::CONTINUOUS,
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == CONT_A::SINGLE
            }
            #[doc = "Checks if the value of the field is `CONTINUOUS`"]
            #[inline(always)]
            pub fn is_continuous(&self) -> bool {
                *self == CONT_A::CONTINUOUS
            }
        }
        #[doc = "Write proxy for field `CONT`"]
        pub struct CONT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CONT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CONT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Single conversion mode"]
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(CONT_A::SINGLE)
            }
            #[doc = "Continuous conversion mode"]
            #[inline(always)]
            pub fn continuous(self) -> &'a mut W {
                self.variant(CONT_A::CONTINUOUS)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "A/D converter ON / OFF\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADON_A {
            #[doc = "0: Disable ADC conversion/calibration and go to power down mode"]
            DISABLED = 0,
            #[doc = "1: Enable ADC and to start conversion"]
            ENABLED = 1,
        }
        impl From<ADON_A> for bool {
            #[inline(always)]
            fn from(variant: ADON_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADON`"]
        pub type ADON_R = crate::R<bool, ADON_A>;
        impl ADON_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADON_A {
                match self.bits {
                    false => ADON_A::DISABLED,
                    true => ADON_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ADON_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ADON_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ADON`"]
        pub struct ADON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable ADC conversion/calibration and go to power down mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADON_A::DISABLED)
            }
            #[doc = "Enable ADC and to start conversion"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
            #[inline(always)]
            pub fn tsvrefe(&self) -> TSVREFE_R {
                TSVREFE_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Start conversion of regular channels"]
            #[inline(always)]
            pub fn swstart(&self) -> SWSTART_R {
                SWSTART_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Start conversion of injected channels"]
            #[inline(always)]
            pub fn jswstart(&self) -> JSWSTART_R {
                JSWSTART_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 20 - External trigger conversion mode for regular channels"]
            #[inline(always)]
            pub fn exttrig(&self) -> EXTTRIG_R {
                EXTTRIG_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bits 17:19 - External event select for regular group"]
            #[inline(always)]
            pub fn extsel(&self) -> EXTSEL_R {
                EXTSEL_R::new(((self.bits >> 17) & 0x07) as u8)
            }
            #[doc = "Bit 15 - External trigger conversion mode for injected channels"]
            #[inline(always)]
            pub fn jexttrig(&self) -> JEXTTRIG_R {
                JEXTTRIG_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - External event select for injected group"]
            #[inline(always)]
            pub fn jextsel(&self) -> JEXTSEL_R {
                JEXTSEL_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Data alignment"]
            #[inline(always)]
            pub fn align(&self) -> ALIGN_R {
                ALIGN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Direct memory access mode"]
            #[inline(always)]
            pub fn dma(&self) -> DMA_R {
                DMA_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Reset calibration"]
            #[inline(always)]
            pub fn rstcal(&self) -> RSTCAL_R {
                RSTCAL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - A/D calibration"]
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Continuous conversion"]
            #[inline(always)]
            pub fn cont(&self) -> CONT_R {
                CONT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - A/D converter ON / OFF"]
            #[inline(always)]
            pub fn adon(&self) -> ADON_R {
                ADON_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
            #[inline(always)]
            pub fn tsvrefe(&mut self) -> TSVREFE_W {
                TSVREFE_W { w: self }
            }
            #[doc = "Bit 22 - Start conversion of regular channels"]
            #[inline(always)]
            pub fn swstart(&mut self) -> SWSTART_W {
                SWSTART_W { w: self }
            }
            #[doc = "Bit 21 - Start conversion of injected channels"]
            #[inline(always)]
            pub fn jswstart(&mut self) -> JSWSTART_W {
                JSWSTART_W { w: self }
            }
            #[doc = "Bit 20 - External trigger conversion mode for regular channels"]
            #[inline(always)]
            pub fn exttrig(&mut self) -> EXTTRIG_W {
                EXTTRIG_W { w: self }
            }
            #[doc = "Bits 17:19 - External event select for regular group"]
            #[inline(always)]
            pub fn extsel(&mut self) -> EXTSEL_W {
                EXTSEL_W { w: self }
            }
            #[doc = "Bit 15 - External trigger conversion mode for injected channels"]
            #[inline(always)]
            pub fn jexttrig(&mut self) -> JEXTTRIG_W {
                JEXTTRIG_W { w: self }
            }
            #[doc = "Bits 12:14 - External event select for injected group"]
            #[inline(always)]
            pub fn jextsel(&mut self) -> JEXTSEL_W {
                JEXTSEL_W { w: self }
            }
            #[doc = "Bit 11 - Data alignment"]
            #[inline(always)]
            pub fn align(&mut self) -> ALIGN_W {
                ALIGN_W { w: self }
            }
            #[doc = "Bit 8 - Direct memory access mode"]
            #[inline(always)]
            pub fn dma(&mut self) -> DMA_W {
                DMA_W { w: self }
            }
            #[doc = "Bit 3 - Reset calibration"]
            #[inline(always)]
            pub fn rstcal(&mut self) -> RSTCAL_W {
                RSTCAL_W { w: self }
            }
            #[doc = "Bit 2 - A/D calibration"]
            #[inline(always)]
            pub fn cal(&mut self) -> CAL_W {
                CAL_W { w: self }
            }
            #[doc = "Bit 1 - Continuous conversion"]
            #[inline(always)]
            pub fn cont(&mut self) -> CONT_W {
                CONT_W { w: self }
            }
            #[doc = "Bit 0 - A/D converter ON / OFF"]
            #[inline(always)]
            pub fn adon(&mut self) -> ADON_W {
                ADON_W { w: self }
            }
        }
    }
    #[doc = "sample time register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smpr1](smpr1) module"]
    pub type SMPR1 = crate::Reg<u32, _SMPR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMPR1;
    #[doc = "`read()` method returns [smpr1::R](smpr1::R) reader structure"]
    impl crate::Readable for SMPR1 {}
    #[doc = "`write(|w| ..)` method takes [smpr1::W](smpr1::W) writer structure"]
    impl crate::Writable for SMPR1 {}
    #[doc = "sample time register 1"]
    pub mod smpr1 {
        #[doc = "Reader of register SMPR1"]
        pub type R = crate::R<u32, super::SMPR1>;
        #[doc = "Writer for register SMPR1"]
        pub type W = crate::W<u32, super::SMPR1>;
        #[doc = "Register SMPR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMPR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Channel 10 sample time selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMP10_A {
            #[doc = "0: 1.5 ADC clock cycles"]
            CYCLES1_5 = 0,
            #[doc = "1: 7.5 ADC clock cycles"]
            CYCLES7_5 = 1,
            #[doc = "2: 13.5 ADC clock cycles"]
            CYCLES13_5 = 2,
            #[doc = "3: 28.5 ADC clock cycles"]
            CYCLES28_5 = 3,
            #[doc = "4: 41.5 ADC clock cycles"]
            CYCLES41_5 = 4,
            #[doc = "5: 55.5 ADC clock cycles"]
            CYCLES55_5 = 5,
            #[doc = "6: 71.5 ADC clock cycles"]
            CYCLES71_5 = 6,
            #[doc = "7: 239.5 ADC clock cycles"]
            CYCLES239_5 = 7,
        }
        impl From<SMP10_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP10_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMP10`"]
        pub type SMP10_R = crate::R<u8, SMP10_A>;
        impl SMP10_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMP10_A {
                match self.bits {
                    0 => SMP10_A::CYCLES1_5,
                    1 => SMP10_A::CYCLES7_5,
                    2 => SMP10_A::CYCLES13_5,
                    3 => SMP10_A::CYCLES28_5,
                    4 => SMP10_A::CYCLES41_5,
                    5 => SMP10_A::CYCLES55_5,
                    6 => SMP10_A::CYCLES71_5,
                    7 => SMP10_A::CYCLES239_5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CYCLES1_5`"]
            #[inline(always)]
            pub fn is_cycles1_5(&self) -> bool {
                *self == SMP10_A::CYCLES1_5
            }
            #[doc = "Checks if the value of the field is `CYCLES7_5`"]
            #[inline(always)]
            pub fn is_cycles7_5(&self) -> bool {
                *self == SMP10_A::CYCLES7_5
            }
            #[doc = "Checks if the value of the field is `CYCLES13_5`"]
            #[inline(always)]
            pub fn is_cycles13_5(&self) -> bool {
                *self == SMP10_A::CYCLES13_5
            }
            #[doc = "Checks if the value of the field is `CYCLES28_5`"]
            #[inline(always)]
            pub fn is_cycles28_5(&self) -> bool {
                *self == SMP10_A::CYCLES28_5
            }
            #[doc = "Checks if the value of the field is `CYCLES41_5`"]
            #[inline(always)]
            pub fn is_cycles41_5(&self) -> bool {
                *self == SMP10_A::CYCLES41_5
            }
            #[doc = "Checks if the value of the field is `CYCLES55_5`"]
            #[inline(always)]
            pub fn is_cycles55_5(&self) -> bool {
                *self == SMP10_A::CYCLES55_5
            }
            #[doc = "Checks if the value of the field is `CYCLES71_5`"]
            #[inline(always)]
            pub fn is_cycles71_5(&self) -> bool {
                *self == SMP10_A::CYCLES71_5
            }
            #[doc = "Checks if the value of the field is `CYCLES239_5`"]
            #[inline(always)]
            pub fn is_cycles239_5(&self) -> bool {
                *self == SMP10_A::CYCLES239_5
            }
        }
        #[doc = "Write proxy for field `SMP10`"]
        pub struct SMP10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Channel 11 sample time selection"]
        pub type SMP11_A = SMP10_A;
        #[doc = "Reader of field `SMP11`"]
        pub type SMP11_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP11`"]
        pub struct SMP11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | (((value as u32) & 0x07) << 3);
                self.w
            }
        }
        #[doc = "Channel 12 sample time selection"]
        pub type SMP12_A = SMP10_A;
        #[doc = "Reader of field `SMP12`"]
        pub type SMP12_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP12`"]
        pub struct SMP12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 6)) | (((value as u32) & 0x07) << 6);
                self.w
            }
        }
        #[doc = "Channel 13 sample time selection"]
        pub type SMP13_A = SMP10_A;
        #[doc = "Reader of field `SMP13`"]
        pub type SMP13_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP13`"]
        pub struct SMP13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 9)) | (((value as u32) & 0x07) << 9);
                self.w
            }
        }
        #[doc = "Channel 14 sample time selection"]
        pub type SMP14_A = SMP10_A;
        #[doc = "Reader of field `SMP14`"]
        pub type SMP14_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP14`"]
        pub struct SMP14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Channel 15 sample time selection"]
        pub type SMP15_A = SMP10_A;
        #[doc = "Reader of field `SMP15`"]
        pub type SMP15_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP15`"]
        pub struct SMP15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 15)) | (((value as u32) & 0x07) << 15);
                self.w
            }
        }
        #[doc = "Channel 16 sample time selection"]
        pub type SMP16_A = SMP10_A;
        #[doc = "Reader of field `SMP16`"]
        pub type SMP16_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP16`"]
        pub struct SMP16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP16_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 18)) | (((value as u32) & 0x07) << 18);
                self.w
            }
        }
        #[doc = "Channel 17 sample time selection"]
        pub type SMP17_A = SMP10_A;
        #[doc = "Reader of field `SMP17`"]
        pub type SMP17_R = crate::R<u8, SMP10_A>;
        #[doc = "Write proxy for field `SMP17`"]
        pub struct SMP17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP17_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 21)) | (((value as u32) & 0x07) << 21);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Channel 10 sample time selection"]
            #[inline(always)]
            pub fn smp10(&self) -> SMP10_R {
                SMP10_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 3:5 - Channel 11 sample time selection"]
            #[inline(always)]
            pub fn smp11(&self) -> SMP11_R {
                SMP11_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            #[doc = "Bits 6:8 - Channel 12 sample time selection"]
            #[inline(always)]
            pub fn smp12(&self) -> SMP12_R {
                SMP12_R::new(((self.bits >> 6) & 0x07) as u8)
            }
            #[doc = "Bits 9:11 - Channel 13 sample time selection"]
            #[inline(always)]
            pub fn smp13(&self) -> SMP13_R {
                SMP13_R::new(((self.bits >> 9) & 0x07) as u8)
            }
            #[doc = "Bits 12:14 - Channel 14 sample time selection"]
            #[inline(always)]
            pub fn smp14(&self) -> SMP14_R {
                SMP14_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 15:17 - Channel 15 sample time selection"]
            #[inline(always)]
            pub fn smp15(&self) -> SMP15_R {
                SMP15_R::new(((self.bits >> 15) & 0x07) as u8)
            }
            #[doc = "Bits 18:20 - Channel 16 sample time selection"]
            #[inline(always)]
            pub fn smp16(&self) -> SMP16_R {
                SMP16_R::new(((self.bits >> 18) & 0x07) as u8)
            }
            #[doc = "Bits 21:23 - Channel 17 sample time selection"]
            #[inline(always)]
            pub fn smp17(&self) -> SMP17_R {
                SMP17_R::new(((self.bits >> 21) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Channel 10 sample time selection"]
            #[inline(always)]
            pub fn smp10(&mut self) -> SMP10_W {
                SMP10_W { w: self }
            }
            #[doc = "Bits 3:5 - Channel 11 sample time selection"]
            #[inline(always)]
            pub fn smp11(&mut self) -> SMP11_W {
                SMP11_W { w: self }
            }
            #[doc = "Bits 6:8 - Channel 12 sample time selection"]
            #[inline(always)]
            pub fn smp12(&mut self) -> SMP12_W {
                SMP12_W { w: self }
            }
            #[doc = "Bits 9:11 - Channel 13 sample time selection"]
            #[inline(always)]
            pub fn smp13(&mut self) -> SMP13_W {
                SMP13_W { w: self }
            }
            #[doc = "Bits 12:14 - Channel 14 sample time selection"]
            #[inline(always)]
            pub fn smp14(&mut self) -> SMP14_W {
                SMP14_W { w: self }
            }
            #[doc = "Bits 15:17 - Channel 15 sample time selection"]
            #[inline(always)]
            pub fn smp15(&mut self) -> SMP15_W {
                SMP15_W { w: self }
            }
            #[doc = "Bits 18:20 - Channel 16 sample time selection"]
            #[inline(always)]
            pub fn smp16(&mut self) -> SMP16_W {
                SMP16_W { w: self }
            }
            #[doc = "Bits 21:23 - Channel 17 sample time selection"]
            #[inline(always)]
            pub fn smp17(&mut self) -> SMP17_W {
                SMP17_W { w: self }
            }
        }
    }
    #[doc = "sample time register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smpr2](smpr2) module"]
    pub type SMPR2 = crate::Reg<u32, _SMPR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMPR2;
    #[doc = "`read()` method returns [smpr2::R](smpr2::R) reader structure"]
    impl crate::Readable for SMPR2 {}
    #[doc = "`write(|w| ..)` method takes [smpr2::W](smpr2::W) writer structure"]
    impl crate::Writable for SMPR2 {}
    #[doc = "sample time register 2"]
    pub mod smpr2 {
        #[doc = "Reader of register SMPR2"]
        pub type R = crate::R<u32, super::SMPR2>;
        #[doc = "Writer for register SMPR2"]
        pub type W = crate::W<u32, super::SMPR2>;
        #[doc = "Register SMPR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMPR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Channel 0 sample time selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMP0_A {
            #[doc = "0: 1.5 ADC clock cycles"]
            CYCLES1_5 = 0,
            #[doc = "1: 7.5 ADC clock cycles"]
            CYCLES7_5 = 1,
            #[doc = "2: 13.5 ADC clock cycles"]
            CYCLES13_5 = 2,
            #[doc = "3: 28.5 ADC clock cycles"]
            CYCLES28_5 = 3,
            #[doc = "4: 41.5 ADC clock cycles"]
            CYCLES41_5 = 4,
            #[doc = "5: 55.5 ADC clock cycles"]
            CYCLES55_5 = 5,
            #[doc = "6: 71.5 ADC clock cycles"]
            CYCLES71_5 = 6,
            #[doc = "7: 239.5 ADC clock cycles"]
            CYCLES239_5 = 7,
        }
        impl From<SMP0_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP0_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMP0`"]
        pub type SMP0_R = crate::R<u8, SMP0_A>;
        impl SMP0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMP0_A {
                match self.bits {
                    0 => SMP0_A::CYCLES1_5,
                    1 => SMP0_A::CYCLES7_5,
                    2 => SMP0_A::CYCLES13_5,
                    3 => SMP0_A::CYCLES28_5,
                    4 => SMP0_A::CYCLES41_5,
                    5 => SMP0_A::CYCLES55_5,
                    6 => SMP0_A::CYCLES71_5,
                    7 => SMP0_A::CYCLES239_5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CYCLES1_5`"]
            #[inline(always)]
            pub fn is_cycles1_5(&self) -> bool {
                *self == SMP0_A::CYCLES1_5
            }
            #[doc = "Checks if the value of the field is `CYCLES7_5`"]
            #[inline(always)]
            pub fn is_cycles7_5(&self) -> bool {
                *self == SMP0_A::CYCLES7_5
            }
            #[doc = "Checks if the value of the field is `CYCLES13_5`"]
            #[inline(always)]
            pub fn is_cycles13_5(&self) -> bool {
                *self == SMP0_A::CYCLES13_5
            }
            #[doc = "Checks if the value of the field is `CYCLES28_5`"]
            #[inline(always)]
            pub fn is_cycles28_5(&self) -> bool {
                *self == SMP0_A::CYCLES28_5
            }
            #[doc = "Checks if the value of the field is `CYCLES41_5`"]
            #[inline(always)]
            pub fn is_cycles41_5(&self) -> bool {
                *self == SMP0_A::CYCLES41_5
            }
            #[doc = "Checks if the value of the field is `CYCLES55_5`"]
            #[inline(always)]
            pub fn is_cycles55_5(&self) -> bool {
                *self == SMP0_A::CYCLES55_5
            }
            #[doc = "Checks if the value of the field is `CYCLES71_5`"]
            #[inline(always)]
            pub fn is_cycles71_5(&self) -> bool {
                *self == SMP0_A::CYCLES71_5
            }
            #[doc = "Checks if the value of the field is `CYCLES239_5`"]
            #[inline(always)]
            pub fn is_cycles239_5(&self) -> bool {
                *self == SMP0_A::CYCLES239_5
            }
        }
        #[doc = "Write proxy for field `SMP0`"]
        pub struct SMP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Channel 1 sample time selection"]
        pub type SMP1_A = SMP0_A;
        #[doc = "Reader of field `SMP1`"]
        pub type SMP1_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP1`"]
        pub struct SMP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | (((value as u32) & 0x07) << 3);
                self.w
            }
        }
        #[doc = "Channel 2 sample time selection"]
        pub type SMP2_A = SMP0_A;
        #[doc = "Reader of field `SMP2`"]
        pub type SMP2_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP2`"]
        pub struct SMP2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 6)) | (((value as u32) & 0x07) << 6);
                self.w
            }
        }
        #[doc = "Channel 3 sample time selection"]
        pub type SMP3_A = SMP0_A;
        #[doc = "Reader of field `SMP3`"]
        pub type SMP3_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP3`"]
        pub struct SMP3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 9)) | (((value as u32) & 0x07) << 9);
                self.w
            }
        }
        #[doc = "Channel 4 sample time selection"]
        pub type SMP4_A = SMP0_A;
        #[doc = "Reader of field `SMP4`"]
        pub type SMP4_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP4`"]
        pub struct SMP4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Channel 5 sample time selection"]
        pub type SMP5_A = SMP0_A;
        #[doc = "Reader of field `SMP5`"]
        pub type SMP5_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP5`"]
        pub struct SMP5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 15)) | (((value as u32) & 0x07) << 15);
                self.w
            }
        }
        #[doc = "Channel 6 sample time selection"]
        pub type SMP6_A = SMP0_A;
        #[doc = "Reader of field `SMP6`"]
        pub type SMP6_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP6`"]
        pub struct SMP6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 18)) | (((value as u32) & 0x07) << 18);
                self.w
            }
        }
        #[doc = "Channel 7 sample time selection"]
        pub type SMP7_A = SMP0_A;
        #[doc = "Reader of field `SMP7`"]
        pub type SMP7_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP7`"]
        pub struct SMP7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 21)) | (((value as u32) & 0x07) << 21);
                self.w
            }
        }
        #[doc = "Channel 8 sample time selection"]
        pub type SMP8_A = SMP0_A;
        #[doc = "Reader of field `SMP8`"]
        pub type SMP8_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP8`"]
        pub struct SMP8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | (((value as u32) & 0x07) << 24);
                self.w
            }
        }
        #[doc = "Channel 9 sample time selection"]
        pub type SMP9_A = SMP0_A;
        #[doc = "Reader of field `SMP9`"]
        pub type SMP9_R = crate::R<u8, SMP0_A>;
        #[doc = "Write proxy for field `SMP9`"]
        pub struct SMP9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            #[doc = "13.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            #[doc = "28.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            #[doc = "41.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            #[doc = "55.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            #[doc = "71.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            #[doc = "239.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 27)) | (((value as u32) & 0x07) << 27);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Channel 0 sample time selection"]
            #[inline(always)]
            pub fn smp0(&self) -> SMP0_R {
                SMP0_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 3:5 - Channel 1 sample time selection"]
            #[inline(always)]
            pub fn smp1(&self) -> SMP1_R {
                SMP1_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            #[doc = "Bits 6:8 - Channel 2 sample time selection"]
            #[inline(always)]
            pub fn smp2(&self) -> SMP2_R {
                SMP2_R::new(((self.bits >> 6) & 0x07) as u8)
            }
            #[doc = "Bits 9:11 - Channel 3 sample time selection"]
            #[inline(always)]
            pub fn smp3(&self) -> SMP3_R {
                SMP3_R::new(((self.bits >> 9) & 0x07) as u8)
            }
            #[doc = "Bits 12:14 - Channel 4 sample time selection"]
            #[inline(always)]
            pub fn smp4(&self) -> SMP4_R {
                SMP4_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 15:17 - Channel 5 sample time selection"]
            #[inline(always)]
            pub fn smp5(&self) -> SMP5_R {
                SMP5_R::new(((self.bits >> 15) & 0x07) as u8)
            }
            #[doc = "Bits 18:20 - Channel 6 sample time selection"]
            #[inline(always)]
            pub fn smp6(&self) -> SMP6_R {
                SMP6_R::new(((self.bits >> 18) & 0x07) as u8)
            }
            #[doc = "Bits 21:23 - Channel 7 sample time selection"]
            #[inline(always)]
            pub fn smp7(&self) -> SMP7_R {
                SMP7_R::new(((self.bits >> 21) & 0x07) as u8)
            }
            #[doc = "Bits 24:26 - Channel 8 sample time selection"]
            #[inline(always)]
            pub fn smp8(&self) -> SMP8_R {
                SMP8_R::new(((self.bits >> 24) & 0x07) as u8)
            }
            #[doc = "Bits 27:29 - Channel 9 sample time selection"]
            #[inline(always)]
            pub fn smp9(&self) -> SMP9_R {
                SMP9_R::new(((self.bits >> 27) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Channel 0 sample time selection"]
            #[inline(always)]
            pub fn smp0(&mut self) -> SMP0_W {
                SMP0_W { w: self }
            }
            #[doc = "Bits 3:5 - Channel 1 sample time selection"]
            #[inline(always)]
            pub fn smp1(&mut self) -> SMP1_W {
                SMP1_W { w: self }
            }
            #[doc = "Bits 6:8 - Channel 2 sample time selection"]
            #[inline(always)]
            pub fn smp2(&mut self) -> SMP2_W {
                SMP2_W { w: self }
            }
            #[doc = "Bits 9:11 - Channel 3 sample time selection"]
            #[inline(always)]
            pub fn smp3(&mut self) -> SMP3_W {
                SMP3_W { w: self }
            }
            #[doc = "Bits 12:14 - Channel 4 sample time selection"]
            #[inline(always)]
            pub fn smp4(&mut self) -> SMP4_W {
                SMP4_W { w: self }
            }
            #[doc = "Bits 15:17 - Channel 5 sample time selection"]
            #[inline(always)]
            pub fn smp5(&mut self) -> SMP5_W {
                SMP5_W { w: self }
            }
            #[doc = "Bits 18:20 - Channel 6 sample time selection"]
            #[inline(always)]
            pub fn smp6(&mut self) -> SMP6_W {
                SMP6_W { w: self }
            }
            #[doc = "Bits 21:23 - Channel 7 sample time selection"]
            #[inline(always)]
            pub fn smp7(&mut self) -> SMP7_W {
                SMP7_W { w: self }
            }
            #[doc = "Bits 24:26 - Channel 8 sample time selection"]
            #[inline(always)]
            pub fn smp8(&mut self) -> SMP8_W {
                SMP8_W { w: self }
            }
            #[doc = "Bits 27:29 - Channel 9 sample time selection"]
            #[inline(always)]
            pub fn smp9(&mut self) -> SMP9_W {
                SMP9_W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jofr1](jofr1) module"]
    pub type JOFR1 = crate::Reg<u32, _JOFR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JOFR1;
    #[doc = "`read()` method returns [jofr1::R](jofr1::R) reader structure"]
    impl crate::Readable for JOFR1 {}
    #[doc = "`write(|w| ..)` method takes [jofr1::W](jofr1::W) writer structure"]
    impl crate::Writable for JOFR1 {}
    #[doc = "injected channel data offset register x"]
    pub mod jofr1 {
        #[doc = "Reader of register JOFR1"]
        pub type R = crate::R<u32, super::JOFR1>;
        #[doc = "Writer for register JOFR1"]
        pub type W = crate::W<u32, super::JOFR1>;
        #[doc = "Register JOFR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::JOFR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `JOFFSET1`"]
        pub type JOFFSET1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `JOFFSET1`"]
        pub struct JOFFSET1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Data offset for injected channel 1"]
            #[inline(always)]
            pub fn joffset1(&self) -> JOFFSET1_R {
                JOFFSET1_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Data offset for injected channel 1"]
            #[inline(always)]
            pub fn joffset1(&mut self) -> JOFFSET1_W {
                JOFFSET1_W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jofr2](jofr2) module"]
    pub type JOFR2 = crate::Reg<u32, _JOFR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JOFR2;
    #[doc = "`read()` method returns [jofr2::R](jofr2::R) reader structure"]
    impl crate::Readable for JOFR2 {}
    #[doc = "`write(|w| ..)` method takes [jofr2::W](jofr2::W) writer structure"]
    impl crate::Writable for JOFR2 {}
    #[doc = "injected channel data offset register x"]
    pub mod jofr2 {
        #[doc = "Reader of register JOFR2"]
        pub type R = crate::R<u32, super::JOFR2>;
        #[doc = "Writer for register JOFR2"]
        pub type W = crate::W<u32, super::JOFR2>;
        #[doc = "Register JOFR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::JOFR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `JOFFSET2`"]
        pub type JOFFSET2_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `JOFFSET2`"]
        pub struct JOFFSET2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Data offset for injected channel 2"]
            #[inline(always)]
            pub fn joffset2(&self) -> JOFFSET2_R {
                JOFFSET2_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Data offset for injected channel 2"]
            #[inline(always)]
            pub fn joffset2(&mut self) -> JOFFSET2_W {
                JOFFSET2_W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jofr3](jofr3) module"]
    pub type JOFR3 = crate::Reg<u32, _JOFR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JOFR3;
    #[doc = "`read()` method returns [jofr3::R](jofr3::R) reader structure"]
    impl crate::Readable for JOFR3 {}
    #[doc = "`write(|w| ..)` method takes [jofr3::W](jofr3::W) writer structure"]
    impl crate::Writable for JOFR3 {}
    #[doc = "injected channel data offset register x"]
    pub mod jofr3 {
        #[doc = "Reader of register JOFR3"]
        pub type R = crate::R<u32, super::JOFR3>;
        #[doc = "Writer for register JOFR3"]
        pub type W = crate::W<u32, super::JOFR3>;
        #[doc = "Register JOFR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::JOFR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `JOFFSET3`"]
        pub type JOFFSET3_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `JOFFSET3`"]
        pub struct JOFFSET3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET3_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Data offset for injected channel 3"]
            #[inline(always)]
            pub fn joffset3(&self) -> JOFFSET3_R {
                JOFFSET3_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Data offset for injected channel 3"]
            #[inline(always)]
            pub fn joffset3(&mut self) -> JOFFSET3_W {
                JOFFSET3_W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jofr4](jofr4) module"]
    pub type JOFR4 = crate::Reg<u32, _JOFR4>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JOFR4;
    #[doc = "`read()` method returns [jofr4::R](jofr4::R) reader structure"]
    impl crate::Readable for JOFR4 {}
    #[doc = "`write(|w| ..)` method takes [jofr4::W](jofr4::W) writer structure"]
    impl crate::Writable for JOFR4 {}
    #[doc = "injected channel data offset register x"]
    pub mod jofr4 {
        #[doc = "Reader of register JOFR4"]
        pub type R = crate::R<u32, super::JOFR4>;
        #[doc = "Writer for register JOFR4"]
        pub type W = crate::W<u32, super::JOFR4>;
        #[doc = "Register JOFR4 `reset()`'s with value 0"]
        impl crate::ResetValue for super::JOFR4 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `JOFFSET4`"]
        pub type JOFFSET4_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `JOFFSET4`"]
        pub struct JOFFSET4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET4_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Data offset for injected channel 4"]
            #[inline(always)]
            pub fn joffset4(&self) -> JOFFSET4_R {
                JOFFSET4_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Data offset for injected channel 4"]
            #[inline(always)]
            pub fn joffset4(&mut self) -> JOFFSET4_W {
                JOFFSET4_W { w: self }
            }
        }
    }
    #[doc = "watchdog higher threshold register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [htr](htr) module"]
    pub type HTR = crate::Reg<u32, _HTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _HTR;
    #[doc = "`read()` method returns [htr::R](htr::R) reader structure"]
    impl crate::Readable for HTR {}
    #[doc = "`write(|w| ..)` method takes [htr::W](htr::W) writer structure"]
    impl crate::Writable for HTR {}
    #[doc = "watchdog higher threshold register"]
    pub mod htr {
        #[doc = "Reader of register HTR"]
        pub type R = crate::R<u32, super::HTR>;
        #[doc = "Writer for register HTR"]
        pub type W = crate::W<u32, super::HTR>;
        #[doc = "Register HTR `reset()`'s with value 0x0fff"]
        impl crate::ResetValue for super::HTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0fff
            }
        }
        #[doc = "Reader of field `HT`"]
        pub type HT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `HT`"]
        pub struct HT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Analog watchdog higher threshold"]
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Analog watchdog higher threshold"]
            #[inline(always)]
            pub fn ht(&mut self) -> HT_W {
                HT_W { w: self }
            }
        }
    }
    #[doc = "watchdog lower threshold register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ltr](ltr) module"]
    pub type LTR = crate::Reg<u32, _LTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LTR;
    #[doc = "`read()` method returns [ltr::R](ltr::R) reader structure"]
    impl crate::Readable for LTR {}
    #[doc = "`write(|w| ..)` method takes [ltr::W](ltr::W) writer structure"]
    impl crate::Writable for LTR {}
    #[doc = "watchdog lower threshold register"]
    pub mod ltr {
        #[doc = "Reader of register LTR"]
        pub type R = crate::R<u32, super::LTR>;
        #[doc = "Writer for register LTR"]
        pub type W = crate::W<u32, super::LTR>;
        #[doc = "Register LTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::LTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `LT`"]
        pub type LT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `LT`"]
        pub struct LT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline(always)]
            pub fn lt(&self) -> LT_R {
                LT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline(always)]
            pub fn lt(&mut self) -> LT_W {
                LT_W { w: self }
            }
        }
    }
    #[doc = "regular sequence register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sqr1](sqr1) module"]
    pub type SQR1 = crate::Reg<u32, _SQR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SQR1;
    #[doc = "`read()` method returns [sqr1::R](sqr1::R) reader structure"]
    impl crate::Readable for SQR1 {}
    #[doc = "`write(|w| ..)` method takes [sqr1::W](sqr1::W) writer structure"]
    impl crate::Writable for SQR1 {}
    #[doc = "regular sequence register 1"]
    pub mod sqr1 {
        #[doc = "Reader of register SQR1"]
        pub type R = crate::R<u32, super::SQR1>;
        #[doc = "Writer for register SQR1"]
        pub type W = crate::W<u32, super::SQR1>;
        #[doc = "Register SQR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SQR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `L`"]
        pub type L_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `L`"]
        pub struct L_W<'a> {
            w: &'a mut W,
        }
        impl<'a> L_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `SQ16`"]
        pub type SQ16_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ16`"]
        pub struct SQ16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ16_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | (((value as u32) & 0x1f) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `SQ15`"]
        pub type SQ15_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ15`"]
        pub struct SQ15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ15_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | (((value as u32) & 0x1f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `SQ14`"]
        pub type SQ14_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ14`"]
        pub struct SQ14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ14_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | (((value as u32) & 0x1f) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `SQ13`"]
        pub type SQ13_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ13`"]
        pub struct SQ13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ13_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 20:23 - Regular channel sequence length"]
            #[inline(always)]
            pub fn l(&self) -> L_R {
                L_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 15:19 - 16th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq16(&self) -> SQ16_R {
                SQ16_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            #[doc = "Bits 10:14 - 15th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq15(&self) -> SQ15_R {
                SQ15_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            #[doc = "Bits 5:9 - 14th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq14(&self) -> SQ14_R {
                SQ14_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - 13th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq13(&self) -> SQ13_R {
                SQ13_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 20:23 - Regular channel sequence length"]
            #[inline(always)]
            pub fn l(&mut self) -> L_W {
                L_W { w: self }
            }
            #[doc = "Bits 15:19 - 16th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq16(&mut self) -> SQ16_W {
                SQ16_W { w: self }
            }
            #[doc = "Bits 10:14 - 15th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq15(&mut self) -> SQ15_W {
                SQ15_W { w: self }
            }
            #[doc = "Bits 5:9 - 14th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq14(&mut self) -> SQ14_W {
                SQ14_W { w: self }
            }
            #[doc = "Bits 0:4 - 13th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq13(&mut self) -> SQ13_W {
                SQ13_W { w: self }
            }
        }
    }
    #[doc = "regular sequence register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sqr2](sqr2) module"]
    pub type SQR2 = crate::Reg<u32, _SQR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SQR2;
    #[doc = "`read()` method returns [sqr2::R](sqr2::R) reader structure"]
    impl crate::Readable for SQR2 {}
    #[doc = "`write(|w| ..)` method takes [sqr2::W](sqr2::W) writer structure"]
    impl crate::Writable for SQR2 {}
    #[doc = "regular sequence register 2"]
    pub mod sqr2 {
        #[doc = "Reader of register SQR2"]
        pub type R = crate::R<u32, super::SQR2>;
        #[doc = "Writer for register SQR2"]
        pub type W = crate::W<u32, super::SQR2>;
        #[doc = "Register SQR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SQR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `SQ12`"]
        pub type SQ12_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ12`"]
        pub struct SQ12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ12_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 25)) | (((value as u32) & 0x1f) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `SQ11`"]
        pub type SQ11_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ11`"]
        pub struct SQ11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ11_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 20)) | (((value as u32) & 0x1f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `SQ10`"]
        pub type SQ10_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ10`"]
        pub struct SQ10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ10_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | (((value as u32) & 0x1f) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `SQ9`"]
        pub type SQ9_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ9`"]
        pub struct SQ9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ9_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | (((value as u32) & 0x1f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `SQ8`"]
        pub type SQ8_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ8`"]
        pub struct SQ8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ8_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | (((value as u32) & 0x1f) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `SQ7`"]
        pub type SQ7_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ7`"]
        pub struct SQ7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ7_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 25:29 - 12th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq12(&self) -> SQ12_R {
                SQ12_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
            #[doc = "Bits 20:24 - 11th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq11(&self) -> SQ11_R {
                SQ11_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            #[doc = "Bits 15:19 - 10th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq10(&self) -> SQ10_R {
                SQ10_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            #[doc = "Bits 10:14 - 9th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq9(&self) -> SQ9_R {
                SQ9_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            #[doc = "Bits 5:9 - 8th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq8(&self) -> SQ8_R {
                SQ8_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - 7th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq7(&self) -> SQ7_R {
                SQ7_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 25:29 - 12th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq12(&mut self) -> SQ12_W {
                SQ12_W { w: self }
            }
            #[doc = "Bits 20:24 - 11th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq11(&mut self) -> SQ11_W {
                SQ11_W { w: self }
            }
            #[doc = "Bits 15:19 - 10th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq10(&mut self) -> SQ10_W {
                SQ10_W { w: self }
            }
            #[doc = "Bits 10:14 - 9th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq9(&mut self) -> SQ9_W {
                SQ9_W { w: self }
            }
            #[doc = "Bits 5:9 - 8th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq8(&mut self) -> SQ8_W {
                SQ8_W { w: self }
            }
            #[doc = "Bits 0:4 - 7th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq7(&mut self) -> SQ7_W {
                SQ7_W { w: self }
            }
        }
    }
    #[doc = "regular sequence register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sqr3](sqr3) module"]
    pub type SQR3 = crate::Reg<u32, _SQR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SQR3;
    #[doc = "`read()` method returns [sqr3::R](sqr3::R) reader structure"]
    impl crate::Readable for SQR3 {}
    #[doc = "`write(|w| ..)` method takes [sqr3::W](sqr3::W) writer structure"]
    impl crate::Writable for SQR3 {}
    #[doc = "regular sequence register 3"]
    pub mod sqr3 {
        #[doc = "Reader of register SQR3"]
        pub type R = crate::R<u32, super::SQR3>;
        #[doc = "Writer for register SQR3"]
        pub type W = crate::W<u32, super::SQR3>;
        #[doc = "Register SQR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SQR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `SQ6`"]
        pub type SQ6_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ6`"]
        pub struct SQ6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ6_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 25)) | (((value as u32) & 0x1f) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `SQ5`"]
        pub type SQ5_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ5`"]
        pub struct SQ5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ5_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 20)) | (((value as u32) & 0x1f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `SQ4`"]
        pub type SQ4_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ4`"]
        pub struct SQ4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ4_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | (((value as u32) & 0x1f) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `SQ3`"]
        pub type SQ3_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ3`"]
        pub struct SQ3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ3_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | (((value as u32) & 0x1f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `SQ2`"]
        pub type SQ2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ2`"]
        pub struct SQ2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | (((value as u32) & 0x1f) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `SQ1`"]
        pub type SQ1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SQ1`"]
        pub struct SQ1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 25:29 - 6th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq6(&self) -> SQ6_R {
                SQ6_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
            #[doc = "Bits 20:24 - 5th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq5(&self) -> SQ5_R {
                SQ5_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            #[doc = "Bits 15:19 - 4th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq4(&self) -> SQ4_R {
                SQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            #[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
            #[inline(always)]
            pub fn sq3(&self) -> SQ3_R {
                SQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            #[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
            #[inline(always)]
            pub fn sq2(&self) -> SQ2_R {
                SQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - 1st conversion in regular sequence"]
            #[inline(always)]
            pub fn sq1(&self) -> SQ1_R {
                SQ1_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 25:29 - 6th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq6(&mut self) -> SQ6_W {
                SQ6_W { w: self }
            }
            #[doc = "Bits 20:24 - 5th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq5(&mut self) -> SQ5_W {
                SQ5_W { w: self }
            }
            #[doc = "Bits 15:19 - 4th conversion in regular sequence"]
            #[inline(always)]
            pub fn sq4(&mut self) -> SQ4_W {
                SQ4_W { w: self }
            }
            #[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
            #[inline(always)]
            pub fn sq3(&mut self) -> SQ3_W {
                SQ3_W { w: self }
            }
            #[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
            #[inline(always)]
            pub fn sq2(&mut self) -> SQ2_W {
                SQ2_W { w: self }
            }
            #[doc = "Bits 0:4 - 1st conversion in regular sequence"]
            #[inline(always)]
            pub fn sq1(&mut self) -> SQ1_W {
                SQ1_W { w: self }
            }
        }
    }
    #[doc = "injected sequence register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jsqr](jsqr) module"]
    pub type JSQR = crate::Reg<u32, _JSQR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JSQR;
    #[doc = "`read()` method returns [jsqr::R](jsqr::R) reader structure"]
    impl crate::Readable for JSQR {}
    #[doc = "`write(|w| ..)` method takes [jsqr::W](jsqr::W) writer structure"]
    impl crate::Writable for JSQR {}
    #[doc = "injected sequence register"]
    pub mod jsqr {
        #[doc = "Reader of register JSQR"]
        pub type R = crate::R<u32, super::JSQR>;
        #[doc = "Writer for register JSQR"]
        pub type W = crate::W<u32, super::JSQR>;
        #[doc = "Register JSQR `reset()`'s with value 0"]
        impl crate::ResetValue for super::JSQR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `JL`"]
        pub type JL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `JL`"]
        pub struct JL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `JSQ4`"]
        pub type JSQ4_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `JSQ4`"]
        pub struct JSQ4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ4_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | (((value as u32) & 0x1f) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `JSQ3`"]
        pub type JSQ3_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `JSQ3`"]
        pub struct JSQ3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ3_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | (((value as u32) & 0x1f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `JSQ2`"]
        pub type JSQ2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `JSQ2`"]
        pub struct JSQ2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | (((value as u32) & 0x1f) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `JSQ1`"]
        pub type JSQ1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `JSQ1`"]
        pub struct JSQ1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 20:21 - Injected sequence length"]
            #[inline(always)]
            pub fn jl(&self) -> JL_R {
                JL_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 15:19 - 4th conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq4(&self) -> JSQ4_R {
                JSQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            #[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq3(&self) -> JSQ3_R {
                JSQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            #[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq2(&self) -> JSQ2_R {
                JSQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - 1st conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq1(&self) -> JSQ1_R {
                JSQ1_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 20:21 - Injected sequence length"]
            #[inline(always)]
            pub fn jl(&mut self) -> JL_W {
                JL_W { w: self }
            }
            #[doc = "Bits 15:19 - 4th conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq4(&mut self) -> JSQ4_W {
                JSQ4_W { w: self }
            }
            #[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq3(&mut self) -> JSQ3_W {
                JSQ3_W { w: self }
            }
            #[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq2(&mut self) -> JSQ2_W {
                JSQ2_W { w: self }
            }
            #[doc = "Bits 0:4 - 1st conversion in injected sequence"]
            #[inline(always)]
            pub fn jsq1(&mut self) -> JSQ1_W {
                JSQ1_W { w: self }
            }
        }
    }
    #[doc = "injected data register x\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jdr1](jdr1) module"]
    pub type JDR1 = crate::Reg<u32, _JDR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JDR1;
    #[doc = "`read()` method returns [jdr1::R](jdr1::R) reader structure"]
    impl crate::Readable for JDR1 {}
    #[doc = "injected data register x"]
    pub mod jdr1 {
        #[doc = "Reader of register JDR1"]
        pub type R = crate::R<u32, super::JDR1>;
        #[doc = "Reader of field `JDATA`"]
        pub type JDATA_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Injected data"]
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "injected data register x\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jdr2](jdr2) module"]
    pub type JDR2 = crate::Reg<u32, _JDR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JDR2;
    #[doc = "`read()` method returns [jdr2::R](jdr2::R) reader structure"]
    impl crate::Readable for JDR2 {}
    #[doc = "injected data register x"]
    pub mod jdr2 {
        #[doc = "Reader of register JDR2"]
        pub type R = crate::R<u32, super::JDR2>;
        #[doc = "Reader of field `JDATA`"]
        pub type JDATA_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Injected data"]
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "injected data register x\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jdr3](jdr3) module"]
    pub type JDR3 = crate::Reg<u32, _JDR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JDR3;
    #[doc = "`read()` method returns [jdr3::R](jdr3::R) reader structure"]
    impl crate::Readable for JDR3 {}
    #[doc = "injected data register x"]
    pub mod jdr3 {
        #[doc = "Reader of register JDR3"]
        pub type R = crate::R<u32, super::JDR3>;
        #[doc = "Reader of field `JDATA`"]
        pub type JDATA_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Injected data"]
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "injected data register x\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jdr4](jdr4) module"]
    pub type JDR4 = crate::Reg<u32, _JDR4>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _JDR4;
    #[doc = "`read()` method returns [jdr4::R](jdr4::R) reader structure"]
    impl crate::Readable for JDR4 {}
    #[doc = "injected data register x"]
    pub mod jdr4 {
        #[doc = "Reader of register JDR4"]
        pub type R = crate::R<u32, super::JDR4>;
        #[doc = "Reader of field `JDATA`"]
        pub type JDATA_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Injected data"]
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "regular data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "regular data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Reader of field `DATA`"]
        pub type DATA_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Regular data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
}
#[doc = "Digital to analog converter"]
pub struct DAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DAC {}
impl DAC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dac::RegisterBlock {
        0x4000_7400 as *const _
    }
}
impl Deref for DAC {
    type Target = dac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DAC::ptr() }
    }
}
#[doc = "Digital to analog converter"]
pub mod dac {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register (DAC_CR)"]
        pub cr: CR,
        #[doc = "0x04 - DAC software trigger register (DAC_SWTRIGR)"]
        pub swtrigr: SWTRIGR,
        #[doc = "0x08 - DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"]
        pub dhr12r1: DHR12R1,
        #[doc = "0x0c - DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"]
        pub dhr12l1: DHR12L1,
        #[doc = "0x10 - DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"]
        pub dhr8r1: DHR8R1,
        #[doc = "0x14 - DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"]
        pub dhr12r2: DHR12R2,
        #[doc = "0x18 - DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"]
        pub dhr12l2: DHR12L2,
        #[doc = "0x1c - DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"]
        pub dhr8r2: DHR8R2,
        #[doc = "0x20 - Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"]
        pub dhr12rd: DHR12RD,
        #[doc = "0x24 - DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"]
        pub dhr12ld: DHR12LD,
        #[doc = "0x28 - DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"]
        pub dhr8rd: DHR8RD,
        #[doc = "0x2c - DAC channel1 data output register (DAC_DOR1)"]
        pub dor1: DOR1,
        #[doc = "0x30 - DAC channel2 data output register (DAC_DOR2)"]
        pub dor2: DOR2,
        #[doc = "0x34 - DAC status register"]
        pub sr: SR,
    }
    #[doc = "Control register (DAC_CR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control register (DAC_CR)"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DAC channel1 enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN1_A {
            #[doc = "0: DAC channel X disabled"]
            DISABLED = 0,
            #[doc = "1: DAC channel X enabled"]
            ENABLED = 1,
        }
        impl From<EN1_A> for bool {
            #[inline(always)]
            fn from(variant: EN1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EN1`"]
        pub type EN1_R = crate::R<bool, EN1_A>;
        impl EN1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EN1_A {
                match self.bits {
                    false => EN1_A::DISABLED,
                    true => EN1_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN1_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN1_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EN1`"]
        pub struct EN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EN1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN1_A::DISABLED)
            }
            #[doc = "DAC channel X enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "DAC channel1 output buffer disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOFF1_A {
            #[doc = "0: DAC channel X output buffer enabled"]
            ENABLED = 0,
            #[doc = "1: DAC channel X output buffer disabled"]
            DISABLED = 1,
        }
        impl From<BOFF1_A> for bool {
            #[inline(always)]
            fn from(variant: BOFF1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BOFF1`"]
        pub type BOFF1_R = crate::R<bool, BOFF1_A>;
        impl BOFF1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BOFF1_A {
                match self.bits {
                    false => BOFF1_A::ENABLED,
                    true => BOFF1_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BOFF1_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BOFF1_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `BOFF1`"]
        pub struct BOFF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BOFF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BOFF1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X output buffer enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF1_A::ENABLED)
            }
            #[doc = "DAC channel X output buffer disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF1_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "DAC channel1 trigger enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEN1_A {
            #[doc = "0: DAC channel X trigger disabled"]
            DISABLED = 0,
            #[doc = "1: DAC channel X trigger enabled"]
            ENABLED = 1,
        }
        impl From<TEN1_A> for bool {
            #[inline(always)]
            fn from(variant: TEN1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TEN1`"]
        pub type TEN1_R = crate::R<bool, TEN1_A>;
        impl TEN1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TEN1_A {
                match self.bits {
                    false => TEN1_A::DISABLED,
                    true => TEN1_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TEN1_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TEN1_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TEN1`"]
        pub struct TEN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEN1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TEN1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X trigger disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN1_A::DISABLED)
            }
            #[doc = "DAC channel X trigger enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "DAC channel1 trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TSEL1_A {
            #[doc = "0: Timer 6 TRGO event"]
            TIM6_TRGO = 0,
            #[doc = "1: Timer 3 TRGO event"]
            TIM3_TRGO = 1,
            #[doc = "2: Timer 7 TRGO event"]
            TIM7_TRGO = 2,
            #[doc = "3: Timer 15 TRGO event"]
            TIM15_TRGO = 3,
            #[doc = "4: Timer 2 TRGO event"]
            TIM2_TRGO = 4,
            #[doc = "6: EXTI line9"]
            EXTI9 = 6,
            #[doc = "7: Software trigger"]
            SOFTWARE = 7,
        }
        impl From<TSEL1_A> for u8 {
            #[inline(always)]
            fn from(variant: TSEL1_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TSEL1`"]
        pub type TSEL1_R = crate::R<u8, TSEL1_A>;
        impl TSEL1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TSEL1_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TSEL1_A::TIM6_TRGO),
                    1 => Val(TSEL1_A::TIM3_TRGO),
                    2 => Val(TSEL1_A::TIM7_TRGO),
                    3 => Val(TSEL1_A::TIM15_TRGO),
                    4 => Val(TSEL1_A::TIM2_TRGO),
                    6 => Val(TSEL1_A::EXTI9),
                    7 => Val(TSEL1_A::SOFTWARE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TIM6_TRGO`"]
            #[inline(always)]
            pub fn is_tim6_trgo(&self) -> bool {
                *self == TSEL1_A::TIM6_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM3_TRGO`"]
            #[inline(always)]
            pub fn is_tim3_trgo(&self) -> bool {
                *self == TSEL1_A::TIM3_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM7_TRGO`"]
            #[inline(always)]
            pub fn is_tim7_trgo(&self) -> bool {
                *self == TSEL1_A::TIM7_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM15_TRGO`"]
            #[inline(always)]
            pub fn is_tim15_trgo(&self) -> bool {
                *self == TSEL1_A::TIM15_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2_TRGO`"]
            #[inline(always)]
            pub fn is_tim2_trgo(&self) -> bool {
                *self == TSEL1_A::TIM2_TRGO
            }
            #[doc = "Checks if the value of the field is `EXTI9`"]
            #[inline(always)]
            pub fn is_exti9(&self) -> bool {
                *self == TSEL1_A::EXTI9
            }
            #[doc = "Checks if the value of the field is `SOFTWARE`"]
            #[inline(always)]
            pub fn is_software(&self) -> bool {
                *self == TSEL1_A::SOFTWARE
            }
        }
        #[doc = "Write proxy for field `TSEL1`"]
        pub struct TSEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSEL1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSEL1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Timer 6 TRGO event"]
            #[inline(always)]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM6_TRGO)
            }
            #[doc = "Timer 3 TRGO event"]
            #[inline(always)]
            pub fn tim3_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM3_TRGO)
            }
            #[doc = "Timer 7 TRGO event"]
            #[inline(always)]
            pub fn tim7_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM7_TRGO)
            }
            #[doc = "Timer 15 TRGO event"]
            #[inline(always)]
            pub fn tim15_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM15_TRGO)
            }
            #[doc = "Timer 2 TRGO event"]
            #[inline(always)]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM2_TRGO)
            }
            #[doc = "EXTI line9"]
            #[inline(always)]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL1_A::EXTI9)
            }
            #[doc = "Software trigger"]
            #[inline(always)]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL1_A::SOFTWARE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | (((value as u32) & 0x07) << 3);
                self.w
            }
        }
        #[doc = "DAC channel1 noise/triangle wave generation enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WAVE1_A {
            #[doc = "0: Wave generation disabled"]
            DISABLED = 0,
            #[doc = "1: Noise wave generation enabled"]
            NOISE = 1,
            #[doc = "2: Triangle wave generation enabled"]
            TRIANGLE = 2,
        }
        impl From<WAVE1_A> for u8 {
            #[inline(always)]
            fn from(variant: WAVE1_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WAVE1`"]
        pub type WAVE1_R = crate::R<u8, WAVE1_A>;
        impl WAVE1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, WAVE1_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(WAVE1_A::DISABLED),
                    1 => Val(WAVE1_A::NOISE),
                    2 => Val(WAVE1_A::TRIANGLE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WAVE1_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `NOISE`"]
            #[inline(always)]
            pub fn is_noise(&self) -> bool {
                *self == WAVE1_A::NOISE
            }
            #[doc = "Checks if the value of the field is `TRIANGLE`"]
            #[inline(always)]
            pub fn is_triangle(&self) -> bool {
                *self == WAVE1_A::TRIANGLE
            }
        }
        #[doc = "Write proxy for field `WAVE1`"]
        pub struct WAVE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAVE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAVE1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Wave generation disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE1_A::DISABLED)
            }
            #[doc = "Noise wave generation enabled"]
            #[inline(always)]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE1_A::NOISE)
            }
            #[doc = "Triangle wave generation enabled"]
            #[inline(always)]
            pub fn triangle(self) -> &'a mut W {
                self.variant(WAVE1_A::TRIANGLE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `MAMP1`"]
        pub type MAMP1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MAMP1`"]
        pub struct MAMP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MAMP1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "DAC channel1 DMA enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN1_A {
            #[doc = "0: DAC channel X DMA mode disabled"]
            DISABLED = 0,
            #[doc = "1: DAC channel X DMA mode enabled"]
            ENABLED = 1,
        }
        impl From<DMAEN1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAEN1`"]
        pub type DMAEN1_R = crate::R<bool, DMAEN1_A>;
        impl DMAEN1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAEN1_A {
                match self.bits {
                    false => DMAEN1_A::DISABLED,
                    true => DMAEN1_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN1_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN1_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAEN1`"]
        pub struct DMAEN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAEN1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X DMA mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::DISABLED)
            }
            #[doc = "DAC channel X DMA mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "DAC channel2 enable"]
        pub type EN2_A = EN1_A;
        #[doc = "Reader of field `EN2`"]
        pub type EN2_R = crate::R<bool, EN1_A>;
        #[doc = "Write proxy for field `EN2`"]
        pub struct EN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EN2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN1_A::DISABLED)
            }
            #[doc = "DAC channel X enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "DAC channel2 output buffer disable"]
        pub type BOFF2_A = BOFF1_A;
        #[doc = "Reader of field `BOFF2`"]
        pub type BOFF2_R = crate::R<bool, BOFF1_A>;
        #[doc = "Write proxy for field `BOFF2`"]
        pub struct BOFF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BOFF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BOFF2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X output buffer enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF1_A::ENABLED)
            }
            #[doc = "DAC channel X output buffer disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF1_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "DAC channel2 trigger enable"]
        pub type TEN2_A = TEN1_A;
        #[doc = "Reader of field `TEN2`"]
        pub type TEN2_R = crate::R<bool, TEN1_A>;
        #[doc = "Write proxy for field `TEN2`"]
        pub struct TEN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEN2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TEN2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X trigger disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN1_A::DISABLED)
            }
            #[doc = "DAC channel X trigger enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "DAC channel2 trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TSEL2_A {
            #[doc = "0: Timer 6 TRGO event"]
            TIM6_TRGO = 0,
            #[doc = "1: Timer 8 TRGO event"]
            TIM8_TRGO = 1,
            #[doc = "2: Timer 7 TRGO event"]
            TIM7_TRGO = 2,
            #[doc = "3: Timer 5 TRGO event"]
            TIM5_TRGO = 3,
            #[doc = "4: Timer 2 TRGO event"]
            TIM2_TRGO = 4,
            #[doc = "5: Timer 4 TRGO event"]
            TIM4_TRGO = 5,
            #[doc = "6: EXTI line9"]
            EXTI9 = 6,
            #[doc = "7: Software trigger"]
            SOFTWARE = 7,
        }
        impl From<TSEL2_A> for u8 {
            #[inline(always)]
            fn from(variant: TSEL2_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TSEL2`"]
        pub type TSEL2_R = crate::R<u8, TSEL2_A>;
        impl TSEL2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TSEL2_A {
                match self.bits {
                    0 => TSEL2_A::TIM6_TRGO,
                    1 => TSEL2_A::TIM8_TRGO,
                    2 => TSEL2_A::TIM7_TRGO,
                    3 => TSEL2_A::TIM5_TRGO,
                    4 => TSEL2_A::TIM2_TRGO,
                    5 => TSEL2_A::TIM4_TRGO,
                    6 => TSEL2_A::EXTI9,
                    7 => TSEL2_A::SOFTWARE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIM6_TRGO`"]
            #[inline(always)]
            pub fn is_tim6_trgo(&self) -> bool {
                *self == TSEL2_A::TIM6_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM8_TRGO`"]
            #[inline(always)]
            pub fn is_tim8_trgo(&self) -> bool {
                *self == TSEL2_A::TIM8_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM7_TRGO`"]
            #[inline(always)]
            pub fn is_tim7_trgo(&self) -> bool {
                *self == TSEL2_A::TIM7_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM5_TRGO`"]
            #[inline(always)]
            pub fn is_tim5_trgo(&self) -> bool {
                *self == TSEL2_A::TIM5_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2_TRGO`"]
            #[inline(always)]
            pub fn is_tim2_trgo(&self) -> bool {
                *self == TSEL2_A::TIM2_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM4_TRGO`"]
            #[inline(always)]
            pub fn is_tim4_trgo(&self) -> bool {
                *self == TSEL2_A::TIM4_TRGO
            }
            #[doc = "Checks if the value of the field is `EXTI9`"]
            #[inline(always)]
            pub fn is_exti9(&self) -> bool {
                *self == TSEL2_A::EXTI9
            }
            #[doc = "Checks if the value of the field is `SOFTWARE`"]
            #[inline(always)]
            pub fn is_software(&self) -> bool {
                *self == TSEL2_A::SOFTWARE
            }
        }
        #[doc = "Write proxy for field `TSEL2`"]
        pub struct TSEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSEL2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSEL2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Timer 6 TRGO event"]
            #[inline(always)]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM6_TRGO)
            }
            #[doc = "Timer 8 TRGO event"]
            #[inline(always)]
            pub fn tim8_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM8_TRGO)
            }
            #[doc = "Timer 7 TRGO event"]
            #[inline(always)]
            pub fn tim7_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM7_TRGO)
            }
            #[doc = "Timer 5 TRGO event"]
            #[inline(always)]
            pub fn tim5_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM5_TRGO)
            }
            #[doc = "Timer 2 TRGO event"]
            #[inline(always)]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM2_TRGO)
            }
            #[doc = "Timer 4 TRGO event"]
            #[inline(always)]
            pub fn tim4_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM4_TRGO)
            }
            #[doc = "EXTI line9"]
            #[inline(always)]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL2_A::EXTI9)
            }
            #[doc = "Software trigger"]
            #[inline(always)]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL2_A::SOFTWARE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 19)) | (((value as u32) & 0x07) << 19);
                self.w
            }
        }
        #[doc = "DAC channel2 noise/triangle wave generation enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WAVE2_A {
            #[doc = "0: Wave generation disabled"]
            DISABLED = 0,
            #[doc = "1: Noise wave generation enabled"]
            NOISE = 1,
            #[doc = "2: Triangle wave generation enabled"]
            TRIANGLE = 2,
        }
        impl From<WAVE2_A> for u8 {
            #[inline(always)]
            fn from(variant: WAVE2_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WAVE2`"]
        pub type WAVE2_R = crate::R<u8, WAVE2_A>;
        impl WAVE2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, WAVE2_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(WAVE2_A::DISABLED),
                    1 => Val(WAVE2_A::NOISE),
                    2 => Val(WAVE2_A::TRIANGLE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WAVE2_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `NOISE`"]
            #[inline(always)]
            pub fn is_noise(&self) -> bool {
                *self == WAVE2_A::NOISE
            }
            #[doc = "Checks if the value of the field is `TRIANGLE`"]
            #[inline(always)]
            pub fn is_triangle(&self) -> bool {
                *self == WAVE2_A::TRIANGLE
            }
        }
        #[doc = "Write proxy for field `WAVE2`"]
        pub struct WAVE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAVE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAVE2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Wave generation disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE2_A::DISABLED)
            }
            #[doc = "Noise wave generation enabled"]
            #[inline(always)]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE2_A::NOISE)
            }
            #[doc = "Triangle wave generation enabled"]
            #[inline(always)]
            pub fn triangle(self) -> &'a mut W {
                self.variant(WAVE2_A::TRIANGLE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `MAMP2`"]
        pub type MAMP2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MAMP2`"]
        pub struct MAMP2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MAMP2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "DAC channel2 DMA enable"]
        pub type DMAEN2_A = DMAEN1_A;
        #[doc = "Reader of field `DMAEN2`"]
        pub type DMAEN2_R = crate::R<bool, DMAEN1_A>;
        #[doc = "Write proxy for field `DMAEN2`"]
        pub struct DMAEN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAEN2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X DMA mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::DISABLED)
            }
            #[doc = "DAC channel X DMA mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "DAC channel1 DMA underrun interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDRIE1_A {
            #[doc = "0: DAC channel X DMA Underrun Interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: DAC channel X DMA Underrun Interrupt enabled"]
            ENABLED = 1,
        }
        impl From<DMAUDRIE1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAUDRIE1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAUDRIE1`"]
        pub type DMAUDRIE1_R = crate::R<bool, DMAUDRIE1_A>;
        impl DMAUDRIE1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAUDRIE1_A {
                match self.bits {
                    false => DMAUDRIE1_A::DISABLED,
                    true => DMAUDRIE1_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAUDRIE1_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAUDRIE1_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAUDRIE1`"]
        pub struct DMAUDRIE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDRIE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAUDRIE1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X DMA Underrun Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1_A::DISABLED)
            }
            #[doc = "DAC channel X DMA Underrun Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "DAC channel2 DMA underrun interrupt enable"]
        pub type DMAUDRIE2_A = DMAUDRIE1_A;
        #[doc = "Reader of field `DMAUDRIE2`"]
        pub type DMAUDRIE2_R = crate::R<bool, DMAUDRIE1_A>;
        #[doc = "Write proxy for field `DMAUDRIE2`"]
        pub struct DMAUDRIE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDRIE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAUDRIE2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X DMA Underrun Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1_A::DISABLED)
            }
            #[doc = "DAC channel X DMA Underrun Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - DAC channel1 enable"]
            #[inline(always)]
            pub fn en1(&self) -> EN1_R {
                EN1_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - DAC channel1 output buffer disable"]
            #[inline(always)]
            pub fn boff1(&self) -> BOFF1_R {
                BOFF1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - DAC channel1 trigger enable"]
            #[inline(always)]
            pub fn ten1(&self) -> TEN1_R {
                TEN1_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 3:5 - DAC channel1 trigger selection"]
            #[inline(always)]
            pub fn tsel1(&self) -> TSEL1_R {
                TSEL1_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            #[doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"]
            #[inline(always)]
            pub fn wave1(&self) -> WAVE1_R {
                WAVE1_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"]
            #[inline(always)]
            pub fn mamp1(&self) -> MAMP1_R {
                MAMP1_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 12 - DAC channel1 DMA enable"]
            #[inline(always)]
            pub fn dmaen1(&self) -> DMAEN1_R {
                DMAEN1_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 16 - DAC channel2 enable"]
            #[inline(always)]
            pub fn en2(&self) -> EN2_R {
                EN2_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - DAC channel2 output buffer disable"]
            #[inline(always)]
            pub fn boff2(&self) -> BOFF2_R {
                BOFF2_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - DAC channel2 trigger enable"]
            #[inline(always)]
            pub fn ten2(&self) -> TEN2_R {
                TEN2_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bits 19:21 - DAC channel2 trigger selection"]
            #[inline(always)]
            pub fn tsel2(&self) -> TSEL2_R {
                TSEL2_R::new(((self.bits >> 19) & 0x07) as u8)
            }
            #[doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"]
            #[inline(always)]
            pub fn wave2(&self) -> WAVE2_R {
                WAVE2_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"]
            #[inline(always)]
            pub fn mamp2(&self) -> MAMP2_R {
                MAMP2_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bit 28 - DAC channel2 DMA enable"]
            #[inline(always)]
            pub fn dmaen2(&self) -> DMAEN2_R {
                DMAEN2_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun interrupt enable"]
            #[inline(always)]
            pub fn dmaudrie1(&self) -> DMAUDRIE1_R {
                DMAUDRIE1_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable"]
            #[inline(always)]
            pub fn dmaudrie2(&self) -> DMAUDRIE2_R {
                DMAUDRIE2_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DAC channel1 enable"]
            #[inline(always)]
            pub fn en1(&mut self) -> EN1_W {
                EN1_W { w: self }
            }
            #[doc = "Bit 1 - DAC channel1 output buffer disable"]
            #[inline(always)]
            pub fn boff1(&mut self) -> BOFF1_W {
                BOFF1_W { w: self }
            }
            #[doc = "Bit 2 - DAC channel1 trigger enable"]
            #[inline(always)]
            pub fn ten1(&mut self) -> TEN1_W {
                TEN1_W { w: self }
            }
            #[doc = "Bits 3:5 - DAC channel1 trigger selection"]
            #[inline(always)]
            pub fn tsel1(&mut self) -> TSEL1_W {
                TSEL1_W { w: self }
            }
            #[doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"]
            #[inline(always)]
            pub fn wave1(&mut self) -> WAVE1_W {
                WAVE1_W { w: self }
            }
            #[doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"]
            #[inline(always)]
            pub fn mamp1(&mut self) -> MAMP1_W {
                MAMP1_W { w: self }
            }
            #[doc = "Bit 12 - DAC channel1 DMA enable"]
            #[inline(always)]
            pub fn dmaen1(&mut self) -> DMAEN1_W {
                DMAEN1_W { w: self }
            }
            #[doc = "Bit 16 - DAC channel2 enable"]
            #[inline(always)]
            pub fn en2(&mut self) -> EN2_W {
                EN2_W { w: self }
            }
            #[doc = "Bit 17 - DAC channel2 output buffer disable"]
            #[inline(always)]
            pub fn boff2(&mut self) -> BOFF2_W {
                BOFF2_W { w: self }
            }
            #[doc = "Bit 18 - DAC channel2 trigger enable"]
            #[inline(always)]
            pub fn ten2(&mut self) -> TEN2_W {
                TEN2_W { w: self }
            }
            #[doc = "Bits 19:21 - DAC channel2 trigger selection"]
            #[inline(always)]
            pub fn tsel2(&mut self) -> TSEL2_W {
                TSEL2_W { w: self }
            }
            #[doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"]
            #[inline(always)]
            pub fn wave2(&mut self) -> WAVE2_W {
                WAVE2_W { w: self }
            }
            #[doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"]
            #[inline(always)]
            pub fn mamp2(&mut self) -> MAMP2_W {
                MAMP2_W { w: self }
            }
            #[doc = "Bit 28 - DAC channel2 DMA enable"]
            #[inline(always)]
            pub fn dmaen2(&mut self) -> DMAEN2_W {
                DMAEN2_W { w: self }
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun interrupt enable"]
            #[inline(always)]
            pub fn dmaudrie1(&mut self) -> DMAUDRIE1_W {
                DMAUDRIE1_W { w: self }
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable"]
            #[inline(always)]
            pub fn dmaudrie2(&mut self) -> DMAUDRIE2_W {
                DMAUDRIE2_W { w: self }
            }
        }
    }
    #[doc = "DAC software trigger register (DAC_SWTRIGR)\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swtrigr](swtrigr) module"]
    pub type SWTRIGR = crate::Reg<u32, _SWTRIGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SWTRIGR;
    #[doc = "`write(|w| ..)` method takes [swtrigr::W](swtrigr::W) writer structure"]
    impl crate::Writable for SWTRIGR {}
    #[doc = "DAC software trigger register (DAC_SWTRIGR)"]
    pub mod swtrigr {
        #[doc = "Writer for register SWTRIGR"]
        pub type W = crate::W<u32, super::SWTRIGR>;
        #[doc = "Register SWTRIGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SWTRIGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DAC channel1 software trigger\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWTRIG1_AW {
            #[doc = "0: DAC channel X software trigger disabled"]
            DISABLED = 0,
            #[doc = "1: DAC channel X software trigger enabled"]
            ENABLED = 1,
        }
        impl From<SWTRIG1_AW> for bool {
            #[inline(always)]
            fn from(variant: SWTRIG1_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `SWTRIG1`"]
        pub struct SWTRIG1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWTRIG1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWTRIG1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X software trigger disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWTRIG1_AW::DISABLED)
            }
            #[doc = "DAC channel X software trigger enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWTRIG1_AW::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "DAC channel2 software trigger"]
        pub type SWTRIG2_AW = SWTRIG1_AW;
        #[doc = "Write proxy for field `SWTRIG2`"]
        pub struct SWTRIG2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWTRIG2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWTRIG2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DAC channel X software trigger disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWTRIG1_AW::DISABLED)
            }
            #[doc = "DAC channel X software trigger enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWTRIG1_AW::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - DAC channel1 software trigger"]
            #[inline(always)]
            pub fn swtrig1(&mut self) -> SWTRIG1_W {
                SWTRIG1_W { w: self }
            }
            #[doc = "Bit 1 - DAC channel2 software trigger"]
            #[inline(always)]
            pub fn swtrig2(&mut self) -> SWTRIG2_W {
                SWTRIG2_W { w: self }
            }
        }
    }
    #[doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr12r1](dhr12r1) module"]
    pub type DHR12R1 = crate::Reg<u32, _DHR12R1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR12R1;
    #[doc = "`read()` method returns [dhr12r1::R](dhr12r1::R) reader structure"]
    impl crate::Readable for DHR12R1 {}
    #[doc = "`write(|w| ..)` method takes [dhr12r1::W](dhr12r1::W) writer structure"]
    impl crate::Writable for DHR12R1 {}
    #[doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"]
    pub mod dhr12r1 {
        #[doc = "Reader of register DHR12R1"]
        pub type R = crate::R<u32, super::DHR12R1>;
        #[doc = "Writer for register DHR12R1"]
        pub type W = crate::W<u32, super::DHR12R1>;
        #[doc = "Register DHR12R1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR12R1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC1DHR`"]
        pub type DACC1DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC1DHR`"]
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
        }
    }
    #[doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr12l1](dhr12l1) module"]
    pub type DHR12L1 = crate::Reg<u32, _DHR12L1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR12L1;
    #[doc = "`read()` method returns [dhr12l1::R](dhr12l1::R) reader structure"]
    impl crate::Readable for DHR12L1 {}
    #[doc = "`write(|w| ..)` method takes [dhr12l1::W](dhr12l1::W) writer structure"]
    impl crate::Writable for DHR12L1 {}
    #[doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"]
    pub mod dhr12l1 {
        #[doc = "Reader of register DHR12L1"]
        pub type R = crate::R<u32, super::DHR12L1>;
        #[doc = "Writer for register DHR12L1"]
        pub type W = crate::W<u32, super::DHR12L1>;
        #[doc = "Register DHR12L1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR12L1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC1DHR`"]
        pub type DACC1DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC1DHR`"]
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | (((value as u32) & 0x0fff) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
        }
    }
    #[doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr8r1](dhr8r1) module"]
    pub type DHR8R1 = crate::Reg<u32, _DHR8R1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR8R1;
    #[doc = "`read()` method returns [dhr8r1::R](dhr8r1::R) reader structure"]
    impl crate::Readable for DHR8R1 {}
    #[doc = "`write(|w| ..)` method takes [dhr8r1::W](dhr8r1::W) writer structure"]
    impl crate::Writable for DHR8R1 {}
    #[doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"]
    pub mod dhr8r1 {
        #[doc = "Reader of register DHR8R1"]
        pub type R = crate::R<u32, super::DHR8R1>;
        #[doc = "Writer for register DHR8R1"]
        pub type W = crate::W<u32, super::DHR8R1>;
        #[doc = "Register DHR8R1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR8R1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC1DHR`"]
        pub type DACC1DHR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DACC1DHR`"]
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
        }
    }
    #[doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr12r2](dhr12r2) module"]
    pub type DHR12R2 = crate::Reg<u32, _DHR12R2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR12R2;
    #[doc = "`read()` method returns [dhr12r2::R](dhr12r2::R) reader structure"]
    impl crate::Readable for DHR12R2 {}
    #[doc = "`write(|w| ..)` method takes [dhr12r2::W](dhr12r2::W) writer structure"]
    impl crate::Writable for DHR12R2 {}
    #[doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"]
    pub mod dhr12r2 {
        #[doc = "Reader of register DHR12R2"]
        pub type R = crate::R<u32, super::DHR12R2>;
        #[doc = "Writer for register DHR12R2"]
        pub type W = crate::W<u32, super::DHR12R2>;
        #[doc = "Register DHR12R2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR12R2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC2DHR`"]
        pub type DACC2DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC2DHR`"]
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
        }
    }
    #[doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr12l2](dhr12l2) module"]
    pub type DHR12L2 = crate::Reg<u32, _DHR12L2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR12L2;
    #[doc = "`read()` method returns [dhr12l2::R](dhr12l2::R) reader structure"]
    impl crate::Readable for DHR12L2 {}
    #[doc = "`write(|w| ..)` method takes [dhr12l2::W](dhr12l2::W) writer structure"]
    impl crate::Writable for DHR12L2 {}
    #[doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"]
    pub mod dhr12l2 {
        #[doc = "Reader of register DHR12L2"]
        pub type R = crate::R<u32, super::DHR12L2>;
        #[doc = "Writer for register DHR12L2"]
        pub type W = crate::W<u32, super::DHR12L2>;
        #[doc = "Register DHR12L2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR12L2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC2DHR`"]
        pub type DACC2DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC2DHR`"]
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | (((value as u32) & 0x0fff) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
        }
    }
    #[doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr8r2](dhr8r2) module"]
    pub type DHR8R2 = crate::Reg<u32, _DHR8R2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR8R2;
    #[doc = "`read()` method returns [dhr8r2::R](dhr8r2::R) reader structure"]
    impl crate::Readable for DHR8R2 {}
    #[doc = "`write(|w| ..)` method takes [dhr8r2::W](dhr8r2::W) writer structure"]
    impl crate::Writable for DHR8R2 {}
    #[doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"]
    pub mod dhr8r2 {
        #[doc = "Reader of register DHR8R2"]
        pub type R = crate::R<u32, super::DHR8R2>;
        #[doc = "Writer for register DHR8R2"]
        pub type W = crate::W<u32, super::DHR8R2>;
        #[doc = "Register DHR8R2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR8R2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC2DHR`"]
        pub type DACC2DHR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DACC2DHR`"]
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
        }
    }
    #[doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr12rd](dhr12rd) module"]
    pub type DHR12RD = crate::Reg<u32, _DHR12RD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR12RD;
    #[doc = "`read()` method returns [dhr12rd::R](dhr12rd::R) reader structure"]
    impl crate::Readable for DHR12RD {}
    #[doc = "`write(|w| ..)` method takes [dhr12rd::W](dhr12rd::W) writer structure"]
    impl crate::Writable for DHR12RD {}
    #[doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"]
    pub mod dhr12rd {
        #[doc = "Reader of register DHR12RD"]
        pub type R = crate::R<u32, super::DHR12RD>;
        #[doc = "Writer for register DHR12RD"]
        pub type W = crate::W<u32, super::DHR12RD>;
        #[doc = "Register DHR12RD `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR12RD {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC1DHR`"]
        pub type DACC1DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC1DHR`"]
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        #[doc = "Reader of field `DACC2DHR`"]
        pub type DACC2DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC2DHR`"]
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 16)) | (((value as u32) & 0x0fff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0x0fff) as u16)
            }
            #[doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 16) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            #[doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
        }
    }
    #[doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr12ld](dhr12ld) module"]
    pub type DHR12LD = crate::Reg<u32, _DHR12LD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR12LD;
    #[doc = "`read()` method returns [dhr12ld::R](dhr12ld::R) reader structure"]
    impl crate::Readable for DHR12LD {}
    #[doc = "`write(|w| ..)` method takes [dhr12ld::W](dhr12ld::W) writer structure"]
    impl crate::Writable for DHR12LD {}
    #[doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"]
    pub mod dhr12ld {
        #[doc = "Reader of register DHR12LD"]
        pub type R = crate::R<u32, super::DHR12LD>;
        #[doc = "Writer for register DHR12LD"]
        pub type W = crate::W<u32, super::DHR12LD>;
        #[doc = "Register DHR12LD `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR12LD {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC1DHR`"]
        pub type DACC1DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC1DHR`"]
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | (((value as u32) & 0x0fff) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `DACC2DHR`"]
        pub type DACC2DHR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DACC2DHR`"]
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 20)) | (((value as u32) & 0x0fff) << 20);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
            #[doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 20) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            #[doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
        }
    }
    #[doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dhr8rd](dhr8rd) module"]
    pub type DHR8RD = crate::Reg<u32, _DHR8RD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DHR8RD;
    #[doc = "`read()` method returns [dhr8rd::R](dhr8rd::R) reader structure"]
    impl crate::Readable for DHR8RD {}
    #[doc = "`write(|w| ..)` method takes [dhr8rd::W](dhr8rd::W) writer structure"]
    impl crate::Writable for DHR8RD {}
    #[doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"]
    pub mod dhr8rd {
        #[doc = "Reader of register DHR8RD"]
        pub type R = crate::R<u32, super::DHR8RD>;
        #[doc = "Writer for register DHR8RD"]
        pub type W = crate::W<u32, super::DHR8RD>;
        #[doc = "Register DHR8RD `reset()`'s with value 0"]
        impl crate::ResetValue for super::DHR8RD {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DACC1DHR`"]
        pub type DACC1DHR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DACC1DHR`"]
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `DACC2DHR`"]
        pub type DACC2DHR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DACC2DHR`"]
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            #[doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data"]
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
        }
    }
    #[doc = "DAC channel1 data output register (DAC_DOR1)\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dor1](dor1) module"]
    pub type DOR1 = crate::Reg<u32, _DOR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DOR1;
    #[doc = "`read()` method returns [dor1::R](dor1::R) reader structure"]
    impl crate::Readable for DOR1 {}
    #[doc = "DAC channel1 data output register (DAC_DOR1)"]
    pub mod dor1 {
        #[doc = "Reader of register DOR1"]
        pub type R = crate::R<u32, super::DOR1>;
        #[doc = "Reader of field `DACC1DOR`"]
        pub type DACC1DOR_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:11 - DAC channel1 data output"]
            #[inline(always)]
            pub fn dacc1dor(&self) -> DACC1DOR_R {
                DACC1DOR_R::new((self.bits & 0x0fff) as u16)
            }
        }
    }
    #[doc = "DAC channel2 data output register (DAC_DOR2)\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dor2](dor2) module"]
    pub type DOR2 = crate::Reg<u32, _DOR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DOR2;
    #[doc = "`read()` method returns [dor2::R](dor2::R) reader structure"]
    impl crate::Readable for DOR2 {}
    #[doc = "DAC channel2 data output register (DAC_DOR2)"]
    pub mod dor2 {
        #[doc = "Reader of register DOR2"]
        pub type R = crate::R<u32, super::DOR2>;
        #[doc = "Reader of field `DACC2DOR`"]
        pub type DACC2DOR_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:11 - DAC channel2 data output"]
            #[inline(always)]
            pub fn dacc2dor(&self) -> DACC2DOR_R {
                DACC2DOR_R::new((self.bits & 0x0fff) as u16)
            }
        }
    }
    #[doc = "DAC status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "DAC status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DAC channel1 DMA underrun flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDR1_A {
            #[doc = "0: No DMA underrun error condition occurred for DAC channel X"]
            NOUNDERRUN = 0,
            #[doc = "1: DMA underrun error condition occurred for DAC channel X"]
            UNDERRUN = 1,
        }
        impl From<DMAUDR1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAUDR1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAUDR1`"]
        pub type DMAUDR1_R = crate::R<bool, DMAUDR1_A>;
        impl DMAUDR1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAUDR1_A {
                match self.bits {
                    false => DMAUDR1_A::NOUNDERRUN,
                    true => DMAUDR1_A::UNDERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOUNDERRUN`"]
            #[inline(always)]
            pub fn is_no_underrun(&self) -> bool {
                *self == DMAUDR1_A::NOUNDERRUN
            }
            #[doc = "Checks if the value of the field is `UNDERRUN`"]
            #[inline(always)]
            pub fn is_underrun(&self) -> bool {
                *self == DMAUDR1_A::UNDERRUN
            }
        }
        #[doc = "Write proxy for field `DMAUDR1`"]
        pub struct DMAUDR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAUDR1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No DMA underrun error condition occurred for DAC channel X"]
            #[inline(always)]
            pub fn no_underrun(self) -> &'a mut W {
                self.variant(DMAUDR1_A::NOUNDERRUN)
            }
            #[doc = "DMA underrun error condition occurred for DAC channel X"]
            #[inline(always)]
            pub fn underrun(self) -> &'a mut W {
                self.variant(DMAUDR1_A::UNDERRUN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "DAC channel2 DMA underrun flag"]
        pub type DMAUDR2_A = DMAUDR1_A;
        #[doc = "Reader of field `DMAUDR2`"]
        pub type DMAUDR2_R = crate::R<bool, DMAUDR1_A>;
        #[doc = "Write proxy for field `DMAUDR2`"]
        pub struct DMAUDR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAUDR2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No DMA underrun error condition occurred for DAC channel X"]
            #[inline(always)]
            pub fn no_underrun(self) -> &'a mut W {
                self.variant(DMAUDR1_A::NOUNDERRUN)
            }
            #[doc = "DMA underrun error condition occurred for DAC channel X"]
            #[inline(always)]
            pub fn underrun(self) -> &'a mut W {
                self.variant(DMAUDR1_A::UNDERRUN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 13 - DAC channel1 DMA underrun flag"]
            #[inline(always)]
            pub fn dmaudr1(&self) -> DMAUDR1_R {
                DMAUDR1_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun flag"]
            #[inline(always)]
            pub fn dmaudr2(&self) -> DMAUDR2_R {
                DMAUDR2_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 13 - DAC channel1 DMA underrun flag"]
            #[inline(always)]
            pub fn dmaudr1(&mut self) -> DMAUDR1_W {
                DMAUDR1_W { w: self }
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun flag"]
            #[inline(always)]
            pub fn dmaudr2(&mut self) -> DMAUDR2_W {
                DMAUDR2_W { w: self }
            }
        }
    }
}
#[doc = "Debug support"]
pub struct DBGMCU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DBGMCU {}
impl DBGMCU {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dbgmcu::RegisterBlock {
        0xe004_2000 as *const _
    }
}
impl Deref for DBGMCU {
    type Target = dbgmcu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DBGMCU::ptr() }
    }
}
#[doc = "Debug support"]
pub mod dbgmcu {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - DBGMCU_IDCODE"]
        pub idcode: IDCODE,
        #[doc = "0x04 - DBGMCU_CR"]
        pub cr: CR,
    }
    #[doc = "DBGMCU_IDCODE\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idcode](idcode) module"]
    pub type IDCODE = crate::Reg<u32, _IDCODE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDCODE;
    #[doc = "`read()` method returns [idcode::R](idcode::R) reader structure"]
    impl crate::Readable for IDCODE {}
    #[doc = "DBGMCU_IDCODE"]
    pub mod idcode {
        #[doc = "Reader of register IDCODE"]
        pub type R = crate::R<u32, super::IDCODE>;
        #[doc = "Reader of field `DEV_ID`"]
        pub type DEV_ID_R = crate::R<u16, u16>;
        #[doc = "Reader of field `REV_ID`"]
        pub type REV_ID_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:11 - DEV_ID"]
            #[inline(always)]
            pub fn dev_id(&self) -> DEV_ID_R {
                DEV_ID_R::new((self.bits & 0x0fff) as u16)
            }
            #[doc = "Bits 16:31 - REV_ID"]
            #[inline(always)]
            pub fn rev_id(&self) -> REV_ID_R {
                REV_ID_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
    }
    #[doc = "DBGMCU_CR\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "DBGMCU_CR"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DBG_SLEEP`"]
        pub type DBG_SLEEP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_SLEEP`"]
        pub struct DBG_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_SLEEP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_STOP`"]
        pub type DBG_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_STOP`"]
        pub struct DBG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_STANDBY`"]
        pub type DBG_STANDBY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_STANDBY`"]
        pub struct DBG_STANDBY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_STANDBY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `TRACE_IOEN`"]
        pub type TRACE_IOEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TRACE_IOEN`"]
        pub struct TRACE_IOEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRACE_IOEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `TRACE_MODE`"]
        pub type TRACE_MODE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TRACE_MODE`"]
        pub struct TRACE_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRACE_MODE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_IWDG_STOP`"]
        pub type DBG_IWDG_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_IWDG_STOP`"]
        pub struct DBG_IWDG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_IWDG_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_WWDG_STOP`"]
        pub type DBG_WWDG_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_WWDG_STOP`"]
        pub struct DBG_WWDG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_WWDG_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM1_STOP`"]
        pub type DBG_TIM1_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM1_STOP`"]
        pub struct DBG_TIM1_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM1_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM2_STOP`"]
        pub type DBG_TIM2_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM2_STOP`"]
        pub struct DBG_TIM2_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM2_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM3_STOP`"]
        pub type DBG_TIM3_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM3_STOP`"]
        pub struct DBG_TIM3_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM3_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM4_STOP`"]
        pub type DBG_TIM4_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM4_STOP`"]
        pub struct DBG_TIM4_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM4_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_I2C1_SMBUS_TIMEOUT`"]
        pub type DBG_I2C1_SMBUS_TIMEOUT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_I2C1_SMBUS_TIMEOUT`"]
        pub struct DBG_I2C1_SMBUS_TIMEOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_I2C1_SMBUS_TIMEOUT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_I2C2_SMBUS_TIMEOUT`"]
        pub type DBG_I2C2_SMBUS_TIMEOUT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_I2C2_SMBUS_TIMEOUT`"]
        pub struct DBG_I2C2_SMBUS_TIMEOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_I2C2_SMBUS_TIMEOUT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM5_STOP`"]
        pub type DBG_TIM5_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM5_STOP`"]
        pub struct DBG_TIM5_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM5_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM6_STOP`"]
        pub type DBG_TIM6_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM6_STOP`"]
        pub struct DBG_TIM6_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM6_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM7_STOP`"]
        pub type DBG_TIM7_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM7_STOP`"]
        pub struct DBG_TIM7_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM7_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM15_STOP`"]
        pub type DBG_TIM15_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM15_STOP`"]
        pub struct DBG_TIM15_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM15_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM16_STOP`"]
        pub type DBG_TIM16_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM16_STOP`"]
        pub struct DBG_TIM16_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM16_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM17_STOP`"]
        pub type DBG_TIM17_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM17_STOP`"]
        pub struct DBG_TIM17_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM17_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM12_STOP`"]
        pub type DBG_TIM12_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM12_STOP`"]
        pub struct DBG_TIM12_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM12_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM13_STOP`"]
        pub type DBG_TIM13_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM13_STOP`"]
        pub struct DBG_TIM13_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM13_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIM14_STOP`"]
        pub type DBG_TIM14_STOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIM14_STOP`"]
        pub struct DBG_TIM14_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM14_STOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - DBG_SLEEP"]
            #[inline(always)]
            pub fn dbg_sleep(&self) -> DBG_SLEEP_R {
                DBG_SLEEP_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - DBG_STOP"]
            #[inline(always)]
            pub fn dbg_stop(&self) -> DBG_STOP_R {
                DBG_STOP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - DBG_STANDBY"]
            #[inline(always)]
            pub fn dbg_standby(&self) -> DBG_STANDBY_R {
                DBG_STANDBY_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 5 - TRACE_IOEN"]
            #[inline(always)]
            pub fn trace_ioen(&self) -> TRACE_IOEN_R {
                TRACE_IOEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bits 6:7 - TRACE_MODE"]
            #[inline(always)]
            pub fn trace_mode(&self) -> TRACE_MODE_R {
                TRACE_MODE_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bit 8 - DBG_IWDG_STOP"]
            #[inline(always)]
            pub fn dbg_iwdg_stop(&self) -> DBG_IWDG_STOP_R {
                DBG_IWDG_STOP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - DBG_WWDG_STOP"]
            #[inline(always)]
            pub fn dbg_wwdg_stop(&self) -> DBG_WWDG_STOP_R {
                DBG_WWDG_STOP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - DBG_TIM1_STOP"]
            #[inline(always)]
            pub fn dbg_tim1_stop(&self) -> DBG_TIM1_STOP_R {
                DBG_TIM1_STOP_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - DBG_TIM2_STOP"]
            #[inline(always)]
            pub fn dbg_tim2_stop(&self) -> DBG_TIM2_STOP_R {
                DBG_TIM2_STOP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - DBG_TIM3_STOP"]
            #[inline(always)]
            pub fn dbg_tim3_stop(&self) -> DBG_TIM3_STOP_R {
                DBG_TIM3_STOP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - DBG_TIM4_STOP"]
            #[inline(always)]
            pub fn dbg_tim4_stop(&self) -> DBG_TIM4_STOP_R {
                DBG_TIM4_STOP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT"]
            #[inline(always)]
            pub fn dbg_i2c1_smbus_timeout(&self) -> DBG_I2C1_SMBUS_TIMEOUT_R {
                DBG_I2C1_SMBUS_TIMEOUT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT"]
            #[inline(always)]
            pub fn dbg_i2c2_smbus_timeout(&self) -> DBG_I2C2_SMBUS_TIMEOUT_R {
                DBG_I2C2_SMBUS_TIMEOUT_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 18 - DBG_TIM5_STOP"]
            #[inline(always)]
            pub fn dbg_tim5_stop(&self) -> DBG_TIM5_STOP_R {
                DBG_TIM5_STOP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - DBG_TIM6_STOP"]
            #[inline(always)]
            pub fn dbg_tim6_stop(&self) -> DBG_TIM6_STOP_R {
                DBG_TIM6_STOP_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - DBG_TIM7_STOP"]
            #[inline(always)]
            pub fn dbg_tim7_stop(&self) -> DBG_TIM7_STOP_R {
                DBG_TIM7_STOP_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 22 - DBG_TIM15_STOP"]
            #[inline(always)]
            pub fn dbg_tim15_stop(&self) -> DBG_TIM15_STOP_R {
                DBG_TIM15_STOP_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - DBG_TIM16_STOP"]
            #[inline(always)]
            pub fn dbg_tim16_stop(&self) -> DBG_TIM16_STOP_R {
                DBG_TIM16_STOP_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24 - DBG_TIM17_STOP"]
            #[inline(always)]
            pub fn dbg_tim17_stop(&self) -> DBG_TIM17_STOP_R {
                DBG_TIM17_STOP_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - DBG_TIM12_STOP"]
            #[inline(always)]
            pub fn dbg_tim12_stop(&self) -> DBG_TIM12_STOP_R {
                DBG_TIM12_STOP_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26 - DBG_TIM13_STOP"]
            #[inline(always)]
            pub fn dbg_tim13_stop(&self) -> DBG_TIM13_STOP_R {
                DBG_TIM13_STOP_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27 - DBG_TIM14_STOP"]
            #[inline(always)]
            pub fn dbg_tim14_stop(&self) -> DBG_TIM14_STOP_R {
                DBG_TIM14_STOP_R::new(((self.bits >> 27) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DBG_SLEEP"]
            #[inline(always)]
            pub fn dbg_sleep(&mut self) -> DBG_SLEEP_W {
                DBG_SLEEP_W { w: self }
            }
            #[doc = "Bit 1 - DBG_STOP"]
            #[inline(always)]
            pub fn dbg_stop(&mut self) -> DBG_STOP_W {
                DBG_STOP_W { w: self }
            }
            #[doc = "Bit 2 - DBG_STANDBY"]
            #[inline(always)]
            pub fn dbg_standby(&mut self) -> DBG_STANDBY_W {
                DBG_STANDBY_W { w: self }
            }
            #[doc = "Bit 5 - TRACE_IOEN"]
            #[inline(always)]
            pub fn trace_ioen(&mut self) -> TRACE_IOEN_W {
                TRACE_IOEN_W { w: self }
            }
            #[doc = "Bits 6:7 - TRACE_MODE"]
            #[inline(always)]
            pub fn trace_mode(&mut self) -> TRACE_MODE_W {
                TRACE_MODE_W { w: self }
            }
            #[doc = "Bit 8 - DBG_IWDG_STOP"]
            #[inline(always)]
            pub fn dbg_iwdg_stop(&mut self) -> DBG_IWDG_STOP_W {
                DBG_IWDG_STOP_W { w: self }
            }
            #[doc = "Bit 9 - DBG_WWDG_STOP"]
            #[inline(always)]
            pub fn dbg_wwdg_stop(&mut self) -> DBG_WWDG_STOP_W {
                DBG_WWDG_STOP_W { w: self }
            }
            #[doc = "Bit 10 - DBG_TIM1_STOP"]
            #[inline(always)]
            pub fn dbg_tim1_stop(&mut self) -> DBG_TIM1_STOP_W {
                DBG_TIM1_STOP_W { w: self }
            }
            #[doc = "Bit 11 - DBG_TIM2_STOP"]
            #[inline(always)]
            pub fn dbg_tim2_stop(&mut self) -> DBG_TIM2_STOP_W {
                DBG_TIM2_STOP_W { w: self }
            }
            #[doc = "Bit 12 - DBG_TIM3_STOP"]
            #[inline(always)]
            pub fn dbg_tim3_stop(&mut self) -> DBG_TIM3_STOP_W {
                DBG_TIM3_STOP_W { w: self }
            }
            #[doc = "Bit 13 - DBG_TIM4_STOP"]
            #[inline(always)]
            pub fn dbg_tim4_stop(&mut self) -> DBG_TIM4_STOP_W {
                DBG_TIM4_STOP_W { w: self }
            }
            #[doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT"]
            #[inline(always)]
            pub fn dbg_i2c1_smbus_timeout(&mut self) -> DBG_I2C1_SMBUS_TIMEOUT_W {
                DBG_I2C1_SMBUS_TIMEOUT_W { w: self }
            }
            #[doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT"]
            #[inline(always)]
            pub fn dbg_i2c2_smbus_timeout(&mut self) -> DBG_I2C2_SMBUS_TIMEOUT_W {
                DBG_I2C2_SMBUS_TIMEOUT_W { w: self }
            }
            #[doc = "Bit 18 - DBG_TIM5_STOP"]
            #[inline(always)]
            pub fn dbg_tim5_stop(&mut self) -> DBG_TIM5_STOP_W {
                DBG_TIM5_STOP_W { w: self }
            }
            #[doc = "Bit 19 - DBG_TIM6_STOP"]
            #[inline(always)]
            pub fn dbg_tim6_stop(&mut self) -> DBG_TIM6_STOP_W {
                DBG_TIM6_STOP_W { w: self }
            }
            #[doc = "Bit 20 - DBG_TIM7_STOP"]
            #[inline(always)]
            pub fn dbg_tim7_stop(&mut self) -> DBG_TIM7_STOP_W {
                DBG_TIM7_STOP_W { w: self }
            }
            #[doc = "Bit 22 - DBG_TIM15_STOP"]
            #[inline(always)]
            pub fn dbg_tim15_stop(&mut self) -> DBG_TIM15_STOP_W {
                DBG_TIM15_STOP_W { w: self }
            }
            #[doc = "Bit 23 - DBG_TIM16_STOP"]
            #[inline(always)]
            pub fn dbg_tim16_stop(&mut self) -> DBG_TIM16_STOP_W {
                DBG_TIM16_STOP_W { w: self }
            }
            #[doc = "Bit 24 - DBG_TIM17_STOP"]
            #[inline(always)]
            pub fn dbg_tim17_stop(&mut self) -> DBG_TIM17_STOP_W {
                DBG_TIM17_STOP_W { w: self }
            }
            #[doc = "Bit 25 - DBG_TIM12_STOP"]
            #[inline(always)]
            pub fn dbg_tim12_stop(&mut self) -> DBG_TIM12_STOP_W {
                DBG_TIM12_STOP_W { w: self }
            }
            #[doc = "Bit 26 - DBG_TIM13_STOP"]
            #[inline(always)]
            pub fn dbg_tim13_stop(&mut self) -> DBG_TIM13_STOP_W {
                DBG_TIM13_STOP_W { w: self }
            }
            #[doc = "Bit 27 - DBG_TIM14_STOP"]
            #[inline(always)]
            pub fn dbg_tim14_stop(&mut self) -> DBG_TIM14_STOP_W {
                DBG_TIM14_STOP_W { w: self }
            }
        }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
pub struct UART4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART4 {}
impl UART4 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart4::RegisterBlock {
        0x4000_4c00 as *const _
    }
}
impl Deref for UART4 {
    type Target = uart4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*UART4::ptr() }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
pub mod uart4 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Status register"]
        pub sr: SR,
        #[doc = "0x04 - Data register"]
        pub dr: DR,
        #[doc = "0x08 - Baud rate register"]
        pub brr: BRR,
        #[doc = "0x0c - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x10 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x14 - Control register 3"]
        pub cr3: CR3,
    }
    #[doc = "Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `FE`"]
        pub type FE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `NE`"]
        pub type NE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ORE`"]
        pub type ORE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `IDLE`"]
        pub type IDLE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RXNE`"]
        pub struct RXNE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `TC`"]
        pub type TC_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TC`"]
        pub struct TC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TC_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `LBD`"]
        pub type LBD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `LBD`"]
        pub struct LBD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Parity error"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Framing error"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Noise error flag"]
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Overrun error"]
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE line detected"]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Transmit data register empty"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline(always)]
            pub fn rxne(&mut self) -> RXNE_W {
                RXNE_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline(always)]
            pub fn tc(&mut self) -> TC_W {
                TC_W { w: self }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline(always)]
            pub fn lbd(&mut self) -> LBD_W {
                LBD_W { w: self }
            }
        }
    }
    #[doc = "Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | ((value as u32) & 0x01ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:8 - DR"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:8 - DR"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "Baud rate register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`read()` method returns [brr::R](brr::R) reader structure"]
    impl crate::Readable for BRR {}
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = "Reader of register BRR"]
        pub type R = crate::R<u32, super::BRR>;
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DIV_Fraction`"]
        pub type DIV_FRACTION_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DIV_Fraction`"]
        pub struct DIV_FRACTION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_FRACTION_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `DIV_Mantissa`"]
        pub type DIV_MANTISSA_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DIV_Mantissa`"]
        pub struct DIV_MANTISSA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_MANTISSA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | (((value as u32) & 0x0fff) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - DIV_Fraction"]
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:15 - DIV_Mantissa"]
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - DIV_Fraction"]
            #[inline(always)]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W {
                DIV_FRACTION_W { w: self }
            }
            #[doc = "Bits 4:15 - DIV_Mantissa"]
            #[inline(always)]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W {
                DIV_MANTISSA_W { w: self }
            }
        }
    }
    #[doc = "Control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Send break\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBK_A {
            #[doc = "0: No break character is transmitted"]
            NOBREAK = 0,
            #[doc = "1: Break character transmitted"]
            BREAK = 1,
        }
        impl From<SBK_A> for bool {
            #[inline(always)]
            fn from(variant: SBK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SBK`"]
        pub type SBK_R = crate::R<bool, SBK_A>;
        impl SBK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SBK_A {
                match self.bits {
                    false => SBK_A::NOBREAK,
                    true => SBK_A::BREAK,
                }
            }
            #[doc = "Checks if the value of the field is `NOBREAK`"]
            #[inline(always)]
            pub fn is_no_break(&self) -> bool {
                *self == SBK_A::NOBREAK
            }
            #[doc = "Checks if the value of the field is `BREAK`"]
            #[inline(always)]
            pub fn is_break_(&self) -> bool {
                *self == SBK_A::BREAK
            }
        }
        #[doc = "Write proxy for field `SBK`"]
        pub struct SBK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SBK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No break character is transmitted"]
            #[inline(always)]
            pub fn no_break(self) -> &'a mut W {
                self.variant(SBK_A::NOBREAK)
            }
            #[doc = "Break character transmitted"]
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBK_A::BREAK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Receiver wakeup\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RWU_A {
            #[doc = "0: Receiver in active mode"]
            ACTIVE = 0,
            #[doc = "1: Receiver in mute mode"]
            MUTE = 1,
        }
        impl From<RWU_A> for bool {
            #[inline(always)]
            fn from(variant: RWU_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RWU`"]
        pub type RWU_R = crate::R<bool, RWU_A>;
        impl RWU_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RWU_A {
                match self.bits {
                    false => RWU_A::ACTIVE,
                    true => RWU_A::MUTE,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == RWU_A::ACTIVE
            }
            #[doc = "Checks if the value of the field is `MUTE`"]
            #[inline(always)]
            pub fn is_mute(&self) -> bool {
                *self == RWU_A::MUTE
            }
        }
        #[doc = "Write proxy for field `RWU`"]
        pub struct RWU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RWU_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RWU_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver in active mode"]
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(RWU_A::ACTIVE)
            }
            #[doc = "Receiver in mute mode"]
            #[inline(always)]
            pub fn mute(self) -> &'a mut W {
                self.variant(RWU_A::MUTE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Receiver enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RE_A {
            #[doc = "0: Receiver disabled"]
            DISABLED = 0,
            #[doc = "1: Receiver enabled"]
            ENABLED = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RE`"]
        pub type RE_R = crate::R<bool, RE_A>;
        impl RE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::DISABLED,
                    true => RE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RE`"]
        pub struct RE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::DISABLED)
            }
            #[doc = "Receiver enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Transmitter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TE_A {
            #[doc = "0: Transmitter disabled"]
            DISABLED = 0,
            #[doc = "1: Transmitter enabled"]
            ENABLED = 1,
        }
        impl From<TE_A> for bool {
            #[inline(always)]
            fn from(variant: TE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TE`"]
        pub type TE_R = crate::R<bool, TE_A>;
        impl TE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TE_A {
                match self.bits {
                    false => TE_A::DISABLED,
                    true => TE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TE`"]
        pub struct TE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Transmitter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TE_A::DISABLED)
            }
            #[doc = "Transmitter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "IDLE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLEIE_A {
            #[doc = "0: IDLE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: IDLE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IDLEIE`"]
        pub type IDLEIE_R = crate::R<bool, IDLEIE_A>;
        impl IDLEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::DISABLED,
                    true => IDLEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IDLEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IDLEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IDLEIE`"]
        pub struct IDLEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "IDLE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::DISABLED)
            }
            #[doc = "IDLE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "RXNE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            #[doc = "0: RXNE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: RXNE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNEIE`"]
        pub type RXNEIE_R = crate::R<bool, RXNEIE_A>;
        impl RXNEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::DISABLED,
                    true => RXNEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXNEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXNEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXNEIE`"]
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RXNE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::DISABLED)
            }
            #[doc = "RXNE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Transmission complete interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            #[doc = "0: TC interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: TC interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIE`"]
        pub type TCIE_R = crate::R<bool, TCIE_A>;
        impl TCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TCIE`"]
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TC interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            #[doc = "TC interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "TXE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            #[doc = "0: TXE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: TXE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXEIE`"]
        pub type TXEIE_R = crate::R<bool, TXEIE_A>;
        impl TXEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::DISABLED,
                    true => TXEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXEIE`"]
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TXE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXEIE_A::DISABLED)
            }
            #[doc = "TXE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "PE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEIE_A {
            #[doc = "0: PE interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: PE interrupt enabled"]
            ENABLED = 1,
        }
        impl From<PEIE_A> for bool {
            #[inline(always)]
            fn from(variant: PEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PEIE`"]
        pub type PEIE_R = crate::R<bool, PEIE_A>;
        impl PEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PEIE_A {
                match self.bits {
                    false => PEIE_A::DISABLED,
                    true => PEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PEIE`"]
        pub struct PEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PE interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEIE_A::DISABLED)
            }
            #[doc = "PE interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Parity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PS_A {
            #[doc = "0: Even parity"]
            EVEN = 0,
            #[doc = "1: Odd parity"]
            ODD = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PS`"]
        pub type PS_R = crate::R<bool, PS_A>;
        impl PS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::EVEN,
                    true => PS_A::ODD,
                }
            }
            #[doc = "Checks if the value of the field is `EVEN`"]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == PS_A::EVEN
            }
            #[doc = "Checks if the value of the field is `ODD`"]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == PS_A::ODD
            }
        }
        #[doc = "Write proxy for field `PS`"]
        pub struct PS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Even parity"]
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::EVEN)
            }
            #[doc = "Odd parity"]
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::ODD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Parity control enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PCE_A {
            #[doc = "0: Parity control disabled"]
            DISABLED = 0,
            #[doc = "1: Parity control enabled"]
            ENABLED = 1,
        }
        impl From<PCE_A> for bool {
            #[inline(always)]
            fn from(variant: PCE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PCE`"]
        pub type PCE_R = crate::R<bool, PCE_A>;
        impl PCE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PCE_A {
                match self.bits {
                    false => PCE_A::DISABLED,
                    true => PCE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PCE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PCE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PCE`"]
        pub struct PCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PCE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Parity control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PCE_A::DISABLED)
            }
            #[doc = "Parity control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PCE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Wakeup method\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKE_A {
            #[doc = "0: USART wakeup on idle line"]
            IDLELINE = 0,
            #[doc = "1: USART wakeup on address mark"]
            ADDRESSMARK = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAKE`"]
        pub type WAKE_R = crate::R<bool, WAKE_A>;
        impl WAKE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IDLELINE,
                    true => WAKE_A::ADDRESSMARK,
                }
            }
            #[doc = "Checks if the value of the field is `IDLELINE`"]
            #[inline(always)]
            pub fn is_idle_line(&self) -> bool {
                *self == WAKE_A::IDLELINE
            }
            #[doc = "Checks if the value of the field is `ADDRESSMARK`"]
            #[inline(always)]
            pub fn is_address_mark(&self) -> bool {
                *self == WAKE_A::ADDRESSMARK
            }
        }
        #[doc = "Write proxy for field `WAKE`"]
        pub struct WAKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAKE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAKE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "USART wakeup on idle line"]
            #[inline(always)]
            pub fn idle_line(self) -> &'a mut W {
                self.variant(WAKE_A::IDLELINE)
            }
            #[doc = "USART wakeup on address mark"]
            #[inline(always)]
            pub fn address_mark(self) -> &'a mut W {
                self.variant(WAKE_A::ADDRESSMARK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Word length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M_A {
            #[doc = "0: 8 data bits"]
            M8 = 0,
            #[doc = "1: 9 data bits"]
            M9 = 1,
        }
        impl From<M_A> for bool {
            #[inline(always)]
            fn from(variant: M_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `M`"]
        pub type M_R = crate::R<bool, M_A>;
        impl M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> M_A {
                match self.bits {
                    false => M_A::M8,
                    true => M_A::M9,
                }
            }
            #[doc = "Checks if the value of the field is `M8`"]
            #[inline(always)]
            pub fn is_m8(&self) -> bool {
                *self == M_A::M8
            }
            #[doc = "Checks if the value of the field is `M9`"]
            #[inline(always)]
            pub fn is_m9(&self) -> bool {
                *self == M_A::M9
            }
        }
        #[doc = "Write proxy for field `M`"]
        pub struct M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: M_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "8 data bits"]
            #[inline(always)]
            pub fn m8(self) -> &'a mut W {
                self.variant(M_A::M8)
            }
            #[doc = "9 data bits"]
            #[inline(always)]
            pub fn m9(self) -> &'a mut W {
                self.variant(M_A::M9)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "USART enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UE_A {
            #[doc = "0: USART prescaler and outputs disabled"]
            DISABLED = 0,
            #[doc = "1: USART enabled"]
            ENABLED = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UE`"]
        pub type UE_R = crate::R<bool, UE_A>;
        impl UE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::DISABLED,
                    true => UE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UE`"]
        pub struct UE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "USART prescaler and outputs disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::DISABLED)
            }
            #[doc = "USART enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Send break"]
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - USART enable"]
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Send break"]
            #[inline(always)]
            pub fn sbk(&mut self) -> SBK_W {
                SBK_W { w: self }
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline(always)]
            pub fn rwu(&mut self) -> RWU_W {
                RWU_W { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&mut self) -> RE_W {
                RE_W { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&mut self) -> TE_W {
                TE_W { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&mut self) -> IDLEIE_W {
                IDLEIE_W { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&mut self) -> PEIE_W {
                PEIE_W { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W {
                PS_W { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&mut self) -> PCE_W {
                PCE_W { w: self }
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline(always)]
            pub fn wake(&mut self) -> WAKE_W {
                WAKE_W { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m(&mut self) -> M_W {
                M_W { w: self }
            }
            #[doc = "Bit 13 - USART enable"]
            #[inline(always)]
            pub fn ue(&mut self) -> UE_W {
                UE_W { w: self }
            }
        }
    }
    #[doc = "Control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "lin break detection length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDL_A {
            #[doc = "0: 10-bit break detection"]
            LBDL10 = 0,
            #[doc = "1: 11-bit break detection"]
            LBDL11 = 1,
        }
        impl From<LBDL_A> for bool {
            #[inline(always)]
            fn from(variant: LBDL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBDL`"]
        pub type LBDL_R = crate::R<bool, LBDL_A>;
        impl LBDL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBDL_A {
                match self.bits {
                    false => LBDL_A::LBDL10,
                    true => LBDL_A::LBDL11,
                }
            }
            #[doc = "Checks if the value of the field is `LBDL10`"]
            #[inline(always)]
            pub fn is_lbdl10(&self) -> bool {
                *self == LBDL_A::LBDL10
            }
            #[doc = "Checks if the value of the field is `LBDL11`"]
            #[inline(always)]
            pub fn is_lbdl11(&self) -> bool {
                *self == LBDL_A::LBDL11
            }
        }
        #[doc = "Write proxy for field `LBDL`"]
        pub struct LBDL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "10-bit break detection"]
            #[inline(always)]
            pub fn lbdl10(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL10)
            }
            #[doc = "11-bit break detection"]
            #[inline(always)]
            pub fn lbdl11(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL11)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "LIN break detection interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDIE_A {
            #[doc = "0: LIN break detection interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: LIN break detection interrupt enabled"]
            ENABLED = 1,
        }
        impl From<LBDIE_A> for bool {
            #[inline(always)]
            fn from(variant: LBDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBDIE`"]
        pub type LBDIE_R = crate::R<bool, LBDIE_A>;
        impl LBDIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBDIE_A {
                match self.bits {
                    false => LBDIE_A::DISABLED,
                    true => LBDIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LBDIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LBDIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LBDIE`"]
        pub struct LBDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LIN break detection interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LBDIE_A::DISABLED)
            }
            #[doc = "LIN break detection interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LBDIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "STOP bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum STOP_A {
            #[doc = "0: 1 stop bit"]
            STOP1 = 0,
            #[doc = "2: 2 stop bits"]
            STOP2 = 2,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `STOP`"]
        pub type STOP_R = crate::R<u8, STOP_A>;
        impl STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, STOP_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(STOP_A::STOP1),
                    2 => Val(STOP_A::STOP2),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `STOP1`"]
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                *self == STOP_A::STOP1
            }
            #[doc = "Checks if the value of the field is `STOP2`"]
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                *self == STOP_A::STOP2
            }
        }
        #[doc = "Write proxy for field `STOP`"]
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "1 stop bit"]
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::STOP1)
            }
            #[doc = "2 stop bits"]
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::STOP2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "LIN mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LINEN_A {
            #[doc = "0: LIN mode disabled"]
            DISABLED = 0,
            #[doc = "1: LIN mode enabled"]
            ENABLED = 1,
        }
        impl From<LINEN_A> for bool {
            #[inline(always)]
            fn from(variant: LINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LINEN`"]
        pub type LINEN_R = crate::R<bool, LINEN_A>;
        impl LINEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LINEN_A {
                match self.bits {
                    false => LINEN_A::DISABLED,
                    true => LINEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LINEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LINEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LINEN`"]
        pub struct LINEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LINEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LINEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LIN mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LINEN_A::DISABLED)
            }
            #[doc = "LIN mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LINEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline(always)]
            pub fn lbdl(&mut self) -> LBDL_W {
                LBDL_W { w: self }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline(always)]
            pub fn lbdie(&mut self) -> LBDIE_W {
                LBDIE_W { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline(always)]
            pub fn linen(&mut self) -> LINEN_W {
                LINEN_W { w: self }
            }
        }
    }
    #[doc = "Control register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr3](cr3) module"]
    pub type CR3 = crate::Reg<u32, _CR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR3;
    #[doc = "`read()` method returns [cr3::R](cr3::R) reader structure"]
    impl crate::Readable for CR3 {}
    #[doc = "`write(|w| ..)` method takes [cr3::W](cr3::W) writer structure"]
    impl crate::Writable for CR3 {}
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = "Reader of register CR3"]
        pub type R = crate::R<u32, super::CR3>;
        #[doc = "Writer for register CR3"]
        pub type W = crate::W<u32, super::CR3>;
        #[doc = "Register CR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EIE_A {
            #[doc = "0: Error interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Error interrupt enabled"]
            ENABLED = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EIE`"]
        pub type EIE_R = crate::R<bool, EIE_A>;
        impl EIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::DISABLED,
                    true => EIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EIE`"]
        pub struct EIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::DISABLED)
            }
            #[doc = "Error interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "IrDA mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IREN_A {
            #[doc = "0: IrDA disabled"]
            DISABLED = 0,
            #[doc = "1: IrDA enabled"]
            ENABLED = 1,
        }
        impl From<IREN_A> for bool {
            #[inline(always)]
            fn from(variant: IREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IREN`"]
        pub type IREN_R = crate::R<bool, IREN_A>;
        impl IREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IREN_A {
                match self.bits {
                    false => IREN_A::DISABLED,
                    true => IREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IREN`"]
        pub struct IREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "IrDA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IREN_A::DISABLED)
            }
            #[doc = "IrDA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "IrDA low-power\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRLP_A {
            #[doc = "0: Normal mode"]
            NORMAL = 0,
            #[doc = "1: Low-power mode"]
            LOWPOWER = 1,
        }
        impl From<IRLP_A> for bool {
            #[inline(always)]
            fn from(variant: IRLP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IRLP`"]
        pub type IRLP_R = crate::R<bool, IRLP_A>;
        impl IRLP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IRLP_A {
                match self.bits {
                    false => IRLP_A::NORMAL,
                    true => IRLP_A::LOWPOWER,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == IRLP_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `LOWPOWER`"]
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                *self == IRLP_A::LOWPOWER
            }
        }
        #[doc = "Write proxy for field `IRLP`"]
        pub struct IRLP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IRLP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRLP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(IRLP_A::NORMAL)
            }
            #[doc = "Low-power mode"]
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(IRLP_A::LOWPOWER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Half-duplex selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HDSEL_A {
            #[doc = "0: Half duplex mode is not selected"]
            FULLDUPLEX = 0,
            #[doc = "1: Half duplex mode is selected"]
            HALFDUPLEX = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HDSEL`"]
        pub type HDSEL_R = crate::R<bool, HDSEL_A>;
        impl HDSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::FULLDUPLEX,
                    true => HDSEL_A::HALFDUPLEX,
                }
            }
            #[doc = "Checks if the value of the field is `FULLDUPLEX`"]
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                *self == HDSEL_A::FULLDUPLEX
            }
            #[doc = "Checks if the value of the field is `HALFDUPLEX`"]
            #[inline(always)]
            pub fn is_half_duplex(&self) -> bool {
                *self == HDSEL_A::HALFDUPLEX
            }
        }
        #[doc = "Write proxy for field `HDSEL`"]
        pub struct HDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HDSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HDSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Half duplex mode is not selected"]
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::FULLDUPLEX)
            }
            #[doc = "Half duplex mode is selected"]
            #[inline(always)]
            pub fn half_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::HALFDUPLEX)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "DMA enable receiver\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR_A {
            #[doc = "0: DMA mode is disabled for reception"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for reception"]
            ENABLED = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAR`"]
        pub type DMAR_R = crate::R<bool, DMAR_A>;
        impl DMAR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::DISABLED,
                    true => DMAR_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAR_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAR_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAR`"]
        pub struct DMAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for reception"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for reception"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "DMA enable transmitter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAT_A {
            #[doc = "0: DMA mode is disabled for transmission"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for transmission"]
            ENABLED = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAT`"]
        pub type DMAT_R = crate::R<bool, DMAT_A>;
        impl DMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::DISABLED,
                    true => DMAT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAT`"]
        pub struct DMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for transmission"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for transmission"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&mut self) -> EIE_W {
                EIE_W { w: self }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline(always)]
            pub fn iren(&mut self) -> IREN_W {
                IREN_W { w: self }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline(always)]
            pub fn irlp(&mut self) -> IRLP_W {
                IRLP_W { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&mut self) -> HDSEL_W {
                HDSEL_W { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&mut self) -> DMAR_W {
                DMAR_W { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&mut self) -> DMAT_W {
                DMAT_W { w: self }
            }
        }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
pub struct UART5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART5 {}
impl UART5 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart4::RegisterBlock {
        0x4000_5000 as *const _
    }
}
impl Deref for UART5 {
    type Target = uart4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*UART5::ptr() }
    }
}
#[doc = "CRC calculation unit"]
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        0x4002_3000 as *const _
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*CRC::ptr() }
    }
}
#[doc = "CRC calculation unit"]
pub mod crc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data register"]
        pub dr: DR,
        #[doc = "0x04 - Independent Data register"]
        pub idr: IDR,
        #[doc = "0x08 - Control register"]
        pub cr: CR,
    }
    #[doc = "Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0xffff_ffff"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff_ffff
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Data Register"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Data Register"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "Independent Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "`write(|w| ..)` method takes [idr::W](idr::W) writer structure"]
    impl crate::Writable for IDR {}
    #[doc = "Independent Data register"]
    pub mod idr {
        #[doc = "Reader of register IDR"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Writer for register IDR"]
        pub type W = crate::W<u32, super::IDR>;
        #[doc = "Register IDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IDR`"]
        pub type IDR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IDR`"]
        pub struct IDR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Independent Data register"]
            #[inline(always)]
            pub fn idr(&self) -> IDR_R {
                IDR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Independent Data register"]
            #[inline(always)]
            pub fn idr(&mut self) -> IDR_W {
                IDR_W { w: self }
            }
        }
    }
    #[doc = "Control register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control register"]
    pub mod cr {
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reset bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESET_AW {
            #[doc = "1: Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF"]
            RESET = 1,
        }
        impl From<RESET_AW> for bool {
            #[inline(always)]
            fn from(variant: RESET_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RESET`"]
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RESET_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RESET_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - Reset bit"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
        }
    }
}
#[doc = "FLASH"]
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        0x4002_2000 as *const _
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*FLASH::ptr() }
    }
}
#[doc = "FLASH"]
pub mod flash {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Flash access control register"]
        pub acr: ACR,
        #[doc = "0x04 - Flash key register"]
        pub keyr: KEYR,
        #[doc = "0x08 - Flash option key register"]
        pub optkeyr: OPTKEYR,
        #[doc = "0x0c - Status register"]
        pub sr: SR,
        #[doc = "0x10 - Control register"]
        pub cr: CR,
        #[doc = "0x14 - Flash address register"]
        pub ar: AR,
        _reserved6: [u8; 4usize],
        #[doc = "0x1c - Option byte register"]
        pub obr: OBR,
        #[doc = "0x20 - Write protection register"]
        pub wrpr: WRPR,
    }
    #[doc = "Flash access control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [acr](acr) module"]
    pub type ACR = crate::Reg<u32, _ACR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ACR;
    #[doc = "`read()` method returns [acr::R](acr::R) reader structure"]
    impl crate::Readable for ACR {}
    #[doc = "`write(|w| ..)` method takes [acr::W](acr::W) writer structure"]
    impl crate::Writable for ACR {}
    #[doc = "Flash access control register"]
    pub mod acr {
        #[doc = "Reader of register ACR"]
        pub type R = crate::R<u32, super::ACR>;
        #[doc = "Writer for register ACR"]
        pub type W = crate::W<u32, super::ACR>;
        #[doc = "Register ACR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ACR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `HLFCYA`"]
        pub type HLFCYA_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `HLFCYA`"]
        pub struct HLFCYA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HLFCYA_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 3 - Flash half cycle access enable"]
            #[inline(always)]
            pub fn hlfcya(&self) -> HLFCYA_R {
                HLFCYA_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - Flash half cycle access enable"]
            #[inline(always)]
            pub fn hlfcya(&mut self) -> HLFCYA_W {
                HLFCYA_W { w: self }
            }
        }
    }
    #[doc = "Flash key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [keyr](keyr) module"]
    pub type KEYR = crate::Reg<u32, _KEYR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEYR;
    #[doc = "`write(|w| ..)` method takes [keyr::W](keyr::W) writer structure"]
    impl crate::Writable for KEYR {}
    #[doc = "Flash key register"]
    pub mod keyr {
        #[doc = "Writer for register KEYR"]
        pub type W = crate::W<u32, super::KEYR>;
        #[doc = "Register KEYR `reset()`'s with value 0"]
        impl crate::ResetValue for super::KEYR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `KEY`"]
        pub struct KEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - FPEC key"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W {
                KEY_W { w: self }
            }
        }
    }
    #[doc = "Flash option key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [optkeyr](optkeyr) module"]
    pub type OPTKEYR = crate::Reg<u32, _OPTKEYR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OPTKEYR;
    #[doc = "`write(|w| ..)` method takes [optkeyr::W](optkeyr::W) writer structure"]
    impl crate::Writable for OPTKEYR {}
    #[doc = "Flash option key register"]
    pub mod optkeyr {
        #[doc = "Writer for register OPTKEYR"]
        pub type W = crate::W<u32, super::OPTKEYR>;
        #[doc = "Register OPTKEYR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OPTKEYR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `OPTKEY`"]
        pub struct OPTKEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTKEY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Option byte key"]
            #[inline(always)]
            pub fn optkey(&mut self) -> OPTKEY_W {
                OPTKEY_W { w: self }
            }
        }
    }
    #[doc = "Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `EOP`"]
        pub type EOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `EOP`"]
        pub struct EOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `WRPRTERR`"]
        pub type WRPRTERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `WRPRTERR`"]
        pub struct WRPRTERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRPRTERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `PGERR`"]
        pub type PGERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PGERR`"]
        pub struct PGERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PGERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `BSY`"]
        pub type BSY_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 5 - End of operation"]
            #[inline(always)]
            pub fn eop(&self) -> EOP_R {
                EOP_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Write protection error"]
            #[inline(always)]
            pub fn wrprterr(&self) -> WRPRTERR_R {
                WRPRTERR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Programming error"]
            #[inline(always)]
            pub fn pgerr(&self) -> PGERR_R {
                PGERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Busy"]
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 5 - End of operation"]
            #[inline(always)]
            pub fn eop(&mut self) -> EOP_W {
                EOP_W { w: self }
            }
            #[doc = "Bit 4 - Write protection error"]
            #[inline(always)]
            pub fn wrprterr(&mut self) -> WRPRTERR_W {
                WRPRTERR_W { w: self }
            }
            #[doc = "Bit 2 - Programming error"]
            #[inline(always)]
            pub fn pgerr(&mut self) -> PGERR_W {
                PGERR_W { w: self }
            }
        }
    }
    #[doc = "Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0x80"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x80
            }
        }
        #[doc = "Reader of field `PG`"]
        pub type PG_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PG`"]
        pub struct PG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `PER`"]
        pub type PER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PER`"]
        pub struct PER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `MER`"]
        pub type MER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MER`"]
        pub struct MER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `OPTPG`"]
        pub type OPTPG_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OPTPG`"]
        pub struct OPTPG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTPG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `OPTER`"]
        pub type OPTER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OPTER`"]
        pub struct OPTER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `STRT`"]
        pub type STRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `STRT`"]
        pub struct STRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `LOCK`"]
        pub type LOCK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `LOCK`"]
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `OPTWRE`"]
        pub type OPTWRE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OPTWRE`"]
        pub struct OPTWRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTWRE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `ERRIE`"]
        pub type ERRIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ERRIE`"]
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `EOPIE`"]
        pub type EOPIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `EOPIE`"]
        pub struct EOPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOPIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Programming"]
            #[inline(always)]
            pub fn pg(&self) -> PG_R {
                PG_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Page Erase"]
            #[inline(always)]
            pub fn per(&self) -> PER_R {
                PER_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Mass Erase"]
            #[inline(always)]
            pub fn mer(&self) -> MER_R {
                MER_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Option byte programming"]
            #[inline(always)]
            pub fn optpg(&self) -> OPTPG_R {
                OPTPG_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Option byte erase"]
            #[inline(always)]
            pub fn opter(&self) -> OPTER_R {
                OPTER_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Start"]
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Lock"]
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Option bytes write enable"]
            #[inline(always)]
            pub fn optwre(&self) -> OPTWRE_R {
                OPTWRE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 12 - End of operation interrupt enable"]
            #[inline(always)]
            pub fn eopie(&self) -> EOPIE_R {
                EOPIE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Programming"]
            #[inline(always)]
            pub fn pg(&mut self) -> PG_W {
                PG_W { w: self }
            }
            #[doc = "Bit 1 - Page Erase"]
            #[inline(always)]
            pub fn per(&mut self) -> PER_W {
                PER_W { w: self }
            }
            #[doc = "Bit 2 - Mass Erase"]
            #[inline(always)]
            pub fn mer(&mut self) -> MER_W {
                MER_W { w: self }
            }
            #[doc = "Bit 4 - Option byte programming"]
            #[inline(always)]
            pub fn optpg(&mut self) -> OPTPG_W {
                OPTPG_W { w: self }
            }
            #[doc = "Bit 5 - Option byte erase"]
            #[inline(always)]
            pub fn opter(&mut self) -> OPTER_W {
                OPTER_W { w: self }
            }
            #[doc = "Bit 6 - Start"]
            #[inline(always)]
            pub fn strt(&mut self) -> STRT_W {
                STRT_W { w: self }
            }
            #[doc = "Bit 7 - Lock"]
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            #[doc = "Bit 9 - Option bytes write enable"]
            #[inline(always)]
            pub fn optwre(&mut self) -> OPTWRE_W {
                OPTWRE_W { w: self }
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            #[doc = "Bit 12 - End of operation interrupt enable"]
            #[inline(always)]
            pub fn eopie(&mut self) -> EOPIE_W {
                EOPIE_W { w: self }
            }
        }
    }
    #[doc = "Flash address register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ar](ar) module"]
    pub type AR = crate::Reg<u32, _AR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AR;
    #[doc = "`write(|w| ..)` method takes [ar::W](ar::W) writer structure"]
    impl crate::Writable for AR {}
    #[doc = "Flash address register"]
    pub mod ar {
        #[doc = "Writer for register AR"]
        pub type W = crate::W<u32, super::AR>;
        #[doc = "Register AR `reset()`'s with value 0"]
        impl crate::ResetValue for super::AR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `FAR`"]
        pub struct FAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FAR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Flash Address"]
            #[inline(always)]
            pub fn far(&mut self) -> FAR_W {
                FAR_W { w: self }
            }
        }
    }
    #[doc = "Option byte register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [obr](obr) module"]
    pub type OBR = crate::Reg<u32, _OBR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OBR;
    #[doc = "`read()` method returns [obr::R](obr::R) reader structure"]
    impl crate::Readable for OBR {}
    #[doc = "Option byte register"]
    pub mod obr {
        #[doc = "Reader of register OBR"]
        pub type R = crate::R<u32, super::OBR>;
        #[doc = "Reader of field `OPTERR`"]
        pub type OPTERR_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RDPRT`"]
        pub type RDPRT_R = crate::R<bool, bool>;
        #[doc = "Reader of field `WDG_SW`"]
        pub type WDG_SW_R = crate::R<bool, bool>;
        #[doc = "Reader of field `nRST_STOP`"]
        pub type NRST_STOP_R = crate::R<bool, bool>;
        #[doc = "Reader of field `nRST_STDBY`"]
        pub type NRST_STDBY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `Data0`"]
        pub type DATA0_R = crate::R<u8, u8>;
        #[doc = "Reader of field `Data1`"]
        pub type DATA1_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bit 0 - Option byte error"]
            #[inline(always)]
            pub fn opterr(&self) -> OPTERR_R {
                OPTERR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Read protection"]
            #[inline(always)]
            pub fn rdprt(&self) -> RDPRT_R {
                RDPRT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - WDG_SW"]
            #[inline(always)]
            pub fn wdg_sw(&self) -> WDG_SW_R {
                WDG_SW_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - nRST_STOP"]
            #[inline(always)]
            pub fn n_rst_stop(&self) -> NRST_STOP_R {
                NRST_STOP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - nRST_STDBY"]
            #[inline(always)]
            pub fn n_rst_stdby(&self) -> NRST_STDBY_R {
                NRST_STDBY_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 10:17 - Data0"]
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new(((self.bits >> 10) & 0xff) as u8)
            }
            #[doc = "Bits 18:25 - Data1"]
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 18) & 0xff) as u8)
            }
        }
    }
    #[doc = "Write protection register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wrpr](wrpr) module"]
    pub type WRPR = crate::Reg<u32, _WRPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _WRPR;
    #[doc = "`read()` method returns [wrpr::R](wrpr::R) reader structure"]
    impl crate::Readable for WRPR {}
    #[doc = "Write protection register"]
    pub mod wrpr {
        #[doc = "Reader of register WRPR"]
        pub type R = crate::R<u32, super::WRPR>;
        #[doc = "Reader of field `WRP`"]
        pub type WRP_R = crate::R<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Write protect"]
            #[inline(always)]
            pub fn wrp(&self) -> WRP_R {
                WRP_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
    }
}
#[doc = "General purpose timers"]
pub struct TIM15 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM15 {}
impl TIM15 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim15::RegisterBlock {
        0x4001_4000 as *const _
    }
}
impl Deref for TIM15 {
    type Target = tim15::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM15::ptr() }
    }
}
#[doc = "General purpose timers"]
pub mod tim15 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved7: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: RCR,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: CCR2,
        _reserved14: [u8; 8usize],
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: BDTR,
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OIS2`"]
        pub type OIS2_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS2`"]
        pub struct OIS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `OIS1N`"]
        pub type OIS1N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS1N`"]
        pub struct OIS1N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `OIS1`"]
        pub type OIS1_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OIS1`"]
        pub struct OIS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `CCDS`"]
        pub type CCDS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CCDS`"]
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CCUS`"]
        pub type CCUS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CCUS`"]
        pub struct CCUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCUS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CCPC`"]
        pub type CCPC_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CCPC`"]
        pub struct CCPC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCPC_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline(always)]
            pub fn ois2(&mut self) -> OIS2_W {
                OIS2_W { w: self }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1n(&mut self) -> OIS1N_W {
                OIS1N_W { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1(&mut self) -> OIS1_W {
                OIS1_W { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline(always)]
            pub fn ccus(&mut self) -> CCUS_W {
                CCUS_W { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline(always)]
            pub fn ccpc(&mut self) -> CCPC_W {
                CCPC_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TDE`"]
        pub type TDE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TDE`"]
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `CC2DE`"]
        pub type CC2DE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2DE`"]
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC1DE`"]
        pub type CC1DE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1DE`"]
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `BIE`"]
        pub type BIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BIE`"]
        pub struct BIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `COMIE`"]
        pub type COMIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COMIE`"]
        pub struct COMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline(always)]
            pub fn bie(&mut self) -> BIE_W {
                BIE_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline(always)]
            pub fn comie(&mut self) -> COMIE_W {
                COMIE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `BIF`"]
        pub type BIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BIF`"]
        pub struct BIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `COMIF`"]
        pub type COMIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COMIF`"]
        pub struct COMIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline(always)]
            pub fn bif(&mut self) -> BIF_W {
                BIF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline(always)]
            pub fn comif(&mut self) -> COMIF_W {
                COMIF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `BG`"]
        pub struct BG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `COMG`"]
        pub struct COMG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 7 - Break generation"]
            #[inline(always)]
            pub fn bg(&mut self) -> BG_W {
                BG_W { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline(always)]
            pub fn comg(&mut self) -> COMG_W {
                COMG_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC2NP`"]
        pub type CC2NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2NP`"]
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CC1NE`"]
        pub type CC1NE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NE`"]
        pub struct CC1NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline(always)]
            pub fn cc1ne(&mut self) -> CC1NE_W {
                CC1NE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "repetition counter register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcr](rcr) module"]
    pub type RCR = crate::Reg<u32, _RCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RCR;
    #[doc = "`read()` method returns [rcr::R](rcr::R) reader structure"]
    impl crate::Readable for RCR {}
    #[doc = "`write(|w| ..)` method takes [rcr::W](rcr::W) writer structure"]
    impl crate::Writable for RCR {}
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = "Reader of register RCR"]
        pub type R = crate::R<u32, super::RCR>;
        #[doc = "Writer for register RCR"]
        pub type W = crate::W<u32, super::RCR>;
        #[doc = "Register RCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `REP`"]
        pub type REP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `REP`"]
        pub struct REP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline(always)]
            pub fn rep(&mut self) -> REP_W {
                REP_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr1](ccr1) module"]
    pub type CCR1 = crate::Reg<u32, _CCR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR1;
    #[doc = "`read()` method returns [ccr1::R](ccr1::R) reader structure"]
    impl crate::Readable for CCR1 {}
    #[doc = "`write(|w| ..)` method takes [ccr1::W](ccr1::W) writer structure"]
    impl crate::Writable for CCR1 {}
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = "Reader of register CCR1"]
        pub type R = crate::R<u32, super::CCR1>;
        #[doc = "Writer for register CCR1"]
        pub type W = crate::W<u32, super::CCR1>;
        #[doc = "Register CCR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR1`"]
        pub type CCR1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR1`"]
        pub struct CCR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr1(&mut self) -> CCR1_W {
                CCR1_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr2](ccr2) module"]
    pub type CCR2 = crate::Reg<u32, _CCR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR2;
    #[doc = "`read()` method returns [ccr2::R](ccr2::R) reader structure"]
    impl crate::Readable for CCR2 {}
    #[doc = "`write(|w| ..)` method takes [ccr2::W](ccr2::W) writer structure"]
    impl crate::Writable for CCR2 {}
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = "Reader of register CCR2"]
        pub type R = crate::R<u32, super::CCR2>;
        #[doc = "Writer for register CCR2"]
        pub type W = crate::W<u32, super::CCR2>;
        #[doc = "Register CCR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR2`"]
        pub type CCR2_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR2`"]
        pub struct CCR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline(always)]
            pub fn ccr2(&mut self) -> CCR2_W {
                CCR2_W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bdtr](bdtr) module"]
    pub type BDTR = crate::Reg<u32, _BDTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BDTR;
    #[doc = "`read()` method returns [bdtr::R](bdtr::R) reader structure"]
    impl crate::Readable for BDTR {}
    #[doc = "`write(|w| ..)` method takes [bdtr::W](bdtr::W) writer structure"]
    impl crate::Writable for BDTR {}
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = "Reader of register BDTR"]
        pub type R = crate::R<u32, super::BDTR>;
        #[doc = "Writer for register BDTR"]
        pub type W = crate::W<u32, super::BDTR>;
        #[doc = "Register BDTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BDTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MOE`"]
        pub type MOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MOE`"]
        pub struct MOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `AOE`"]
        pub type AOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `AOE`"]
        pub struct AOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `BKP`"]
        pub type BKP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BKP`"]
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `BKE`"]
        pub type BKE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BKE`"]
        pub struct BKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `OSSR`"]
        pub type OSSR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OSSR`"]
        pub struct OSSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OSSI`"]
        pub type OSSI_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OSSI`"]
        pub struct OSSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSI_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `LOCK`"]
        pub type LOCK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `LOCK`"]
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DTG`"]
        pub type DTG_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DTG`"]
        pub struct DTG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DTG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Main output enable"]
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Main output enable"]
            #[inline(always)]
            pub fn moe(&mut self) -> MOE_W {
                MOE_W { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline(always)]
            pub fn aoe(&mut self) -> AOE_W {
                AOE_W { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline(always)]
            pub fn bke(&mut self) -> BKE_W {
                BKE_W { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline(always)]
            pub fn ossr(&mut self) -> OSSR_W {
                OSSR_W { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline(always)]
            pub fn ossi(&mut self) -> OSSI_W {
                OSSI_W { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline(always)]
            pub fn dtg(&mut self) -> DTG_W {
                DTG_W { w: self }
            }
        }
    }
    #[doc = "DMA control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dcr](dcr) module"]
    pub type DCR = crate::Reg<u32, _DCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DCR;
    #[doc = "`read()` method returns [dcr::R](dcr::R) reader structure"]
    impl crate::Readable for DCR {}
    #[doc = "`write(|w| ..)` method takes [dcr::W](dcr::W) writer structure"]
    impl crate::Writable for DCR {}
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = "Reader of register DCR"]
        pub type R = crate::R<u32, super::DCR>;
        #[doc = "Writer for register DCR"]
        pub type W = crate::W<u32, super::DCR>;
        #[doc = "Register DCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DBL`"]
        pub type DBL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBL`"]
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DBA`"]
        pub type DBA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBA`"]
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmar](dmar) module"]
    pub type DMAR = crate::Reg<u32, _DMAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMAR;
    #[doc = "`read()` method returns [dmar::R](dmar::R) reader structure"]
    impl crate::Readable for DMAR {}
    #[doc = "`write(|w| ..)` method takes [dmar::W](dmar::W) writer structure"]
    impl crate::Writable for DMAR {}
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = "Reader of register DMAR"]
        pub type R = crate::R<u32, super::DMAR>;
        #[doc = "Writer for register DMAR"]
        pub type W = crate::W<u32, super::DMAR>;
        #[doc = "Register DMAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DMAB`"]
        pub type DMAB_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DMAB`"]
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct TIM16 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM16 {}
impl TIM16 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim16::RegisterBlock {
        0x4001_4400 as *const _
    }
}
impl Deref for TIM16 {
    type Target = tim16::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM16::ptr() }
    }
}
#[doc = "General-purpose-timers"]
pub mod tim16 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        _reserved2: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_5_ccmr1: [u8; 4usize],
        _reserved6: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: RCR,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        _reserved12: [u8; 12usize],
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: BDTR,
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Not stopped at update event"]
            NOTSTOPPED = 0,
            #[doc = "1: Counter stops counting at next update event"]
            STOPPED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::NOTSTOPPED,
                    true => OPM_A::STOPPED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTOPPED`"]
            #[inline(always)]
            pub fn is_not_stopped(&self) -> bool {
                *self == OPM_A::NOTSTOPPED
            }
            #[doc = "Checks if the value of the field is `STOPPED`"]
            #[inline(always)]
            pub fn is_stopped(&self) -> bool {
                *self == OPM_A::STOPPED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Not stopped at update event"]
            #[inline(always)]
            pub fn not_stopped(self) -> &'a mut W {
                self.variant(OPM_A::NOTSTOPPED)
            }
            #[doc = "Counter stops counting at next update event"]
            #[inline(always)]
            pub fn stopped(self) -> &'a mut W {
                self.variant(OPM_A::STOPPED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Output Idle state 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OIS1N_A {
            #[doc = "0: OC1N=0 after a dead-time when MOE=0"]
            LOW = 0,
            #[doc = "1: OC1N=1 after a dead-time when MOE=0"]
            HIGH = 1,
        }
        impl From<OIS1N_A> for bool {
            #[inline(always)]
            fn from(variant: OIS1N_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OIS1N`"]
        pub type OIS1N_R = crate::R<bool, OIS1N_A>;
        impl OIS1N_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OIS1N_A {
                match self.bits {
                    false => OIS1N_A::LOW,
                    true => OIS1N_A::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == OIS1N_A::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == OIS1N_A::HIGH
            }
        }
        #[doc = "Write proxy for field `OIS1N`"]
        pub struct OIS1N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1N_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OIS1N_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "OC1N=0 after a dead-time when MOE=0"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OIS1N_A::LOW)
            }
            #[doc = "OC1N=1 after a dead-time when MOE=0"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OIS1N_A::HIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Output Idle state 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OIS1_A {
            #[doc = "0: OC1=0 (after a dead-time if OC1N is implemented) when MOE=0"]
            LOW = 0,
            #[doc = "1: OC1=1 (after a dead-time if OC1N is implemented) when MOE=0"]
            HIGH = 1,
        }
        impl From<OIS1_A> for bool {
            #[inline(always)]
            fn from(variant: OIS1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OIS1`"]
        pub type OIS1_R = crate::R<bool, OIS1_A>;
        impl OIS1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OIS1_A {
                match self.bits {
                    false => OIS1_A::LOW,
                    true => OIS1_A::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == OIS1_A::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == OIS1_A::HIGH
            }
        }
        #[doc = "Write proxy for field `OIS1`"]
        pub struct OIS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OIS1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "OC1=0 (after a dead-time if OC1N is implemented) when MOE=0"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OIS1_A::LOW)
            }
            #[doc = "OC1=1 (after a dead-time if OC1N is implemented) when MOE=0"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OIS1_A::HIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Capture/compare DMA selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            #[doc = "0: CCx DMA request sent when CCx event occurs"]
            ONCOMPARE = 0,
            #[doc = "1: CCx DMA request sent when update event occurs"]
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCDS`"]
        pub type CCDS_R = crate::R<bool, CCDS_A>;
        impl CCDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            #[doc = "Checks if the value of the field is `ONCOMPARE`"]
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                *self == CCDS_A::ONCOMPARE
            }
            #[doc = "Checks if the value of the field is `ONUPDATE`"]
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                *self == CCDS_A::ONUPDATE
            }
        }
        #[doc = "Write proxy for field `CCDS`"]
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request sent when CCx event occurs"]
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            #[doc = "CCx DMA request sent when update event occurs"]
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/compare control update selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCUS_A {
            #[doc = "0: Capture/compare are updated only by setting the COMG bit"]
            DEFAULT = 0,
            #[doc = "1: Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
            WITHRISINGEDGE = 1,
        }
        impl From<CCUS_A> for bool {
            #[inline(always)]
            fn from(variant: CCUS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCUS`"]
        pub type CCUS_R = crate::R<bool, CCUS_A>;
        impl CCUS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCUS_A {
                match self.bits {
                    false => CCUS_A::DEFAULT,
                    true => CCUS_A::WITHRISINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `DEFAULT`"]
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                *self == CCUS_A::DEFAULT
            }
            #[doc = "Checks if the value of the field is `WITHRISINGEDGE`"]
            #[inline(always)]
            pub fn is_with_rising_edge(&self) -> bool {
                *self == CCUS_A::WITHRISINGEDGE
            }
        }
        #[doc = "Write proxy for field `CCUS`"]
        pub struct CCUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCUS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCUS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture/compare are updated only by setting the COMG bit"]
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(CCUS_A::DEFAULT)
            }
            #[doc = "Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
            #[inline(always)]
            pub fn with_rising_edge(self) -> &'a mut W {
                self.variant(CCUS_A::WITHRISINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare preloaded control\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCPC_A {
            #[doc = "0: CCxE, CCxNE and OCxM bits are not preloaded"]
            NOTPRELOADED = 0,
            #[doc = "1: CCxE, CCxNE and OCxM bits are preloaded"]
            PRELOADED = 1,
        }
        impl From<CCPC_A> for bool {
            #[inline(always)]
            fn from(variant: CCPC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCPC`"]
        pub type CCPC_R = crate::R<bool, CCPC_A>;
        impl CCPC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCPC_A {
                match self.bits {
                    false => CCPC_A::NOTPRELOADED,
                    true => CCPC_A::PRELOADED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRELOADED`"]
            #[inline(always)]
            pub fn is_not_preloaded(&self) -> bool {
                *self == CCPC_A::NOTPRELOADED
            }
            #[doc = "Checks if the value of the field is `PRELOADED`"]
            #[inline(always)]
            pub fn is_preloaded(&self) -> bool {
                *self == CCPC_A::PRELOADED
            }
        }
        #[doc = "Write proxy for field `CCPC`"]
        pub struct CCPC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCPC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCPC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCxE, CCxNE and OCxM bits are not preloaded"]
            #[inline(always)]
            pub fn not_preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::NOTPRELOADED)
            }
            #[doc = "CCxE, CCxNE and OCxM bits are preloaded"]
            #[inline(always)]
            pub fn preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::PRELOADED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1n(&mut self) -> OIS1N_W {
                OIS1N_W { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline(always)]
            pub fn ois1(&mut self) -> OIS1_W {
                OIS1_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline(always)]
            pub fn ccus(&mut self) -> CCUS_W {
                CCUS_W { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline(always)]
            pub fn ccpc(&mut self) -> CCPC_W {
                CCPC_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TDE`"]
        pub type TDE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TDE`"]
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1DE_A {
            #[doc = "0: CC1 DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: CC1 DMA request enabled"]
            ENABLED = 1,
        }
        impl From<CC1DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1DE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC1DE`"]
        pub type CC1DE_R = crate::R<bool, CC1DE_A>;
        impl CC1DE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC1DE_A {
                match self.bits {
                    false => CC1DE_A::DISABLED,
                    true => CC1DE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC1DE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC1DE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC1DE`"]
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CC1 DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            #[doc = "CC1 DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Break interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIE_A {
            #[doc = "0: Break interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Break interrupt enabled"]
            ENABLED = 1,
        }
        impl From<BIE_A> for bool {
            #[inline(always)]
            fn from(variant: BIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BIE`"]
        pub type BIE_R = crate::R<bool, BIE_A>;
        impl BIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BIE_A {
                match self.bits {
                    false => BIE_A::DISABLED,
                    true => BIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `BIE`"]
        pub struct BIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Break interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BIE_A::DISABLED)
            }
            #[doc = "Break interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "COM interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMIE_A {
            #[doc = "0: COM interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: COM interrupt enabled"]
            ENABLED = 1,
        }
        impl From<COMIE_A> for bool {
            #[inline(always)]
            fn from(variant: COMIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMIE`"]
        pub type COMIE_R = crate::R<bool, COMIE_A>;
        impl COMIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMIE_A {
                match self.bits {
                    false => COMIE_A::DISABLED,
                    true => COMIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == COMIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == COMIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `COMIE`"]
        pub struct COMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "COM interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMIE_A::DISABLED)
            }
            #[doc = "COM interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1IE_A {
            #[doc = "0: CC1 interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CC1 interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CC1IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, CC1IE_A>;
        impl CC1IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC1IE_A {
                match self.bits {
                    false => CC1IE_A::DISABLED,
                    true => CC1IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC1IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC1IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CC1 interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            #[doc = "CC1 interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline(always)]
            pub fn bie(&mut self) -> BIE_W {
                BIE_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline(always)]
            pub fn comie(&mut self) -> COMIE_W {
                COMIE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `BIF`"]
        pub type BIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BIF`"]
        pub struct BIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `COMIF`"]
        pub type COMIF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COMIF`"]
        pub struct COMIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline(always)]
            pub fn bif(&mut self) -> BIF_W {
                BIF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline(always)]
            pub fn comif(&mut self) -> COMIF_W {
                COMIF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `BG`"]
        pub struct BG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `COMG`"]
        pub struct COMG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 7 - Break generation"]
            #[inline(always)]
            pub fn bg(&mut self) -> BG_W {
                BG_W { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline(always)]
            pub fn comg(&mut self) -> COMG_W {
                COMG_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `CC1NE`"]
        pub type CC1NE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1NE`"]
        pub struct CC1NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline(always)]
            pub fn cc1ne(&mut self) -> CC1NE_W {
                CC1NE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "repetition counter register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcr](rcr) module"]
    pub type RCR = crate::Reg<u32, _RCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RCR;
    #[doc = "`read()` method returns [rcr::R](rcr::R) reader structure"]
    impl crate::Readable for RCR {}
    #[doc = "`write(|w| ..)` method takes [rcr::W](rcr::W) writer structure"]
    impl crate::Writable for RCR {}
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = "Reader of register RCR"]
        pub type R = crate::R<u32, super::RCR>;
        #[doc = "Writer for register RCR"]
        pub type W = crate::W<u32, super::RCR>;
        #[doc = "Register RCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `REP`"]
        pub type REP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `REP`"]
        pub struct REP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline(always)]
            pub fn rep(&mut self) -> REP_W {
                REP_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr1](ccr1) module"]
    pub type CCR1 = crate::Reg<u32, _CCR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR1;
    #[doc = "`read()` method returns [ccr1::R](ccr1::R) reader structure"]
    impl crate::Readable for CCR1 {}
    #[doc = "`write(|w| ..)` method takes [ccr1::W](ccr1::W) writer structure"]
    impl crate::Writable for CCR1 {}
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = "Reader of register CCR1"]
        pub type R = crate::R<u32, super::CCR1>;
        #[doc = "Writer for register CCR1"]
        pub type W = crate::W<u32, super::CCR1>;
        #[doc = "Register CCR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR1`"]
        pub type CCR1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR1`"]
        pub struct CCR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr1(&mut self) -> CCR1_W {
                CCR1_W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bdtr](bdtr) module"]
    pub type BDTR = crate::Reg<u32, _BDTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BDTR;
    #[doc = "`read()` method returns [bdtr::R](bdtr::R) reader structure"]
    impl crate::Readable for BDTR {}
    #[doc = "`write(|w| ..)` method takes [bdtr::W](bdtr::W) writer structure"]
    impl crate::Writable for BDTR {}
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = "Reader of register BDTR"]
        pub type R = crate::R<u32, super::BDTR>;
        #[doc = "Writer for register BDTR"]
        pub type W = crate::W<u32, super::BDTR>;
        #[doc = "Register BDTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BDTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MOE`"]
        pub type MOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MOE`"]
        pub struct MOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `AOE`"]
        pub type AOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `AOE`"]
        pub struct AOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `BKP`"]
        pub type BKP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BKP`"]
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `BKE`"]
        pub type BKE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BKE`"]
        pub struct BKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `OSSR`"]
        pub type OSSR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OSSR`"]
        pub struct OSSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OSSI`"]
        pub type OSSI_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OSSI`"]
        pub struct OSSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSI_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `LOCK`"]
        pub type LOCK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `LOCK`"]
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DTG`"]
        pub type DTG_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DTG`"]
        pub struct DTG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DTG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Main output enable"]
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Main output enable"]
            #[inline(always)]
            pub fn moe(&mut self) -> MOE_W {
                MOE_W { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline(always)]
            pub fn aoe(&mut self) -> AOE_W {
                AOE_W { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline(always)]
            pub fn bke(&mut self) -> BKE_W {
                BKE_W { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline(always)]
            pub fn ossr(&mut self) -> OSSR_W {
                OSSR_W { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline(always)]
            pub fn ossi(&mut self) -> OSSI_W {
                OSSI_W { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline(always)]
            pub fn dtg(&mut self) -> DTG_W {
                DTG_W { w: self }
            }
        }
    }
    #[doc = "DMA control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dcr](dcr) module"]
    pub type DCR = crate::Reg<u32, _DCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DCR;
    #[doc = "`read()` method returns [dcr::R](dcr::R) reader structure"]
    impl crate::Readable for DCR {}
    #[doc = "`write(|w| ..)` method takes [dcr::W](dcr::W) writer structure"]
    impl crate::Writable for DCR {}
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = "Reader of register DCR"]
        pub type R = crate::R<u32, super::DCR>;
        #[doc = "Writer for register DCR"]
        pub type W = crate::W<u32, super::DCR>;
        #[doc = "Register DCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DBL`"]
        pub type DBL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBL`"]
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DBA`"]
        pub type DBA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBA`"]
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmar](dmar) module"]
    pub type DMAR = crate::Reg<u32, _DMAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMAR;
    #[doc = "`read()` method returns [dmar::R](dmar::R) reader structure"]
    impl crate::Readable for DMAR {}
    #[doc = "`write(|w| ..)` method takes [dmar::W](dmar::W) writer structure"]
    impl crate::Writable for DMAR {}
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = "Reader of register DMAR"]
        pub type R = crate::R<u32, super::DMAR>;
        #[doc = "Writer for register DMAR"]
        pub type W = crate::W<u32, super::DMAR>;
        #[doc = "Register DMAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DMAB`"]
        pub type DMAB_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DMAB`"]
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct TIM17 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM17 {}
impl TIM17 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim16::RegisterBlock {
        0x4001_4800 as *const _
    }
}
impl Deref for TIM17 {
    type Target = tim16::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM17::ptr() }
    }
}
#[doc = "HDMI-CEC controller"]
pub struct CEC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CEC {}
impl CEC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cec::RegisterBlock {
        0x4000_7800 as *const _
    }
}
impl Deref for CEC {
    type Target = cec::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*CEC::ptr() }
    }
}
#[doc = "HDMI-CEC controller"]
pub mod cec {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - configuration register"]
        pub cfgr: CFGR,
        #[doc = "0x04 - CEC own address register"]
        pub oar: OAR,
        #[doc = "0x08 - Rx Data Register"]
        pub pres: PRES,
        #[doc = "0x0c - CEC error status register"]
        pub esr: ESR,
        #[doc = "0x10 - CEC control and status register"]
        pub csr: CSR,
        #[doc = "0x14 - CEC Tx data register"]
        pub txd: TXD,
        #[doc = "0x18 - CEC Rx data register"]
        pub rxd: RXD,
    }
    #[doc = "configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr](cfgr) module"]
    pub type CFGR = crate::Reg<u32, _CFGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR;
    #[doc = "`read()` method returns [cfgr::R](cfgr::R) reader structure"]
    impl crate::Readable for CFGR {}
    #[doc = "`write(|w| ..)` method takes [cfgr::W](cfgr::W) writer structure"]
    impl crate::Writable for CFGR {}
    #[doc = "configuration register"]
    pub mod cfgr {
        #[doc = "Reader of register CFGR"]
        pub type R = crate::R<u32, super::CFGR>;
        #[doc = "Writer for register CFGR"]
        pub type W = crate::W<u32, super::CFGR>;
        #[doc = "Register CFGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PE`"]
        pub struct PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `IE`"]
        pub type IE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `IE`"]
        pub struct IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `BTEM`"]
        pub type BTEM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BTEM`"]
        pub struct BTEM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BTEM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `BPEM`"]
        pub type BPEM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `BPEM`"]
        pub struct BPEM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BPEM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Bit timing error mode"]
            #[inline(always)]
            pub fn btem(&self) -> BTEM_R {
                BTEM_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Bit period error mode"]
            #[inline(always)]
            pub fn bpem(&self) -> BPEM_R {
                BPEM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W {
                PE_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W {
                IE_W { w: self }
            }
            #[doc = "Bit 2 - Bit timing error mode"]
            #[inline(always)]
            pub fn btem(&mut self) -> BTEM_W {
                BTEM_W { w: self }
            }
            #[doc = "Bit 3 - Bit period error mode"]
            #[inline(always)]
            pub fn bpem(&mut self) -> BPEM_W {
                BPEM_W { w: self }
            }
        }
    }
    #[doc = "CEC own address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [oar](oar) module"]
    pub type OAR = crate::Reg<u32, _OAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OAR;
    #[doc = "`read()` method returns [oar::R](oar::R) reader structure"]
    impl crate::Readable for OAR {}
    #[doc = "`write(|w| ..)` method takes [oar::W](oar::W) writer structure"]
    impl crate::Writable for OAR {}
    #[doc = "CEC own address register"]
    pub mod oar {
        #[doc = "Reader of register OAR"]
        pub type R = crate::R<u32, super::OAR>;
        #[doc = "Writer for register OAR"]
        pub type W = crate::W<u32, super::OAR>;
        #[doc = "Register OAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OA`"]
        pub type OA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OA`"]
        pub struct OA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Own address"]
            #[inline(always)]
            pub fn oa(&self) -> OA_R {
                OA_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Own address"]
            #[inline(always)]
            pub fn oa(&mut self) -> OA_W {
                OA_W { w: self }
            }
        }
    }
    #[doc = "Rx Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pres](pres) module"]
    pub type PRES = crate::Reg<u32, _PRES>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRES;
    #[doc = "`read()` method returns [pres::R](pres::R) reader structure"]
    impl crate::Readable for PRES {}
    #[doc = "`write(|w| ..)` method takes [pres::W](pres::W) writer structure"]
    impl crate::Writable for PRES {}
    #[doc = "Rx Data Register"]
    pub mod pres {
        #[doc = "Reader of register PRES"]
        pub type R = crate::R<u32, super::PRES>;
        #[doc = "Writer for register PRES"]
        pub type W = crate::W<u32, super::PRES>;
        #[doc = "Register PRES `reset()`'s with value 0"]
        impl crate::ResetValue for super::PRES {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PRESC`"]
        pub type PRESC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PRESC`"]
        pub struct PRESC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRESC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3fff) | ((value as u32) & 0x3fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:13 - CEC Rx Data Register"]
            #[inline(always)]
            pub fn presc(&self) -> PRESC_R {
                PRESC_R::new((self.bits & 0x3fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:13 - CEC Rx Data Register"]
            #[inline(always)]
            pub fn presc(&mut self) -> PRESC_W {
                PRESC_W { w: self }
            }
        }
    }
    #[doc = "CEC error status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [esr](esr) module"]
    pub type ESR = crate::Reg<u32, _ESR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ESR;
    #[doc = "`read()` method returns [esr::R](esr::R) reader structure"]
    impl crate::Readable for ESR {}
    #[doc = "CEC error status register"]
    pub mod esr {
        #[doc = "Reader of register ESR"]
        pub type R = crate::R<u32, super::ESR>;
        #[doc = "Reader of field `BTE`"]
        pub type BTE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `BPE`"]
        pub type BPE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RBTFE`"]
        pub type RBTFE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `SBE`"]
        pub type SBE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ACKE`"]
        pub type ACKE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `LINE`"]
        pub type LINE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TBTFE`"]
        pub type TBTFE_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - Bit timing error"]
            #[inline(always)]
            pub fn bte(&self) -> BTE_R {
                BTE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Bit period error"]
            #[inline(always)]
            pub fn bpe(&self) -> BPE_R {
                BPE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Rx block transfer finished error"]
            #[inline(always)]
            pub fn rbtfe(&self) -> RBTFE_R {
                RBTFE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Start bit error"]
            #[inline(always)]
            pub fn sbe(&self) -> SBE_R {
                SBE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Block acknowledge error"]
            #[inline(always)]
            pub fn acke(&self) -> ACKE_R {
                ACKE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Line error"]
            #[inline(always)]
            pub fn line(&self) -> LINE_R {
                LINE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Tx block transfer finished error"]
            #[inline(always)]
            pub fn tbtfe(&self) -> TBTFE_R {
                TBTFE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
        }
    }
    #[doc = "CEC control and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
    pub type CSR = crate::Reg<u32, _CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSR;
    #[doc = "`read()` method returns [csr::R](csr::R) reader structure"]
    impl crate::Readable for CSR {}
    #[doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
    impl crate::Writable for CSR {}
    #[doc = "CEC control and status register"]
    pub mod csr {
        #[doc = "Reader of register CSR"]
        pub type R = crate::R<u32, super::CSR>;
        #[doc = "Writer for register CSR"]
        pub type W = crate::W<u32, super::CSR>;
        #[doc = "Register CSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TSOM`"]
        pub type TSOM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TSOM`"]
        pub struct TSOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSOM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `TEOM`"]
        pub type TEOM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TEOM`"]
        pub struct TEOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEOM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `TERR`"]
        pub type TERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TERR`"]
        pub struct TERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `TBTRF`"]
        pub type TBTRF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TBTRF`"]
        pub struct TBTRF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TBTRF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `RSOM`"]
        pub type RSOM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RSOM`"]
        pub struct RSOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSOM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `REOM`"]
        pub type REOM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `REOM`"]
        pub struct REOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REOM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `RERR`"]
        pub type RERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RERR`"]
        pub struct RERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `RBTF`"]
        pub type RBTF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RBTF`"]
        pub struct RBTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RBTF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Tx start of message"]
            #[inline(always)]
            pub fn tsom(&self) -> TSOM_R {
                TSOM_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Tx end of message"]
            #[inline(always)]
            pub fn teom(&self) -> TEOM_R {
                TEOM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Tx error"]
            #[inline(always)]
            pub fn terr(&self) -> TERR_R {
                TERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Tx byte transfer request or block transfer finished"]
            #[inline(always)]
            pub fn tbtrf(&self) -> TBTRF_R {
                TBTRF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Rx start of message"]
            #[inline(always)]
            pub fn rsom(&self) -> RSOM_R {
                RSOM_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Rx end of message"]
            #[inline(always)]
            pub fn reom(&self) -> REOM_R {
                REOM_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Rx error"]
            #[inline(always)]
            pub fn rerr(&self) -> RERR_R {
                RERR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Rx byte/block transfer finished"]
            #[inline(always)]
            pub fn rbtf(&self) -> RBTF_R {
                RBTF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Tx start of message"]
            #[inline(always)]
            pub fn tsom(&mut self) -> TSOM_W {
                TSOM_W { w: self }
            }
            #[doc = "Bit 1 - Tx end of message"]
            #[inline(always)]
            pub fn teom(&mut self) -> TEOM_W {
                TEOM_W { w: self }
            }
            #[doc = "Bit 2 - Tx error"]
            #[inline(always)]
            pub fn terr(&mut self) -> TERR_W {
                TERR_W { w: self }
            }
            #[doc = "Bit 3 - Tx byte transfer request or block transfer finished"]
            #[inline(always)]
            pub fn tbtrf(&mut self) -> TBTRF_W {
                TBTRF_W { w: self }
            }
            #[doc = "Bit 4 - Rx start of message"]
            #[inline(always)]
            pub fn rsom(&mut self) -> RSOM_W {
                RSOM_W { w: self }
            }
            #[doc = "Bit 5 - Rx end of message"]
            #[inline(always)]
            pub fn reom(&mut self) -> REOM_W {
                REOM_W { w: self }
            }
            #[doc = "Bit 6 - Rx error"]
            #[inline(always)]
            pub fn rerr(&mut self) -> RERR_W {
                RERR_W { w: self }
            }
            #[doc = "Bit 7 - Rx byte/block transfer finished"]
            #[inline(always)]
            pub fn rbtf(&mut self) -> RBTF_W {
                RBTF_W { w: self }
            }
        }
    }
    #[doc = "CEC Tx data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txd](txd) module"]
    pub type TXD = crate::Reg<u32, _TXD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXD;
    #[doc = "`read()` method returns [txd::R](txd::R) reader structure"]
    impl crate::Readable for TXD {}
    #[doc = "`write(|w| ..)` method takes [txd::W](txd::W) writer structure"]
    impl crate::Writable for TXD {}
    #[doc = "CEC Tx data register"]
    pub mod txd {
        #[doc = "Reader of register TXD"]
        pub type R = crate::R<u32, super::TXD>;
        #[doc = "Writer for register TXD"]
        pub type W = crate::W<u32, super::TXD>;
        #[doc = "Register TXD `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXD {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TXD`"]
        pub type TXD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TXD`"]
        pub struct TXD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Tx Data register"]
            #[inline(always)]
            pub fn txd(&self) -> TXD_R {
                TXD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Tx Data register"]
            #[inline(always)]
            pub fn txd(&mut self) -> TXD_W {
                TXD_W { w: self }
            }
        }
    }
    #[doc = "CEC Rx data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxd](rxd) module"]
    pub type RXD = crate::Reg<u32, _RXD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXD;
    #[doc = "`read()` method returns [rxd::R](rxd::R) reader structure"]
    impl crate::Readable for RXD {}
    #[doc = "CEC Rx data register"]
    pub mod rxd {
        #[doc = "Reader of register RXD"]
        pub type R = crate::R<u32, super::RXD>;
        #[doc = "Reader of field `RXD`"]
        pub type RXD_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 0:7 - Rx data"]
            #[inline(always)]
            pub fn rxd(&self) -> RXD_R {
                RXD_R::new((self.bits & 0xff) as u8)
            }
        }
    }
}
#[doc = "System control block ACTLR"]
pub struct SCB_ACTRL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SCB_ACTRL {}
impl SCB_ACTRL {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb_actrl::RegisterBlock {
        0xe000_e008 as *const _
    }
}
impl Deref for SCB_ACTRL {
    type Target = scb_actrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SCB_ACTRL::ptr() }
    }
}
#[doc = "System control block ACTLR"]
pub mod scb_actrl {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Auxiliary control register"]
        pub actrl: ACTRL,
    }
    #[doc = "Auxiliary control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [actrl](actrl) module"]
    pub type ACTRL = crate::Reg<u32, _ACTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ACTRL;
    #[doc = "`read()` method returns [actrl::R](actrl::R) reader structure"]
    impl crate::Readable for ACTRL {}
    #[doc = "`write(|w| ..)` method takes [actrl::W](actrl::W) writer structure"]
    impl crate::Writable for ACTRL {}
    #[doc = "Auxiliary control register"]
    pub mod actrl {
        #[doc = "Reader of register ACTRL"]
        pub type R = crate::R<u32, super::ACTRL>;
        #[doc = "Writer for register ACTRL"]
        pub type W = crate::W<u32, super::ACTRL>;
        #[doc = "Register ACTRL `reset()`'s with value 0"]
        impl crate::ResetValue for super::ACTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DISFOLD`"]
        pub type DISFOLD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DISFOLD`"]
        pub struct DISFOLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISFOLD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `FPEXCODIS`"]
        pub type FPEXCODIS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `FPEXCODIS`"]
        pub struct FPEXCODIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FPEXCODIS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `DISRAMODE`"]
        pub type DISRAMODE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DISRAMODE`"]
        pub struct DISRAMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISRAMODE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `DISITMATBFLUSH`"]
        pub type DISITMATBFLUSH_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DISITMATBFLUSH`"]
        pub struct DISITMATBFLUSH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISITMATBFLUSH_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 2 - DISFOLD"]
            #[inline(always)]
            pub fn disfold(&self) -> DISFOLD_R {
                DISFOLD_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 10 - FPEXCODIS"]
            #[inline(always)]
            pub fn fpexcodis(&self) -> FPEXCODIS_R {
                FPEXCODIS_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - DISRAMODE"]
            #[inline(always)]
            pub fn disramode(&self) -> DISRAMODE_R {
                DISRAMODE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - DISITMATBFLUSH"]
            #[inline(always)]
            pub fn disitmatbflush(&self) -> DISITMATBFLUSH_R {
                DISITMATBFLUSH_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - DISFOLD"]
            #[inline(always)]
            pub fn disfold(&mut self) -> DISFOLD_W {
                DISFOLD_W { w: self }
            }
            #[doc = "Bit 10 - FPEXCODIS"]
            #[inline(always)]
            pub fn fpexcodis(&mut self) -> FPEXCODIS_W {
                FPEXCODIS_W { w: self }
            }
            #[doc = "Bit 11 - DISRAMODE"]
            #[inline(always)]
            pub fn disramode(&mut self) -> DISRAMODE_W {
                DISRAMODE_W { w: self }
            }
            #[doc = "Bit 12 - DISITMATBFLUSH"]
            #[inline(always)]
            pub fn disitmatbflush(&mut self) -> DISITMATBFLUSH_W {
                DISITMATBFLUSH_W { w: self }
            }
        }
    }
}
#[doc = "Nested vectored interrupt controller"]
pub struct NVIC_STIR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for NVIC_STIR {}
impl NVIC_STIR {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const nvic_stir::RegisterBlock {
        0xe000_ef00 as *const _
    }
}
impl Deref for NVIC_STIR {
    type Target = nvic_stir::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*NVIC_STIR::ptr() }
    }
}
#[doc = "Nested vectored interrupt controller"]
pub mod nvic_stir {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Software trigger interrupt register"]
        pub stir: STIR,
    }
    #[doc = "Software trigger interrupt register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [stir](stir) module"]
    pub type STIR = crate::Reg<u32, _STIR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STIR;
    #[doc = "`read()` method returns [stir::R](stir::R) reader structure"]
    impl crate::Readable for STIR {}
    #[doc = "`write(|w| ..)` method takes [stir::W](stir::W) writer structure"]
    impl crate::Writable for STIR {}
    #[doc = "Software trigger interrupt register"]
    pub mod stir {
        #[doc = "Reader of register STIR"]
        pub type R = crate::R<u32, super::STIR>;
        #[doc = "Writer for register STIR"]
        pub type W = crate::W<u32, super::STIR>;
        #[doc = "Register STIR `reset()`'s with value 0"]
        impl crate::ResetValue for super::STIR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `INTID`"]
        pub type INTID_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `INTID`"]
        pub struct INTID_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INTID_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | ((value as u32) & 0x01ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:8 - Software generated interrupt ID"]
            #[inline(always)]
            pub fn intid(&self) -> INTID_R {
                INTID_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:8 - Software generated interrupt ID"]
            #[inline(always)]
            pub fn intid(&mut self) -> INTID_W {
                INTID_W { w: self }
            }
        }
    }
}
#[doc = "SysTick timer"]
pub struct STK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for STK {}
impl STK {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const stk::RegisterBlock {
        0xe000_e010 as *const _
    }
}
impl Deref for STK {
    type Target = stk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*STK::ptr() }
    }
}
#[doc = "SysTick timer"]
pub mod stk {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SysTick control and status register"]
        pub ctrl: CTRL,
        #[doc = "0x04 - SysTick reload value register"]
        pub load_: LOAD_,
        #[doc = "0x08 - SysTick current value register"]
        pub val: VAL,
        #[doc = "0x0c - SysTick calibration value register"]
        pub calib: CALIB,
    }
    #[doc = "SysTick control and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](ctrl) module"]
    pub type CTRL = crate::Reg<u32, _CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTRL;
    #[doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure"]
    impl crate::Readable for CTRL {}
    #[doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure"]
    impl crate::Writable for CTRL {}
    #[doc = "SysTick control and status register"]
    pub mod ctrl {
        #[doc = "Reader of register CTRL"]
        pub type R = crate::R<u32, super::CTRL>;
        #[doc = "Writer for register CTRL"]
        pub type W = crate::W<u32, super::CTRL>;
        #[doc = "Register CTRL `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ENABLE`"]
        pub type ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ENABLE`"]
        pub struct ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `TICKINT`"]
        pub type TICKINT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TICKINT`"]
        pub struct TICKINT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TICKINT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CLKSOURCE`"]
        pub type CLKSOURCE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CLKSOURCE`"]
        pub struct CLKSOURCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKSOURCE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `COUNTFLAG`"]
        pub type COUNTFLAG_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `COUNTFLAG`"]
        pub struct COUNTFLAG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNTFLAG_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - SysTick exception request enable"]
            #[inline(always)]
            pub fn tickint(&self) -> TICKINT_R {
                TICKINT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Clock source selection"]
            #[inline(always)]
            pub fn clksource(&self) -> CLKSOURCE_R {
                CLKSOURCE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 16 - COUNTFLAG"]
            #[inline(always)]
            pub fn countflag(&self) -> COUNTFLAG_R {
                COUNTFLAG_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W {
                ENABLE_W { w: self }
            }
            #[doc = "Bit 1 - SysTick exception request enable"]
            #[inline(always)]
            pub fn tickint(&mut self) -> TICKINT_W {
                TICKINT_W { w: self }
            }
            #[doc = "Bit 2 - Clock source selection"]
            #[inline(always)]
            pub fn clksource(&mut self) -> CLKSOURCE_W {
                CLKSOURCE_W { w: self }
            }
            #[doc = "Bit 16 - COUNTFLAG"]
            #[inline(always)]
            pub fn countflag(&mut self) -> COUNTFLAG_W {
                COUNTFLAG_W { w: self }
            }
        }
    }
    #[doc = "SysTick reload value register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [load_](load_) module"]
    pub type LOAD_ = crate::Reg<u32, _LOAD_>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LOAD_;
    #[doc = "`read()` method returns [load_::R](load_::R) reader structure"]
    impl crate::Readable for LOAD_ {}
    #[doc = "`write(|w| ..)` method takes [load_::W](load_::W) writer structure"]
    impl crate::Writable for LOAD_ {}
    #[doc = "SysTick reload value register"]
    pub mod load_ {
        #[doc = "Reader of register LOAD_"]
        pub type R = crate::R<u32, super::LOAD_>;
        #[doc = "Writer for register LOAD_"]
        pub type W = crate::W<u32, super::LOAD_>;
        #[doc = "Register LOAD_ `reset()`'s with value 0"]
        impl crate::ResetValue for super::LOAD_ {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `RELOAD`"]
        pub type RELOAD_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `RELOAD`"]
        pub struct RELOAD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RELOAD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | ((value as u32) & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:23 - RELOAD value"]
            #[inline(always)]
            pub fn reload(&self) -> RELOAD_R {
                RELOAD_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - RELOAD value"]
            #[inline(always)]
            pub fn reload(&mut self) -> RELOAD_W {
                RELOAD_W { w: self }
            }
        }
    }
    #[doc = "SysTick current value register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [val](val) module"]
    pub type VAL = crate::Reg<u32, _VAL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _VAL;
    #[doc = "`read()` method returns [val::R](val::R) reader structure"]
    impl crate::Readable for VAL {}
    #[doc = "`write(|w| ..)` method takes [val::W](val::W) writer structure"]
    impl crate::Writable for VAL {}
    #[doc = "SysTick current value register"]
    pub mod val {
        #[doc = "Reader of register VAL"]
        pub type R = crate::R<u32, super::VAL>;
        #[doc = "Writer for register VAL"]
        pub type W = crate::W<u32, super::VAL>;
        #[doc = "Register VAL `reset()`'s with value 0"]
        impl crate::ResetValue for super::VAL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CURRENT`"]
        pub type CURRENT_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `CURRENT`"]
        pub struct CURRENT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CURRENT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | ((value as u32) & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:23 - Current counter value"]
            #[inline(always)]
            pub fn current(&self) -> CURRENT_R {
                CURRENT_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - Current counter value"]
            #[inline(always)]
            pub fn current(&mut self) -> CURRENT_W {
                CURRENT_W { w: self }
            }
        }
    }
    #[doc = "SysTick calibration value register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calib](calib) module"]
    pub type CALIB = crate::Reg<u32, _CALIB>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CALIB;
    #[doc = "`read()` method returns [calib::R](calib::R) reader structure"]
    impl crate::Readable for CALIB {}
    #[doc = "`write(|w| ..)` method takes [calib::W](calib::W) writer structure"]
    impl crate::Writable for CALIB {}
    #[doc = "SysTick calibration value register"]
    pub mod calib {
        #[doc = "Reader of register CALIB"]
        pub type R = crate::R<u32, super::CALIB>;
        #[doc = "Writer for register CALIB"]
        pub type W = crate::W<u32, super::CALIB>;
        #[doc = "Register CALIB `reset()`'s with value 0"]
        impl crate::ResetValue for super::CALIB {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TENMS`"]
        pub type TENMS_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `TENMS`"]
        pub struct TENMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TENMS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | ((value as u32) & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:23 - Calibration value"]
            #[inline(always)]
            pub fn tenms(&self) -> TENMS_R {
                TENMS_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:23 - Calibration value"]
            #[inline(always)]
            pub fn tenms(&mut self) -> TENMS_W {
                TENMS_W { w: self }
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "FSMC"]
    pub FSMC: FSMC,
    #[doc = "PWR"]
    pub PWR: PWR,
    #[doc = "RCC"]
    pub RCC: RCC,
    #[doc = "GPIOA"]
    pub GPIOA: GPIOA,
    #[doc = "GPIOB"]
    pub GPIOB: GPIOB,
    #[doc = "GPIOC"]
    pub GPIOC: GPIOC,
    #[doc = "GPIOD"]
    pub GPIOD: GPIOD,
    #[doc = "GPIOE"]
    pub GPIOE: GPIOE,
    #[doc = "GPIOF"]
    pub GPIOF: GPIOF,
    #[doc = "GPIOG"]
    pub GPIOG: GPIOG,
    #[doc = "AFIO"]
    pub AFIO: AFIO,
    #[doc = "EXTI"]
    pub EXTI: EXTI,
    #[doc = "DMA1"]
    pub DMA1: DMA1,
    #[doc = "DMA2"]
    pub DMA2: DMA2,
    #[doc = "RTC"]
    pub RTC: RTC,
    #[doc = "BKP"]
    pub BKP: BKP,
    #[doc = "IWDG"]
    pub IWDG: IWDG,
    #[doc = "WWDG"]
    pub WWDG: WWDG,
    #[doc = "TIM1"]
    pub TIM1: TIM1,
    #[doc = "TIM2"]
    pub TIM2: TIM2,
    #[doc = "TIM3"]
    pub TIM3: TIM3,
    #[doc = "TIM4"]
    pub TIM4: TIM4,
    #[doc = "TIM5"]
    pub TIM5: TIM5,
    #[doc = "TIM12"]
    pub TIM12: TIM12,
    #[doc = "TIM13"]
    pub TIM13: TIM13,
    #[doc = "TIM14"]
    pub TIM14: TIM14,
    #[doc = "TIM6"]
    pub TIM6: TIM6,
    #[doc = "TIM7"]
    pub TIM7: TIM7,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "SPI3"]
    pub SPI3: SPI3,
    #[doc = "USART1"]
    pub USART1: USART1,
    #[doc = "USART2"]
    pub USART2: USART2,
    #[doc = "USART3"]
    pub USART3: USART3,
    #[doc = "ADC1"]
    pub ADC1: ADC1,
    #[doc = "DAC"]
    pub DAC: DAC,
    #[doc = "DBGMCU"]
    pub DBGMCU: DBGMCU,
    #[doc = "UART4"]
    pub UART4: UART4,
    #[doc = "UART5"]
    pub UART5: UART5,
    #[doc = "CRC"]
    pub CRC: CRC,
    #[doc = "FLASH"]
    pub FLASH: FLASH,
    #[doc = "TIM15"]
    pub TIM15: TIM15,
    #[doc = "TIM16"]
    pub TIM16: TIM16,
    #[doc = "TIM17"]
    pub TIM17: TIM17,
    #[doc = "CEC"]
    pub CEC: CEC,
    #[doc = "SCB_ACTRL"]
    pub SCB_ACTRL: SCB_ACTRL,
    #[doc = "NVIC_STIR"]
    pub NVIC_STIR: NVIC_STIR,
    #[doc = "STK"]
    pub STK: STK,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            FSMC: FSMC {
                _marker: PhantomData,
            },
            PWR: PWR {
                _marker: PhantomData,
            },
            RCC: RCC {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            GPIOE: GPIOE {
                _marker: PhantomData,
            },
            GPIOF: GPIOF {
                _marker: PhantomData,
            },
            GPIOG: GPIOG {
                _marker: PhantomData,
            },
            AFIO: AFIO {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            DMA1: DMA1 {
                _marker: PhantomData,
            },
            DMA2: DMA2 {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            BKP: BKP {
                _marker: PhantomData,
            },
            IWDG: IWDG {
                _marker: PhantomData,
            },
            WWDG: WWDG {
                _marker: PhantomData,
            },
            TIM1: TIM1 {
                _marker: PhantomData,
            },
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            TIM3: TIM3 {
                _marker: PhantomData,
            },
            TIM4: TIM4 {
                _marker: PhantomData,
            },
            TIM5: TIM5 {
                _marker: PhantomData,
            },
            TIM12: TIM12 {
                _marker: PhantomData,
            },
            TIM13: TIM13 {
                _marker: PhantomData,
            },
            TIM14: TIM14 {
                _marker: PhantomData,
            },
            TIM6: TIM6 {
                _marker: PhantomData,
            },
            TIM7: TIM7 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            USART2: USART2 {
                _marker: PhantomData,
            },
            USART3: USART3 {
                _marker: PhantomData,
            },
            ADC1: ADC1 {
                _marker: PhantomData,
            },
            DAC: DAC {
                _marker: PhantomData,
            },
            DBGMCU: DBGMCU {
                _marker: PhantomData,
            },
            UART4: UART4 {
                _marker: PhantomData,
            },
            UART5: UART5 {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            TIM15: TIM15 {
                _marker: PhantomData,
            },
            TIM16: TIM16 {
                _marker: PhantomData,
            },
            TIM17: TIM17 {
                _marker: PhantomData,
            },
            CEC: CEC {
                _marker: PhantomData,
            },
            SCB_ACTRL: SCB_ACTRL {
                _marker: PhantomData,
            },
            NVIC_STIR: NVIC_STIR {
                _marker: PhantomData,
            },
            STK: STK {
                _marker: PhantomData,
            },
        }
    }
}
