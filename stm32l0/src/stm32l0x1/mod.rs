#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
extern "C" {
    fn WWDG();
    fn PVD();
    fn RTC();
    fn FLASH();
    fn RCC();
    fn EXTI0_1();
    fn EXTI2_3();
    fn EXTI4_15();
    fn DMA1_CHANNEL1();
    fn DMA1_CHANNEL2_3();
    fn DMA1_CHANNEL4_7();
    fn ADC_COMP();
    fn LPTIM1();
    fn USART4_USART5();
    fn TIM2();
    fn TIM3();
    fn TIM6();
    fn TIM7();
    fn TIM21();
    fn I2C3();
    fn TIM22();
    fn I2C1();
    fn I2C2();
    fn SPI1();
    fn SPI2();
    fn USART1();
    fn USART2();
    fn AES_RNG_LPUART1();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 30] = [
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector { _handler: RTC },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI0_1 },
    Vector { _handler: EXTI2_3 },
    Vector { _handler: EXTI4_15 },
    Vector { _reserved: 0 },
    Vector {
        _handler: DMA1_CHANNEL1,
    },
    Vector {
        _handler: DMA1_CHANNEL2_3,
    },
    Vector {
        _handler: DMA1_CHANNEL4_7,
    },
    Vector { _handler: ADC_COMP },
    Vector { _handler: LPTIM1 },
    Vector {
        _handler: USART4_USART5,
    },
    Vector { _handler: TIM2 },
    Vector { _handler: TIM3 },
    Vector { _handler: TIM6 },
    Vector { _handler: TIM7 },
    Vector { _reserved: 0 },
    Vector { _handler: TIM21 },
    Vector { _handler: I2C3 },
    Vector { _handler: TIM22 },
    Vector { _handler: I2C1 },
    Vector { _handler: I2C2 },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: USART1 },
    Vector { _handler: USART2 },
    Vector {
        _handler: AES_RNG_LPUART1,
    },
];
#[doc = r"Enumeration of all the interrupts"]
#[derive(Copy, Clone, Debug)]
#[repr(u8)]
pub enum Interrupt {
    #[doc = "0 - Window Watchdog interrupt"]
    WWDG = 0,
    #[doc = "1 - PVD through EXTI line detection"]
    PVD = 1,
    #[doc = "2 - RTC global interrupt"]
    RTC = 2,
    #[doc = "3 - Flash global interrupt"]
    FLASH = 3,
    #[doc = "4 - RCC global interrupt"]
    RCC = 4,
    #[doc = "5 - EXTI Line\\[1:0\\]
interrupts"]
    EXTI0_1 = 5,
    #[doc = "6 - EXTI Line\\[3:2\\]
interrupts"]
    EXTI2_3 = 6,
    #[doc = "7 - EXTI Line15 and EXTI4 interrupts"]
    EXTI4_15 = 7,
    #[doc = "9 - DMA1 Channel1 global interrupt"]
    DMA1_CHANNEL1 = 9,
    #[doc = "10 - DMA1 Channel2 and 3 interrupts"]
    DMA1_CHANNEL2_3 = 10,
    #[doc = "11 - DMA1 Channel4 to 7 interrupts"]
    DMA1_CHANNEL4_7 = 11,
    #[doc = "12 - ADC and comparator 1 and 2"]
    ADC_COMP = 12,
    #[doc = "13 - LPTIMER1 interrupt through EXTI29"]
    LPTIM1 = 13,
    #[doc = "14 - USART4/USART5 global interrupt"]
    USART4_USART5 = 14,
    #[doc = "15 - TIM2 global interrupt"]
    TIM2 = 15,
    #[doc = "16 - TIM3 global interrupt"]
    TIM3 = 16,
    #[doc = "17 - TIM6 global interrupt and DAC"]
    TIM6 = 17,
    #[doc = "18 - TIM7 global interrupt and DAC"]
    TIM7 = 18,
    #[doc = "20 - TIMER21 global interrupt"]
    TIM21 = 20,
    #[doc = "21 - I2C3 global interrupt"]
    I2C3 = 21,
    #[doc = "22 - TIMER22 global interrupt"]
    TIM22 = 22,
    #[doc = "23 - I2C1 global interrupt"]
    I2C1 = 23,
    #[doc = "24 - I2C2 global interrupt"]
    I2C2 = 24,
    #[doc = "25 - SPI1_global_interrupt"]
    SPI1 = 25,
    #[doc = "26 - SPI2 global interrupt"]
    SPI2 = 26,
    #[doc = "27 - USART1 global interrupt"]
    USART1 = 27,
    #[doc = "28 - USART2 global interrupt"]
    USART2 = 28,
    #[doc = "29 - AES global interrupt RNG global interrupt and LPUART1 global interrupt through"]
    AES_RNG_LPUART1 = 29,
}
unsafe impl bare_metal::Nr for Interrupt {
    #[inline(always)]
    fn nr(&self) -> u8 {
        *self as u8
    }
}
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[doc = "Advanced encryption standard hardware accelerator"]
pub struct AES {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AES {}
impl AES {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aes::RegisterBlock {
        0x4002_6000 as *const _
    }
}
impl Deref for AES {
    type Target = aes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*AES::ptr() }
    }
}
#[doc = "Advanced encryption standard hardware accelerator"]
pub mod aes {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register"]
        pub cr: CR,
        #[doc = "0x04 - status register"]
        pub sr: SR,
        #[doc = "0x08 - data input register"]
        pub dinr: DINR,
        #[doc = "0x0c - data output register"]
        pub doutr: DOUTR,
        #[doc = "0x10 - key register 0"]
        pub keyr0: KEYR0,
        #[doc = "0x14 - key register 1"]
        pub keyr1: KEYR1,
        #[doc = "0x18 - key register 2"]
        pub keyr2: KEYR2,
        #[doc = "0x1c - key register 3"]
        pub keyr3: KEYR3,
        #[doc = "0x20 - initialization vector register 0"]
        pub ivr0: IVR0,
        #[doc = "0x24 - initialization vector register 1"]
        pub ivr1: IVR1,
        #[doc = "0x28 - initialization vector register 2"]
        pub ivr2: IVR2,
        #[doc = "0x2c - initialization vector register 3"]
        pub ivr3: IVR3,
    }
    #[doc = "control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Enable DMA management of data output phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAOUTEN_A {
            #[doc = "0: Disable DMA Output"]
            DISABLED = 0,
            #[doc = "1: Enabled DMA Output"]
            ENABLED = 1,
        }
        impl From<DMAOUTEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAOUTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAOUTEN`"]
        pub type DMAOUTEN_R = crate::R<bool, DMAOUTEN_A>;
        impl DMAOUTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAOUTEN_A {
                match self.bits {
                    false => DMAOUTEN_A::DISABLED,
                    true => DMAOUTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAOUTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAOUTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAOUTEN`"]
        pub struct DMAOUTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAOUTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAOUTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable DMA Output"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAOUTEN_A::DISABLED)
            }
            #[doc = "Enabled DMA Output"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAOUTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Enable DMA management of data input phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAINEN_A {
            #[doc = "0: Disable DMA Input"]
            DISABLED = 0,
            #[doc = "1: Enable DMA Input"]
            ENABLED = 1,
        }
        impl From<DMAINEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAINEN`"]
        pub type DMAINEN_R = crate::R<bool, DMAINEN_A>;
        impl DMAINEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAINEN_A {
                match self.bits {
                    false => DMAINEN_A::DISABLED,
                    true => DMAINEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAINEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAINEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAINEN`"]
        pub struct DMAINEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAINEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAINEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable DMA Input"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAINEN_A::DISABLED)
            }
            #[doc = "Enable DMA Input"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAINEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRIE_A {
            #[doc = "0: Disable (mask) error interrupt"]
            DISABLED = 0,
            #[doc = "1: Enable error interrupt"]
            ENABLED = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERRIE`"]
        pub type ERRIE_R = crate::R<bool, ERRIE_A>;
        impl ERRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::DISABLED,
                    true => ERRIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ERRIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ERRIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ERRIE`"]
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable (mask) error interrupt"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ERRIE_A::DISABLED)
            }
            #[doc = "Enable error interrupt"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ERRIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "CCF flag interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCFIE_A {
            #[doc = "0: Disable (mask) CCF interrupt"]
            DISABLED = 0,
            #[doc = "1: Enable CCF interrupt"]
            ENABLED = 1,
        }
        impl From<CCFIE_A> for bool {
            #[inline(always)]
            fn from(variant: CCFIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCFIE`"]
        pub type CCFIE_R = crate::R<bool, CCFIE_A>;
        impl CCFIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCFIE_A {
                match self.bits {
                    false => CCFIE_A::DISABLED,
                    true => CCFIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CCFIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CCFIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CCFIE`"]
        pub struct CCFIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCFIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCFIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable (mask) CCF interrupt"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CCFIE_A::DISABLED)
            }
            #[doc = "Enable CCF interrupt"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CCFIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Error clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRC_A {
            #[doc = "1: Clear RDERR and WRERR flags"]
            CLEAR = 1,
        }
        impl From<ERRC_A> for bool {
            #[inline(always)]
            fn from(variant: ERRC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERRC`"]
        pub type ERRC_R = crate::R<bool, ERRC_A>;
        impl ERRC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, ERRC_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(ERRC_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == ERRC_A::CLEAR
            }
        }
        #[doc = "Write proxy for field `ERRC`"]
        pub struct ERRC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERRC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear RDERR and WRERR flags"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ERRC_A::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Computation Complete Flag Clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCFC_A {
            #[doc = "1: Clear computation complete flag"]
            CLEAR = 1,
        }
        impl From<CCFC_A> for bool {
            #[inline(always)]
            fn from(variant: CCFC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCFC`"]
        pub type CCFC_R = crate::R<bool, CCFC_A>;
        impl CCFC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CCFC_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CCFC_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CCFC_A::CLEAR
            }
        }
        #[doc = "Write proxy for field `CCFC`"]
        pub struct CCFC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCFC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCFC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear computation complete flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CCFC_A::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "AES chaining mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CHMOD_A {
            #[doc = "0: Electronic codebook (ECB)"]
            ECB = 0,
            #[doc = "1: Cipher-Block Chaining (CBC)"]
            CBC = 1,
            #[doc = "2: Counter Mode (CTR)"]
            CTR = 2,
        }
        impl From<CHMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: CHMOD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CHMOD`"]
        pub type CHMOD_R = crate::R<u8, CHMOD_A>;
        impl CHMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CHMOD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CHMOD_A::ECB),
                    1 => Val(CHMOD_A::CBC),
                    2 => Val(CHMOD_A::CTR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ECB`"]
            #[inline(always)]
            pub fn is_ecb(&self) -> bool {
                *self == CHMOD_A::ECB
            }
            #[doc = "Checks if the value of the field is `CBC`"]
            #[inline(always)]
            pub fn is_cbc(&self) -> bool {
                *self == CHMOD_A::CBC
            }
            #[doc = "Checks if the value of the field is `CTR`"]
            #[inline(always)]
            pub fn is_ctr(&self) -> bool {
                *self == CHMOD_A::CTR
            }
        }
        #[doc = "Write proxy for field `CHMOD`"]
        pub struct CHMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHMOD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Electronic codebook (ECB)"]
            #[inline(always)]
            pub fn ecb(self) -> &'a mut W {
                self.variant(CHMOD_A::ECB)
            }
            #[doc = "Cipher-Block Chaining (CBC)"]
            #[inline(always)]
            pub fn cbc(self) -> &'a mut W {
                self.variant(CHMOD_A::CBC)
            }
            #[doc = "Counter Mode (CTR)"]
            #[inline(always)]
            pub fn ctr(self) -> &'a mut W {
                self.variant(CHMOD_A::CTR)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "AES operating mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE_A {
            #[doc = "0: Mode 1: encryption"]
            MODE1 = 0,
            #[doc = "1: Mode 2: key derivation (or key preparation for ECB/CBC decryption)"]
            MODE2 = 1,
            #[doc = "2: Mode 3: decryption"]
            MODE3 = 2,
            #[doc = "3: Mode 4: key derivation then single decryption"]
            MODE4 = 3,
        }
        impl From<MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MODE`"]
        pub type MODE_R = crate::R<u8, MODE_A>;
        impl MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODE_A {
                match self.bits {
                    0 => MODE_A::MODE1,
                    1 => MODE_A::MODE2,
                    2 => MODE_A::MODE3,
                    3 => MODE_A::MODE4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline(always)]
            pub fn is_mode1(&self) -> bool {
                *self == MODE_A::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline(always)]
            pub fn is_mode2(&self) -> bool {
                *self == MODE_A::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline(always)]
            pub fn is_mode3(&self) -> bool {
                *self == MODE_A::MODE3
            }
            #[doc = "Checks if the value of the field is `MODE4`"]
            #[inline(always)]
            pub fn is_mode4(&self) -> bool {
                *self == MODE_A::MODE4
            }
        }
        #[doc = "Write proxy for field `MODE`"]
        pub struct MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Mode 1: encryption"]
            #[inline(always)]
            pub fn mode1(self) -> &'a mut W {
                self.variant(MODE_A::MODE1)
            }
            #[doc = "Mode 2: key derivation (or key preparation for ECB/CBC decryption)"]
            #[inline(always)]
            pub fn mode2(self) -> &'a mut W {
                self.variant(MODE_A::MODE2)
            }
            #[doc = "Mode 3: decryption"]
            #[inline(always)]
            pub fn mode3(self) -> &'a mut W {
                self.variant(MODE_A::MODE3)
            }
            #[doc = "Mode 4: key derivation then single decryption"]
            #[inline(always)]
            pub fn mode4(self) -> &'a mut W {
                self.variant(MODE_A::MODE4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        #[doc = "Data type selection (for data in and data out to/from the cryptographic block)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum DATATYPE_A {
            #[doc = "0: Word"]
            NONE = 0,
            #[doc = "1: Half-word (16-bit)"]
            HALFWORD = 1,
            #[doc = "2: Byte (8-bit)"]
            BYTE = 2,
            #[doc = "3: Bit"]
            BIT = 3,
        }
        impl From<DATATYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: DATATYPE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `DATATYPE`"]
        pub type DATATYPE_R = crate::R<u8, DATATYPE_A>;
        impl DATATYPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATATYPE_A {
                match self.bits {
                    0 => DATATYPE_A::NONE,
                    1 => DATATYPE_A::HALFWORD,
                    2 => DATATYPE_A::BYTE,
                    3 => DATATYPE_A::BIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == DATATYPE_A::NONE
            }
            #[doc = "Checks if the value of the field is `HALFWORD`"]
            #[inline(always)]
            pub fn is_half_word(&self) -> bool {
                *self == DATATYPE_A::HALFWORD
            }
            #[doc = "Checks if the value of the field is `BYTE`"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == DATATYPE_A::BYTE
            }
            #[doc = "Checks if the value of the field is `BIT`"]
            #[inline(always)]
            pub fn is_bit_(&self) -> bool {
                *self == DATATYPE_A::BIT
            }
        }
        #[doc = "Write proxy for field `DATATYPE`"]
        pub struct DATATYPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATATYPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATATYPE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Word"]
            #[inline(always)]
            pub fn none(self) -> &'a mut W {
                self.variant(DATATYPE_A::NONE)
            }
            #[doc = "Half-word (16-bit)"]
            #[inline(always)]
            pub fn half_word(self) -> &'a mut W {
                self.variant(DATATYPE_A::HALFWORD)
            }
            #[doc = "Byte (8-bit)"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut W {
                self.variant(DATATYPE_A::BYTE)
            }
            #[doc = "Bit"]
            #[inline(always)]
            pub fn bit_(self) -> &'a mut W {
                self.variant(DATATYPE_A::BIT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 1)) | (((value as u32) & 0x03) << 1);
                self.w
            }
        }
        #[doc = "AES enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN_A {
            #[doc = "0: Disable AES"]
            DISABLED = 0,
            #[doc = "1: Enable AES"]
            ENABLED = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EN`"]
        pub type EN_R = crate::R<bool, EN_A>;
        impl EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::DISABLED,
                    true => EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EN`"]
        pub struct EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable AES"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::DISABLED)
            }
            #[doc = "Enable AES"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 12 - Enable DMA management of data output phase"]
            #[inline(always)]
            pub fn dmaouten(&self) -> DMAOUTEN_R {
                DMAOUTEN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Enable DMA management of data input phase"]
            #[inline(always)]
            pub fn dmainen(&self) -> DMAINEN_R {
                DMAINEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - CCF flag interrupt enable"]
            #[inline(always)]
            pub fn ccfie(&self) -> CCFIE_R {
                CCFIE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Error clear"]
            #[inline(always)]
            pub fn errc(&self) -> ERRC_R {
                ERRC_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Computation Complete Flag Clear"]
            #[inline(always)]
            pub fn ccfc(&self) -> CCFC_R {
                CCFC_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - AES chaining mode"]
            #[inline(always)]
            pub fn chmod(&self) -> CHMOD_R {
                CHMOD_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bits 3:4 - AES operating mode"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 3) & 0x03) as u8)
            }
            #[doc = "Bits 1:2 - Data type selection (for data in and data out to/from the cryptographic block)"]
            #[inline(always)]
            pub fn datatype(&self) -> DATATYPE_R {
                DATATYPE_R::new(((self.bits >> 1) & 0x03) as u8)
            }
            #[doc = "Bit 0 - AES enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 12 - Enable DMA management of data output phase"]
            #[inline(always)]
            pub fn dmaouten(&mut self) -> DMAOUTEN_W {
                DMAOUTEN_W { w: self }
            }
            #[doc = "Bit 11 - Enable DMA management of data input phase"]
            #[inline(always)]
            pub fn dmainen(&mut self) -> DMAINEN_W {
                DMAINEN_W { w: self }
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            #[doc = "Bit 9 - CCF flag interrupt enable"]
            #[inline(always)]
            pub fn ccfie(&mut self) -> CCFIE_W {
                CCFIE_W { w: self }
            }
            #[doc = "Bit 8 - Error clear"]
            #[inline(always)]
            pub fn errc(&mut self) -> ERRC_W {
                ERRC_W { w: self }
            }
            #[doc = "Bit 7 - Computation Complete Flag Clear"]
            #[inline(always)]
            pub fn ccfc(&mut self) -> CCFC_W {
                CCFC_W { w: self }
            }
            #[doc = "Bits 5:6 - AES chaining mode"]
            #[inline(always)]
            pub fn chmod(&mut self) -> CHMOD_W {
                CHMOD_W { w: self }
            }
            #[doc = "Bits 3:4 - AES operating mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W {
                MODE_W { w: self }
            }
            #[doc = "Bits 1:2 - Data type selection (for data in and data out to/from the cryptographic block)"]
            #[inline(always)]
            pub fn datatype(&mut self) -> DATATYPE_W {
                DATATYPE_W { w: self }
            }
            #[doc = "Bit 0 - AES enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W {
                EN_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Write error flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WRERR_A {
            #[doc = "0: Write error not detected"]
            NOERROR = 0,
            #[doc = "1: Write error detected"]
            ERROR = 1,
        }
        impl From<WRERR_A> for bool {
            #[inline(always)]
            fn from(variant: WRERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WRERR`"]
        pub type WRERR_R = crate::R<bool, WRERR_A>;
        impl WRERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WRERR_A {
                match self.bits {
                    false => WRERR_A::NOERROR,
                    true => WRERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == WRERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == WRERR_A::ERROR
            }
        }
        #[doc = "Read error flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RDERR_A {
            #[doc = "0: Read error not detected"]
            NOERROR = 0,
            #[doc = "1: Read error detected"]
            ERROR = 1,
        }
        impl From<RDERR_A> for bool {
            #[inline(always)]
            fn from(variant: RDERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RDERR`"]
        pub type RDERR_R = crate::R<bool, RDERR_A>;
        impl RDERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RDERR_A {
                match self.bits {
                    false => RDERR_A::NOERROR,
                    true => RDERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == RDERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == RDERR_A::ERROR
            }
        }
        #[doc = "Computation complete flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCF_A {
            #[doc = "0: Computation complete"]
            COMPLETE = 0,
            #[doc = "1: Computation not complete"]
            NOTCOMPLETE = 1,
        }
        impl From<CCF_A> for bool {
            #[inline(always)]
            fn from(variant: CCF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCF`"]
        pub type CCF_R = crate::R<bool, CCF_A>;
        impl CCF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCF_A {
                match self.bits {
                    false => CCF_A::COMPLETE,
                    true => CCF_A::NOTCOMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == CCF_A::COMPLETE
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == CCF_A::NOTCOMPLETE
            }
        }
        impl R {
            #[doc = "Bit 2 - Write error flag"]
            #[inline(always)]
            pub fn wrerr(&self) -> WRERR_R {
                WRERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Read error flag"]
            #[inline(always)]
            pub fn rderr(&self) -> RDERR_R {
                RDERR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Computation complete flag"]
            #[inline(always)]
            pub fn ccf(&self) -> CCF_R {
                CCF_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "data input register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dinr](dinr) module"]
    pub type DINR = crate::Reg<u32, _DINR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DINR;
    #[doc = "`read()` method returns [dinr::R](dinr::R) reader structure"]
    impl crate::Readable for DINR {}
    #[doc = "`write(|w| ..)` method takes [dinr::W](dinr::W) writer structure"]
    impl crate::Writable for DINR {}
    #[doc = "data input register"]
    pub mod dinr {
        #[doc = "Reader of register DINR"]
        pub type R = crate::R<u32, super::DINR>;
        #[doc = "Writer for register DINR"]
        pub type W = crate::W<u32, super::DINR>;
        #[doc = "Register DINR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DINR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DIN`"]
        pub type DIN_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `DIN`"]
        pub struct DIN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Data Input Register."]
            #[inline(always)]
            pub fn din(&self) -> DIN_R {
                DIN_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Data Input Register."]
            #[inline(always)]
            pub fn din(&mut self) -> DIN_W {
                DIN_W { w: self }
            }
        }
    }
    #[doc = "data output register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [doutr](doutr) module"]
    pub type DOUTR = crate::Reg<u32, _DOUTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DOUTR;
    #[doc = "`read()` method returns [doutr::R](doutr::R) reader structure"]
    impl crate::Readable for DOUTR {}
    #[doc = "data output register"]
    pub mod doutr {
        #[doc = "Reader of register DOUTR"]
        pub type R = crate::R<u32, super::DOUTR>;
        #[doc = "Reader of field `DOUT`"]
        pub type DOUT_R = crate::R<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Data output register"]
            #[inline(always)]
            pub fn dout(&self) -> DOUT_R {
                DOUT_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
    }
    #[doc = "key register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [keyr0](keyr0) module"]
    pub type KEYR0 = crate::Reg<u32, _KEYR0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEYR0;
    #[doc = "`read()` method returns [keyr0::R](keyr0::R) reader structure"]
    impl crate::Readable for KEYR0 {}
    #[doc = "`write(|w| ..)` method takes [keyr0::W](keyr0::W) writer structure"]
    impl crate::Writable for KEYR0 {}
    #[doc = "key register 0"]
    pub mod keyr0 {
        #[doc = "Reader of register KEYR0"]
        pub type R = crate::R<u32, super::KEYR0>;
        #[doc = "Writer for register KEYR0"]
        pub type W = crate::W<u32, super::KEYR0>;
        #[doc = "Register KEYR0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::KEYR0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `KEY0`"]
        pub type KEY0_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `KEY0`"]
        pub struct KEY0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Data Output Register (LSB key \\[31:0\\])"]
            #[inline(always)]
            pub fn key0(&self) -> KEY0_R {
                KEY0_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Data Output Register (LSB key \\[31:0\\])"]
            #[inline(always)]
            pub fn key0(&mut self) -> KEY0_W {
                KEY0_W { w: self }
            }
        }
    }
    #[doc = "key register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [keyr1](keyr1) module"]
    pub type KEYR1 = crate::Reg<u32, _KEYR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEYR1;
    #[doc = "`read()` method returns [keyr1::R](keyr1::R) reader structure"]
    impl crate::Readable for KEYR1 {}
    #[doc = "`write(|w| ..)` method takes [keyr1::W](keyr1::W) writer structure"]
    impl crate::Writable for KEYR1 {}
    #[doc = "key register 1"]
    pub mod keyr1 {
        #[doc = "Reader of register KEYR1"]
        pub type R = crate::R<u32, super::KEYR1>;
        #[doc = "Writer for register KEYR1"]
        pub type W = crate::W<u32, super::KEYR1>;
        #[doc = "Register KEYR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::KEYR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `KEY1`"]
        pub type KEY1_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `KEY1`"]
        pub struct KEY1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - AES key register (key \\[63:32\\])"]
            #[inline(always)]
            pub fn key1(&self) -> KEY1_R {
                KEY1_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - AES key register (key \\[63:32\\])"]
            #[inline(always)]
            pub fn key1(&mut self) -> KEY1_W {
                KEY1_W { w: self }
            }
        }
    }
    #[doc = "key register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [keyr2](keyr2) module"]
    pub type KEYR2 = crate::Reg<u32, _KEYR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEYR2;
    #[doc = "`read()` method returns [keyr2::R](keyr2::R) reader structure"]
    impl crate::Readable for KEYR2 {}
    #[doc = "`write(|w| ..)` method takes [keyr2::W](keyr2::W) writer structure"]
    impl crate::Writable for KEYR2 {}
    #[doc = "key register 2"]
    pub mod keyr2 {
        #[doc = "Reader of register KEYR2"]
        pub type R = crate::R<u32, super::KEYR2>;
        #[doc = "Writer for register KEYR2"]
        pub type W = crate::W<u32, super::KEYR2>;
        #[doc = "Register KEYR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::KEYR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `KEY2`"]
        pub type KEY2_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `KEY2`"]
        pub struct KEY2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - AES key register (key \\[95:64\\])"]
            #[inline(always)]
            pub fn key2(&self) -> KEY2_R {
                KEY2_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - AES key register (key \\[95:64\\])"]
            #[inline(always)]
            pub fn key2(&mut self) -> KEY2_W {
                KEY2_W { w: self }
            }
        }
    }
    #[doc = "key register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [keyr3](keyr3) module"]
    pub type KEYR3 = crate::Reg<u32, _KEYR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEYR3;
    #[doc = "`read()` method returns [keyr3::R](keyr3::R) reader structure"]
    impl crate::Readable for KEYR3 {}
    #[doc = "`write(|w| ..)` method takes [keyr3::W](keyr3::W) writer structure"]
    impl crate::Writable for KEYR3 {}
    #[doc = "key register 3"]
    pub mod keyr3 {
        #[doc = "Reader of register KEYR3"]
        pub type R = crate::R<u32, super::KEYR3>;
        #[doc = "Writer for register KEYR3"]
        pub type W = crate::W<u32, super::KEYR3>;
        #[doc = "Register KEYR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::KEYR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `KEY3`"]
        pub type KEY3_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `KEY3`"]
        pub struct KEY3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY3_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - AES key register (MSB key \\[127:96\\])"]
            #[inline(always)]
            pub fn key3(&self) -> KEY3_R {
                KEY3_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - AES key register (MSB key \\[127:96\\])"]
            #[inline(always)]
            pub fn key3(&mut self) -> KEY3_W {
                KEY3_W { w: self }
            }
        }
    }
    #[doc = "initialization vector register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ivr0](ivr0) module"]
    pub type IVR0 = crate::Reg<u32, _IVR0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IVR0;
    #[doc = "`read()` method returns [ivr0::R](ivr0::R) reader structure"]
    impl crate::Readable for IVR0 {}
    #[doc = "`write(|w| ..)` method takes [ivr0::W](ivr0::W) writer structure"]
    impl crate::Writable for IVR0 {}
    #[doc = "initialization vector register 0"]
    pub mod ivr0 {
        #[doc = "Reader of register IVR0"]
        pub type R = crate::R<u32, super::IVR0>;
        #[doc = "Writer for register IVR0"]
        pub type W = crate::W<u32, super::IVR0>;
        #[doc = "Register IVR0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::IVR0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IV0`"]
        pub type IV0_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `IV0`"]
        pub struct IV0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IV0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - initialization vector register (LSB IVR \\[31:0\\])"]
            #[inline(always)]
            pub fn iv0(&self) -> IV0_R {
                IV0_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - initialization vector register (LSB IVR \\[31:0\\])"]
            #[inline(always)]
            pub fn iv0(&mut self) -> IV0_W {
                IV0_W { w: self }
            }
        }
    }
    #[doc = "initialization vector register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ivr1](ivr1) module"]
    pub type IVR1 = crate::Reg<u32, _IVR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IVR1;
    #[doc = "`read()` method returns [ivr1::R](ivr1::R) reader structure"]
    impl crate::Readable for IVR1 {}
    #[doc = "`write(|w| ..)` method takes [ivr1::W](ivr1::W) writer structure"]
    impl crate::Writable for IVR1 {}
    #[doc = "initialization vector register 1"]
    pub mod ivr1 {
        #[doc = "Reader of register IVR1"]
        pub type R = crate::R<u32, super::IVR1>;
        #[doc = "Writer for register IVR1"]
        pub type W = crate::W<u32, super::IVR1>;
        #[doc = "Register IVR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::IVR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IV1`"]
        pub type IV1_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `IV1`"]
        pub struct IV1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IV1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[63:32\\])"]
            #[inline(always)]
            pub fn iv1(&self) -> IV1_R {
                IV1_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[63:32\\])"]
            #[inline(always)]
            pub fn iv1(&mut self) -> IV1_W {
                IV1_W { w: self }
            }
        }
    }
    #[doc = "initialization vector register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ivr2](ivr2) module"]
    pub type IVR2 = crate::Reg<u32, _IVR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IVR2;
    #[doc = "`read()` method returns [ivr2::R](ivr2::R) reader structure"]
    impl crate::Readable for IVR2 {}
    #[doc = "`write(|w| ..)` method takes [ivr2::W](ivr2::W) writer structure"]
    impl crate::Writable for IVR2 {}
    #[doc = "initialization vector register 2"]
    pub mod ivr2 {
        #[doc = "Reader of register IVR2"]
        pub type R = crate::R<u32, super::IVR2>;
        #[doc = "Writer for register IVR2"]
        pub type W = crate::W<u32, super::IVR2>;
        #[doc = "Register IVR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::IVR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IV2`"]
        pub type IV2_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `IV2`"]
        pub struct IV2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IV2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[95:64\\])"]
            #[inline(always)]
            pub fn iv2(&self) -> IV2_R {
                IV2_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Initialization Vector Register (IVR \\[95:64\\])"]
            #[inline(always)]
            pub fn iv2(&mut self) -> IV2_W {
                IV2_W { w: self }
            }
        }
    }
    #[doc = "initialization vector register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ivr3](ivr3) module"]
    pub type IVR3 = crate::Reg<u32, _IVR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IVR3;
    #[doc = "`read()` method returns [ivr3::R](ivr3::R) reader structure"]
    impl crate::Readable for IVR3 {}
    #[doc = "`write(|w| ..)` method takes [ivr3::W](ivr3::W) writer structure"]
    impl crate::Writable for IVR3 {}
    #[doc = "initialization vector register 3"]
    pub mod ivr3 {
        #[doc = "Reader of register IVR3"]
        pub type R = crate::R<u32, super::IVR3>;
        #[doc = "Writer for register IVR3"]
        pub type W = crate::W<u32, super::IVR3>;
        #[doc = "Register IVR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::IVR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IV3`"]
        pub type IV3_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `IV3`"]
        pub struct IV3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IV3_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Initialization Vector Register (MSB IVR \\[127:96\\])"]
            #[inline(always)]
            pub fn iv3(&self) -> IV3_R {
                IV3_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Initialization Vector Register (MSB IVR \\[127:96\\])"]
            #[inline(always)]
            pub fn iv3(&mut self) -> IV3_W {
                IV3_W { w: self }
            }
        }
    }
}
#[doc = "Direct memory access controller"]
pub struct DMA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA1 {}
impl DMA1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma1::RegisterBlock {
        0x4002_0000 as *const _
    }
}
impl Deref for DMA1 {
    type Target = dma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DMA1::ptr() }
    }
}
#[doc = "Direct memory access controller"]
pub mod dma1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - interrupt status register"]
        pub isr: ISR,
        #[doc = "0x04 - interrupt flag clear register"]
        pub ifcr: IFCR,
        #[doc = "0x08 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch1: CH,
        _reserved3: [u8; 4usize],
        #[doc = "0x1c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch2: CH,
        _reserved4: [u8; 4usize],
        #[doc = "0x30 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch3: CH,
        _reserved5: [u8; 4usize],
        #[doc = "0x44 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch4: CH,
        _reserved6: [u8; 4usize],
        #[doc = "0x58 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch5: CH,
        _reserved7: [u8; 4usize],
        #[doc = "0x6c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch6: CH,
        _reserved8: [u8; 4usize],
        #[doc = "0x80 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch7: CH,
        _reserved9: [u8; 24usize],
        #[doc = "0xa8 - channel selection register"]
        pub cselr: CSELR,
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct CH {
        #[doc = "0x00 - channel x configuration register"]
        pub cr: self::ch::CR,
        #[doc = "0x04 - channel x number of data register"]
        pub ndtr: self::ch::NDTR,
        #[doc = "0x08 - channel x peripheral address register"]
        pub par: self::ch::PAR,
        #[doc = "0x0c - channel x memory address register"]
        pub mar: self::ch::MAR,
    }
    #[doc = r"Register block"]
    #[doc = "Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
    pub mod ch {
        #[doc = "channel x configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
        pub type CR = crate::Reg<u32, _CR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CR;
        #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
        impl crate::Readable for CR {}
        #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
        impl crate::Writable for CR {}
        #[doc = "channel x configuration register"]
        pub mod cr {
            #[doc = "Reader of register CR"]
            pub type R = crate::R<u32, super::CR>;
            #[doc = "Writer for register CR"]
            pub type W = crate::W<u32, super::CR>;
            #[doc = "Register CR `reset()`'s with value 0"]
            impl crate::ResetValue for super::CR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Memory to memory mode\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MEM2MEM_A {
                #[doc = "0: Memory to memory mode disabled"]
                DISABLED = 0,
                #[doc = "1: Memory to memory mode enabled"]
                ENABLED = 1,
            }
            impl From<MEM2MEM_A> for bool {
                #[inline(always)]
                fn from(variant: MEM2MEM_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `MEM2MEM`"]
            pub type MEM2MEM_R = crate::R<bool, MEM2MEM_A>;
            impl MEM2MEM_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> MEM2MEM_A {
                    match self.bits {
                        false => MEM2MEM_A::DISABLED,
                        true => MEM2MEM_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == MEM2MEM_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == MEM2MEM_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `MEM2MEM`"]
            pub struct MEM2MEM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MEM2MEM_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MEM2MEM_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Memory to memory mode disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MEM2MEM_A::DISABLED)
                }
                #[doc = "Memory to memory mode enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MEM2MEM_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                    self.w
                }
            }
            #[doc = "Channel priority level\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum PL_A {
                #[doc = "0: Low priority"]
                LOW = 0,
                #[doc = "1: Medium priority"]
                MEDIUM = 1,
                #[doc = "2: High priority"]
                HIGH = 2,
                #[doc = "3: Very high priority"]
                VERYHIGH = 3,
            }
            impl From<PL_A> for u8 {
                #[inline(always)]
                fn from(variant: PL_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `PL`"]
            pub type PL_R = crate::R<u8, PL_A>;
            impl PL_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> PL_A {
                    match self.bits {
                        0 => PL_A::LOW,
                        1 => PL_A::MEDIUM,
                        2 => PL_A::HIGH,
                        3 => PL_A::VERYHIGH,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `LOW`"]
                #[inline(always)]
                pub fn is_low(&self) -> bool {
                    *self == PL_A::LOW
                }
                #[doc = "Checks if the value of the field is `MEDIUM`"]
                #[inline(always)]
                pub fn is_medium(&self) -> bool {
                    *self == PL_A::MEDIUM
                }
                #[doc = "Checks if the value of the field is `HIGH`"]
                #[inline(always)]
                pub fn is_high(&self) -> bool {
                    *self == PL_A::HIGH
                }
                #[doc = "Checks if the value of the field is `VERYHIGH`"]
                #[inline(always)]
                pub fn is_very_high(&self) -> bool {
                    *self == PL_A::VERYHIGH
                }
            }
            #[doc = "Write proxy for field `PL`"]
            pub struct PL_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PL_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PL_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Low priority"]
                #[inline(always)]
                pub fn low(self) -> &'a mut W {
                    self.variant(PL_A::LOW)
                }
                #[doc = "Medium priority"]
                #[inline(always)]
                pub fn medium(self) -> &'a mut W {
                    self.variant(PL_A::MEDIUM)
                }
                #[doc = "High priority"]
                #[inline(always)]
                pub fn high(self) -> &'a mut W {
                    self.variant(PL_A::HIGH)
                }
                #[doc = "Very high priority"]
                #[inline(always)]
                pub fn very_high(self) -> &'a mut W {
                    self.variant(PL_A::VERYHIGH)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                    self.w
                }
            }
            #[doc = "Memory size\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum MSIZE_A {
                #[doc = "0: 8-bit size"]
                BITS8 = 0,
                #[doc = "1: 16-bit size"]
                BITS16 = 1,
                #[doc = "2: 32-bit size"]
                BITS32 = 2,
            }
            impl From<MSIZE_A> for u8 {
                #[inline(always)]
                fn from(variant: MSIZE_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `MSIZE`"]
            pub type MSIZE_R = crate::R<u8, MSIZE_A>;
            impl MSIZE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> crate::Variant<u8, MSIZE_A> {
                    use crate::Variant::*;
                    match self.bits {
                        0 => Val(MSIZE_A::BITS8),
                        1 => Val(MSIZE_A::BITS16),
                        2 => Val(MSIZE_A::BITS32),
                        i => Res(i),
                    }
                }
                #[doc = "Checks if the value of the field is `BITS8`"]
                #[inline(always)]
                pub fn is_bits8(&self) -> bool {
                    *self == MSIZE_A::BITS8
                }
                #[doc = "Checks if the value of the field is `BITS16`"]
                #[inline(always)]
                pub fn is_bits16(&self) -> bool {
                    *self == MSIZE_A::BITS16
                }
                #[doc = "Checks if the value of the field is `BITS32`"]
                #[inline(always)]
                pub fn is_bits32(&self) -> bool {
                    *self == MSIZE_A::BITS32
                }
            }
            #[doc = "Write proxy for field `MSIZE`"]
            pub struct MSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MSIZE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "8-bit size"]
                #[inline(always)]
                pub fn bits8(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS8)
                }
                #[doc = "16-bit size"]
                #[inline(always)]
                pub fn bits16(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS16)
                }
                #[doc = "32-bit size"]
                #[inline(always)]
                pub fn bits32(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS32)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                    self.w
                }
            }
            #[doc = "Peripheral size"]
            pub type PSIZE_A = MSIZE_A;
            #[doc = "Reader of field `PSIZE`"]
            pub type PSIZE_R = crate::R<u8, MSIZE_A>;
            #[doc = "Write proxy for field `PSIZE`"]
            pub struct PSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PSIZE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "8-bit size"]
                #[inline(always)]
                pub fn bits8(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS8)
                }
                #[doc = "16-bit size"]
                #[inline(always)]
                pub fn bits16(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS16)
                }
                #[doc = "32-bit size"]
                #[inline(always)]
                pub fn bits32(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS32)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                    self.w
                }
            }
            #[doc = "Memory increment mode\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MINC_A {
                #[doc = "0: Increment mode disabled"]
                DISABLED = 0,
                #[doc = "1: Increment mode enabled"]
                ENABLED = 1,
            }
            impl From<MINC_A> for bool {
                #[inline(always)]
                fn from(variant: MINC_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `MINC`"]
            pub type MINC_R = crate::R<bool, MINC_A>;
            impl MINC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> MINC_A {
                    match self.bits {
                        false => MINC_A::DISABLED,
                        true => MINC_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == MINC_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == MINC_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `MINC`"]
            pub struct MINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MINC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MINC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Increment mode disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MINC_A::DISABLED)
                }
                #[doc = "Increment mode enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MINC_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                    self.w
                }
            }
            #[doc = "Peripheral increment mode"]
            pub type PINC_A = MINC_A;
            #[doc = "Reader of field `PINC`"]
            pub type PINC_R = crate::R<bool, MINC_A>;
            #[doc = "Write proxy for field `PINC`"]
            pub struct PINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PINC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PINC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Increment mode disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MINC_A::DISABLED)
                }
                #[doc = "Increment mode enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MINC_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Circular mode\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum CIRC_A {
                #[doc = "0: Circular buffer disabled"]
                DISABLED = 0,
                #[doc = "1: Circular buffer enabled"]
                ENABLED = 1,
            }
            impl From<CIRC_A> for bool {
                #[inline(always)]
                fn from(variant: CIRC_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `CIRC`"]
            pub type CIRC_R = crate::R<bool, CIRC_A>;
            impl CIRC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> CIRC_A {
                    match self.bits {
                        false => CIRC_A::DISABLED,
                        true => CIRC_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == CIRC_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == CIRC_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `CIRC`"]
            pub struct CIRC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> CIRC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: CIRC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Circular buffer disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(CIRC_A::DISABLED)
                }
                #[doc = "Circular buffer enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(CIRC_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                    self.w
                }
            }
            #[doc = "Data transfer direction\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum DIR_A {
                #[doc = "0: Read from peripheral"]
                FROMPERIPHERAL = 0,
                #[doc = "1: Read from memory"]
                FROMMEMORY = 1,
            }
            impl From<DIR_A> for bool {
                #[inline(always)]
                fn from(variant: DIR_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `DIR`"]
            pub type DIR_R = crate::R<bool, DIR_A>;
            impl DIR_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> DIR_A {
                    match self.bits {
                        false => DIR_A::FROMPERIPHERAL,
                        true => DIR_A::FROMMEMORY,
                    }
                }
                #[doc = "Checks if the value of the field is `FROMPERIPHERAL`"]
                #[inline(always)]
                pub fn is_from_peripheral(&self) -> bool {
                    *self == DIR_A::FROMPERIPHERAL
                }
                #[doc = "Checks if the value of the field is `FROMMEMORY`"]
                #[inline(always)]
                pub fn is_from_memory(&self) -> bool {
                    *self == DIR_A::FROMMEMORY
                }
            }
            #[doc = "Write proxy for field `DIR`"]
            pub struct DIR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DIR_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DIR_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Read from peripheral"]
                #[inline(always)]
                pub fn from_peripheral(self) -> &'a mut W {
                    self.variant(DIR_A::FROMPERIPHERAL)
                }
                #[doc = "Read from memory"]
                #[inline(always)]
                pub fn from_memory(self) -> &'a mut W {
                    self.variant(DIR_A::FROMMEMORY)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Transfer error interrupt enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TEIE_A {
                #[doc = "0: Transfer Error interrupt disabled"]
                DISABLED = 0,
                #[doc = "1: Transfer Error interrupt enabled"]
                ENABLED = 1,
            }
            impl From<TEIE_A> for bool {
                #[inline(always)]
                fn from(variant: TEIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `TEIE`"]
            pub type TEIE_R = crate::R<bool, TEIE_A>;
            impl TEIE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> TEIE_A {
                    match self.bits {
                        false => TEIE_A::DISABLED,
                        true => TEIE_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == TEIE_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == TEIE_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `TEIE`"]
            pub struct TEIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TEIE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: TEIE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Transfer Error interrupt disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TEIE_A::DISABLED)
                }
                #[doc = "Transfer Error interrupt enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TEIE_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Half transfer interrupt enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HTIE_A {
                #[doc = "0: Half Transfer interrupt disabled"]
                DISABLED = 0,
                #[doc = "1: Half Transfer interrupt enabled"]
                ENABLED = 1,
            }
            impl From<HTIE_A> for bool {
                #[inline(always)]
                fn from(variant: HTIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `HTIE`"]
            pub type HTIE_R = crate::R<bool, HTIE_A>;
            impl HTIE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> HTIE_A {
                    match self.bits {
                        false => HTIE_A::DISABLED,
                        true => HTIE_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == HTIE_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == HTIE_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `HTIE`"]
            pub struct HTIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> HTIE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: HTIE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Half Transfer interrupt disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(HTIE_A::DISABLED)
                }
                #[doc = "Half Transfer interrupt enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(HTIE_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                    self.w
                }
            }
            #[doc = "Transfer complete interrupt enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TCIE_A {
                #[doc = "0: Transfer Complete interrupt disabled"]
                DISABLED = 0,
                #[doc = "1: Transfer Complete interrupt enabled"]
                ENABLED = 1,
            }
            impl From<TCIE_A> for bool {
                #[inline(always)]
                fn from(variant: TCIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `TCIE`"]
            pub type TCIE_R = crate::R<bool, TCIE_A>;
            impl TCIE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> TCIE_A {
                    match self.bits {
                        false => TCIE_A::DISABLED,
                        true => TCIE_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == TCIE_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == TCIE_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `TCIE`"]
            pub struct TCIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TCIE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Transfer Complete interrupt disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TCIE_A::DISABLED)
                }
                #[doc = "Transfer Complete interrupt enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TCIE_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Channel enable\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum EN_A {
                #[doc = "0: Channel disabled"]
                DISABLED = 0,
                #[doc = "1: Channel enabled"]
                ENABLED = 1,
            }
            impl From<EN_A> for bool {
                #[inline(always)]
                fn from(variant: EN_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `EN`"]
            pub type EN_R = crate::R<bool, EN_A>;
            impl EN_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> EN_A {
                    match self.bits {
                        false => EN_A::DISABLED,
                        true => EN_A::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    *self == EN_A::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    *self == EN_A::ENABLED
                }
            }
            #[doc = "Write proxy for field `EN`"]
            pub struct EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> EN_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: EN_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Channel disabled"]
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(EN_A::DISABLED)
                }
                #[doc = "Channel enabled"]
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(EN_A::ENABLED)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 14 - Memory to memory mode"]
                #[inline(always)]
                pub fn mem2mem(&self) -> MEM2MEM_R {
                    MEM2MEM_R::new(((self.bits >> 14) & 0x01) != 0)
                }
                #[doc = "Bits 12:13 - Channel priority level"]
                #[inline(always)]
                pub fn pl(&self) -> PL_R {
                    PL_R::new(((self.bits >> 12) & 0x03) as u8)
                }
                #[doc = "Bits 10:11 - Memory size"]
                #[inline(always)]
                pub fn msize(&self) -> MSIZE_R {
                    MSIZE_R::new(((self.bits >> 10) & 0x03) as u8)
                }
                #[doc = "Bits 8:9 - Peripheral size"]
                #[inline(always)]
                pub fn psize(&self) -> PSIZE_R {
                    PSIZE_R::new(((self.bits >> 8) & 0x03) as u8)
                }
                #[doc = "Bit 7 - Memory increment mode"]
                #[inline(always)]
                pub fn minc(&self) -> MINC_R {
                    MINC_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Peripheral increment mode"]
                #[inline(always)]
                pub fn pinc(&self) -> PINC_R {
                    PINC_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Circular mode"]
                #[inline(always)]
                pub fn circ(&self) -> CIRC_R {
                    CIRC_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Data transfer direction"]
                #[inline(always)]
                pub fn dir(&self) -> DIR_R {
                    DIR_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Transfer error interrupt enable"]
                #[inline(always)]
                pub fn teie(&self) -> TEIE_R {
                    TEIE_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 2 - Half transfer interrupt enable"]
                #[inline(always)]
                pub fn htie(&self) -> HTIE_R {
                    HTIE_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                #[doc = "Bit 1 - Transfer complete interrupt enable"]
                #[inline(always)]
                pub fn tcie(&self) -> TCIE_R {
                    TCIE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 0 - Channel enable"]
                #[inline(always)]
                pub fn en(&self) -> EN_R {
                    EN_R::new((self.bits & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 14 - Memory to memory mode"]
                #[inline(always)]
                pub fn mem2mem(&mut self) -> MEM2MEM_W {
                    MEM2MEM_W { w: self }
                }
                #[doc = "Bits 12:13 - Channel priority level"]
                #[inline(always)]
                pub fn pl(&mut self) -> PL_W {
                    PL_W { w: self }
                }
                #[doc = "Bits 10:11 - Memory size"]
                #[inline(always)]
                pub fn msize(&mut self) -> MSIZE_W {
                    MSIZE_W { w: self }
                }
                #[doc = "Bits 8:9 - Peripheral size"]
                #[inline(always)]
                pub fn psize(&mut self) -> PSIZE_W {
                    PSIZE_W { w: self }
                }
                #[doc = "Bit 7 - Memory increment mode"]
                #[inline(always)]
                pub fn minc(&mut self) -> MINC_W {
                    MINC_W { w: self }
                }
                #[doc = "Bit 6 - Peripheral increment mode"]
                #[inline(always)]
                pub fn pinc(&mut self) -> PINC_W {
                    PINC_W { w: self }
                }
                #[doc = "Bit 5 - Circular mode"]
                #[inline(always)]
                pub fn circ(&mut self) -> CIRC_W {
                    CIRC_W { w: self }
                }
                #[doc = "Bit 4 - Data transfer direction"]
                #[inline(always)]
                pub fn dir(&mut self) -> DIR_W {
                    DIR_W { w: self }
                }
                #[doc = "Bit 3 - Transfer error interrupt enable"]
                #[inline(always)]
                pub fn teie(&mut self) -> TEIE_W {
                    TEIE_W { w: self }
                }
                #[doc = "Bit 2 - Half transfer interrupt enable"]
                #[inline(always)]
                pub fn htie(&mut self) -> HTIE_W {
                    HTIE_W { w: self }
                }
                #[doc = "Bit 1 - Transfer complete interrupt enable"]
                #[inline(always)]
                pub fn tcie(&mut self) -> TCIE_W {
                    TCIE_W { w: self }
                }
                #[doc = "Bit 0 - Channel enable"]
                #[inline(always)]
                pub fn en(&mut self) -> EN_W {
                    EN_W { w: self }
                }
            }
        }
        #[doc = "channel x number of data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ndtr](ndtr) module"]
        pub type NDTR = crate::Reg<u32, _NDTR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _NDTR;
        #[doc = "`read()` method returns [ndtr::R](ndtr::R) reader structure"]
        impl crate::Readable for NDTR {}
        #[doc = "`write(|w| ..)` method takes [ndtr::W](ndtr::W) writer structure"]
        impl crate::Writable for NDTR {}
        #[doc = "channel x number of data register"]
        pub mod ndtr {
            #[doc = "Reader of register NDTR"]
            pub type R = crate::R<u32, super::NDTR>;
            #[doc = "Writer for register NDTR"]
            pub type W = crate::W<u32, super::NDTR>;
            #[doc = "Register NDTR `reset()`'s with value 0"]
            impl crate::ResetValue for super::NDTR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `NDT`"]
            pub type NDT_R = crate::R<u16, u16>;
            #[doc = "Write proxy for field `NDT`"]
            pub struct NDT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> NDT_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u16) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:15 - Number of data to transfer"]
                #[inline(always)]
                pub fn ndt(&self) -> NDT_R {
                    NDT_R::new((self.bits & 0xffff) as u16)
                }
            }
            impl W {
                #[doc = "Bits 0:15 - Number of data to transfer"]
                #[inline(always)]
                pub fn ndt(&mut self) -> NDT_W {
                    NDT_W { w: self }
                }
            }
        }
        #[doc = "channel x peripheral address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [par](par) module"]
        pub type PAR = crate::Reg<u32, _PAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _PAR;
        #[doc = "`read()` method returns [par::R](par::R) reader structure"]
        impl crate::Readable for PAR {}
        #[doc = "`write(|w| ..)` method takes [par::W](par::W) writer structure"]
        impl crate::Writable for PAR {}
        #[doc = "channel x peripheral address register"]
        pub mod par {
            #[doc = "Reader of register PAR"]
            pub type R = crate::R<u32, super::PAR>;
            #[doc = "Writer for register PAR"]
            pub type W = crate::W<u32, super::PAR>;
            #[doc = "Register PAR `reset()`'s with value 0"]
            impl crate::ResetValue for super::PAR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `PA`"]
            pub type PA_R = crate::R<u32, u32>;
            #[doc = "Write proxy for field `PA`"]
            pub struct PA_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PA_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:31 - Peripheral address"]
                #[inline(always)]
                pub fn pa(&self) -> PA_R {
                    PA_R::new((self.bits & 0xffff_ffff) as u32)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - Peripheral address"]
                #[inline(always)]
                pub fn pa(&mut self) -> PA_W {
                    PA_W { w: self }
                }
            }
        }
        #[doc = "channel x memory address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mar](mar) module"]
        pub type MAR = crate::Reg<u32, _MAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _MAR;
        #[doc = "`read()` method returns [mar::R](mar::R) reader structure"]
        impl crate::Readable for MAR {}
        #[doc = "`write(|w| ..)` method takes [mar::W](mar::W) writer structure"]
        impl crate::Writable for MAR {}
        #[doc = "channel x memory address register"]
        pub mod mar {
            #[doc = "Reader of register MAR"]
            pub type R = crate::R<u32, super::MAR>;
            #[doc = "Writer for register MAR"]
            pub type W = crate::W<u32, super::MAR>;
            #[doc = "Register MAR `reset()`'s with value 0"]
            impl crate::ResetValue for super::MAR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `MA`"]
            pub type MA_R = crate::R<u32, u32>;
            #[doc = "Write proxy for field `MA`"]
            pub struct MA_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MA_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:31 - Memory address"]
                #[inline(always)]
                pub fn ma(&self) -> MA_R {
                    MA_R::new((self.bits & 0xffff_ffff) as u32)
                }
            }
            impl W {
                #[doc = "Bits 0:31 - Memory address"]
                #[inline(always)]
                pub fn ma(&mut self) -> MA_W {
                    MA_W { w: self }
                }
            }
        }
    }
    #[doc = "interrupt status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "interrupt status register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Channel x transfer error flag (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEIF7_A {
            #[doc = "0: No transfer error"]
            NOERROR = 0,
            #[doc = "1: A transfer error has occured"]
            ERROR = 1,
        }
        impl From<TEIF7_A> for bool {
            #[inline(always)]
            fn from(variant: TEIF7_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TEIF7`"]
        pub type TEIF7_R = crate::R<bool, TEIF7_A>;
        impl TEIF7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TEIF7_A {
                match self.bits {
                    false => TEIF7_A::NOERROR,
                    true => TEIF7_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == TEIF7_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == TEIF7_A::ERROR
            }
        }
        #[doc = "Channel x half transfer flag (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HTIF7_A {
            #[doc = "0: No half transfer event"]
            NOTHALF = 0,
            #[doc = "1: A half transfer event has occured"]
            HALF = 1,
        }
        impl From<HTIF7_A> for bool {
            #[inline(always)]
            fn from(variant: HTIF7_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HTIF7`"]
        pub type HTIF7_R = crate::R<bool, HTIF7_A>;
        impl HTIF7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HTIF7_A {
                match self.bits {
                    false => HTIF7_A::NOTHALF,
                    true => HTIF7_A::HALF,
                }
            }
            #[doc = "Checks if the value of the field is `NOTHALF`"]
            #[inline(always)]
            pub fn is_not_half(&self) -> bool {
                *self == HTIF7_A::NOTHALF
            }
            #[doc = "Checks if the value of the field is `HALF`"]
            #[inline(always)]
            pub fn is_half(&self) -> bool {
                *self == HTIF7_A::HALF
            }
        }
        #[doc = "Channel x transfer complete flag (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIF7_A {
            #[doc = "0: No transfer complete event"]
            NOTCOMPLETE = 0,
            #[doc = "1: A transfer complete event has occured"]
            COMPLETE = 1,
        }
        impl From<TCIF7_A> for bool {
            #[inline(always)]
            fn from(variant: TCIF7_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIF7`"]
        pub type TCIF7_R = crate::R<bool, TCIF7_A>;
        impl TCIF7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIF7_A {
                match self.bits {
                    false => TCIF7_A::NOTCOMPLETE,
                    true => TCIF7_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == TCIF7_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == TCIF7_A::COMPLETE
            }
        }
        #[doc = "Channel x global interrupt flag (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GIF7_A {
            #[doc = "0: No transfer error, half event, complete event"]
            NOEVENT = 0,
            #[doc = "1: A transfer error, half event or complete event has occured"]
            EVENT = 1,
        }
        impl From<GIF7_A> for bool {
            #[inline(always)]
            fn from(variant: GIF7_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `GIF7`"]
        pub type GIF7_R = crate::R<bool, GIF7_A>;
        impl GIF7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> GIF7_A {
                match self.bits {
                    false => GIF7_A::NOEVENT,
                    true => GIF7_A::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == GIF7_A::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                *self == GIF7_A::EVENT
            }
        }
        #[doc = "Channel x transfer error flag (x = 1 ..7)"]
        pub type TEIF6_A = TEIF7_A;
        #[doc = "Reader of field `TEIF6`"]
        pub type TEIF6_R = crate::R<bool, TEIF7_A>;
        #[doc = "Channel x half transfer flag (x = 1 ..7)"]
        pub type HTIF6_A = HTIF7_A;
        #[doc = "Reader of field `HTIF6`"]
        pub type HTIF6_R = crate::R<bool, HTIF7_A>;
        #[doc = "Channel x transfer complete flag (x = 1 ..7)"]
        pub type TCIF6_A = TCIF7_A;
        #[doc = "Reader of field `TCIF6`"]
        pub type TCIF6_R = crate::R<bool, TCIF7_A>;
        #[doc = "Channel x global interrupt flag (x = 1 ..7)"]
        pub type GIF6_A = GIF7_A;
        #[doc = "Reader of field `GIF6`"]
        pub type GIF6_R = crate::R<bool, GIF7_A>;
        #[doc = "Channel x transfer error flag (x = 1 ..7)"]
        pub type TEIF5_A = TEIF7_A;
        #[doc = "Reader of field `TEIF5`"]
        pub type TEIF5_R = crate::R<bool, TEIF7_A>;
        #[doc = "Channel x half transfer flag (x = 1 ..7)"]
        pub type HTIF5_A = HTIF7_A;
        #[doc = "Reader of field `HTIF5`"]
        pub type HTIF5_R = crate::R<bool, HTIF7_A>;
        #[doc = "Channel x transfer complete flag (x = 1 ..7)"]
        pub type TCIF5_A = TCIF7_A;
        #[doc = "Reader of field `TCIF5`"]
        pub type TCIF5_R = crate::R<bool, TCIF7_A>;
        #[doc = "Channel x global interrupt flag (x = 1 ..7)"]
        pub type GIF5_A = GIF7_A;
        #[doc = "Reader of field `GIF5`"]
        pub type GIF5_R = crate::R<bool, GIF7_A>;
        #[doc = "Channel x transfer error flag (x = 1 ..7)"]
        pub type TEIF4_A = TEIF7_A;
        #[doc = "Reader of field `TEIF4`"]
        pub type TEIF4_R = crate::R<bool, TEIF7_A>;
        #[doc = "Channel x half transfer flag (x = 1 ..7)"]
        pub type HTIF4_A = HTIF7_A;
        #[doc = "Reader of field `HTIF4`"]
        pub type HTIF4_R = crate::R<bool, HTIF7_A>;
        #[doc = "Channel x transfer complete flag (x = 1 ..7)"]
        pub type TCIF4_A = TCIF7_A;
        #[doc = "Reader of field `TCIF4`"]
        pub type TCIF4_R = crate::R<bool, TCIF7_A>;
        #[doc = "Channel x global interrupt flag (x = 1 ..7)"]
        pub type GIF4_A = GIF7_A;
        #[doc = "Reader of field `GIF4`"]
        pub type GIF4_R = crate::R<bool, GIF7_A>;
        #[doc = "Channel x transfer error flag (x = 1 ..7)"]
        pub type TEIF3_A = TEIF7_A;
        #[doc = "Reader of field `TEIF3`"]
        pub type TEIF3_R = crate::R<bool, TEIF7_A>;
        #[doc = "Channel x half transfer flag (x = 1 ..7)"]
        pub type HTIF3_A = HTIF7_A;
        #[doc = "Reader of field `HTIF3`"]
        pub type HTIF3_R = crate::R<bool, HTIF7_A>;
        #[doc = "Channel x transfer complete flag (x = 1 ..7)"]
        pub type TCIF3_A = TCIF7_A;
        #[doc = "Reader of field `TCIF3`"]
        pub type TCIF3_R = crate::R<bool, TCIF7_A>;
        #[doc = "Channel x global interrupt flag (x = 1 ..7)"]
        pub type GIF3_A = GIF7_A;
        #[doc = "Reader of field `GIF3`"]
        pub type GIF3_R = crate::R<bool, GIF7_A>;
        #[doc = "Channel x transfer error flag (x = 1 ..7)"]
        pub type TEIF2_A = TEIF7_A;
        #[doc = "Reader of field `TEIF2`"]
        pub type TEIF2_R = crate::R<bool, TEIF7_A>;
        #[doc = "Channel x half transfer flag (x = 1 ..7)"]
        pub type HTIF2_A = HTIF7_A;
        #[doc = "Reader of field `HTIF2`"]
        pub type HTIF2_R = crate::R<bool, HTIF7_A>;
        #[doc = "Channel x transfer complete flag (x = 1 ..7)"]
        pub type TCIF2_A = TCIF7_A;
        #[doc = "Reader of field `TCIF2`"]
        pub type TCIF2_R = crate::R<bool, TCIF7_A>;
        #[doc = "Channel x global interrupt flag (x = 1 ..7)"]
        pub type GIF2_A = GIF7_A;
        #[doc = "Reader of field `GIF2`"]
        pub type GIF2_R = crate::R<bool, GIF7_A>;
        #[doc = "Channel x transfer error flag (x = 1 ..7)"]
        pub type TEIF1_A = TEIF7_A;
        #[doc = "Reader of field `TEIF1`"]
        pub type TEIF1_R = crate::R<bool, TEIF7_A>;
        #[doc = "Channel x half transfer flag (x = 1 ..7)"]
        pub type HTIF1_A = HTIF7_A;
        #[doc = "Reader of field `HTIF1`"]
        pub type HTIF1_R = crate::R<bool, HTIF7_A>;
        #[doc = "Channel x transfer complete flag (x = 1 ..7)"]
        pub type TCIF1_A = TCIF7_A;
        #[doc = "Reader of field `TCIF1`"]
        pub type TCIF1_R = crate::R<bool, TCIF7_A>;
        #[doc = "Channel x global interrupt flag (x = 1 ..7)"]
        pub type GIF1_A = GIF7_A;
        #[doc = "Reader of field `GIF1`"]
        pub type GIF1_R = crate::R<bool, GIF7_A>;
        impl R {
            #[doc = "Bit 27 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif7(&self) -> TEIF7_R {
                TEIF7_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 26 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif7(&self) -> HTIF7_R {
                HTIF7_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif7(&self) -> TCIF7_R {
                TCIF7_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif7(&self) -> GIF7_R {
                GIF7_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif6(&self) -> TEIF6_R {
                TEIF6_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif6(&self) -> HTIF6_R {
                HTIF6_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif6(&self) -> TCIF6_R {
                TCIF6_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif6(&self) -> GIF6_R {
                GIF6_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif5(&self) -> TEIF5_R {
                TEIF5_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif5(&self) -> HTIF5_R {
                HTIF5_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif5(&self) -> TCIF5_R {
                TCIF5_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif5(&self) -> GIF5_R {
                GIF5_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif4(&self) -> TEIF4_R {
                TEIF4_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif4(&self) -> HTIF4_R {
                HTIF4_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif4(&self) -> TCIF4_R {
                TCIF4_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif4(&self) -> GIF4_R {
                GIF4_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif3(&self) -> TEIF3_R {
                TEIF3_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif3(&self) -> HTIF3_R {
                HTIF3_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif3(&self) -> TCIF3_R {
                TCIF3_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif3(&self) -> GIF3_R {
                GIF3_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif2(&self) -> TEIF2_R {
                TEIF2_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif2(&self) -> HTIF2_R {
                HTIF2_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif2(&self) -> TCIF2_R {
                TCIF2_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif2(&self) -> GIF2_R {
                GIF2_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Channel x transfer error flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn teif1(&self) -> TEIF1_R {
                TEIF1_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Channel x half transfer flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn htif1(&self) -> HTIF1_R {
                HTIF1_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Channel x transfer complete flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn tcif1(&self) -> TCIF1_R {
                TCIF1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Channel x global interrupt flag (x = 1 ..7)"]
            #[inline(always)]
            pub fn gif1(&self) -> GIF1_R {
                GIF1_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "interrupt flag clear register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ifcr](ifcr) module"]
    pub type IFCR = crate::Reg<u32, _IFCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IFCR;
    #[doc = "`write(|w| ..)` method takes [ifcr::W](ifcr::W) writer structure"]
    impl crate::Writable for IFCR {}
    #[doc = "interrupt flag clear register"]
    pub mod ifcr {
        #[doc = "Writer for register IFCR"]
        pub type W = crate::W<u32, super::IFCR>;
        #[doc = "Register IFCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IFCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTEIF7_AW {
            #[doc = "1: Clears the TEIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CTEIF7_AW> for bool {
            #[inline(always)]
            fn from(variant: CTEIF7_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTEIF7`"]
        pub struct CTEIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHTIF7_AW {
            #[doc = "1: Clears the HTIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CHTIF7_AW> for bool {
            #[inline(always)]
            fn from(variant: CHTIF7_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CHTIF7`"]
        pub struct CHTIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTCIF7_AW {
            #[doc = "1: Clears the TCIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CTCIF7_AW> for bool {
            #[inline(always)]
            fn from(variant: CTCIF7_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTCIF7`"]
        pub struct CTCIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CGIF7_AW {
            #[doc = "1: Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            CLEAR = 1,
        }
        impl From<CGIF7_AW> for bool {
            #[inline(always)]
            fn from(variant: CGIF7_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CGIF7`"]
        pub struct CGIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)"]
        pub type CTEIF6_AW = CTEIF7_AW;
        #[doc = "Write proxy for field `CTEIF6`"]
        pub struct CTEIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)"]
        pub type CHTIF6_AW = CHTIF7_AW;
        #[doc = "Write proxy for field `CHTIF6`"]
        pub struct CHTIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)"]
        pub type CTCIF6_AW = CTCIF7_AW;
        #[doc = "Write proxy for field `CTCIF6`"]
        pub struct CTCIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)"]
        pub type CGIF6_AW = CGIF7_AW;
        #[doc = "Write proxy for field `CGIF6`"]
        pub struct CGIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)"]
        pub type CTEIF5_AW = CTEIF7_AW;
        #[doc = "Write proxy for field `CTEIF5`"]
        pub struct CTEIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)"]
        pub type CHTIF5_AW = CHTIF7_AW;
        #[doc = "Write proxy for field `CHTIF5`"]
        pub struct CHTIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)"]
        pub type CTCIF5_AW = CTCIF7_AW;
        #[doc = "Write proxy for field `CTCIF5`"]
        pub struct CTCIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)"]
        pub type CGIF5_AW = CGIF7_AW;
        #[doc = "Write proxy for field `CGIF5`"]
        pub struct CGIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)"]
        pub type CTEIF4_AW = CTEIF7_AW;
        #[doc = "Write proxy for field `CTEIF4`"]
        pub struct CTEIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)"]
        pub type CHTIF4_AW = CHTIF7_AW;
        #[doc = "Write proxy for field `CHTIF4`"]
        pub struct CHTIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)"]
        pub type CTCIF4_AW = CTCIF7_AW;
        #[doc = "Write proxy for field `CTCIF4`"]
        pub struct CTCIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)"]
        pub type CGIF4_AW = CGIF7_AW;
        #[doc = "Write proxy for field `CGIF4`"]
        pub struct CGIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)"]
        pub type CTEIF3_AW = CTEIF7_AW;
        #[doc = "Write proxy for field `CTEIF3`"]
        pub struct CTEIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)"]
        pub type CHTIF3_AW = CHTIF7_AW;
        #[doc = "Write proxy for field `CHTIF3`"]
        pub struct CHTIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)"]
        pub type CTCIF3_AW = CTCIF7_AW;
        #[doc = "Write proxy for field `CTCIF3`"]
        pub struct CTCIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)"]
        pub type CGIF3_AW = CGIF7_AW;
        #[doc = "Write proxy for field `CGIF3`"]
        pub struct CGIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)"]
        pub type CTEIF2_AW = CTEIF7_AW;
        #[doc = "Write proxy for field `CTEIF2`"]
        pub struct CTEIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)"]
        pub type CHTIF2_AW = CHTIF7_AW;
        #[doc = "Write proxy for field `CHTIF2`"]
        pub struct CHTIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)"]
        pub type CTCIF2_AW = CTCIF7_AW;
        #[doc = "Write proxy for field `CTCIF2`"]
        pub struct CTCIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)"]
        pub type CGIF2_AW = CGIF7_AW;
        #[doc = "Write proxy for field `CGIF2`"]
        pub struct CGIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Channel x transfer error clear (x = 1 ..7)"]
        pub type CTEIF1_AW = CTEIF7_AW;
        #[doc = "Write proxy for field `CTEIF1`"]
        pub struct CTEIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTEIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Channel x half transfer clear (x = 1 ..7)"]
        pub type CHTIF1_AW = CHTIF7_AW;
        #[doc = "Write proxy for field `CHTIF1`"]
        pub struct CHTIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHTIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Channel x transfer complete clear (x = 1 ..7)"]
        pub type CTCIF1_AW = CTCIF7_AW;
        #[doc = "Write proxy for field `CTCIF1`"]
        pub struct CTCIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTCIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Channel x global interrupt clear (x = 1 ..7)"]
        pub type CGIF1_AW = CGIF7_AW;
        #[doc = "Write proxy for field `CGIF1`"]
        pub struct CGIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CGIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 27 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif7(&mut self) -> CTEIF7_W {
                CTEIF7_W { w: self }
            }
            #[doc = "Bit 26 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif7(&mut self) -> CHTIF7_W {
                CHTIF7_W { w: self }
            }
            #[doc = "Bit 25 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif7(&mut self) -> CTCIF7_W {
                CTCIF7_W { w: self }
            }
            #[doc = "Bit 24 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif7(&mut self) -> CGIF7_W {
                CGIF7_W { w: self }
            }
            #[doc = "Bit 23 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif6(&mut self) -> CTEIF6_W {
                CTEIF6_W { w: self }
            }
            #[doc = "Bit 22 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif6(&mut self) -> CHTIF6_W {
                CHTIF6_W { w: self }
            }
            #[doc = "Bit 21 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif6(&mut self) -> CTCIF6_W {
                CTCIF6_W { w: self }
            }
            #[doc = "Bit 20 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif6(&mut self) -> CGIF6_W {
                CGIF6_W { w: self }
            }
            #[doc = "Bit 19 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif5(&mut self) -> CTEIF5_W {
                CTEIF5_W { w: self }
            }
            #[doc = "Bit 18 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif5(&mut self) -> CHTIF5_W {
                CHTIF5_W { w: self }
            }
            #[doc = "Bit 17 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif5(&mut self) -> CTCIF5_W {
                CTCIF5_W { w: self }
            }
            #[doc = "Bit 16 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif5(&mut self) -> CGIF5_W {
                CGIF5_W { w: self }
            }
            #[doc = "Bit 15 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif4(&mut self) -> CTEIF4_W {
                CTEIF4_W { w: self }
            }
            #[doc = "Bit 14 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif4(&mut self) -> CHTIF4_W {
                CHTIF4_W { w: self }
            }
            #[doc = "Bit 13 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif4(&mut self) -> CTCIF4_W {
                CTCIF4_W { w: self }
            }
            #[doc = "Bit 12 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif4(&mut self) -> CGIF4_W {
                CGIF4_W { w: self }
            }
            #[doc = "Bit 11 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif3(&mut self) -> CTEIF3_W {
                CTEIF3_W { w: self }
            }
            #[doc = "Bit 10 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif3(&mut self) -> CHTIF3_W {
                CHTIF3_W { w: self }
            }
            #[doc = "Bit 9 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif3(&mut self) -> CTCIF3_W {
                CTCIF3_W { w: self }
            }
            #[doc = "Bit 8 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif3(&mut self) -> CGIF3_W {
                CGIF3_W { w: self }
            }
            #[doc = "Bit 7 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif2(&mut self) -> CTEIF2_W {
                CTEIF2_W { w: self }
            }
            #[doc = "Bit 6 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif2(&mut self) -> CHTIF2_W {
                CHTIF2_W { w: self }
            }
            #[doc = "Bit 5 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif2(&mut self) -> CTCIF2_W {
                CTCIF2_W { w: self }
            }
            #[doc = "Bit 4 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif2(&mut self) -> CGIF2_W {
                CGIF2_W { w: self }
            }
            #[doc = "Bit 3 - Channel x transfer error clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cteif1(&mut self) -> CTEIF1_W {
                CTEIF1_W { w: self }
            }
            #[doc = "Bit 2 - Channel x half transfer clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn chtif1(&mut self) -> CHTIF1_W {
                CHTIF1_W { w: self }
            }
            #[doc = "Bit 1 - Channel x transfer complete clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn ctcif1(&mut self) -> CTCIF1_W {
                CTCIF1_W { w: self }
            }
            #[doc = "Bit 0 - Channel x global interrupt clear (x = 1 ..7)"]
            #[inline(always)]
            pub fn cgif1(&mut self) -> CGIF1_W {
                CGIF1_W { w: self }
            }
        }
    }
    #[doc = "channel selection register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cselr](cselr) module"]
    pub type CSELR = crate::Reg<u32, _CSELR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSELR;
    #[doc = "`read()` method returns [cselr::R](cselr::R) reader structure"]
    impl crate::Readable for CSELR {}
    #[doc = "`write(|w| ..)` method takes [cselr::W](cselr::W) writer structure"]
    impl crate::Writable for CSELR {}
    #[doc = "channel selection register"]
    pub mod cselr {
        #[doc = "Reader of register CSELR"]
        pub type R = crate::R<u32, super::CSELR>;
        #[doc = "Writer for register CSELR"]
        pub type W = crate::W<u32, super::CSELR>;
        #[doc = "Register CSELR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSELR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DMA channel 7 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum C7S_A {
            #[doc = "0: Default mapping"]
            NOMAPPING = 0,
            #[doc = "1: Mapping 1"]
            MAP1 = 1,
            #[doc = "2: Mapping 2"]
            MAP2 = 2,
            #[doc = "3: Mapping 3"]
            MAP3 = 3,
            #[doc = "4: Mapping 4"]
            MAP4 = 4,
            #[doc = "5: Mapping 5"]
            MAP5 = 5,
            #[doc = "6: Mapping 6"]
            MAP6 = 6,
            #[doc = "7: Mapping 7"]
            MAP7 = 7,
            #[doc = "8: Mapping 8"]
            MAP8 = 8,
            #[doc = "9: Mapping 9"]
            MAP9 = 9,
            #[doc = "10: Mapping 10"]
            MAP10 = 10,
            #[doc = "11: Mapping 11"]
            MAP11 = 11,
            #[doc = "12: Mapping 12"]
            MAP12 = 12,
            #[doc = "13: Mapping 13"]
            MAP13 = 13,
            #[doc = "14: Mapping 14"]
            MAP14 = 14,
            #[doc = "15: Mapping 15"]
            MAP15 = 15,
        }
        impl From<C7S_A> for u8 {
            #[inline(always)]
            fn from(variant: C7S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `C7S`"]
        pub type C7S_R = crate::R<u8, C7S_A>;
        impl C7S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> C7S_A {
                match self.bits {
                    0 => C7S_A::NOMAPPING,
                    1 => C7S_A::MAP1,
                    2 => C7S_A::MAP2,
                    3 => C7S_A::MAP3,
                    4 => C7S_A::MAP4,
                    5 => C7S_A::MAP5,
                    6 => C7S_A::MAP6,
                    7 => C7S_A::MAP7,
                    8 => C7S_A::MAP8,
                    9 => C7S_A::MAP9,
                    10 => C7S_A::MAP10,
                    11 => C7S_A::MAP11,
                    12 => C7S_A::MAP12,
                    13 => C7S_A::MAP13,
                    14 => C7S_A::MAP14,
                    15 => C7S_A::MAP15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOMAPPING`"]
            #[inline(always)]
            pub fn is_no_mapping(&self) -> bool {
                *self == C7S_A::NOMAPPING
            }
            #[doc = "Checks if the value of the field is `MAP1`"]
            #[inline(always)]
            pub fn is_map1(&self) -> bool {
                *self == C7S_A::MAP1
            }
            #[doc = "Checks if the value of the field is `MAP2`"]
            #[inline(always)]
            pub fn is_map2(&self) -> bool {
                *self == C7S_A::MAP2
            }
            #[doc = "Checks if the value of the field is `MAP3`"]
            #[inline(always)]
            pub fn is_map3(&self) -> bool {
                *self == C7S_A::MAP3
            }
            #[doc = "Checks if the value of the field is `MAP4`"]
            #[inline(always)]
            pub fn is_map4(&self) -> bool {
                *self == C7S_A::MAP4
            }
            #[doc = "Checks if the value of the field is `MAP5`"]
            #[inline(always)]
            pub fn is_map5(&self) -> bool {
                *self == C7S_A::MAP5
            }
            #[doc = "Checks if the value of the field is `MAP6`"]
            #[inline(always)]
            pub fn is_map6(&self) -> bool {
                *self == C7S_A::MAP6
            }
            #[doc = "Checks if the value of the field is `MAP7`"]
            #[inline(always)]
            pub fn is_map7(&self) -> bool {
                *self == C7S_A::MAP7
            }
            #[doc = "Checks if the value of the field is `MAP8`"]
            #[inline(always)]
            pub fn is_map8(&self) -> bool {
                *self == C7S_A::MAP8
            }
            #[doc = "Checks if the value of the field is `MAP9`"]
            #[inline(always)]
            pub fn is_map9(&self) -> bool {
                *self == C7S_A::MAP9
            }
            #[doc = "Checks if the value of the field is `MAP10`"]
            #[inline(always)]
            pub fn is_map10(&self) -> bool {
                *self == C7S_A::MAP10
            }
            #[doc = "Checks if the value of the field is `MAP11`"]
            #[inline(always)]
            pub fn is_map11(&self) -> bool {
                *self == C7S_A::MAP11
            }
            #[doc = "Checks if the value of the field is `MAP12`"]
            #[inline(always)]
            pub fn is_map12(&self) -> bool {
                *self == C7S_A::MAP12
            }
            #[doc = "Checks if the value of the field is `MAP13`"]
            #[inline(always)]
            pub fn is_map13(&self) -> bool {
                *self == C7S_A::MAP13
            }
            #[doc = "Checks if the value of the field is `MAP14`"]
            #[inline(always)]
            pub fn is_map14(&self) -> bool {
                *self == C7S_A::MAP14
            }
            #[doc = "Checks if the value of the field is `MAP15`"]
            #[inline(always)]
            pub fn is_map15(&self) -> bool {
                *self == C7S_A::MAP15
            }
        }
        #[doc = "Write proxy for field `C7S`"]
        pub struct C7S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C7S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C7S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "DMA channel 6 selection"]
        pub type C6S_A = C7S_A;
        #[doc = "Reader of field `C6S`"]
        pub type C6S_R = crate::R<u8, C7S_A>;
        #[doc = "Write proxy for field `C6S`"]
        pub struct C6S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C6S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C6S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "DMA channel 5 selection"]
        pub type C5S_A = C7S_A;
        #[doc = "Reader of field `C5S`"]
        pub type C5S_R = crate::R<u8, C7S_A>;
        #[doc = "Write proxy for field `C5S`"]
        pub struct C5S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C5S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C5S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "DMA channel 4 selection"]
        pub type C4S_A = C7S_A;
        #[doc = "Reader of field `C4S`"]
        pub type C4S_R = crate::R<u8, C7S_A>;
        #[doc = "Write proxy for field `C4S`"]
        pub struct C4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C4S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "DMA channel 3 selection"]
        pub type C3S_A = C7S_A;
        #[doc = "Reader of field `C3S`"]
        pub type C3S_R = crate::R<u8, C7S_A>;
        #[doc = "Write proxy for field `C3S`"]
        pub struct C3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C3S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "DMA channel 2 selection"]
        pub type C2S_A = C7S_A;
        #[doc = "Reader of field `C2S`"]
        pub type C2S_R = crate::R<u8, C7S_A>;
        #[doc = "Write proxy for field `C2S`"]
        pub struct C2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C2S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "DMA channel 1 selection"]
        pub type C1S_A = C7S_A;
        #[doc = "Reader of field `C1S`"]
        pub type C1S_R = crate::R<u8, C7S_A>;
        #[doc = "Write proxy for field `C1S`"]
        pub struct C1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> C1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: C1S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Default mapping"]
            #[inline(always)]
            pub fn no_mapping(self) -> &'a mut W {
                self.variant(C7S_A::NOMAPPING)
            }
            #[doc = "Mapping 1"]
            #[inline(always)]
            pub fn map1(self) -> &'a mut W {
                self.variant(C7S_A::MAP1)
            }
            #[doc = "Mapping 2"]
            #[inline(always)]
            pub fn map2(self) -> &'a mut W {
                self.variant(C7S_A::MAP2)
            }
            #[doc = "Mapping 3"]
            #[inline(always)]
            pub fn map3(self) -> &'a mut W {
                self.variant(C7S_A::MAP3)
            }
            #[doc = "Mapping 4"]
            #[inline(always)]
            pub fn map4(self) -> &'a mut W {
                self.variant(C7S_A::MAP4)
            }
            #[doc = "Mapping 5"]
            #[inline(always)]
            pub fn map5(self) -> &'a mut W {
                self.variant(C7S_A::MAP5)
            }
            #[doc = "Mapping 6"]
            #[inline(always)]
            pub fn map6(self) -> &'a mut W {
                self.variant(C7S_A::MAP6)
            }
            #[doc = "Mapping 7"]
            #[inline(always)]
            pub fn map7(self) -> &'a mut W {
                self.variant(C7S_A::MAP7)
            }
            #[doc = "Mapping 8"]
            #[inline(always)]
            pub fn map8(self) -> &'a mut W {
                self.variant(C7S_A::MAP8)
            }
            #[doc = "Mapping 9"]
            #[inline(always)]
            pub fn map9(self) -> &'a mut W {
                self.variant(C7S_A::MAP9)
            }
            #[doc = "Mapping 10"]
            #[inline(always)]
            pub fn map10(self) -> &'a mut W {
                self.variant(C7S_A::MAP10)
            }
            #[doc = "Mapping 11"]
            #[inline(always)]
            pub fn map11(self) -> &'a mut W {
                self.variant(C7S_A::MAP11)
            }
            #[doc = "Mapping 12"]
            #[inline(always)]
            pub fn map12(self) -> &'a mut W {
                self.variant(C7S_A::MAP12)
            }
            #[doc = "Mapping 13"]
            #[inline(always)]
            pub fn map13(self) -> &'a mut W {
                self.variant(C7S_A::MAP13)
            }
            #[doc = "Mapping 14"]
            #[inline(always)]
            pub fn map14(self) -> &'a mut W {
                self.variant(C7S_A::MAP14)
            }
            #[doc = "Mapping 15"]
            #[inline(always)]
            pub fn map15(self) -> &'a mut W {
                self.variant(C7S_A::MAP15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 24:27 - DMA channel 7 selection"]
            #[inline(always)]
            pub fn c7s(&self) -> C7S_R {
                C7S_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - DMA channel 6 selection"]
            #[inline(always)]
            pub fn c6s(&self) -> C6S_R {
                C6S_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - DMA channel 5 selection"]
            #[inline(always)]
            pub fn c5s(&self) -> C5S_R {
                C5S_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - DMA channel 4 selection"]
            #[inline(always)]
            pub fn c4s(&self) -> C4S_R {
                C4S_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - DMA channel 3 selection"]
            #[inline(always)]
            pub fn c3s(&self) -> C3S_R {
                C3S_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - DMA channel 2 selection"]
            #[inline(always)]
            pub fn c2s(&self) -> C2S_R {
                C2S_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - DMA channel 1 selection"]
            #[inline(always)]
            pub fn c1s(&self) -> C1S_R {
                C1S_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 24:27 - DMA channel 7 selection"]
            #[inline(always)]
            pub fn c7s(&mut self) -> C7S_W {
                C7S_W { w: self }
            }
            #[doc = "Bits 20:23 - DMA channel 6 selection"]
            #[inline(always)]
            pub fn c6s(&mut self) -> C6S_W {
                C6S_W { w: self }
            }
            #[doc = "Bits 16:19 - DMA channel 5 selection"]
            #[inline(always)]
            pub fn c5s(&mut self) -> C5S_W {
                C5S_W { w: self }
            }
            #[doc = "Bits 12:15 - DMA channel 4 selection"]
            #[inline(always)]
            pub fn c4s(&mut self) -> C4S_W {
                C4S_W { w: self }
            }
            #[doc = "Bits 8:11 - DMA channel 3 selection"]
            #[inline(always)]
            pub fn c3s(&mut self) -> C3S_W {
                C3S_W { w: self }
            }
            #[doc = "Bits 4:7 - DMA channel 2 selection"]
            #[inline(always)]
            pub fn c2s(&mut self) -> C2S_W {
                C2S_W { w: self }
            }
            #[doc = "Bits 0:3 - DMA channel 1 selection"]
            #[inline(always)]
            pub fn c1s(&mut self) -> C1S_W {
                C1S_W { w: self }
            }
        }
    }
}
#[doc = "Cyclic redundancy check calculation unit"]
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        0x4002_3000 as *const _
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*CRC::ptr() }
    }
}
#[doc = "Cyclic redundancy check calculation unit"]
pub mod crc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved_0_dr: [u8; 4usize],
        #[doc = "0x04 - Independent data register"]
        pub idr: IDR,
        #[doc = "0x08 - Control register"]
        pub cr: CR,
        _reserved3: [u8; 4usize],
        #[doc = "0x10 - Initial CRC value"]
        pub init: INIT,
        #[doc = "0x14 - polynomial"]
        pub pol: POL,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Data register - half-word sized"]
        #[inline(always)]
        pub fn dr16(&self) -> &DR16 {
            unsafe { &*(((self as *const Self) as *const u8).add(0usize) as *const DR16) }
        }
        #[doc = "0x00 - Data register - half-word sized"]
        #[inline(always)]
        pub fn dr16_mut(&self) -> &mut DR16 {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(0usize) as *mut DR16) }
        }
        #[doc = "0x00 - Data register - byte sized"]
        #[inline(always)]
        pub fn dr8(&self) -> &DR8 {
            unsafe { &*(((self as *const Self) as *const u8).add(0usize) as *const DR8) }
        }
        #[doc = "0x00 - Data register - byte sized"]
        #[inline(always)]
        pub fn dr8_mut(&self) -> &mut DR8 {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(0usize) as *mut DR8) }
        }
        #[doc = "0x00 - Data register"]
        #[inline(always)]
        pub fn dr(&self) -> &DR {
            unsafe { &*(((self as *const Self) as *const u8).add(0usize) as *const DR) }
        }
        #[doc = "0x00 - Data register"]
        #[inline(always)]
        pub fn dr_mut(&self) -> &mut DR {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(0usize) as *mut DR) }
        }
    }
    #[doc = "Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0xffff_ffff"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff_ffff
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Data register bits"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Data register bits"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "Independent data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "`write(|w| ..)` method takes [idr::W](idr::W) writer structure"]
    impl crate::Writable for IDR {}
    #[doc = "Independent data register"]
    pub mod idr {
        #[doc = "Reader of register IDR"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Writer for register IDR"]
        pub type W = crate::W<u32, super::IDR>;
        #[doc = "Register IDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IDR`"]
        pub type IDR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IDR`"]
        pub struct IDR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - General-purpose 8-bit data register bits"]
            #[inline(always)]
            pub fn idr(&self) -> IDR_R {
                IDR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - General-purpose 8-bit data register bits"]
            #[inline(always)]
            pub fn idr(&mut self) -> IDR_W {
                IDR_W { w: self }
            }
        }
    }
    #[doc = "Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reverse output data\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REV_OUT_A {
            #[doc = "0: Bit order not affected"]
            NORMAL = 0,
            #[doc = "1: Bit reversed output"]
            REVERSED = 1,
        }
        impl From<REV_OUT_A> for bool {
            #[inline(always)]
            fn from(variant: REV_OUT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `REV_OUT`"]
        pub type REV_OUT_R = crate::R<bool, REV_OUT_A>;
        impl REV_OUT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> REV_OUT_A {
                match self.bits {
                    false => REV_OUT_A::NORMAL,
                    true => REV_OUT_A::REVERSED,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == REV_OUT_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `REVERSED`"]
            #[inline(always)]
            pub fn is_reversed(&self) -> bool {
                *self == REV_OUT_A::REVERSED
            }
        }
        #[doc = "Write proxy for field `REV_OUT`"]
        pub struct REV_OUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REV_OUT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REV_OUT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Bit order not affected"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(REV_OUT_A::NORMAL)
            }
            #[doc = "Bit reversed output"]
            #[inline(always)]
            pub fn reversed(self) -> &'a mut W {
                self.variant(REV_OUT_A::REVERSED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reverse input data\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum REV_IN_A {
            #[doc = "0: Bit order not affected"]
            NORMAL = 0,
            #[doc = "1: Bit reversal done by byte"]
            BYTE = 1,
            #[doc = "2: Bit reversal done by half-word"]
            HALFWORD = 2,
            #[doc = "3: Bit reversal done by word"]
            WORD = 3,
        }
        impl From<REV_IN_A> for u8 {
            #[inline(always)]
            fn from(variant: REV_IN_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `REV_IN`"]
        pub type REV_IN_R = crate::R<u8, REV_IN_A>;
        impl REV_IN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> REV_IN_A {
                match self.bits {
                    0 => REV_IN_A::NORMAL,
                    1 => REV_IN_A::BYTE,
                    2 => REV_IN_A::HALFWORD,
                    3 => REV_IN_A::WORD,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == REV_IN_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `BYTE`"]
            #[inline(always)]
            pub fn is_byte(&self) -> bool {
                *self == REV_IN_A::BYTE
            }
            #[doc = "Checks if the value of the field is `HALFWORD`"]
            #[inline(always)]
            pub fn is_half_word(&self) -> bool {
                *self == REV_IN_A::HALFWORD
            }
            #[doc = "Checks if the value of the field is `WORD`"]
            #[inline(always)]
            pub fn is_word(&self) -> bool {
                *self == REV_IN_A::WORD
            }
        }
        #[doc = "Write proxy for field `REV_IN`"]
        pub struct REV_IN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REV_IN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REV_IN_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Bit order not affected"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(REV_IN_A::NORMAL)
            }
            #[doc = "Bit reversal done by byte"]
            #[inline(always)]
            pub fn byte(self) -> &'a mut W {
                self.variant(REV_IN_A::BYTE)
            }
            #[doc = "Bit reversal done by half-word"]
            #[inline(always)]
            pub fn half_word(self) -> &'a mut W {
                self.variant(REV_IN_A::HALFWORD)
            }
            #[doc = "Bit reversal done by word"]
            #[inline(always)]
            pub fn word(self) -> &'a mut W {
                self.variant(REV_IN_A::WORD)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "Polynomial size\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum POLYSIZE_A {
            #[doc = "0: 32-bit polynomial"]
            POLYSIZE32 = 0,
            #[doc = "1: 16-bit polynomial"]
            POLYSIZE16 = 1,
            #[doc = "2: 8-bit polynomial"]
            POLYSIZE8 = 2,
            #[doc = "3: 7-bit polynomial"]
            POLYSIZE7 = 3,
        }
        impl From<POLYSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: POLYSIZE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `POLYSIZE`"]
        pub type POLYSIZE_R = crate::R<u8, POLYSIZE_A>;
        impl POLYSIZE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> POLYSIZE_A {
                match self.bits {
                    0 => POLYSIZE_A::POLYSIZE32,
                    1 => POLYSIZE_A::POLYSIZE16,
                    2 => POLYSIZE_A::POLYSIZE8,
                    3 => POLYSIZE_A::POLYSIZE7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `POLYSIZE32`"]
            #[inline(always)]
            pub fn is_polysize32(&self) -> bool {
                *self == POLYSIZE_A::POLYSIZE32
            }
            #[doc = "Checks if the value of the field is `POLYSIZE16`"]
            #[inline(always)]
            pub fn is_polysize16(&self) -> bool {
                *self == POLYSIZE_A::POLYSIZE16
            }
            #[doc = "Checks if the value of the field is `POLYSIZE8`"]
            #[inline(always)]
            pub fn is_polysize8(&self) -> bool {
                *self == POLYSIZE_A::POLYSIZE8
            }
            #[doc = "Checks if the value of the field is `POLYSIZE7`"]
            #[inline(always)]
            pub fn is_polysize7(&self) -> bool {
                *self == POLYSIZE_A::POLYSIZE7
            }
        }
        #[doc = "Write proxy for field `POLYSIZE`"]
        pub struct POLYSIZE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POLYSIZE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: POLYSIZE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "32-bit polynomial"]
            #[inline(always)]
            pub fn polysize32(self) -> &'a mut W {
                self.variant(POLYSIZE_A::POLYSIZE32)
            }
            #[doc = "16-bit polynomial"]
            #[inline(always)]
            pub fn polysize16(self) -> &'a mut W {
                self.variant(POLYSIZE_A::POLYSIZE16)
            }
            #[doc = "8-bit polynomial"]
            #[inline(always)]
            pub fn polysize8(self) -> &'a mut W {
                self.variant(POLYSIZE_A::POLYSIZE8)
            }
            #[doc = "7-bit polynomial"]
            #[inline(always)]
            pub fn polysize7(self) -> &'a mut W {
                self.variant(POLYSIZE_A::POLYSIZE7)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        #[doc = "RESET bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESET_AW {
            #[doc = "1: Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF"]
            RESET = 1,
        }
        impl From<RESET_AW> for bool {
            #[inline(always)]
            fn from(variant: RESET_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RESET`"]
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RESET_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RESET_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Reverse output data"]
            #[inline(always)]
            pub fn rev_out(&self) -> REV_OUT_R {
                REV_OUT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - Reverse input data"]
            #[inline(always)]
            pub fn rev_in(&self) -> REV_IN_R {
                REV_IN_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bits 3:4 - Polynomial size"]
            #[inline(always)]
            pub fn polysize(&self) -> POLYSIZE_R {
                POLYSIZE_R::new(((self.bits >> 3) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 7 - Reverse output data"]
            #[inline(always)]
            pub fn rev_out(&mut self) -> REV_OUT_W {
                REV_OUT_W { w: self }
            }
            #[doc = "Bits 5:6 - Reverse input data"]
            #[inline(always)]
            pub fn rev_in(&mut self) -> REV_IN_W {
                REV_IN_W { w: self }
            }
            #[doc = "Bits 3:4 - Polynomial size"]
            #[inline(always)]
            pub fn polysize(&mut self) -> POLYSIZE_W {
                POLYSIZE_W { w: self }
            }
            #[doc = "Bit 0 - RESET bit"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
        }
    }
    #[doc = "Initial CRC value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [init](init) module"]
    pub type INIT = crate::Reg<u32, _INIT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INIT;
    #[doc = "`read()` method returns [init::R](init::R) reader structure"]
    impl crate::Readable for INIT {}
    #[doc = "`write(|w| ..)` method takes [init::W](init::W) writer structure"]
    impl crate::Writable for INIT {}
    #[doc = "Initial CRC value"]
    pub mod init {
        #[doc = "Reader of register INIT"]
        pub type R = crate::R<u32, super::INIT>;
        #[doc = "Writer for register INIT"]
        pub type W = crate::W<u32, super::INIT>;
        #[doc = "Register INIT `reset()`'s with value 0xffff_ffff"]
        impl crate::ResetValue for super::INIT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff_ffff
            }
        }
        #[doc = "Reader of field `INIT`"]
        pub type INIT_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `INIT`"]
        pub struct INIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INIT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Programmable initial CRC value"]
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Programmable initial CRC value"]
            #[inline(always)]
            pub fn init(&mut self) -> INIT_W {
                INIT_W { w: self }
            }
        }
    }
    #[doc = "polynomial\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pol](pol) module"]
    pub type POL = crate::Reg<u32, _POL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _POL;
    #[doc = "`read()` method returns [pol::R](pol::R) reader structure"]
    impl crate::Readable for POL {}
    #[doc = "`write(|w| ..)` method takes [pol::W](pol::W) writer structure"]
    impl crate::Writable for POL {}
    #[doc = "polynomial"]
    pub mod pol {
        #[doc = "Reader of register POL"]
        pub type R = crate::R<u32, super::POL>;
        #[doc = "Writer for register POL"]
        pub type W = crate::W<u32, super::POL>;
        #[doc = "Register POL `reset()`'s with value 0x04c1_1db7"]
        impl crate::ResetValue for super::POL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x04c1_1db7
            }
        }
        #[doc = "Reader of field `POL`"]
        pub type POL_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `POL`"]
        pub struct POL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Programmable polynomial"]
            #[inline(always)]
            pub fn pol(&self) -> POL_R {
                POL_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Programmable polynomial"]
            #[inline(always)]
            pub fn pol(&mut self) -> POL_W {
                POL_W { w: self }
            }
        }
    }
    #[doc = "Data register - byte sized\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr8](dr8) module"]
    pub type DR8 = crate::Reg<u8, _DR8>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR8;
    #[doc = "`read()` method returns [dr8::R](dr8::R) reader structure"]
    impl crate::Readable for DR8 {}
    #[doc = "`write(|w| ..)` method takes [dr8::W](dr8::W) writer structure"]
    impl crate::Writable for DR8 {}
    #[doc = "Data register - byte sized"]
    pub mod dr8 {
        #[doc = "Reader of register DR8"]
        pub type R = crate::R<u8, super::DR8>;
        #[doc = "Writer for register DR8"]
        pub type W = crate::W<u8, super::DR8>;
        #[doc = "Register DR8 `reset()`'s with value 0xff"]
        impl crate::ResetValue for super::DR8 {
            type Type = u8;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xff
            }
        }
        #[doc = "Reader of field `DR8`"]
        pub type DR8_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DR8`"]
        pub struct DR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR8_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u8) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Data register bits"]
            #[inline(always)]
            pub fn dr8(&self) -> DR8_R {
                DR8_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data register bits"]
            #[inline(always)]
            pub fn dr8(&mut self) -> DR8_W {
                DR8_W { w: self }
            }
        }
    }
    #[doc = "Data register - half-word sized\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr16](dr16) module"]
    pub type DR16 = crate::Reg<u16, _DR16>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR16;
    #[doc = "`read()` method returns [dr16::R](dr16::R) reader structure"]
    impl crate::Readable for DR16 {}
    #[doc = "`write(|w| ..)` method takes [dr16::W](dr16::W) writer structure"]
    impl crate::Writable for DR16 {}
    #[doc = "Data register - half-word sized"]
    pub mod dr16 {
        #[doc = "Reader of register DR16"]
        pub type R = crate::R<u16, super::DR16>;
        #[doc = "Writer for register DR16"]
        pub type W = crate::W<u16, super::DR16>;
        #[doc = "Register DR16 `reset()`'s with value 0xffff"]
        impl crate::ResetValue for super::DR16 {
            type Type = u16;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff
            }
        }
        #[doc = "Reader of field `DR16`"]
        pub type DR16_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DR16`"]
        pub struct DR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR16_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u16) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Data register bits"]
            #[inline(always)]
            pub fn dr16(&self) -> DR16_R {
                DR16_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Data register bits"]
            #[inline(always)]
            pub fn dr16(&mut self) -> DR16_W {
                DR16_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose I/Os"]
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        0x5000_0000 as *const _
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOA::ptr() }
    }
}
#[doc = "General-purpose I/Os"]
pub mod gpioa {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - GPIO port mode register"]
        pub moder: MODER,
        #[doc = "0x04 - GPIO port output type register"]
        pub otyper: OTYPER,
        #[doc = "0x08 - GPIO port output speed register"]
        pub ospeedr: OSPEEDR,
        #[doc = "0x0c - GPIO port pull-up/pull-down register"]
        pub pupdr: PUPDR,
        #[doc = "0x10 - GPIO port input data register"]
        pub idr: IDR,
        #[doc = "0x14 - GPIO port output data register"]
        pub odr: ODR,
        #[doc = "0x18 - GPIO port bit set/reset register"]
        pub bsrr: BSRR,
        #[doc = "0x1c - GPIO port configuration lock register"]
        pub lckr: LCKR,
        #[doc = "0x20 - GPIO alternate function low register"]
        pub afrl: AFRL,
        #[doc = "0x24 - GPIO alternate function high register"]
        pub afrh: AFRH,
        #[doc = "0x28 - GPIO port bit reset register"]
        pub brr: BRR,
    }
    #[doc = "GPIO port mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [moder](moder) module"]
    pub type MODER = crate::Reg<u32, _MODER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MODER;
    #[doc = "`read()` method returns [moder::R](moder::R) reader structure"]
    impl crate::Readable for MODER {}
    #[doc = "`write(|w| ..)` method takes [moder::W](moder::W) writer structure"]
    impl crate::Writable for MODER {}
    #[doc = "GPIO port mode register"]
    pub mod moder {
        #[doc = "Reader of register MODER"]
        pub type R = crate::R<u32, super::MODER>;
        #[doc = "Writer for register MODER"]
        pub type W = crate::W<u32, super::MODER>;
        #[doc = "Register MODER `reset()`'s with value 0xebff_fcff"]
        impl crate::ResetValue for super::MODER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xebff_fcff
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 3"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE0_A {
            #[doc = "0: Input mode (reset state)"]
            INPUT = 0,
            #[doc = "1: General purpose output mode"]
            OUTPUT = 1,
            #[doc = "2: Alternate function mode"]
            ALTERNATE = 2,
            #[doc = "3: Analog mode"]
            ANALOG = 3,
        }
        impl From<MODE0_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE0_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MODE0`"]
        pub type MODE0_R = crate::R<u8, MODE0_A>;
        impl MODE0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODE0_A {
                match self.bits {
                    0 => MODE0_A::INPUT,
                    1 => MODE0_A::OUTPUT,
                    2 => MODE0_A::ALTERNATE,
                    3 => MODE0_A::ANALOG,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == MODE0_A::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == MODE0_A::OUTPUT
            }
            #[doc = "Checks if the value of the field is `ALTERNATE`"]
            #[inline(always)]
            pub fn is_alternate(&self) -> bool {
                *self == MODE0_A::ALTERNATE
            }
            #[doc = "Checks if the value of the field is `ANALOG`"]
            #[inline(always)]
            pub fn is_analog(&self) -> bool {
                *self == MODE0_A::ANALOG
            }
        }
        #[doc = "Write proxy for field `MODE0`"]
        pub struct MODE0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE1_A = MODE0_A;
        #[doc = "Reader of field `MODE1`"]
        pub type MODE1_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE1`"]
        pub struct MODE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE2_A = MODE0_A;
        #[doc = "Reader of field `MODE2`"]
        pub type MODE2_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE2`"]
        pub struct MODE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE3_A = MODE0_A;
        #[doc = "Reader of field `MODE3`"]
        pub type MODE3_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE3`"]
        pub struct MODE3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE4_A = MODE0_A;
        #[doc = "Reader of field `MODE4`"]
        pub type MODE4_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE4`"]
        pub struct MODE4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE5_A = MODE0_A;
        #[doc = "Reader of field `MODE5`"]
        pub type MODE5_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE5`"]
        pub struct MODE5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE6_A = MODE0_A;
        #[doc = "Reader of field `MODE6`"]
        pub type MODE6_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE6`"]
        pub struct MODE6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE7_A = MODE0_A;
        #[doc = "Reader of field `MODE7`"]
        pub type MODE7_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE7`"]
        pub struct MODE7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE8_A = MODE0_A;
        #[doc = "Reader of field `MODE8`"]
        pub type MODE8_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE8`"]
        pub struct MODE8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE9_A = MODE0_A;
        #[doc = "Reader of field `MODE9`"]
        pub type MODE9_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE9`"]
        pub struct MODE9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE10_A = MODE0_A;
        #[doc = "Reader of field `MODE10`"]
        pub type MODE10_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE10`"]
        pub struct MODE10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE11_A = MODE0_A;
        #[doc = "Reader of field `MODE11`"]
        pub type MODE11_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE11`"]
        pub struct MODE11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE12_A = MODE0_A;
        #[doc = "Reader of field `MODE12`"]
        pub type MODE12_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE12`"]
        pub struct MODE12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE13_A = MODE0_A;
        #[doc = "Reader of field `MODE13`"]
        pub type MODE13_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE13`"]
        pub struct MODE13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE14_A = MODE0_A;
        #[doc = "Reader of field `MODE14`"]
        pub type MODE14_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE14`"]
        pub struct MODE14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE15_A = MODE0_A;
        #[doc = "Reader of field `MODE15`"]
        pub type MODE15_R = crate::R<u8, MODE0_A>;
        #[doc = "Write proxy for field `MODE15`"]
        pub struct MODE15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE0_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE0_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode8(&self) -> MODE8_R {
                MODE8_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode9(&self) -> MODE9_R {
                MODE9_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode10(&self) -> MODE10_R {
                MODE10_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode11(&self) -> MODE11_R {
                MODE11_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode12(&self) -> MODE12_R {
                MODE12_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode13(&self) -> MODE13_R {
                MODE13_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode14(&self) -> MODE14_R {
                MODE14_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode15(&self) -> MODE15_R {
                MODE15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode0(&mut self) -> MODE0_W {
                MODE0_W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode1(&mut self) -> MODE1_W {
                MODE1_W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode2(&mut self) -> MODE2_W {
                MODE2_W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode3(&mut self) -> MODE3_W {
                MODE3_W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode4(&mut self) -> MODE4_W {
                MODE4_W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode5(&mut self) -> MODE5_W {
                MODE5_W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode6(&mut self) -> MODE6_W {
                MODE6_W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode7(&mut self) -> MODE7_W {
                MODE7_W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode8(&mut self) -> MODE8_W {
                MODE8_W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode9(&mut self) -> MODE9_W {
                MODE9_W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode10(&mut self) -> MODE10_W {
                MODE10_W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode11(&mut self) -> MODE11_W {
                MODE11_W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode12(&mut self) -> MODE12_W {
                MODE12_W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode13(&mut self) -> MODE13_W {
                MODE13_W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode14(&mut self) -> MODE14_W {
                MODE14_W { w: self }
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode15(&mut self) -> MODE15_W {
                MODE15_W { w: self }
            }
        }
    }
    #[doc = "GPIO port output type register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [otyper](otyper) module"]
    pub type OTYPER = crate::Reg<u32, _OTYPER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OTYPER;
    #[doc = "`read()` method returns [otyper::R](otyper::R) reader structure"]
    impl crate::Readable for OTYPER {}
    #[doc = "`write(|w| ..)` method takes [otyper::W](otyper::W) writer structure"]
    impl crate::Writable for OTYPER {}
    #[doc = "GPIO port output type register"]
    pub mod otyper {
        #[doc = "Reader of register OTYPER"]
        pub type R = crate::R<u32, super::OTYPER>;
        #[doc = "Writer for register OTYPER"]
        pub type W = crate::W<u32, super::OTYPER>;
        #[doc = "Register OTYPER `reset()`'s with value 0"]
        impl crate::ResetValue for super::OTYPER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OT15_A {
            #[doc = "0: Output push-pull (reset state)"]
            PUSHPULL = 0,
            #[doc = "1: Output open-drain"]
            OPENDRAIN = 1,
        }
        impl From<OT15_A> for bool {
            #[inline(always)]
            fn from(variant: OT15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OT15`"]
        pub type OT15_R = crate::R<bool, OT15_A>;
        impl OT15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OT15_A {
                match self.bits {
                    false => OT15_A::PUSHPULL,
                    true => OT15_A::OPENDRAIN,
                }
            }
            #[doc = "Checks if the value of the field is `PUSHPULL`"]
            #[inline(always)]
            pub fn is_push_pull(&self) -> bool {
                *self == OT15_A::PUSHPULL
            }
            #[doc = "Checks if the value of the field is `OPENDRAIN`"]
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                *self == OT15_A::OPENDRAIN
            }
        }
        #[doc = "Write proxy for field `OT15`"]
        pub struct OT15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT14_A = OT15_A;
        #[doc = "Reader of field `OT14`"]
        pub type OT14_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT14`"]
        pub struct OT14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT13_A = OT15_A;
        #[doc = "Reader of field `OT13`"]
        pub type OT13_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT13`"]
        pub struct OT13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT12_A = OT15_A;
        #[doc = "Reader of field `OT12`"]
        pub type OT12_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT12`"]
        pub struct OT12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT11_A = OT15_A;
        #[doc = "Reader of field `OT11`"]
        pub type OT11_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT11`"]
        pub struct OT11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT10_A = OT15_A;
        #[doc = "Reader of field `OT10`"]
        pub type OT10_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT10`"]
        pub struct OT10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT9_A = OT15_A;
        #[doc = "Reader of field `OT9`"]
        pub type OT9_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT9`"]
        pub struct OT9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT8_A = OT15_A;
        #[doc = "Reader of field `OT8`"]
        pub type OT8_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT8`"]
        pub struct OT8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT7_A = OT15_A;
        #[doc = "Reader of field `OT7`"]
        pub type OT7_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT7`"]
        pub struct OT7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT6_A = OT15_A;
        #[doc = "Reader of field `OT6`"]
        pub type OT6_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT6`"]
        pub struct OT6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT5_A = OT15_A;
        #[doc = "Reader of field `OT5`"]
        pub type OT5_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT5`"]
        pub struct OT5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT4_A = OT15_A;
        #[doc = "Reader of field `OT4`"]
        pub type OT4_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT4`"]
        pub struct OT4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT3_A = OT15_A;
        #[doc = "Reader of field `OT3`"]
        pub type OT3_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT3`"]
        pub struct OT3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT2_A = OT15_A;
        #[doc = "Reader of field `OT2`"]
        pub type OT2_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT2`"]
        pub struct OT2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT1_A = OT15_A;
        #[doc = "Reader of field `OT1`"]
        pub type OT1_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT1`"]
        pub struct OT1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT0_A = OT15_A;
        #[doc = "Reader of field `OT0`"]
        pub type OT0_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT0`"]
        pub struct OT0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot15(&self) -> OT15_R {
                OT15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot14(&self) -> OT14_R {
                OT14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot13(&self) -> OT13_R {
                OT13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot12(&self) -> OT12_R {
                OT12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot11(&self) -> OT11_R {
                OT11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot10(&self) -> OT10_R {
                OT10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot9(&self) -> OT9_R {
                OT9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot8(&self) -> OT8_R {
                OT8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot7(&self) -> OT7_R {
                OT7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot6(&self) -> OT6_R {
                OT6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot5(&self) -> OT5_R {
                OT5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot4(&self) -> OT4_R {
                OT4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot3(&self) -> OT3_R {
                OT3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot2(&self) -> OT2_R {
                OT2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot1(&self) -> OT1_R {
                OT1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot0(&self) -> OT0_R {
                OT0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot15(&mut self) -> OT15_W {
                OT15_W { w: self }
            }
            #[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot14(&mut self) -> OT14_W {
                OT14_W { w: self }
            }
            #[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot13(&mut self) -> OT13_W {
                OT13_W { w: self }
            }
            #[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot12(&mut self) -> OT12_W {
                OT12_W { w: self }
            }
            #[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot11(&mut self) -> OT11_W {
                OT11_W { w: self }
            }
            #[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot10(&mut self) -> OT10_W {
                OT10_W { w: self }
            }
            #[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot9(&mut self) -> OT9_W {
                OT9_W { w: self }
            }
            #[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot8(&mut self) -> OT8_W {
                OT8_W { w: self }
            }
            #[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot7(&mut self) -> OT7_W {
                OT7_W { w: self }
            }
            #[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot6(&mut self) -> OT6_W {
                OT6_W { w: self }
            }
            #[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot5(&mut self) -> OT5_W {
                OT5_W { w: self }
            }
            #[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot4(&mut self) -> OT4_W {
                OT4_W { w: self }
            }
            #[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot3(&mut self) -> OT3_W {
                OT3_W { w: self }
            }
            #[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot2(&mut self) -> OT2_W {
                OT2_W { w: self }
            }
            #[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot1(&mut self) -> OT1_W {
                OT1_W { w: self }
            }
            #[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot0(&mut self) -> OT0_W {
                OT0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port output speed register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ospeedr](ospeedr) module"]
    pub type OSPEEDR = crate::Reg<u32, _OSPEEDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OSPEEDR;
    #[doc = "`read()` method returns [ospeedr::R](ospeedr::R) reader structure"]
    impl crate::Readable for OSPEEDR {}
    #[doc = "`write(|w| ..)` method takes [ospeedr::W](ospeedr::W) writer structure"]
    impl crate::Writable for OSPEEDR {}
    #[doc = "GPIO port output speed register"]
    pub mod ospeedr {
        #[doc = "Reader of register OSPEEDR"]
        pub type R = crate::R<u32, super::OSPEEDR>;
        #[doc = "Writer for register OSPEEDR"]
        pub type W = crate::W<u32, super::OSPEEDR>;
        #[doc = "Register OSPEEDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OSPEEDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OSPEED15_A {
            #[doc = "0: Low speed"]
            LOWSPEED = 0,
            #[doc = "1: Medium speed"]
            MEDIUMSPEED = 1,
            #[doc = "2: High speed"]
            HIGHSPEED = 2,
            #[doc = "3: Very high speed"]
            VERYHIGHSPEED = 3,
        }
        impl From<OSPEED15_A> for u8 {
            #[inline(always)]
            fn from(variant: OSPEED15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OSPEED15`"]
        pub type OSPEED15_R = crate::R<u8, OSPEED15_A>;
        impl OSPEED15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OSPEED15_A {
                match self.bits {
                    0 => OSPEED15_A::LOWSPEED,
                    1 => OSPEED15_A::MEDIUMSPEED,
                    2 => OSPEED15_A::HIGHSPEED,
                    3 => OSPEED15_A::VERYHIGHSPEED,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOWSPEED`"]
            #[inline(always)]
            pub fn is_low_speed(&self) -> bool {
                *self == OSPEED15_A::LOWSPEED
            }
            #[doc = "Checks if the value of the field is `MEDIUMSPEED`"]
            #[inline(always)]
            pub fn is_medium_speed(&self) -> bool {
                *self == OSPEED15_A::MEDIUMSPEED
            }
            #[doc = "Checks if the value of the field is `HIGHSPEED`"]
            #[inline(always)]
            pub fn is_high_speed(&self) -> bool {
                *self == OSPEED15_A::HIGHSPEED
            }
            #[doc = "Checks if the value of the field is `VERYHIGHSPEED`"]
            #[inline(always)]
            pub fn is_very_high_speed(&self) -> bool {
                *self == OSPEED15_A::VERYHIGHSPEED
            }
        }
        #[doc = "Write proxy for field `OSPEED15`"]
        pub struct OSPEED15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED14_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED14`"]
        pub type OSPEED14_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED14`"]
        pub struct OSPEED14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED13_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED13`"]
        pub type OSPEED13_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED13`"]
        pub struct OSPEED13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED12_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED12`"]
        pub type OSPEED12_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED12`"]
        pub struct OSPEED12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED11_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED11`"]
        pub type OSPEED11_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED11`"]
        pub struct OSPEED11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED10_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED10`"]
        pub type OSPEED10_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED10`"]
        pub struct OSPEED10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED9_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED9`"]
        pub type OSPEED9_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED9`"]
        pub struct OSPEED9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED8_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED8`"]
        pub type OSPEED8_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED8`"]
        pub struct OSPEED8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED7_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED7`"]
        pub type OSPEED7_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED7`"]
        pub struct OSPEED7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED6_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED6`"]
        pub type OSPEED6_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED6`"]
        pub struct OSPEED6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED5_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED5`"]
        pub type OSPEED5_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED5`"]
        pub struct OSPEED5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED4_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED4`"]
        pub type OSPEED4_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED4`"]
        pub struct OSPEED4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED3_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED3`"]
        pub type OSPEED3_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED3`"]
        pub struct OSPEED3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED2_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED2`"]
        pub type OSPEED2_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED2`"]
        pub struct OSPEED2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED1_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED1`"]
        pub type OSPEED1_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED1`"]
        pub struct OSPEED1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED0_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED0`"]
        pub type OSPEED0_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED0`"]
        pub struct OSPEED0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed15(&self) -> OSPEED15_R {
                OSPEED15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed14(&self) -> OSPEED14_R {
                OSPEED14_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed13(&self) -> OSPEED13_R {
                OSPEED13_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed12(&self) -> OSPEED12_R {
                OSPEED12_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed11(&self) -> OSPEED11_R {
                OSPEED11_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed10(&self) -> OSPEED10_R {
                OSPEED10_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed9(&self) -> OSPEED9_R {
                OSPEED9_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed8(&self) -> OSPEED8_R {
                OSPEED8_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed7(&self) -> OSPEED7_R {
                OSPEED7_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed6(&self) -> OSPEED6_R {
                OSPEED6_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed5(&self) -> OSPEED5_R {
                OSPEED5_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed4(&self) -> OSPEED4_R {
                OSPEED4_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed3(&self) -> OSPEED3_R {
                OSPEED3_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed2(&self) -> OSPEED2_R {
                OSPEED2_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed1(&self) -> OSPEED1_R {
                OSPEED1_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed0(&self) -> OSPEED0_R {
                OSPEED0_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed15(&mut self) -> OSPEED15_W {
                OSPEED15_W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed14(&mut self) -> OSPEED14_W {
                OSPEED14_W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed13(&mut self) -> OSPEED13_W {
                OSPEED13_W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed12(&mut self) -> OSPEED12_W {
                OSPEED12_W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed11(&mut self) -> OSPEED11_W {
                OSPEED11_W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed10(&mut self) -> OSPEED10_W {
                OSPEED10_W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed9(&mut self) -> OSPEED9_W {
                OSPEED9_W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed8(&mut self) -> OSPEED8_W {
                OSPEED8_W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed7(&mut self) -> OSPEED7_W {
                OSPEED7_W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed6(&mut self) -> OSPEED6_W {
                OSPEED6_W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed5(&mut self) -> OSPEED5_W {
                OSPEED5_W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed4(&mut self) -> OSPEED4_W {
                OSPEED4_W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed3(&mut self) -> OSPEED3_W {
                OSPEED3_W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed2(&mut self) -> OSPEED2_W {
                OSPEED2_W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed1(&mut self) -> OSPEED1_W {
                OSPEED1_W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed0(&mut self) -> OSPEED0_W {
                OSPEED0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port pull-up/pull-down register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pupdr](pupdr) module"]
    pub type PUPDR = crate::Reg<u32, _PUPDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PUPDR;
    #[doc = "`read()` method returns [pupdr::R](pupdr::R) reader structure"]
    impl crate::Readable for PUPDR {}
    #[doc = "`write(|w| ..)` method takes [pupdr::W](pupdr::W) writer structure"]
    impl crate::Writable for PUPDR {}
    #[doc = "GPIO port pull-up/pull-down register"]
    pub mod pupdr {
        #[doc = "Reader of register PUPDR"]
        pub type R = crate::R<u32, super::PUPDR>;
        #[doc = "Writer for register PUPDR"]
        pub type W = crate::W<u32, super::PUPDR>;
        #[doc = "Register PUPDR `reset()`'s with value 0x2400_0000"]
        impl crate::ResetValue for super::PUPDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x2400_0000
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PUPD15_A {
            #[doc = "0: No pull-up, pull-down"]
            FLOATING = 0,
            #[doc = "1: Pull-up"]
            PULLUP = 1,
            #[doc = "2: Pull-down"]
            PULLDOWN = 2,
        }
        impl From<PUPD15_A> for u8 {
            #[inline(always)]
            fn from(variant: PUPD15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PUPD15`"]
        pub type PUPD15_R = crate::R<u8, PUPD15_A>;
        impl PUPD15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PUPD15_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(PUPD15_A::FLOATING),
                    1 => Val(PUPD15_A::PULLUP),
                    2 => Val(PUPD15_A::PULLDOWN),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `FLOATING`"]
            #[inline(always)]
            pub fn is_floating(&self) -> bool {
                *self == PUPD15_A::FLOATING
            }
            #[doc = "Checks if the value of the field is `PULLUP`"]
            #[inline(always)]
            pub fn is_pull_up(&self) -> bool {
                *self == PUPD15_A::PULLUP
            }
            #[doc = "Checks if the value of the field is `PULLDOWN`"]
            #[inline(always)]
            pub fn is_pull_down(&self) -> bool {
                *self == PUPD15_A::PULLDOWN
            }
        }
        #[doc = "Write proxy for field `PUPD15`"]
        pub struct PUPD15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD15_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD14_A = PUPD15_A;
        #[doc = "Reader of field `PUPD14`"]
        pub type PUPD14_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD14`"]
        pub struct PUPD14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD14_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD13_A = PUPD15_A;
        #[doc = "Reader of field `PUPD13`"]
        pub type PUPD13_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD13`"]
        pub struct PUPD13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD13_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD12_A = PUPD15_A;
        #[doc = "Reader of field `PUPD12`"]
        pub type PUPD12_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD12`"]
        pub struct PUPD12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD12_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD11_A = PUPD15_A;
        #[doc = "Reader of field `PUPD11`"]
        pub type PUPD11_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD11`"]
        pub struct PUPD11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD11_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD10_A = PUPD15_A;
        #[doc = "Reader of field `PUPD10`"]
        pub type PUPD10_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD10`"]
        pub struct PUPD10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD10_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD9_A = PUPD15_A;
        #[doc = "Reader of field `PUPD9`"]
        pub type PUPD9_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD9`"]
        pub struct PUPD9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD9_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD8_A = PUPD15_A;
        #[doc = "Reader of field `PUPD8`"]
        pub type PUPD8_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD8`"]
        pub struct PUPD8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD8_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD7_A = PUPD15_A;
        #[doc = "Reader of field `PUPD7`"]
        pub type PUPD7_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD7`"]
        pub struct PUPD7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD7_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD6_A = PUPD15_A;
        #[doc = "Reader of field `PUPD6`"]
        pub type PUPD6_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD6`"]
        pub struct PUPD6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD6_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD5_A = PUPD15_A;
        #[doc = "Reader of field `PUPD5`"]
        pub type PUPD5_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD5`"]
        pub struct PUPD5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD5_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD4_A = PUPD15_A;
        #[doc = "Reader of field `PUPD4`"]
        pub type PUPD4_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD4`"]
        pub struct PUPD4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD4_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD3_A = PUPD15_A;
        #[doc = "Reader of field `PUPD3`"]
        pub type PUPD3_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD3`"]
        pub struct PUPD3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD3_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD2_A = PUPD15_A;
        #[doc = "Reader of field `PUPD2`"]
        pub type PUPD2_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD2`"]
        pub struct PUPD2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD1_A = PUPD15_A;
        #[doc = "Reader of field `PUPD1`"]
        pub type PUPD1_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD1`"]
        pub struct PUPD1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD0_A = PUPD15_A;
        #[doc = "Reader of field `PUPD0`"]
        pub type PUPD0_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD0`"]
        pub struct PUPD0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD0_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd15(&self) -> PUPD15_R {
                PUPD15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd14(&self) -> PUPD14_R {
                PUPD14_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd13(&self) -> PUPD13_R {
                PUPD13_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd12(&self) -> PUPD12_R {
                PUPD12_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd11(&self) -> PUPD11_R {
                PUPD11_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd10(&self) -> PUPD10_R {
                PUPD10_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd9(&self) -> PUPD9_R {
                PUPD9_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd8(&self) -> PUPD8_R {
                PUPD8_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd7(&self) -> PUPD7_R {
                PUPD7_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd6(&self) -> PUPD6_R {
                PUPD6_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd5(&self) -> PUPD5_R {
                PUPD5_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd4(&self) -> PUPD4_R {
                PUPD4_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd3(&self) -> PUPD3_R {
                PUPD3_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd2(&self) -> PUPD2_R {
                PUPD2_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd1(&self) -> PUPD1_R {
                PUPD1_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd0(&self) -> PUPD0_R {
                PUPD0_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd15(&mut self) -> PUPD15_W {
                PUPD15_W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd14(&mut self) -> PUPD14_W {
                PUPD14_W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd13(&mut self) -> PUPD13_W {
                PUPD13_W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd12(&mut self) -> PUPD12_W {
                PUPD12_W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd11(&mut self) -> PUPD11_W {
                PUPD11_W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd10(&mut self) -> PUPD10_W {
                PUPD10_W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd9(&mut self) -> PUPD9_W {
                PUPD9_W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd8(&mut self) -> PUPD8_W {
                PUPD8_W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd7(&mut self) -> PUPD7_W {
                PUPD7_W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd6(&mut self) -> PUPD6_W {
                PUPD6_W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd5(&mut self) -> PUPD5_W {
                PUPD5_W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd4(&mut self) -> PUPD4_W {
                PUPD4_W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd3(&mut self) -> PUPD3_W {
                PUPD3_W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd2(&mut self) -> PUPD2_W {
                PUPD2_W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd1(&mut self) -> PUPD1_W {
                PUPD1_W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd0(&mut self) -> PUPD0_W {
                PUPD0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port input data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "GPIO port input data register"]
    pub mod idr {
        #[doc = "Reader of register IDR"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Port input data bit (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ID15_A {
            #[doc = "1: Input is logic high"]
            HIGH = 1,
            #[doc = "0: Input is logic low"]
            LOW = 0,
        }
        impl From<ID15_A> for bool {
            #[inline(always)]
            fn from(variant: ID15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ID15`"]
        pub type ID15_R = crate::R<bool, ID15_A>;
        impl ID15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ID15_A {
                match self.bits {
                    true => ID15_A::HIGH,
                    false => ID15_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == ID15_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == ID15_A::LOW
            }
        }
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID14_A = ID15_A;
        #[doc = "Reader of field `ID14`"]
        pub type ID14_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID13_A = ID15_A;
        #[doc = "Reader of field `ID13`"]
        pub type ID13_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID12_A = ID15_A;
        #[doc = "Reader of field `ID12`"]
        pub type ID12_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID11_A = ID15_A;
        #[doc = "Reader of field `ID11`"]
        pub type ID11_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID10_A = ID15_A;
        #[doc = "Reader of field `ID10`"]
        pub type ID10_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID9_A = ID15_A;
        #[doc = "Reader of field `ID9`"]
        pub type ID9_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID8_A = ID15_A;
        #[doc = "Reader of field `ID8`"]
        pub type ID8_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID7_A = ID15_A;
        #[doc = "Reader of field `ID7`"]
        pub type ID7_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID6_A = ID15_A;
        #[doc = "Reader of field `ID6`"]
        pub type ID6_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID5_A = ID15_A;
        #[doc = "Reader of field `ID5`"]
        pub type ID5_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID4_A = ID15_A;
        #[doc = "Reader of field `ID4`"]
        pub type ID4_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID3_A = ID15_A;
        #[doc = "Reader of field `ID3`"]
        pub type ID3_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID2_A = ID15_A;
        #[doc = "Reader of field `ID2`"]
        pub type ID2_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID1_A = ID15_A;
        #[doc = "Reader of field `ID1`"]
        pub type ID1_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID0_A = ID15_A;
        #[doc = "Reader of field `ID0`"]
        pub type ID0_R = crate::R<bool, ID15_A>;
        impl R {
            #[doc = "Bit 15 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id15(&self) -> ID15_R {
                ID15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id14(&self) -> ID14_R {
                ID14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id13(&self) -> ID13_R {
                ID13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id12(&self) -> ID12_R {
                ID12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id11(&self) -> ID11_R {
                ID11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id10(&self) -> ID10_R {
                ID10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id9(&self) -> ID9_R {
                ID9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id8(&self) -> ID8_R {
                ID8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id7(&self) -> ID7_R {
                ID7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id6(&self) -> ID6_R {
                ID6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id5(&self) -> ID5_R {
                ID5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id4(&self) -> ID4_R {
                ID4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id3(&self) -> ID3_R {
                ID3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id2(&self) -> ID2_R {
                ID2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id1(&self) -> ID1_R {
                ID1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id0(&self) -> ID0_R {
                ID0_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "GPIO port output data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [odr](odr) module"]
    pub type ODR = crate::Reg<u32, _ODR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ODR;
    #[doc = "`read()` method returns [odr::R](odr::R) reader structure"]
    impl crate::Readable for ODR {}
    #[doc = "`write(|w| ..)` method takes [odr::W](odr::W) writer structure"]
    impl crate::Writable for ODR {}
    #[doc = "GPIO port output data register"]
    pub mod odr {
        #[doc = "Reader of register ODR"]
        pub type R = crate::R<u32, super::ODR>;
        #[doc = "Writer for register ODR"]
        pub type W = crate::W<u32, super::ODR>;
        #[doc = "Register ODR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ODR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port output data bit (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OD15_A {
            #[doc = "1: Set output to logic high"]
            HIGH = 1,
            #[doc = "0: Set output to logic low"]
            LOW = 0,
        }
        impl From<OD15_A> for bool {
            #[inline(always)]
            fn from(variant: OD15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OD15`"]
        pub type OD15_R = crate::R<bool, OD15_A>;
        impl OD15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OD15_A {
                match self.bits {
                    true => OD15_A::HIGH,
                    false => OD15_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == OD15_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == OD15_A::LOW
            }
        }
        #[doc = "Write proxy for field `OD15`"]
        pub struct OD15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD14_A = OD15_A;
        #[doc = "Reader of field `OD14`"]
        pub type OD14_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD14`"]
        pub struct OD14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD13_A = OD15_A;
        #[doc = "Reader of field `OD13`"]
        pub type OD13_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD13`"]
        pub struct OD13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD12_A = OD15_A;
        #[doc = "Reader of field `OD12`"]
        pub type OD12_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD12`"]
        pub struct OD12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD11_A = OD15_A;
        #[doc = "Reader of field `OD11`"]
        pub type OD11_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD11`"]
        pub struct OD11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD10_A = OD15_A;
        #[doc = "Reader of field `OD10`"]
        pub type OD10_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD10`"]
        pub struct OD10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD9_A = OD15_A;
        #[doc = "Reader of field `OD9`"]
        pub type OD9_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD9`"]
        pub struct OD9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD8_A = OD15_A;
        #[doc = "Reader of field `OD8`"]
        pub type OD8_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD8`"]
        pub struct OD8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD7_A = OD15_A;
        #[doc = "Reader of field `OD7`"]
        pub type OD7_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD7`"]
        pub struct OD7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD6_A = OD15_A;
        #[doc = "Reader of field `OD6`"]
        pub type OD6_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD6`"]
        pub struct OD6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD5_A = OD15_A;
        #[doc = "Reader of field `OD5`"]
        pub type OD5_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD5`"]
        pub struct OD5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD4_A = OD15_A;
        #[doc = "Reader of field `OD4`"]
        pub type OD4_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD4`"]
        pub struct OD4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD3_A = OD15_A;
        #[doc = "Reader of field `OD3`"]
        pub type OD3_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD3`"]
        pub struct OD3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD2_A = OD15_A;
        #[doc = "Reader of field `OD2`"]
        pub type OD2_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD2`"]
        pub struct OD2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD1_A = OD15_A;
        #[doc = "Reader of field `OD1`"]
        pub type OD1_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD1`"]
        pub struct OD1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD0_A = OD15_A;
        #[doc = "Reader of field `OD0`"]
        pub type OD0_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD0`"]
        pub struct OD0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od15(&self) -> OD15_R {
                OD15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od14(&self) -> OD14_R {
                OD14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od13(&self) -> OD13_R {
                OD13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od12(&self) -> OD12_R {
                OD12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od11(&self) -> OD11_R {
                OD11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od10(&self) -> OD10_R {
                OD10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od9(&self) -> OD9_R {
                OD9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od8(&self) -> OD8_R {
                OD8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od7(&self) -> OD7_R {
                OD7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od6(&self) -> OD6_R {
                OD6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od5(&self) -> OD5_R {
                OD5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od4(&self) -> OD4_R {
                OD4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od3(&self) -> OD3_R {
                OD3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od2(&self) -> OD2_R {
                OD2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od1(&self) -> OD1_R {
                OD1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od0(&self) -> OD0_R {
                OD0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od15(&mut self) -> OD15_W {
                OD15_W { w: self }
            }
            #[doc = "Bit 14 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od14(&mut self) -> OD14_W {
                OD14_W { w: self }
            }
            #[doc = "Bit 13 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od13(&mut self) -> OD13_W {
                OD13_W { w: self }
            }
            #[doc = "Bit 12 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od12(&mut self) -> OD12_W {
                OD12_W { w: self }
            }
            #[doc = "Bit 11 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od11(&mut self) -> OD11_W {
                OD11_W { w: self }
            }
            #[doc = "Bit 10 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od10(&mut self) -> OD10_W {
                OD10_W { w: self }
            }
            #[doc = "Bit 9 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od9(&mut self) -> OD9_W {
                OD9_W { w: self }
            }
            #[doc = "Bit 8 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od8(&mut self) -> OD8_W {
                OD8_W { w: self }
            }
            #[doc = "Bit 7 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od7(&mut self) -> OD7_W {
                OD7_W { w: self }
            }
            #[doc = "Bit 6 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od6(&mut self) -> OD6_W {
                OD6_W { w: self }
            }
            #[doc = "Bit 5 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od5(&mut self) -> OD5_W {
                OD5_W { w: self }
            }
            #[doc = "Bit 4 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od4(&mut self) -> OD4_W {
                OD4_W { w: self }
            }
            #[doc = "Bit 3 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od3(&mut self) -> OD3_W {
                OD3_W { w: self }
            }
            #[doc = "Bit 2 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od2(&mut self) -> OD2_W {
                OD2_W { w: self }
            }
            #[doc = "Bit 1 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od1(&mut self) -> OD1_W {
                OD1_W { w: self }
            }
            #[doc = "Bit 0 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od0(&mut self) -> OD0_W {
                OD0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port bit set/reset register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bsrr](bsrr) module"]
    pub type BSRR = crate::Reg<u32, _BSRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BSRR;
    #[doc = "`write(|w| ..)` method takes [bsrr::W](bsrr::W) writer structure"]
    impl crate::Writable for BSRR {}
    #[doc = "GPIO port bit set/reset register"]
    pub mod bsrr {
        #[doc = "Writer for register BSRR"]
        pub type W = crate::W<u32, super::BSRR>;
        #[doc = "Register BSRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BSRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BR15_AW {
            #[doc = "1: Resets the corresponding ODx bit"]
            RESET = 1,
        }
        impl From<BR15_AW> for bool {
            #[inline(always)]
            fn from(variant: BR15_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BR15`"]
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR14_AW = BR15_AW;
        #[doc = "Write proxy for field `BR14`"]
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR13_AW = BR15_AW;
        #[doc = "Write proxy for field `BR13`"]
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR12_AW = BR15_AW;
        #[doc = "Write proxy for field `BR12`"]
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR11_AW = BR15_AW;
        #[doc = "Write proxy for field `BR11`"]
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR10_AW = BR15_AW;
        #[doc = "Write proxy for field `BR10`"]
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR9_AW = BR15_AW;
        #[doc = "Write proxy for field `BR9`"]
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR8_AW = BR15_AW;
        #[doc = "Write proxy for field `BR8`"]
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR7_AW = BR15_AW;
        #[doc = "Write proxy for field `BR7`"]
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR6_AW = BR15_AW;
        #[doc = "Write proxy for field `BR6`"]
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR5_AW = BR15_AW;
        #[doc = "Write proxy for field `BR5`"]
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR4_AW = BR15_AW;
        #[doc = "Write proxy for field `BR4`"]
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR3_AW = BR15_AW;
        #[doc = "Write proxy for field `BR3`"]
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR2_AW = BR15_AW;
        #[doc = "Write proxy for field `BR2`"]
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR1_AW = BR15_AW;
        #[doc = "Write proxy for field `BR1`"]
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR0_AW = BR15_AW;
        #[doc = "Write proxy for field `BR0`"]
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BS15_AW {
            #[doc = "1: Sets the corresponding ODx bit"]
            SET = 1,
        }
        impl From<BS15_AW> for bool {
            #[inline(always)]
            fn from(variant: BS15_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BS15`"]
        pub struct BS15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS14_AW = BS15_AW;
        #[doc = "Write proxy for field `BS14`"]
        pub struct BS14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS13_AW = BS15_AW;
        #[doc = "Write proxy for field `BS13`"]
        pub struct BS13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS12_AW = BS15_AW;
        #[doc = "Write proxy for field `BS12`"]
        pub struct BS12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS11_AW = BS15_AW;
        #[doc = "Write proxy for field `BS11`"]
        pub struct BS11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS10_AW = BS15_AW;
        #[doc = "Write proxy for field `BS10`"]
        pub struct BS10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS9_AW = BS15_AW;
        #[doc = "Write proxy for field `BS9`"]
        pub struct BS9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS8_AW = BS15_AW;
        #[doc = "Write proxy for field `BS8`"]
        pub struct BS8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS7_AW = BS15_AW;
        #[doc = "Write proxy for field `BS7`"]
        pub struct BS7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS6_AW = BS15_AW;
        #[doc = "Write proxy for field `BS6`"]
        pub struct BS6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS5_AW = BS15_AW;
        #[doc = "Write proxy for field `BS5`"]
        pub struct BS5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS4_AW = BS15_AW;
        #[doc = "Write proxy for field `BS4`"]
        pub struct BS4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS3_AW = BS15_AW;
        #[doc = "Write proxy for field `BS3`"]
        pub struct BS3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS2_AW = BS15_AW;
        #[doc = "Write proxy for field `BS2`"]
        pub struct BS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS1_AW = BS15_AW;
        #[doc = "Write proxy for field `BS1`"]
        pub struct BS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS0_AW = BS15_AW;
        #[doc = "Write proxy for field `BS0`"]
        pub struct BS0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
            #[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            #[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            #[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            #[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            #[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            #[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            #[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            #[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            #[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            #[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            #[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            #[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            #[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            #[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            #[doc = "Bit 16 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
            #[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs15(&mut self) -> BS15_W {
                BS15_W { w: self }
            }
            #[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs14(&mut self) -> BS14_W {
                BS14_W { w: self }
            }
            #[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs13(&mut self) -> BS13_W {
                BS13_W { w: self }
            }
            #[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs12(&mut self) -> BS12_W {
                BS12_W { w: self }
            }
            #[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs11(&mut self) -> BS11_W {
                BS11_W { w: self }
            }
            #[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs10(&mut self) -> BS10_W {
                BS10_W { w: self }
            }
            #[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs9(&mut self) -> BS9_W {
                BS9_W { w: self }
            }
            #[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs8(&mut self) -> BS8_W {
                BS8_W { w: self }
            }
            #[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs7(&mut self) -> BS7_W {
                BS7_W { w: self }
            }
            #[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs6(&mut self) -> BS6_W {
                BS6_W { w: self }
            }
            #[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs5(&mut self) -> BS5_W {
                BS5_W { w: self }
            }
            #[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs4(&mut self) -> BS4_W {
                BS4_W { w: self }
            }
            #[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs3(&mut self) -> BS3_W {
                BS3_W { w: self }
            }
            #[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs2(&mut self) -> BS2_W {
                BS2_W { w: self }
            }
            #[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs1(&mut self) -> BS1_W {
                BS1_W { w: self }
            }
            #[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs0(&mut self) -> BS0_W {
                BS0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port configuration lock register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lckr](lckr) module"]
    pub type LCKR = crate::Reg<u32, _LCKR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LCKR;
    #[doc = "`read()` method returns [lckr::R](lckr::R) reader structure"]
    impl crate::Readable for LCKR {}
    #[doc = "`write(|w| ..)` method takes [lckr::W](lckr::W) writer structure"]
    impl crate::Writable for LCKR {}
    #[doc = "GPIO port configuration lock register"]
    pub mod lckr {
        #[doc = "Reader of register LCKR"]
        pub type R = crate::R<u32, super::LCKR>;
        #[doc = "Writer for register LCKR"]
        pub type W = crate::W<u32, super::LCKR>;
        #[doc = "Register LCKR `reset()`'s with value 0"]
        impl crate::ResetValue for super::LCKR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCKK_A {
            #[doc = "0: Port configuration lock key not active"]
            NOTACTIVE = 0,
            #[doc = "1: Port configuration lock key active"]
            ACTIVE = 1,
        }
        impl From<LCKK_A> for bool {
            #[inline(always)]
            fn from(variant: LCKK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCKK`"]
        pub type LCKK_R = crate::R<bool, LCKK_A>;
        impl LCKK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCKK_A {
                match self.bits {
                    false => LCKK_A::NOTACTIVE,
                    true => LCKK_A::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTACTIVE`"]
            #[inline(always)]
            pub fn is_not_active(&self) -> bool {
                *self == LCKK_A::NOTACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == LCKK_A::ACTIVE
            }
        }
        #[doc = "Write proxy for field `LCKK`"]
        pub struct LCKK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCKK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCKK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration lock key not active"]
            #[inline(always)]
            pub fn not_active(self) -> &'a mut W {
                self.variant(LCKK_A::NOTACTIVE)
            }
            #[doc = "Port configuration lock key active"]
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(LCKK_A::ACTIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK15_A {
            #[doc = "0: Port configuration not locked"]
            UNLOCKED = 0,
            #[doc = "1: Port configuration locked"]
            LOCKED = 1,
        }
        impl From<LCK15_A> for bool {
            #[inline(always)]
            fn from(variant: LCK15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCK15`"]
        pub type LCK15_R = crate::R<bool, LCK15_A>;
        impl LCK15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCK15_A {
                match self.bits {
                    false => LCK15_A::UNLOCKED,
                    true => LCK15_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK15_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCK15_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `LCK15`"]
        pub struct LCK15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK14_A = LCK15_A;
        #[doc = "Reader of field `LCK14`"]
        pub type LCK14_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK14`"]
        pub struct LCK14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK13_A = LCK15_A;
        #[doc = "Reader of field `LCK13`"]
        pub type LCK13_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK13`"]
        pub struct LCK13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK12_A = LCK15_A;
        #[doc = "Reader of field `LCK12`"]
        pub type LCK12_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK12`"]
        pub struct LCK12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK11_A = LCK15_A;
        #[doc = "Reader of field `LCK11`"]
        pub type LCK11_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK11`"]
        pub struct LCK11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK10_A = LCK15_A;
        #[doc = "Reader of field `LCK10`"]
        pub type LCK10_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK10`"]
        pub struct LCK10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK9_A {
            #[doc = "0: Port configuration not locked"]
            UNLOCKED = 0,
            #[doc = "1: Port configuration locked"]
            LOCKED = 1,
        }
        impl From<LCK9_A> for bool {
            #[inline(always)]
            fn from(variant: LCK9_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCK9`"]
        pub type LCK9_R = crate::R<bool, LCK9_A>;
        impl LCK9_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCK9_A {
                match self.bits {
                    false => LCK9_A::UNLOCKED,
                    true => LCK9_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK9_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCK9_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `LCK9`"]
        pub struct LCK9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK8_A = LCK9_A;
        #[doc = "Reader of field `LCK8`"]
        pub type LCK8_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK8`"]
        pub struct LCK8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK7_A = LCK9_A;
        #[doc = "Reader of field `LCK7`"]
        pub type LCK7_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK7`"]
        pub struct LCK7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK6_A = LCK9_A;
        #[doc = "Reader of field `LCK6`"]
        pub type LCK6_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK6`"]
        pub struct LCK6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK5_A = LCK9_A;
        #[doc = "Reader of field `LCK5`"]
        pub type LCK5_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK5`"]
        pub struct LCK5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK4_A = LCK9_A;
        #[doc = "Reader of field `LCK4`"]
        pub type LCK4_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK4`"]
        pub struct LCK4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK3_A = LCK9_A;
        #[doc = "Reader of field `LCK3`"]
        pub type LCK3_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK3`"]
        pub struct LCK3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK2_A = LCK9_A;
        #[doc = "Reader of field `LCK2`"]
        pub type LCK2_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK2`"]
        pub struct LCK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK1_A = LCK9_A;
        #[doc = "Reader of field `LCK1`"]
        pub type LCK1_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK1`"]
        pub struct LCK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK0_A = LCK9_A;
        #[doc = "Reader of field `LCK0`"]
        pub type LCK0_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK0`"]
        pub struct LCK0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck15(&self) -> LCK15_R {
                LCK15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck14(&self) -> LCK14_R {
                LCK14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck13(&self) -> LCK13_R {
                LCK13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck12(&self) -> LCK12_R {
                LCK12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck11(&self) -> LCK11_R {
                LCK11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck10(&self) -> LCK10_R {
                LCK10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck9(&self) -> LCK9_R {
                LCK9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck8(&self) -> LCK8_R {
                LCK8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lckk(&mut self) -> LCKK_W {
                LCKK_W { w: self }
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck15(&mut self) -> LCK15_W {
                LCK15_W { w: self }
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck14(&mut self) -> LCK14_W {
                LCK14_W { w: self }
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck13(&mut self) -> LCK13_W {
                LCK13_W { w: self }
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck12(&mut self) -> LCK12_W {
                LCK12_W { w: self }
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck11(&mut self) -> LCK11_W {
                LCK11_W { w: self }
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck10(&mut self) -> LCK10_W {
                LCK10_W { w: self }
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck9(&mut self) -> LCK9_W {
                LCK9_W { w: self }
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck8(&mut self) -> LCK8_W {
                LCK8_W { w: self }
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck7(&mut self) -> LCK7_W {
                LCK7_W { w: self }
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck6(&mut self) -> LCK6_W {
                LCK6_W { w: self }
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck5(&mut self) -> LCK5_W {
                LCK5_W { w: self }
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck4(&mut self) -> LCK4_W {
                LCK4_W { w: self }
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck3(&mut self) -> LCK3_W {
                LCK3_W { w: self }
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck2(&mut self) -> LCK2_W {
                LCK2_W { w: self }
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck1(&mut self) -> LCK1_W {
                LCK1_W { w: self }
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck0(&mut self) -> LCK0_W {
                LCK0_W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function low register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [afrl](afrl) module"]
    pub type AFRL = crate::Reg<u32, _AFRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AFRL;
    #[doc = "`read()` method returns [afrl::R](afrl::R) reader structure"]
    impl crate::Readable for AFRL {}
    #[doc = "`write(|w| ..)` method takes [afrl::W](afrl::W) writer structure"]
    impl crate::Writable for AFRL {}
    #[doc = "GPIO alternate function low register"]
    pub mod afrl {
        #[doc = "Reader of register AFRL"]
        pub type R = crate::R<u32, super::AFRL>;
        #[doc = "Writer for register AFRL"]
        pub type W = crate::W<u32, super::AFRL>;
        #[doc = "Register AFRL `reset()`'s with value 0"]
        impl crate::ResetValue for super::AFRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum AFSEL7_A {
            #[doc = "0: AF0"]
            AF0 = 0,
            #[doc = "1: AF1"]
            AF1 = 1,
            #[doc = "2: AF2"]
            AF2 = 2,
            #[doc = "3: AF3"]
            AF3 = 3,
            #[doc = "4: AF4"]
            AF4 = 4,
            #[doc = "5: AF5"]
            AF5 = 5,
            #[doc = "6: AF6"]
            AF6 = 6,
            #[doc = "7: AF7"]
            AF7 = 7,
            #[doc = "8: AF8"]
            AF8 = 8,
            #[doc = "9: AF9"]
            AF9 = 9,
            #[doc = "10: AF10"]
            AF10 = 10,
            #[doc = "11: AF11"]
            AF11 = 11,
            #[doc = "12: AF12"]
            AF12 = 12,
            #[doc = "13: AF13"]
            AF13 = 13,
            #[doc = "14: AF14"]
            AF14 = 14,
            #[doc = "15: AF15"]
            AF15 = 15,
        }
        impl From<AFSEL7_A> for u8 {
            #[inline(always)]
            fn from(variant: AFSEL7_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `AFSEL7`"]
        pub type AFSEL7_R = crate::R<u8, AFSEL7_A>;
        impl AFSEL7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AFSEL7_A {
                match self.bits {
                    0 => AFSEL7_A::AF0,
                    1 => AFSEL7_A::AF1,
                    2 => AFSEL7_A::AF2,
                    3 => AFSEL7_A::AF3,
                    4 => AFSEL7_A::AF4,
                    5 => AFSEL7_A::AF5,
                    6 => AFSEL7_A::AF6,
                    7 => AFSEL7_A::AF7,
                    8 => AFSEL7_A::AF8,
                    9 => AFSEL7_A::AF9,
                    10 => AFSEL7_A::AF10,
                    11 => AFSEL7_A::AF11,
                    12 => AFSEL7_A::AF12,
                    13 => AFSEL7_A::AF13,
                    14 => AFSEL7_A::AF14,
                    15 => AFSEL7_A::AF15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `AF0`"]
            #[inline(always)]
            pub fn is_af0(&self) -> bool {
                *self == AFSEL7_A::AF0
            }
            #[doc = "Checks if the value of the field is `AF1`"]
            #[inline(always)]
            pub fn is_af1(&self) -> bool {
                *self == AFSEL7_A::AF1
            }
            #[doc = "Checks if the value of the field is `AF2`"]
            #[inline(always)]
            pub fn is_af2(&self) -> bool {
                *self == AFSEL7_A::AF2
            }
            #[doc = "Checks if the value of the field is `AF3`"]
            #[inline(always)]
            pub fn is_af3(&self) -> bool {
                *self == AFSEL7_A::AF3
            }
            #[doc = "Checks if the value of the field is `AF4`"]
            #[inline(always)]
            pub fn is_af4(&self) -> bool {
                *self == AFSEL7_A::AF4
            }
            #[doc = "Checks if the value of the field is `AF5`"]
            #[inline(always)]
            pub fn is_af5(&self) -> bool {
                *self == AFSEL7_A::AF5
            }
            #[doc = "Checks if the value of the field is `AF6`"]
            #[inline(always)]
            pub fn is_af6(&self) -> bool {
                *self == AFSEL7_A::AF6
            }
            #[doc = "Checks if the value of the field is `AF7`"]
            #[inline(always)]
            pub fn is_af7(&self) -> bool {
                *self == AFSEL7_A::AF7
            }
            #[doc = "Checks if the value of the field is `AF8`"]
            #[inline(always)]
            pub fn is_af8(&self) -> bool {
                *self == AFSEL7_A::AF8
            }
            #[doc = "Checks if the value of the field is `AF9`"]
            #[inline(always)]
            pub fn is_af9(&self) -> bool {
                *self == AFSEL7_A::AF9
            }
            #[doc = "Checks if the value of the field is `AF10`"]
            #[inline(always)]
            pub fn is_af10(&self) -> bool {
                *self == AFSEL7_A::AF10
            }
            #[doc = "Checks if the value of the field is `AF11`"]
            #[inline(always)]
            pub fn is_af11(&self) -> bool {
                *self == AFSEL7_A::AF11
            }
            #[doc = "Checks if the value of the field is `AF12`"]
            #[inline(always)]
            pub fn is_af12(&self) -> bool {
                *self == AFSEL7_A::AF12
            }
            #[doc = "Checks if the value of the field is `AF13`"]
            #[inline(always)]
            pub fn is_af13(&self) -> bool {
                *self == AFSEL7_A::AF13
            }
            #[doc = "Checks if the value of the field is `AF14`"]
            #[inline(always)]
            pub fn is_af14(&self) -> bool {
                *self == AFSEL7_A::AF14
            }
            #[doc = "Checks if the value of the field is `AF15`"]
            #[inline(always)]
            pub fn is_af15(&self) -> bool {
                *self == AFSEL7_A::AF15
            }
        }
        #[doc = "Write proxy for field `AFSEL7`"]
        pub struct AFSEL7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 28)) | (((value as u32) & 0x0f) << 28);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL6_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL6`"]
        pub type AFSEL6_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL6`"]
        pub struct AFSEL6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL5_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL5`"]
        pub type AFSEL5_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL5`"]
        pub struct AFSEL5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL4_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL4`"]
        pub type AFSEL4_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL4`"]
        pub struct AFSEL4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL3_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL3`"]
        pub type AFSEL3_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL3`"]
        pub struct AFSEL3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL2_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL2`"]
        pub type AFSEL2_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL2`"]
        pub struct AFSEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL1_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL1`"]
        pub type AFSEL1_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL1`"]
        pub struct AFSEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL0_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL0`"]
        pub type AFSEL0_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL0`"]
        pub struct AFSEL0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel7(&self) -> AFSEL7_R {
                AFSEL7_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel6(&self) -> AFSEL6_R {
                AFSEL6_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel5(&self) -> AFSEL5_R {
                AFSEL5_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel4(&self) -> AFSEL4_R {
                AFSEL4_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel3(&self) -> AFSEL3_R {
                AFSEL3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel2(&self) -> AFSEL2_R {
                AFSEL2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel1(&self) -> AFSEL1_R {
                AFSEL1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel0(&self) -> AFSEL0_R {
                AFSEL0_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel7(&mut self) -> AFSEL7_W {
                AFSEL7_W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel6(&mut self) -> AFSEL6_W {
                AFSEL6_W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel5(&mut self) -> AFSEL5_W {
                AFSEL5_W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel4(&mut self) -> AFSEL4_W {
                AFSEL4_W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel3(&mut self) -> AFSEL3_W {
                AFSEL3_W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel2(&mut self) -> AFSEL2_W {
                AFSEL2_W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel1(&mut self) -> AFSEL1_W {
                AFSEL1_W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel0(&mut self) -> AFSEL0_W {
                AFSEL0_W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function high register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [afrh](afrh) module"]
    pub type AFRH = crate::Reg<u32, _AFRH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AFRH;
    #[doc = "`read()` method returns [afrh::R](afrh::R) reader structure"]
    impl crate::Readable for AFRH {}
    #[doc = "`write(|w| ..)` method takes [afrh::W](afrh::W) writer structure"]
    impl crate::Writable for AFRH {}
    #[doc = "GPIO alternate function high register"]
    pub mod afrh {
        #[doc = "Reader of register AFRH"]
        pub type R = crate::R<u32, super::AFRH>;
        #[doc = "Writer for register AFRH"]
        pub type W = crate::W<u32, super::AFRH>;
        #[doc = "Register AFRH `reset()`'s with value 0"]
        impl crate::ResetValue for super::AFRH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum AFSEL15_A {
            #[doc = "0: AF0"]
            AF0 = 0,
            #[doc = "1: AF1"]
            AF1 = 1,
            #[doc = "2: AF2"]
            AF2 = 2,
            #[doc = "3: AF3"]
            AF3 = 3,
            #[doc = "4: AF4"]
            AF4 = 4,
            #[doc = "5: AF5"]
            AF5 = 5,
            #[doc = "6: AF6"]
            AF6 = 6,
            #[doc = "7: AF7"]
            AF7 = 7,
            #[doc = "8: AF8"]
            AF8 = 8,
            #[doc = "9: AF9"]
            AF9 = 9,
            #[doc = "10: AF10"]
            AF10 = 10,
            #[doc = "11: AF11"]
            AF11 = 11,
            #[doc = "12: AF12"]
            AF12 = 12,
            #[doc = "13: AF13"]
            AF13 = 13,
            #[doc = "14: AF14"]
            AF14 = 14,
            #[doc = "15: AF15"]
            AF15 = 15,
        }
        impl From<AFSEL15_A> for u8 {
            #[inline(always)]
            fn from(variant: AFSEL15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `AFSEL15`"]
        pub type AFSEL15_R = crate::R<u8, AFSEL15_A>;
        impl AFSEL15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AFSEL15_A {
                match self.bits {
                    0 => AFSEL15_A::AF0,
                    1 => AFSEL15_A::AF1,
                    2 => AFSEL15_A::AF2,
                    3 => AFSEL15_A::AF3,
                    4 => AFSEL15_A::AF4,
                    5 => AFSEL15_A::AF5,
                    6 => AFSEL15_A::AF6,
                    7 => AFSEL15_A::AF7,
                    8 => AFSEL15_A::AF8,
                    9 => AFSEL15_A::AF9,
                    10 => AFSEL15_A::AF10,
                    11 => AFSEL15_A::AF11,
                    12 => AFSEL15_A::AF12,
                    13 => AFSEL15_A::AF13,
                    14 => AFSEL15_A::AF14,
                    15 => AFSEL15_A::AF15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `AF0`"]
            #[inline(always)]
            pub fn is_af0(&self) -> bool {
                *self == AFSEL15_A::AF0
            }
            #[doc = "Checks if the value of the field is `AF1`"]
            #[inline(always)]
            pub fn is_af1(&self) -> bool {
                *self == AFSEL15_A::AF1
            }
            #[doc = "Checks if the value of the field is `AF2`"]
            #[inline(always)]
            pub fn is_af2(&self) -> bool {
                *self == AFSEL15_A::AF2
            }
            #[doc = "Checks if the value of the field is `AF3`"]
            #[inline(always)]
            pub fn is_af3(&self) -> bool {
                *self == AFSEL15_A::AF3
            }
            #[doc = "Checks if the value of the field is `AF4`"]
            #[inline(always)]
            pub fn is_af4(&self) -> bool {
                *self == AFSEL15_A::AF4
            }
            #[doc = "Checks if the value of the field is `AF5`"]
            #[inline(always)]
            pub fn is_af5(&self) -> bool {
                *self == AFSEL15_A::AF5
            }
            #[doc = "Checks if the value of the field is `AF6`"]
            #[inline(always)]
            pub fn is_af6(&self) -> bool {
                *self == AFSEL15_A::AF6
            }
            #[doc = "Checks if the value of the field is `AF7`"]
            #[inline(always)]
            pub fn is_af7(&self) -> bool {
                *self == AFSEL15_A::AF7
            }
            #[doc = "Checks if the value of the field is `AF8`"]
            #[inline(always)]
            pub fn is_af8(&self) -> bool {
                *self == AFSEL15_A::AF8
            }
            #[doc = "Checks if the value of the field is `AF9`"]
            #[inline(always)]
            pub fn is_af9(&self) -> bool {
                *self == AFSEL15_A::AF9
            }
            #[doc = "Checks if the value of the field is `AF10`"]
            #[inline(always)]
            pub fn is_af10(&self) -> bool {
                *self == AFSEL15_A::AF10
            }
            #[doc = "Checks if the value of the field is `AF11`"]
            #[inline(always)]
            pub fn is_af11(&self) -> bool {
                *self == AFSEL15_A::AF11
            }
            #[doc = "Checks if the value of the field is `AF12`"]
            #[inline(always)]
            pub fn is_af12(&self) -> bool {
                *self == AFSEL15_A::AF12
            }
            #[doc = "Checks if the value of the field is `AF13`"]
            #[inline(always)]
            pub fn is_af13(&self) -> bool {
                *self == AFSEL15_A::AF13
            }
            #[doc = "Checks if the value of the field is `AF14`"]
            #[inline(always)]
            pub fn is_af14(&self) -> bool {
                *self == AFSEL15_A::AF14
            }
            #[doc = "Checks if the value of the field is `AF15`"]
            #[inline(always)]
            pub fn is_af15(&self) -> bool {
                *self == AFSEL15_A::AF15
            }
        }
        #[doc = "Write proxy for field `AFSEL15`"]
        pub struct AFSEL15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 28)) | (((value as u32) & 0x0f) << 28);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL14_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL14`"]
        pub type AFSEL14_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL14`"]
        pub struct AFSEL14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL13_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL13`"]
        pub type AFSEL13_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL13`"]
        pub struct AFSEL13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL12_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL12`"]
        pub type AFSEL12_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL12`"]
        pub struct AFSEL12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL11_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL11`"]
        pub type AFSEL11_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL11`"]
        pub struct AFSEL11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL10_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL10`"]
        pub type AFSEL10_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL10`"]
        pub struct AFSEL10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL9_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL9`"]
        pub type AFSEL9_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL9`"]
        pub struct AFSEL9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL8_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL8`"]
        pub type AFSEL8_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL8`"]
        pub struct AFSEL8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel15(&self) -> AFSEL15_R {
                AFSEL15_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel14(&self) -> AFSEL14_R {
                AFSEL14_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel13(&self) -> AFSEL13_R {
                AFSEL13_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel12(&self) -> AFSEL12_R {
                AFSEL12_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel11(&self) -> AFSEL11_R {
                AFSEL11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel10(&self) -> AFSEL10_R {
                AFSEL10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel9(&self) -> AFSEL9_R {
                AFSEL9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel8(&self) -> AFSEL8_R {
                AFSEL8_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel15(&mut self) -> AFSEL15_W {
                AFSEL15_W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel14(&mut self) -> AFSEL14_W {
                AFSEL14_W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel13(&mut self) -> AFSEL13_W {
                AFSEL13_W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel12(&mut self) -> AFSEL12_W {
                AFSEL12_W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel11(&mut self) -> AFSEL11_W {
                AFSEL11_W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel10(&mut self) -> AFSEL10_W {
                AFSEL10_W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel9(&mut self) -> AFSEL9_W {
                AFSEL9_W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel8(&mut self) -> AFSEL8_W {
                AFSEL8_W { w: self }
            }
        }
    }
    #[doc = "GPIO port bit reset register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "GPIO port bit reset register"]
    pub mod brr {
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `BR15`"]
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR14`"]
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR13`"]
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR12`"]
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR11`"]
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR10`"]
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR9`"]
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR8`"]
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR7`"]
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR6`"]
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR5`"]
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR4`"]
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR3`"]
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR2`"]
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR1`"]
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR0`"]
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 15 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
            #[doc = "Bit 14 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            #[doc = "Bit 13 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            #[doc = "Bit 12 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            #[doc = "Bit 11 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            #[doc = "Bit 10 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            #[doc = "Bit 9 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            #[doc = "Bit 8 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            #[doc = "Bit 7 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            #[doc = "Bit 6 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            #[doc = "Bit 5 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            #[doc = "Bit 4 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            #[doc = "Bit 3 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            #[doc = "Bit 2 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            #[doc = "Bit 1 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            #[doc = "Bit 0 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose I/Os"]
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        0x5000_0400 as *const _
    }
}
impl Deref for GPIOB {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOB::ptr() }
    }
}
#[doc = "General-purpose I/Os"]
pub mod gpiob {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - GPIO port mode register"]
        pub moder: MODER,
        #[doc = "0x04 - GPIO port output type register"]
        pub otyper: OTYPER,
        #[doc = "0x08 - GPIO port output speed register"]
        pub ospeedr: OSPEEDR,
        #[doc = "0x0c - GPIO port pull-up/pull-down register"]
        pub pupdr: PUPDR,
        #[doc = "0x10 - GPIO port input data register"]
        pub idr: IDR,
        #[doc = "0x14 - GPIO port output data register"]
        pub odr: ODR,
        #[doc = "0x18 - GPIO port bit set/reset register"]
        pub bsrr: BSRR,
        #[doc = "0x1c - GPIO port configuration lock register"]
        pub lckr: LCKR,
        #[doc = "0x20 - GPIO alternate function low register"]
        pub afrl: AFRL,
        #[doc = "0x24 - GPIO alternate function high register"]
        pub afrh: AFRH,
        #[doc = "0x28 - GPIO port bit reset register"]
        pub brr: BRR,
    }
    #[doc = "GPIO port mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [moder](moder) module"]
    pub type MODER = crate::Reg<u32, _MODER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MODER;
    #[doc = "`read()` method returns [moder::R](moder::R) reader structure"]
    impl crate::Readable for MODER {}
    #[doc = "`write(|w| ..)` method takes [moder::W](moder::W) writer structure"]
    impl crate::Writable for MODER {}
    #[doc = "GPIO port mode register"]
    pub mod moder {
        #[doc = "Reader of register MODER"]
        pub type R = crate::R<u32, super::MODER>;
        #[doc = "Writer for register MODER"]
        pub type W = crate::W<u32, super::MODER>;
        #[doc = "Register MODER `reset()`'s with value 0xffff_ffff"]
        impl crate::ResetValue for super::MODER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff_ffff
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 3"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE15_A {
            #[doc = "0: Input mode (reset state)"]
            INPUT = 0,
            #[doc = "1: General purpose output mode"]
            OUTPUT = 1,
            #[doc = "2: Alternate function mode"]
            ALTERNATE = 2,
            #[doc = "3: Analog mode"]
            ANALOG = 3,
        }
        impl From<MODE15_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MODE15`"]
        pub type MODE15_R = crate::R<u8, MODE15_A>;
        impl MODE15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODE15_A {
                match self.bits {
                    0 => MODE15_A::INPUT,
                    1 => MODE15_A::OUTPUT,
                    2 => MODE15_A::ALTERNATE,
                    3 => MODE15_A::ANALOG,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == MODE15_A::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == MODE15_A::OUTPUT
            }
            #[doc = "Checks if the value of the field is `ALTERNATE`"]
            #[inline(always)]
            pub fn is_alternate(&self) -> bool {
                *self == MODE15_A::ALTERNATE
            }
            #[doc = "Checks if the value of the field is `ANALOG`"]
            #[inline(always)]
            pub fn is_analog(&self) -> bool {
                *self == MODE15_A::ANALOG
            }
        }
        #[doc = "Write proxy for field `MODE15`"]
        pub struct MODE15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE14_A = MODE15_A;
        #[doc = "Reader of field `MODE14`"]
        pub type MODE14_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE14`"]
        pub struct MODE14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE13_A = MODE15_A;
        #[doc = "Reader of field `MODE13`"]
        pub type MODE13_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE13`"]
        pub struct MODE13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE12_A = MODE15_A;
        #[doc = "Reader of field `MODE12`"]
        pub type MODE12_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE12`"]
        pub struct MODE12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE11_A = MODE15_A;
        #[doc = "Reader of field `MODE11`"]
        pub type MODE11_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE11`"]
        pub struct MODE11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE10_A = MODE15_A;
        #[doc = "Reader of field `MODE10`"]
        pub type MODE10_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE10`"]
        pub struct MODE10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE9_A = MODE15_A;
        #[doc = "Reader of field `MODE9`"]
        pub type MODE9_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE9`"]
        pub struct MODE9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE8_A = MODE15_A;
        #[doc = "Reader of field `MODE8`"]
        pub type MODE8_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE8`"]
        pub struct MODE8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE7_A = MODE15_A;
        #[doc = "Reader of field `MODE7`"]
        pub type MODE7_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE7`"]
        pub struct MODE7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE6_A = MODE15_A;
        #[doc = "Reader of field `MODE6`"]
        pub type MODE6_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE6`"]
        pub struct MODE6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE5_A = MODE15_A;
        #[doc = "Reader of field `MODE5`"]
        pub type MODE5_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE5`"]
        pub struct MODE5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE4_A = MODE15_A;
        #[doc = "Reader of field `MODE4`"]
        pub type MODE4_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE4`"]
        pub struct MODE4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE3_A = MODE15_A;
        #[doc = "Reader of field `MODE3`"]
        pub type MODE3_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE3`"]
        pub struct MODE3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE2_A = MODE15_A;
        #[doc = "Reader of field `MODE2`"]
        pub type MODE2_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE2`"]
        pub struct MODE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE1_A = MODE15_A;
        #[doc = "Reader of field `MODE1`"]
        pub type MODE1_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE1`"]
        pub struct MODE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type MODE0_A = MODE15_A;
        #[doc = "Reader of field `MODE0`"]
        pub type MODE0_R = crate::R<u8, MODE15_A>;
        #[doc = "Write proxy for field `MODE0`"]
        pub struct MODE0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Input mode (reset state)"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            #[doc = "General purpose output mode"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            #[doc = "Alternate function mode"]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(MODE15_A::ALTERNATE)
            }
            #[doc = "Analog mode"]
            #[inline(always)]
            pub fn analog(self) -> &'a mut W {
                self.variant(MODE15_A::ANALOG)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode15(&self) -> MODE15_R {
                MODE15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode14(&self) -> MODE14_R {
                MODE14_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode13(&self) -> MODE13_R {
                MODE13_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode12(&self) -> MODE12_R {
                MODE12_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode11(&self) -> MODE11_R {
                MODE11_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode10(&self) -> MODE10_R {
                MODE10_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode9(&self) -> MODE9_R {
                MODE9_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode8(&self) -> MODE8_R {
                MODE8_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode15(&mut self) -> MODE15_W {
                MODE15_W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode14(&mut self) -> MODE14_W {
                MODE14_W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode13(&mut self) -> MODE13_W {
                MODE13_W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode12(&mut self) -> MODE12_W {
                MODE12_W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode11(&mut self) -> MODE11_W {
                MODE11_W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode10(&mut self) -> MODE10_W {
                MODE10_W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode9(&mut self) -> MODE9_W {
                MODE9_W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode8(&mut self) -> MODE8_W {
                MODE8_W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode7(&mut self) -> MODE7_W {
                MODE7_W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode6(&mut self) -> MODE6_W {
                MODE6_W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode5(&mut self) -> MODE5_W {
                MODE5_W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode4(&mut self) -> MODE4_W {
                MODE4_W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode3(&mut self) -> MODE3_W {
                MODE3_W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode2(&mut self) -> MODE2_W {
                MODE2_W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode1(&mut self) -> MODE1_W {
                MODE1_W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn mode0(&mut self) -> MODE0_W {
                MODE0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port output type register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [otyper](otyper) module"]
    pub type OTYPER = crate::Reg<u32, _OTYPER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OTYPER;
    #[doc = "`read()` method returns [otyper::R](otyper::R) reader structure"]
    impl crate::Readable for OTYPER {}
    #[doc = "`write(|w| ..)` method takes [otyper::W](otyper::W) writer structure"]
    impl crate::Writable for OTYPER {}
    #[doc = "GPIO port output type register"]
    pub mod otyper {
        #[doc = "Reader of register OTYPER"]
        pub type R = crate::R<u32, super::OTYPER>;
        #[doc = "Writer for register OTYPER"]
        pub type W = crate::W<u32, super::OTYPER>;
        #[doc = "Register OTYPER `reset()`'s with value 0"]
        impl crate::ResetValue for super::OTYPER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OT15_A {
            #[doc = "0: Output push-pull (reset state)"]
            PUSHPULL = 0,
            #[doc = "1: Output open-drain"]
            OPENDRAIN = 1,
        }
        impl From<OT15_A> for bool {
            #[inline(always)]
            fn from(variant: OT15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OT15`"]
        pub type OT15_R = crate::R<bool, OT15_A>;
        impl OT15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OT15_A {
                match self.bits {
                    false => OT15_A::PUSHPULL,
                    true => OT15_A::OPENDRAIN,
                }
            }
            #[doc = "Checks if the value of the field is `PUSHPULL`"]
            #[inline(always)]
            pub fn is_push_pull(&self) -> bool {
                *self == OT15_A::PUSHPULL
            }
            #[doc = "Checks if the value of the field is `OPENDRAIN`"]
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                *self == OT15_A::OPENDRAIN
            }
        }
        #[doc = "Write proxy for field `OT15`"]
        pub struct OT15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT14_A = OT15_A;
        #[doc = "Reader of field `OT14`"]
        pub type OT14_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT14`"]
        pub struct OT14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT13_A = OT15_A;
        #[doc = "Reader of field `OT13`"]
        pub type OT13_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT13`"]
        pub struct OT13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT12_A = OT15_A;
        #[doc = "Reader of field `OT12`"]
        pub type OT12_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT12`"]
        pub struct OT12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT11_A = OT15_A;
        #[doc = "Reader of field `OT11`"]
        pub type OT11_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT11`"]
        pub struct OT11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT10_A = OT15_A;
        #[doc = "Reader of field `OT10`"]
        pub type OT10_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT10`"]
        pub struct OT10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT9_A = OT15_A;
        #[doc = "Reader of field `OT9`"]
        pub type OT9_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT9`"]
        pub struct OT9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT8_A = OT15_A;
        #[doc = "Reader of field `OT8`"]
        pub type OT8_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT8`"]
        pub struct OT8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT7_A = OT15_A;
        #[doc = "Reader of field `OT7`"]
        pub type OT7_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT7`"]
        pub struct OT7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT6_A = OT15_A;
        #[doc = "Reader of field `OT6`"]
        pub type OT6_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT6`"]
        pub struct OT6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT5_A = OT15_A;
        #[doc = "Reader of field `OT5`"]
        pub type OT5_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT5`"]
        pub struct OT5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT4_A = OT15_A;
        #[doc = "Reader of field `OT4`"]
        pub type OT4_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT4`"]
        pub struct OT4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT3_A = OT15_A;
        #[doc = "Reader of field `OT3`"]
        pub type OT3_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT3`"]
        pub struct OT3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT2_A = OT15_A;
        #[doc = "Reader of field `OT2`"]
        pub type OT2_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT2`"]
        pub struct OT2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT1_A = OT15_A;
        #[doc = "Reader of field `OT1`"]
        pub type OT1_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT1`"]
        pub struct OT1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OT0_A = OT15_A;
        #[doc = "Reader of field `OT0`"]
        pub type OT0_R = crate::R<bool, OT15_A>;
        #[doc = "Write proxy for field `OT0`"]
        pub struct OT0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OT0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OT0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output push-pull (reset state)"]
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(OT15_A::PUSHPULL)
            }
            #[doc = "Output open-drain"]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(OT15_A::OPENDRAIN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot15(&self) -> OT15_R {
                OT15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot14(&self) -> OT14_R {
                OT14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot13(&self) -> OT13_R {
                OT13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot12(&self) -> OT12_R {
                OT12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot11(&self) -> OT11_R {
                OT11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot10(&self) -> OT10_R {
                OT10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot9(&self) -> OT9_R {
                OT9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot8(&self) -> OT8_R {
                OT8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot7(&self) -> OT7_R {
                OT7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot6(&self) -> OT6_R {
                OT6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot5(&self) -> OT5_R {
                OT5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot4(&self) -> OT4_R {
                OT4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot3(&self) -> OT3_R {
                OT3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot2(&self) -> OT2_R {
                OT2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot1(&self) -> OT1_R {
                OT1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot0(&self) -> OT0_R {
                OT0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot15(&mut self) -> OT15_W {
                OT15_W { w: self }
            }
            #[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot14(&mut self) -> OT14_W {
                OT14_W { w: self }
            }
            #[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot13(&mut self) -> OT13_W {
                OT13_W { w: self }
            }
            #[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot12(&mut self) -> OT12_W {
                OT12_W { w: self }
            }
            #[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot11(&mut self) -> OT11_W {
                OT11_W { w: self }
            }
            #[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot10(&mut self) -> OT10_W {
                OT10_W { w: self }
            }
            #[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot9(&mut self) -> OT9_W {
                OT9_W { w: self }
            }
            #[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot8(&mut self) -> OT8_W {
                OT8_W { w: self }
            }
            #[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot7(&mut self) -> OT7_W {
                OT7_W { w: self }
            }
            #[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot6(&mut self) -> OT6_W {
                OT6_W { w: self }
            }
            #[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot5(&mut self) -> OT5_W {
                OT5_W { w: self }
            }
            #[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot4(&mut self) -> OT4_W {
                OT4_W { w: self }
            }
            #[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot3(&mut self) -> OT3_W {
                OT3_W { w: self }
            }
            #[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot2(&mut self) -> OT2_W {
                OT2_W { w: self }
            }
            #[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot1(&mut self) -> OT1_W {
                OT1_W { w: self }
            }
            #[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ot0(&mut self) -> OT0_W {
                OT0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port output speed register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ospeedr](ospeedr) module"]
    pub type OSPEEDR = crate::Reg<u32, _OSPEEDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OSPEEDR;
    #[doc = "`read()` method returns [ospeedr::R](ospeedr::R) reader structure"]
    impl crate::Readable for OSPEEDR {}
    #[doc = "`write(|w| ..)` method takes [ospeedr::W](ospeedr::W) writer structure"]
    impl crate::Writable for OSPEEDR {}
    #[doc = "GPIO port output speed register"]
    pub mod ospeedr {
        #[doc = "Reader of register OSPEEDR"]
        pub type R = crate::R<u32, super::OSPEEDR>;
        #[doc = "Writer for register OSPEEDR"]
        pub type W = crate::W<u32, super::OSPEEDR>;
        #[doc = "Register OSPEEDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OSPEEDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OSPEED15_A {
            #[doc = "0: Low speed"]
            LOWSPEED = 0,
            #[doc = "1: Medium speed"]
            MEDIUMSPEED = 1,
            #[doc = "2: High speed"]
            HIGHSPEED = 2,
            #[doc = "3: Very high speed"]
            VERYHIGHSPEED = 3,
        }
        impl From<OSPEED15_A> for u8 {
            #[inline(always)]
            fn from(variant: OSPEED15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OSPEED15`"]
        pub type OSPEED15_R = crate::R<u8, OSPEED15_A>;
        impl OSPEED15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OSPEED15_A {
                match self.bits {
                    0 => OSPEED15_A::LOWSPEED,
                    1 => OSPEED15_A::MEDIUMSPEED,
                    2 => OSPEED15_A::HIGHSPEED,
                    3 => OSPEED15_A::VERYHIGHSPEED,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOWSPEED`"]
            #[inline(always)]
            pub fn is_low_speed(&self) -> bool {
                *self == OSPEED15_A::LOWSPEED
            }
            #[doc = "Checks if the value of the field is `MEDIUMSPEED`"]
            #[inline(always)]
            pub fn is_medium_speed(&self) -> bool {
                *self == OSPEED15_A::MEDIUMSPEED
            }
            #[doc = "Checks if the value of the field is `HIGHSPEED`"]
            #[inline(always)]
            pub fn is_high_speed(&self) -> bool {
                *self == OSPEED15_A::HIGHSPEED
            }
            #[doc = "Checks if the value of the field is `VERYHIGHSPEED`"]
            #[inline(always)]
            pub fn is_very_high_speed(&self) -> bool {
                *self == OSPEED15_A::VERYHIGHSPEED
            }
        }
        #[doc = "Write proxy for field `OSPEED15`"]
        pub struct OSPEED15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED14_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED14`"]
        pub type OSPEED14_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED14`"]
        pub struct OSPEED14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED13_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED13`"]
        pub type OSPEED13_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED13`"]
        pub struct OSPEED13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED12_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED12`"]
        pub type OSPEED12_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED12`"]
        pub struct OSPEED12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED11_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED11`"]
        pub type OSPEED11_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED11`"]
        pub struct OSPEED11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED10_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED10`"]
        pub type OSPEED10_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED10`"]
        pub struct OSPEED10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED9_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED9`"]
        pub type OSPEED9_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED9`"]
        pub struct OSPEED9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED8_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED8`"]
        pub type OSPEED8_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED8`"]
        pub struct OSPEED8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED7_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED7`"]
        pub type OSPEED7_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED7`"]
        pub struct OSPEED7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED6_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED6`"]
        pub type OSPEED6_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED6`"]
        pub struct OSPEED6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED5_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED5`"]
        pub type OSPEED5_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED5`"]
        pub struct OSPEED5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED4_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED4`"]
        pub type OSPEED4_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED4`"]
        pub struct OSPEED4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED3_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED3`"]
        pub type OSPEED3_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED3`"]
        pub struct OSPEED3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED2_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED2`"]
        pub type OSPEED2_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED2`"]
        pub struct OSPEED2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED1_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED1`"]
        pub type OSPEED1_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED1`"]
        pub struct OSPEED1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type OSPEED0_A = OSPEED15_A;
        #[doc = "Reader of field `OSPEED0`"]
        pub type OSPEED0_R = crate::R<u8, OSPEED15_A>;
        #[doc = "Write proxy for field `OSPEED0`"]
        pub struct OSPEED0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSPEED0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSPEED0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Low speed"]
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::LOWSPEED)
            }
            #[doc = "Medium speed"]
            #[inline(always)]
            pub fn medium_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::MEDIUMSPEED)
            }
            #[doc = "High speed"]
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::HIGHSPEED)
            }
            #[doc = "Very high speed"]
            #[inline(always)]
            pub fn very_high_speed(self) -> &'a mut W {
                self.variant(OSPEED15_A::VERYHIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed15(&self) -> OSPEED15_R {
                OSPEED15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed14(&self) -> OSPEED14_R {
                OSPEED14_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed13(&self) -> OSPEED13_R {
                OSPEED13_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed12(&self) -> OSPEED12_R {
                OSPEED12_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed11(&self) -> OSPEED11_R {
                OSPEED11_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed10(&self) -> OSPEED10_R {
                OSPEED10_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed9(&self) -> OSPEED9_R {
                OSPEED9_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed8(&self) -> OSPEED8_R {
                OSPEED8_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed7(&self) -> OSPEED7_R {
                OSPEED7_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed6(&self) -> OSPEED6_R {
                OSPEED6_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed5(&self) -> OSPEED5_R {
                OSPEED5_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed4(&self) -> OSPEED4_R {
                OSPEED4_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed3(&self) -> OSPEED3_R {
                OSPEED3_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed2(&self) -> OSPEED2_R {
                OSPEED2_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed1(&self) -> OSPEED1_R {
                OSPEED1_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed0(&self) -> OSPEED0_R {
                OSPEED0_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed15(&mut self) -> OSPEED15_W {
                OSPEED15_W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed14(&mut self) -> OSPEED14_W {
                OSPEED14_W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed13(&mut self) -> OSPEED13_W {
                OSPEED13_W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed12(&mut self) -> OSPEED12_W {
                OSPEED12_W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed11(&mut self) -> OSPEED11_W {
                OSPEED11_W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed10(&mut self) -> OSPEED10_W {
                OSPEED10_W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed9(&mut self) -> OSPEED9_W {
                OSPEED9_W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed8(&mut self) -> OSPEED8_W {
                OSPEED8_W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed7(&mut self) -> OSPEED7_W {
                OSPEED7_W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed6(&mut self) -> OSPEED6_W {
                OSPEED6_W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed5(&mut self) -> OSPEED5_W {
                OSPEED5_W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed4(&mut self) -> OSPEED4_W {
                OSPEED4_W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed3(&mut self) -> OSPEED3_W {
                OSPEED3_W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed2(&mut self) -> OSPEED2_W {
                OSPEED2_W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed1(&mut self) -> OSPEED1_W {
                OSPEED1_W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn ospeed0(&mut self) -> OSPEED0_W {
                OSPEED0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port pull-up/pull-down register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pupdr](pupdr) module"]
    pub type PUPDR = crate::Reg<u32, _PUPDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PUPDR;
    #[doc = "`read()` method returns [pupdr::R](pupdr::R) reader structure"]
    impl crate::Readable for PUPDR {}
    #[doc = "`write(|w| ..)` method takes [pupdr::W](pupdr::W) writer structure"]
    impl crate::Writable for PUPDR {}
    #[doc = "GPIO port pull-up/pull-down register"]
    pub mod pupdr {
        #[doc = "Reader of register PUPDR"]
        pub type R = crate::R<u32, super::PUPDR>;
        #[doc = "Writer for register PUPDR"]
        pub type W = crate::W<u32, super::PUPDR>;
        #[doc = "Register PUPDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PUPDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PUPD15_A {
            #[doc = "0: No pull-up, pull-down"]
            FLOATING = 0,
            #[doc = "1: Pull-up"]
            PULLUP = 1,
            #[doc = "2: Pull-down"]
            PULLDOWN = 2,
        }
        impl From<PUPD15_A> for u8 {
            #[inline(always)]
            fn from(variant: PUPD15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PUPD15`"]
        pub type PUPD15_R = crate::R<u8, PUPD15_A>;
        impl PUPD15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PUPD15_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(PUPD15_A::FLOATING),
                    1 => Val(PUPD15_A::PULLUP),
                    2 => Val(PUPD15_A::PULLDOWN),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `FLOATING`"]
            #[inline(always)]
            pub fn is_floating(&self) -> bool {
                *self == PUPD15_A::FLOATING
            }
            #[doc = "Checks if the value of the field is `PULLUP`"]
            #[inline(always)]
            pub fn is_pull_up(&self) -> bool {
                *self == PUPD15_A::PULLUP
            }
            #[doc = "Checks if the value of the field is `PULLDOWN`"]
            #[inline(always)]
            pub fn is_pull_down(&self) -> bool {
                *self == PUPD15_A::PULLDOWN
            }
        }
        #[doc = "Write proxy for field `PUPD15`"]
        pub struct PUPD15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD15_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD14_A = PUPD15_A;
        #[doc = "Reader of field `PUPD14`"]
        pub type PUPD14_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD14`"]
        pub struct PUPD14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD14_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD13_A = PUPD15_A;
        #[doc = "Reader of field `PUPD13`"]
        pub type PUPD13_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD13`"]
        pub struct PUPD13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD13_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD12_A = PUPD15_A;
        #[doc = "Reader of field `PUPD12`"]
        pub type PUPD12_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD12`"]
        pub struct PUPD12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD12_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | (((value as u32) & 0x03) << 24);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD11_A = PUPD15_A;
        #[doc = "Reader of field `PUPD11`"]
        pub type PUPD11_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD11`"]
        pub struct PUPD11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD11_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD10_A = PUPD15_A;
        #[doc = "Reader of field `PUPD10`"]
        pub type PUPD10_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD10`"]
        pub struct PUPD10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD10_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD9_A = PUPD15_A;
        #[doc = "Reader of field `PUPD9`"]
        pub type PUPD9_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD9`"]
        pub struct PUPD9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD9_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD8_A = PUPD15_A;
        #[doc = "Reader of field `PUPD8`"]
        pub type PUPD8_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD8`"]
        pub struct PUPD8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD8_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD7_A = PUPD15_A;
        #[doc = "Reader of field `PUPD7`"]
        pub type PUPD7_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD7`"]
        pub struct PUPD7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD7_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | (((value as u32) & 0x03) << 14);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD6_A = PUPD15_A;
        #[doc = "Reader of field `PUPD6`"]
        pub type PUPD6_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD6`"]
        pub struct PUPD6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD6_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD5_A = PUPD15_A;
        #[doc = "Reader of field `PUPD5`"]
        pub type PUPD5_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD5`"]
        pub struct PUPD5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD5_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD4_A = PUPD15_A;
        #[doc = "Reader of field `PUPD4`"]
        pub type PUPD4_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD4`"]
        pub struct PUPD4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD4_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD3_A = PUPD15_A;
        #[doc = "Reader of field `PUPD3`"]
        pub type PUPD3_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD3`"]
        pub struct PUPD3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD3_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD2_A = PUPD15_A;
        #[doc = "Reader of field `PUPD2`"]
        pub type PUPD2_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD2`"]
        pub struct PUPD2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD1_A = PUPD15_A;
        #[doc = "Reader of field `PUPD1`"]
        pub type PUPD1_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD1`"]
        pub struct PUPD1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Port x configuration bits (y = 0..15)"]
        pub type PUPD0_A = PUPD15_A;
        #[doc = "Reader of field `PUPD0`"]
        pub type PUPD0_R = crate::R<u8, PUPD15_A>;
        #[doc = "Write proxy for field `PUPD0`"]
        pub struct PUPD0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PUPD0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PUPD0_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No pull-up, pull-down"]
            #[inline(always)]
            pub fn floating(self) -> &'a mut W {
                self.variant(PUPD15_A::FLOATING)
            }
            #[doc = "Pull-up"]
            #[inline(always)]
            pub fn pull_up(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLUP)
            }
            #[doc = "Pull-down"]
            #[inline(always)]
            pub fn pull_down(self) -> &'a mut W {
                self.variant(PUPD15_A::PULLDOWN)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd15(&self) -> PUPD15_R {
                PUPD15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd14(&self) -> PUPD14_R {
                PUPD14_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd13(&self) -> PUPD13_R {
                PUPD13_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd12(&self) -> PUPD12_R {
                PUPD12_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd11(&self) -> PUPD11_R {
                PUPD11_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd10(&self) -> PUPD10_R {
                PUPD10_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd9(&self) -> PUPD9_R {
                PUPD9_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd8(&self) -> PUPD8_R {
                PUPD8_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd7(&self) -> PUPD7_R {
                PUPD7_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd6(&self) -> PUPD6_R {
                PUPD6_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd5(&self) -> PUPD5_R {
                PUPD5_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd4(&self) -> PUPD4_R {
                PUPD4_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd3(&self) -> PUPD3_R {
                PUPD3_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd2(&self) -> PUPD2_R {
                PUPD2_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd1(&self) -> PUPD1_R {
                PUPD1_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd0(&self) -> PUPD0_R {
                PUPD0_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd15(&mut self) -> PUPD15_W {
                PUPD15_W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd14(&mut self) -> PUPD14_W {
                PUPD14_W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd13(&mut self) -> PUPD13_W {
                PUPD13_W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd12(&mut self) -> PUPD12_W {
                PUPD12_W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd11(&mut self) -> PUPD11_W {
                PUPD11_W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd10(&mut self) -> PUPD10_W {
                PUPD10_W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd9(&mut self) -> PUPD9_W {
                PUPD9_W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd8(&mut self) -> PUPD8_W {
                PUPD8_W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd7(&mut self) -> PUPD7_W {
                PUPD7_W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd6(&mut self) -> PUPD6_W {
                PUPD6_W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd5(&mut self) -> PUPD5_W {
                PUPD5_W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd4(&mut self) -> PUPD4_W {
                PUPD4_W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd3(&mut self) -> PUPD3_W {
                PUPD3_W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd2(&mut self) -> PUPD2_W {
                PUPD2_W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd1(&mut self) -> PUPD1_W {
                PUPD1_W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline(always)]
            pub fn pupd0(&mut self) -> PUPD0_W {
                PUPD0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port input data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "GPIO port input data register"]
    pub mod idr {
        #[doc = "Reader of register IDR"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Port input data bit (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ID15_A {
            #[doc = "1: Input is logic high"]
            HIGH = 1,
            #[doc = "0: Input is logic low"]
            LOW = 0,
        }
        impl From<ID15_A> for bool {
            #[inline(always)]
            fn from(variant: ID15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ID15`"]
        pub type ID15_R = crate::R<bool, ID15_A>;
        impl ID15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ID15_A {
                match self.bits {
                    true => ID15_A::HIGH,
                    false => ID15_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == ID15_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == ID15_A::LOW
            }
        }
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID14_A = ID15_A;
        #[doc = "Reader of field `ID14`"]
        pub type ID14_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID13_A = ID15_A;
        #[doc = "Reader of field `ID13`"]
        pub type ID13_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID12_A = ID15_A;
        #[doc = "Reader of field `ID12`"]
        pub type ID12_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID11_A = ID15_A;
        #[doc = "Reader of field `ID11`"]
        pub type ID11_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID10_A = ID15_A;
        #[doc = "Reader of field `ID10`"]
        pub type ID10_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID9_A = ID15_A;
        #[doc = "Reader of field `ID9`"]
        pub type ID9_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID8_A = ID15_A;
        #[doc = "Reader of field `ID8`"]
        pub type ID8_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID7_A = ID15_A;
        #[doc = "Reader of field `ID7`"]
        pub type ID7_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID6_A = ID15_A;
        #[doc = "Reader of field `ID6`"]
        pub type ID6_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID5_A = ID15_A;
        #[doc = "Reader of field `ID5`"]
        pub type ID5_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID4_A = ID15_A;
        #[doc = "Reader of field `ID4`"]
        pub type ID4_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID3_A = ID15_A;
        #[doc = "Reader of field `ID3`"]
        pub type ID3_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID2_A = ID15_A;
        #[doc = "Reader of field `ID2`"]
        pub type ID2_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID1_A = ID15_A;
        #[doc = "Reader of field `ID1`"]
        pub type ID1_R = crate::R<bool, ID15_A>;
        #[doc = "Port input data bit (y = 0..15)"]
        pub type ID0_A = ID15_A;
        #[doc = "Reader of field `ID0`"]
        pub type ID0_R = crate::R<bool, ID15_A>;
        impl R {
            #[doc = "Bit 15 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id15(&self) -> ID15_R {
                ID15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id14(&self) -> ID14_R {
                ID14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id13(&self) -> ID13_R {
                ID13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id12(&self) -> ID12_R {
                ID12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id11(&self) -> ID11_R {
                ID11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id10(&self) -> ID10_R {
                ID10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id9(&self) -> ID9_R {
                ID9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id8(&self) -> ID8_R {
                ID8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id7(&self) -> ID7_R {
                ID7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id6(&self) -> ID6_R {
                ID6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id5(&self) -> ID5_R {
                ID5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id4(&self) -> ID4_R {
                ID4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id3(&self) -> ID3_R {
                ID3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id2(&self) -> ID2_R {
                ID2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id1(&self) -> ID1_R {
                ID1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port input data bit (y = 0..15)"]
            #[inline(always)]
            pub fn id0(&self) -> ID0_R {
                ID0_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "GPIO port output data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [odr](odr) module"]
    pub type ODR = crate::Reg<u32, _ODR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ODR;
    #[doc = "`read()` method returns [odr::R](odr::R) reader structure"]
    impl crate::Readable for ODR {}
    #[doc = "`write(|w| ..)` method takes [odr::W](odr::W) writer structure"]
    impl crate::Writable for ODR {}
    #[doc = "GPIO port output data register"]
    pub mod odr {
        #[doc = "Reader of register ODR"]
        pub type R = crate::R<u32, super::ODR>;
        #[doc = "Writer for register ODR"]
        pub type W = crate::W<u32, super::ODR>;
        #[doc = "Register ODR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ODR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port output data bit (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OD15_A {
            #[doc = "1: Set output to logic high"]
            HIGH = 1,
            #[doc = "0: Set output to logic low"]
            LOW = 0,
        }
        impl From<OD15_A> for bool {
            #[inline(always)]
            fn from(variant: OD15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OD15`"]
        pub type OD15_R = crate::R<bool, OD15_A>;
        impl OD15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OD15_A {
                match self.bits {
                    true => OD15_A::HIGH,
                    false => OD15_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == OD15_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == OD15_A::LOW
            }
        }
        #[doc = "Write proxy for field `OD15`"]
        pub struct OD15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD14_A = OD15_A;
        #[doc = "Reader of field `OD14`"]
        pub type OD14_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD14`"]
        pub struct OD14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD13_A = OD15_A;
        #[doc = "Reader of field `OD13`"]
        pub type OD13_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD13`"]
        pub struct OD13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD12_A = OD15_A;
        #[doc = "Reader of field `OD12`"]
        pub type OD12_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD12`"]
        pub struct OD12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD11_A = OD15_A;
        #[doc = "Reader of field `OD11`"]
        pub type OD11_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD11`"]
        pub struct OD11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD10_A = OD15_A;
        #[doc = "Reader of field `OD10`"]
        pub type OD10_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD10`"]
        pub struct OD10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD9_A = OD15_A;
        #[doc = "Reader of field `OD9`"]
        pub type OD9_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD9`"]
        pub struct OD9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD8_A = OD15_A;
        #[doc = "Reader of field `OD8`"]
        pub type OD8_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD8`"]
        pub struct OD8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD7_A = OD15_A;
        #[doc = "Reader of field `OD7`"]
        pub type OD7_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD7`"]
        pub struct OD7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD6_A = OD15_A;
        #[doc = "Reader of field `OD6`"]
        pub type OD6_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD6`"]
        pub struct OD6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD5_A = OD15_A;
        #[doc = "Reader of field `OD5`"]
        pub type OD5_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD5`"]
        pub struct OD5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD4_A = OD15_A;
        #[doc = "Reader of field `OD4`"]
        pub type OD4_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD4`"]
        pub struct OD4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD3_A = OD15_A;
        #[doc = "Reader of field `OD3`"]
        pub type OD3_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD3`"]
        pub struct OD3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD2_A = OD15_A;
        #[doc = "Reader of field `OD2`"]
        pub type OD2_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD2`"]
        pub struct OD2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD1_A = OD15_A;
        #[doc = "Reader of field `OD1`"]
        pub type OD1_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD1`"]
        pub struct OD1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port output data bit (y = 0..15)"]
        pub type OD0_A = OD15_A;
        #[doc = "Reader of field `OD0`"]
        pub type OD0_R = crate::R<bool, OD15_A>;
        #[doc = "Write proxy for field `OD0`"]
        pub struct OD0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OD0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OD0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OD15_A::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OD15_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od15(&self) -> OD15_R {
                OD15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od14(&self) -> OD14_R {
                OD14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od13(&self) -> OD13_R {
                OD13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od12(&self) -> OD12_R {
                OD12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od11(&self) -> OD11_R {
                OD11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od10(&self) -> OD10_R {
                OD10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od9(&self) -> OD9_R {
                OD9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od8(&self) -> OD8_R {
                OD8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od7(&self) -> OD7_R {
                OD7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od6(&self) -> OD6_R {
                OD6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od5(&self) -> OD5_R {
                OD5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od4(&self) -> OD4_R {
                OD4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od3(&self) -> OD3_R {
                OD3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od2(&self) -> OD2_R {
                OD2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od1(&self) -> OD1_R {
                OD1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od0(&self) -> OD0_R {
                OD0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od15(&mut self) -> OD15_W {
                OD15_W { w: self }
            }
            #[doc = "Bit 14 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od14(&mut self) -> OD14_W {
                OD14_W { w: self }
            }
            #[doc = "Bit 13 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od13(&mut self) -> OD13_W {
                OD13_W { w: self }
            }
            #[doc = "Bit 12 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od12(&mut self) -> OD12_W {
                OD12_W { w: self }
            }
            #[doc = "Bit 11 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od11(&mut self) -> OD11_W {
                OD11_W { w: self }
            }
            #[doc = "Bit 10 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od10(&mut self) -> OD10_W {
                OD10_W { w: self }
            }
            #[doc = "Bit 9 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od9(&mut self) -> OD9_W {
                OD9_W { w: self }
            }
            #[doc = "Bit 8 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od8(&mut self) -> OD8_W {
                OD8_W { w: self }
            }
            #[doc = "Bit 7 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od7(&mut self) -> OD7_W {
                OD7_W { w: self }
            }
            #[doc = "Bit 6 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od6(&mut self) -> OD6_W {
                OD6_W { w: self }
            }
            #[doc = "Bit 5 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od5(&mut self) -> OD5_W {
                OD5_W { w: self }
            }
            #[doc = "Bit 4 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od4(&mut self) -> OD4_W {
                OD4_W { w: self }
            }
            #[doc = "Bit 3 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od3(&mut self) -> OD3_W {
                OD3_W { w: self }
            }
            #[doc = "Bit 2 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od2(&mut self) -> OD2_W {
                OD2_W { w: self }
            }
            #[doc = "Bit 1 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od1(&mut self) -> OD1_W {
                OD1_W { w: self }
            }
            #[doc = "Bit 0 - Port output data bit (y = 0..15)"]
            #[inline(always)]
            pub fn od0(&mut self) -> OD0_W {
                OD0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port bit set/reset register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bsrr](bsrr) module"]
    pub type BSRR = crate::Reg<u32, _BSRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BSRR;
    #[doc = "`write(|w| ..)` method takes [bsrr::W](bsrr::W) writer structure"]
    impl crate::Writable for BSRR {}
    #[doc = "GPIO port bit set/reset register"]
    pub mod bsrr {
        #[doc = "Writer for register BSRR"]
        pub type W = crate::W<u32, super::BSRR>;
        #[doc = "Register BSRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BSRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BR15_AW {
            #[doc = "1: Resets the corresponding ODx bit"]
            RESET = 1,
        }
        impl From<BR15_AW> for bool {
            #[inline(always)]
            fn from(variant: BR15_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BR15`"]
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR14_AW = BR15_AW;
        #[doc = "Write proxy for field `BR14`"]
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR13_AW = BR15_AW;
        #[doc = "Write proxy for field `BR13`"]
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR12_AW = BR15_AW;
        #[doc = "Write proxy for field `BR12`"]
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR11_AW = BR15_AW;
        #[doc = "Write proxy for field `BR11`"]
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR10_AW = BR15_AW;
        #[doc = "Write proxy for field `BR10`"]
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR9_AW = BR15_AW;
        #[doc = "Write proxy for field `BR9`"]
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR8_AW = BR15_AW;
        #[doc = "Write proxy for field `BR8`"]
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR7_AW = BR15_AW;
        #[doc = "Write proxy for field `BR7`"]
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR6_AW = BR15_AW;
        #[doc = "Write proxy for field `BR6`"]
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR5_AW = BR15_AW;
        #[doc = "Write proxy for field `BR5`"]
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR4_AW = BR15_AW;
        #[doc = "Write proxy for field `BR4`"]
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR3_AW = BR15_AW;
        #[doc = "Write proxy for field `BR3`"]
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR2_AW = BR15_AW;
        #[doc = "Write proxy for field `BR2`"]
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR1_AW = BR15_AW;
        #[doc = "Write proxy for field `BR1`"]
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Port x reset bit y (y = 0..15)"]
        pub type BR0_AW = BR15_AW;
        #[doc = "Write proxy for field `BR0`"]
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the corresponding ODx bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BS15_AW {
            #[doc = "1: Sets the corresponding ODx bit"]
            SET = 1,
        }
        impl From<BS15_AW> for bool {
            #[inline(always)]
            fn from(variant: BS15_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BS15`"]
        pub struct BS15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS14_AW = BS15_AW;
        #[doc = "Write proxy for field `BS14`"]
        pub struct BS14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS13_AW = BS15_AW;
        #[doc = "Write proxy for field `BS13`"]
        pub struct BS13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS12_AW = BS15_AW;
        #[doc = "Write proxy for field `BS12`"]
        pub struct BS12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS11_AW = BS15_AW;
        #[doc = "Write proxy for field `BS11`"]
        pub struct BS11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS10_AW = BS15_AW;
        #[doc = "Write proxy for field `BS10`"]
        pub struct BS10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS9_AW = BS15_AW;
        #[doc = "Write proxy for field `BS9`"]
        pub struct BS9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS8_AW = BS15_AW;
        #[doc = "Write proxy for field `BS8`"]
        pub struct BS8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS7_AW = BS15_AW;
        #[doc = "Write proxy for field `BS7`"]
        pub struct BS7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS6_AW = BS15_AW;
        #[doc = "Write proxy for field `BS6`"]
        pub struct BS6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS5_AW = BS15_AW;
        #[doc = "Write proxy for field `BS5`"]
        pub struct BS5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS4_AW = BS15_AW;
        #[doc = "Write proxy for field `BS4`"]
        pub struct BS4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS3_AW = BS15_AW;
        #[doc = "Write proxy for field `BS3`"]
        pub struct BS3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS2_AW = BS15_AW;
        #[doc = "Write proxy for field `BS2`"]
        pub struct BS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS1_AW = BS15_AW;
        #[doc = "Write proxy for field `BS1`"]
        pub struct BS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port x set bit y (y= 0..15)"]
        pub type BS0_AW = BS15_AW;
        #[doc = "Write proxy for field `BS0`"]
        pub struct BS0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BS0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets the corresponding ODx bit"]
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
            #[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            #[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            #[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            #[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            #[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            #[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            #[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            #[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            #[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            #[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            #[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            #[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            #[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            #[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            #[doc = "Bit 16 - Port x reset bit y (y = 0..15)"]
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
            #[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs15(&mut self) -> BS15_W {
                BS15_W { w: self }
            }
            #[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs14(&mut self) -> BS14_W {
                BS14_W { w: self }
            }
            #[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs13(&mut self) -> BS13_W {
                BS13_W { w: self }
            }
            #[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs12(&mut self) -> BS12_W {
                BS12_W { w: self }
            }
            #[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs11(&mut self) -> BS11_W {
                BS11_W { w: self }
            }
            #[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs10(&mut self) -> BS10_W {
                BS10_W { w: self }
            }
            #[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs9(&mut self) -> BS9_W {
                BS9_W { w: self }
            }
            #[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs8(&mut self) -> BS8_W {
                BS8_W { w: self }
            }
            #[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs7(&mut self) -> BS7_W {
                BS7_W { w: self }
            }
            #[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs6(&mut self) -> BS6_W {
                BS6_W { w: self }
            }
            #[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs5(&mut self) -> BS5_W {
                BS5_W { w: self }
            }
            #[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs4(&mut self) -> BS4_W {
                BS4_W { w: self }
            }
            #[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs3(&mut self) -> BS3_W {
                BS3_W { w: self }
            }
            #[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs2(&mut self) -> BS2_W {
                BS2_W { w: self }
            }
            #[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs1(&mut self) -> BS1_W {
                BS1_W { w: self }
            }
            #[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
            #[inline(always)]
            pub fn bs0(&mut self) -> BS0_W {
                BS0_W { w: self }
            }
        }
    }
    #[doc = "GPIO port configuration lock register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lckr](lckr) module"]
    pub type LCKR = crate::Reg<u32, _LCKR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LCKR;
    #[doc = "`read()` method returns [lckr::R](lckr::R) reader structure"]
    impl crate::Readable for LCKR {}
    #[doc = "`write(|w| ..)` method takes [lckr::W](lckr::W) writer structure"]
    impl crate::Writable for LCKR {}
    #[doc = "GPIO port configuration lock register"]
    pub mod lckr {
        #[doc = "Reader of register LCKR"]
        pub type R = crate::R<u32, super::LCKR>;
        #[doc = "Writer for register LCKR"]
        pub type W = crate::W<u32, super::LCKR>;
        #[doc = "Register LCKR `reset()`'s with value 0"]
        impl crate::ResetValue for super::LCKR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCKK_A {
            #[doc = "0: Port configuration lock key not active"]
            NOTACTIVE = 0,
            #[doc = "1: Port configuration lock key active"]
            ACTIVE = 1,
        }
        impl From<LCKK_A> for bool {
            #[inline(always)]
            fn from(variant: LCKK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCKK`"]
        pub type LCKK_R = crate::R<bool, LCKK_A>;
        impl LCKK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCKK_A {
                match self.bits {
                    false => LCKK_A::NOTACTIVE,
                    true => LCKK_A::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTACTIVE`"]
            #[inline(always)]
            pub fn is_not_active(&self) -> bool {
                *self == LCKK_A::NOTACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == LCKK_A::ACTIVE
            }
        }
        #[doc = "Write proxy for field `LCKK`"]
        pub struct LCKK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCKK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCKK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration lock key not active"]
            #[inline(always)]
            pub fn not_active(self) -> &'a mut W {
                self.variant(LCKK_A::NOTACTIVE)
            }
            #[doc = "Port configuration lock key active"]
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(LCKK_A::ACTIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK15_A {
            #[doc = "0: Port configuration not locked"]
            UNLOCKED = 0,
            #[doc = "1: Port configuration locked"]
            LOCKED = 1,
        }
        impl From<LCK15_A> for bool {
            #[inline(always)]
            fn from(variant: LCK15_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCK15`"]
        pub type LCK15_R = crate::R<bool, LCK15_A>;
        impl LCK15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCK15_A {
                match self.bits {
                    false => LCK15_A::UNLOCKED,
                    true => LCK15_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK15_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCK15_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `LCK15`"]
        pub struct LCK15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK14_A = LCK15_A;
        #[doc = "Reader of field `LCK14`"]
        pub type LCK14_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK14`"]
        pub struct LCK14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK13_A = LCK15_A;
        #[doc = "Reader of field `LCK13`"]
        pub type LCK13_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK13`"]
        pub struct LCK13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK12_A = LCK15_A;
        #[doc = "Reader of field `LCK12`"]
        pub type LCK12_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK12`"]
        pub struct LCK12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK11_A = LCK15_A;
        #[doc = "Reader of field `LCK11`"]
        pub type LCK11_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK11`"]
        pub struct LCK11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK10_A = LCK15_A;
        #[doc = "Reader of field `LCK10`"]
        pub type LCK10_R = crate::R<bool, LCK15_A>;
        #[doc = "Write proxy for field `LCK10`"]
        pub struct LCK10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK9_A {
            #[doc = "0: Port configuration not locked"]
            UNLOCKED = 0,
            #[doc = "1: Port configuration locked"]
            LOCKED = 1,
        }
        impl From<LCK9_A> for bool {
            #[inline(always)]
            fn from(variant: LCK9_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LCK9`"]
        pub type LCK9_R = crate::R<bool, LCK9_A>;
        impl LCK9_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LCK9_A {
                match self.bits {
                    false => LCK9_A::UNLOCKED,
                    true => LCK9_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK9_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCK9_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `LCK9`"]
        pub struct LCK9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK8_A = LCK9_A;
        #[doc = "Reader of field `LCK8`"]
        pub type LCK8_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK8`"]
        pub struct LCK8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK7_A = LCK9_A;
        #[doc = "Reader of field `LCK7`"]
        pub type LCK7_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK7`"]
        pub struct LCK7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK6_A = LCK9_A;
        #[doc = "Reader of field `LCK6`"]
        pub type LCK6_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK6`"]
        pub struct LCK6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK5_A = LCK9_A;
        #[doc = "Reader of field `LCK5`"]
        pub type LCK5_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK5`"]
        pub struct LCK5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK4_A = LCK9_A;
        #[doc = "Reader of field `LCK4`"]
        pub type LCK4_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK4`"]
        pub struct LCK4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK3_A = LCK9_A;
        #[doc = "Reader of field `LCK3`"]
        pub type LCK3_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK3`"]
        pub struct LCK3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK2_A = LCK9_A;
        #[doc = "Reader of field `LCK2`"]
        pub type LCK2_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK2`"]
        pub struct LCK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK1_A = LCK9_A;
        #[doc = "Reader of field `LCK1`"]
        pub type LCK1_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK1`"]
        pub struct LCK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port x lock bit y (y= 0..15)"]
        pub type LCK0_A = LCK9_A;
        #[doc = "Reader of field `LCK0`"]
        pub type LCK0_R = crate::R<bool, LCK9_A>;
        #[doc = "Write proxy for field `LCK0`"]
        pub struct LCK0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LCK0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck15(&self) -> LCK15_R {
                LCK15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck14(&self) -> LCK14_R {
                LCK14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck13(&self) -> LCK13_R {
                LCK13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck12(&self) -> LCK12_R {
                LCK12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck11(&self) -> LCK11_R {
                LCK11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck10(&self) -> LCK10_R {
                LCK10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck9(&self) -> LCK9_R {
                LCK9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck8(&self) -> LCK8_R {
                LCK8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lckk(&mut self) -> LCKK_W {
                LCKK_W { w: self }
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck15(&mut self) -> LCK15_W {
                LCK15_W { w: self }
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck14(&mut self) -> LCK14_W {
                LCK14_W { w: self }
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck13(&mut self) -> LCK13_W {
                LCK13_W { w: self }
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck12(&mut self) -> LCK12_W {
                LCK12_W { w: self }
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck11(&mut self) -> LCK11_W {
                LCK11_W { w: self }
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck10(&mut self) -> LCK10_W {
                LCK10_W { w: self }
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck9(&mut self) -> LCK9_W {
                LCK9_W { w: self }
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck8(&mut self) -> LCK8_W {
                LCK8_W { w: self }
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck7(&mut self) -> LCK7_W {
                LCK7_W { w: self }
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck6(&mut self) -> LCK6_W {
                LCK6_W { w: self }
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck5(&mut self) -> LCK5_W {
                LCK5_W { w: self }
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck4(&mut self) -> LCK4_W {
                LCK4_W { w: self }
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck3(&mut self) -> LCK3_W {
                LCK3_W { w: self }
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck2(&mut self) -> LCK2_W {
                LCK2_W { w: self }
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck1(&mut self) -> LCK1_W {
                LCK1_W { w: self }
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline(always)]
            pub fn lck0(&mut self) -> LCK0_W {
                LCK0_W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function low register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [afrl](afrl) module"]
    pub type AFRL = crate::Reg<u32, _AFRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AFRL;
    #[doc = "`read()` method returns [afrl::R](afrl::R) reader structure"]
    impl crate::Readable for AFRL {}
    #[doc = "`write(|w| ..)` method takes [afrl::W](afrl::W) writer structure"]
    impl crate::Writable for AFRL {}
    #[doc = "GPIO alternate function low register"]
    pub mod afrl {
        #[doc = "Reader of register AFRL"]
        pub type R = crate::R<u32, super::AFRL>;
        #[doc = "Writer for register AFRL"]
        pub type W = crate::W<u32, super::AFRL>;
        #[doc = "Register AFRL `reset()`'s with value 0"]
        impl crate::ResetValue for super::AFRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum AFSEL7_A {
            #[doc = "0: AF0"]
            AF0 = 0,
            #[doc = "1: AF1"]
            AF1 = 1,
            #[doc = "2: AF2"]
            AF2 = 2,
            #[doc = "3: AF3"]
            AF3 = 3,
            #[doc = "4: AF4"]
            AF4 = 4,
            #[doc = "5: AF5"]
            AF5 = 5,
            #[doc = "6: AF6"]
            AF6 = 6,
            #[doc = "7: AF7"]
            AF7 = 7,
            #[doc = "8: AF8"]
            AF8 = 8,
            #[doc = "9: AF9"]
            AF9 = 9,
            #[doc = "10: AF10"]
            AF10 = 10,
            #[doc = "11: AF11"]
            AF11 = 11,
            #[doc = "12: AF12"]
            AF12 = 12,
            #[doc = "13: AF13"]
            AF13 = 13,
            #[doc = "14: AF14"]
            AF14 = 14,
            #[doc = "15: AF15"]
            AF15 = 15,
        }
        impl From<AFSEL7_A> for u8 {
            #[inline(always)]
            fn from(variant: AFSEL7_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `AFSEL7`"]
        pub type AFSEL7_R = crate::R<u8, AFSEL7_A>;
        impl AFSEL7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AFSEL7_A {
                match self.bits {
                    0 => AFSEL7_A::AF0,
                    1 => AFSEL7_A::AF1,
                    2 => AFSEL7_A::AF2,
                    3 => AFSEL7_A::AF3,
                    4 => AFSEL7_A::AF4,
                    5 => AFSEL7_A::AF5,
                    6 => AFSEL7_A::AF6,
                    7 => AFSEL7_A::AF7,
                    8 => AFSEL7_A::AF8,
                    9 => AFSEL7_A::AF9,
                    10 => AFSEL7_A::AF10,
                    11 => AFSEL7_A::AF11,
                    12 => AFSEL7_A::AF12,
                    13 => AFSEL7_A::AF13,
                    14 => AFSEL7_A::AF14,
                    15 => AFSEL7_A::AF15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `AF0`"]
            #[inline(always)]
            pub fn is_af0(&self) -> bool {
                *self == AFSEL7_A::AF0
            }
            #[doc = "Checks if the value of the field is `AF1`"]
            #[inline(always)]
            pub fn is_af1(&self) -> bool {
                *self == AFSEL7_A::AF1
            }
            #[doc = "Checks if the value of the field is `AF2`"]
            #[inline(always)]
            pub fn is_af2(&self) -> bool {
                *self == AFSEL7_A::AF2
            }
            #[doc = "Checks if the value of the field is `AF3`"]
            #[inline(always)]
            pub fn is_af3(&self) -> bool {
                *self == AFSEL7_A::AF3
            }
            #[doc = "Checks if the value of the field is `AF4`"]
            #[inline(always)]
            pub fn is_af4(&self) -> bool {
                *self == AFSEL7_A::AF4
            }
            #[doc = "Checks if the value of the field is `AF5`"]
            #[inline(always)]
            pub fn is_af5(&self) -> bool {
                *self == AFSEL7_A::AF5
            }
            #[doc = "Checks if the value of the field is `AF6`"]
            #[inline(always)]
            pub fn is_af6(&self) -> bool {
                *self == AFSEL7_A::AF6
            }
            #[doc = "Checks if the value of the field is `AF7`"]
            #[inline(always)]
            pub fn is_af7(&self) -> bool {
                *self == AFSEL7_A::AF7
            }
            #[doc = "Checks if the value of the field is `AF8`"]
            #[inline(always)]
            pub fn is_af8(&self) -> bool {
                *self == AFSEL7_A::AF8
            }
            #[doc = "Checks if the value of the field is `AF9`"]
            #[inline(always)]
            pub fn is_af9(&self) -> bool {
                *self == AFSEL7_A::AF9
            }
            #[doc = "Checks if the value of the field is `AF10`"]
            #[inline(always)]
            pub fn is_af10(&self) -> bool {
                *self == AFSEL7_A::AF10
            }
            #[doc = "Checks if the value of the field is `AF11`"]
            #[inline(always)]
            pub fn is_af11(&self) -> bool {
                *self == AFSEL7_A::AF11
            }
            #[doc = "Checks if the value of the field is `AF12`"]
            #[inline(always)]
            pub fn is_af12(&self) -> bool {
                *self == AFSEL7_A::AF12
            }
            #[doc = "Checks if the value of the field is `AF13`"]
            #[inline(always)]
            pub fn is_af13(&self) -> bool {
                *self == AFSEL7_A::AF13
            }
            #[doc = "Checks if the value of the field is `AF14`"]
            #[inline(always)]
            pub fn is_af14(&self) -> bool {
                *self == AFSEL7_A::AF14
            }
            #[doc = "Checks if the value of the field is `AF15`"]
            #[inline(always)]
            pub fn is_af15(&self) -> bool {
                *self == AFSEL7_A::AF15
            }
        }
        #[doc = "Write proxy for field `AFSEL7`"]
        pub struct AFSEL7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL7_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 28)) | (((value as u32) & 0x0f) << 28);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL6_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL6`"]
        pub type AFSEL6_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL6`"]
        pub struct AFSEL6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL6_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL5_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL5`"]
        pub type AFSEL5_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL5`"]
        pub struct AFSEL5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL5_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL4_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL4`"]
        pub type AFSEL4_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL4`"]
        pub struct AFSEL4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL4_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL3_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL3`"]
        pub type AFSEL3_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL3`"]
        pub struct AFSEL3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL3_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL2_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL2`"]
        pub type AFSEL2_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL2`"]
        pub struct AFSEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL2_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL1_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL1`"]
        pub type AFSEL1_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL1`"]
        pub struct AFSEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL1_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 0..7)"]
        pub type AFSEL0_A = AFSEL7_A;
        #[doc = "Reader of field `AFSEL0`"]
        pub type AFSEL0_R = crate::R<u8, AFSEL7_A>;
        #[doc = "Write proxy for field `AFSEL0`"]
        pub struct AFSEL0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL0_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL7_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel7(&self) -> AFSEL7_R {
                AFSEL7_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel6(&self) -> AFSEL6_R {
                AFSEL6_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel5(&self) -> AFSEL5_R {
                AFSEL5_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel4(&self) -> AFSEL4_R {
                AFSEL4_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel3(&self) -> AFSEL3_R {
                AFSEL3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel2(&self) -> AFSEL2_R {
                AFSEL2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel1(&self) -> AFSEL1_R {
                AFSEL1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel0(&self) -> AFSEL0_R {
                AFSEL0_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel7(&mut self) -> AFSEL7_W {
                AFSEL7_W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel6(&mut self) -> AFSEL6_W {
                AFSEL6_W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel5(&mut self) -> AFSEL5_W {
                AFSEL5_W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel4(&mut self) -> AFSEL4_W {
                AFSEL4_W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel3(&mut self) -> AFSEL3_W {
                AFSEL3_W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel2(&mut self) -> AFSEL2_W {
                AFSEL2_W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel1(&mut self) -> AFSEL1_W {
                AFSEL1_W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 0..7)"]
            #[inline(always)]
            pub fn afsel0(&mut self) -> AFSEL0_W {
                AFSEL0_W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function high register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [afrh](afrh) module"]
    pub type AFRH = crate::Reg<u32, _AFRH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AFRH;
    #[doc = "`read()` method returns [afrh::R](afrh::R) reader structure"]
    impl crate::Readable for AFRH {}
    #[doc = "`write(|w| ..)` method takes [afrh::W](afrh::W) writer structure"]
    impl crate::Writable for AFRH {}
    #[doc = "GPIO alternate function high register"]
    pub mod afrh {
        #[doc = "Reader of register AFRH"]
        pub type R = crate::R<u32, super::AFRH>;
        #[doc = "Writer for register AFRH"]
        pub type W = crate::W<u32, super::AFRH>;
        #[doc = "Register AFRH `reset()`'s with value 0"]
        impl crate::ResetValue for super::AFRH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum AFSEL15_A {
            #[doc = "0: AF0"]
            AF0 = 0,
            #[doc = "1: AF1"]
            AF1 = 1,
            #[doc = "2: AF2"]
            AF2 = 2,
            #[doc = "3: AF3"]
            AF3 = 3,
            #[doc = "4: AF4"]
            AF4 = 4,
            #[doc = "5: AF5"]
            AF5 = 5,
            #[doc = "6: AF6"]
            AF6 = 6,
            #[doc = "7: AF7"]
            AF7 = 7,
            #[doc = "8: AF8"]
            AF8 = 8,
            #[doc = "9: AF9"]
            AF9 = 9,
            #[doc = "10: AF10"]
            AF10 = 10,
            #[doc = "11: AF11"]
            AF11 = 11,
            #[doc = "12: AF12"]
            AF12 = 12,
            #[doc = "13: AF13"]
            AF13 = 13,
            #[doc = "14: AF14"]
            AF14 = 14,
            #[doc = "15: AF15"]
            AF15 = 15,
        }
        impl From<AFSEL15_A> for u8 {
            #[inline(always)]
            fn from(variant: AFSEL15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `AFSEL15`"]
        pub type AFSEL15_R = crate::R<u8, AFSEL15_A>;
        impl AFSEL15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AFSEL15_A {
                match self.bits {
                    0 => AFSEL15_A::AF0,
                    1 => AFSEL15_A::AF1,
                    2 => AFSEL15_A::AF2,
                    3 => AFSEL15_A::AF3,
                    4 => AFSEL15_A::AF4,
                    5 => AFSEL15_A::AF5,
                    6 => AFSEL15_A::AF6,
                    7 => AFSEL15_A::AF7,
                    8 => AFSEL15_A::AF8,
                    9 => AFSEL15_A::AF9,
                    10 => AFSEL15_A::AF10,
                    11 => AFSEL15_A::AF11,
                    12 => AFSEL15_A::AF12,
                    13 => AFSEL15_A::AF13,
                    14 => AFSEL15_A::AF14,
                    15 => AFSEL15_A::AF15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `AF0`"]
            #[inline(always)]
            pub fn is_af0(&self) -> bool {
                *self == AFSEL15_A::AF0
            }
            #[doc = "Checks if the value of the field is `AF1`"]
            #[inline(always)]
            pub fn is_af1(&self) -> bool {
                *self == AFSEL15_A::AF1
            }
            #[doc = "Checks if the value of the field is `AF2`"]
            #[inline(always)]
            pub fn is_af2(&self) -> bool {
                *self == AFSEL15_A::AF2
            }
            #[doc = "Checks if the value of the field is `AF3`"]
            #[inline(always)]
            pub fn is_af3(&self) -> bool {
                *self == AFSEL15_A::AF3
            }
            #[doc = "Checks if the value of the field is `AF4`"]
            #[inline(always)]
            pub fn is_af4(&self) -> bool {
                *self == AFSEL15_A::AF4
            }
            #[doc = "Checks if the value of the field is `AF5`"]
            #[inline(always)]
            pub fn is_af5(&self) -> bool {
                *self == AFSEL15_A::AF5
            }
            #[doc = "Checks if the value of the field is `AF6`"]
            #[inline(always)]
            pub fn is_af6(&self) -> bool {
                *self == AFSEL15_A::AF6
            }
            #[doc = "Checks if the value of the field is `AF7`"]
            #[inline(always)]
            pub fn is_af7(&self) -> bool {
                *self == AFSEL15_A::AF7
            }
            #[doc = "Checks if the value of the field is `AF8`"]
            #[inline(always)]
            pub fn is_af8(&self) -> bool {
                *self == AFSEL15_A::AF8
            }
            #[doc = "Checks if the value of the field is `AF9`"]
            #[inline(always)]
            pub fn is_af9(&self) -> bool {
                *self == AFSEL15_A::AF9
            }
            #[doc = "Checks if the value of the field is `AF10`"]
            #[inline(always)]
            pub fn is_af10(&self) -> bool {
                *self == AFSEL15_A::AF10
            }
            #[doc = "Checks if the value of the field is `AF11`"]
            #[inline(always)]
            pub fn is_af11(&self) -> bool {
                *self == AFSEL15_A::AF11
            }
            #[doc = "Checks if the value of the field is `AF12`"]
            #[inline(always)]
            pub fn is_af12(&self) -> bool {
                *self == AFSEL15_A::AF12
            }
            #[doc = "Checks if the value of the field is `AF13`"]
            #[inline(always)]
            pub fn is_af13(&self) -> bool {
                *self == AFSEL15_A::AF13
            }
            #[doc = "Checks if the value of the field is `AF14`"]
            #[inline(always)]
            pub fn is_af14(&self) -> bool {
                *self == AFSEL15_A::AF14
            }
            #[doc = "Checks if the value of the field is `AF15`"]
            #[inline(always)]
            pub fn is_af15(&self) -> bool {
                *self == AFSEL15_A::AF15
            }
        }
        #[doc = "Write proxy for field `AFSEL15`"]
        pub struct AFSEL15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL15_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 28)) | (((value as u32) & 0x0f) << 28);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL14_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL14`"]
        pub type AFSEL14_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL14`"]
        pub struct AFSEL14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL14_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL13_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL13`"]
        pub type AFSEL13_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL13`"]
        pub struct AFSEL13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL13_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL12_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL12`"]
        pub type AFSEL12_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL12`"]
        pub struct AFSEL12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL12_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL11_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL11`"]
        pub type AFSEL11_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL11`"]
        pub struct AFSEL11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL11_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL10_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL10`"]
        pub type AFSEL10_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL10`"]
        pub struct AFSEL10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL10_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL9_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL9`"]
        pub type AFSEL9_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL9`"]
        pub struct AFSEL9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL9_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Alternate function selection for port x pin y (y = 8..15)"]
        pub type AFSEL8_A = AFSEL15_A;
        #[doc = "Reader of field `AFSEL8`"]
        pub type AFSEL8_R = crate::R<u8, AFSEL15_A>;
        #[doc = "Write proxy for field `AFSEL8`"]
        pub struct AFSEL8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFSEL8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AFSEL8_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "AF0"]
            #[inline(always)]
            pub fn af0(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF0)
            }
            #[doc = "AF1"]
            #[inline(always)]
            pub fn af1(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF1)
            }
            #[doc = "AF2"]
            #[inline(always)]
            pub fn af2(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF2)
            }
            #[doc = "AF3"]
            #[inline(always)]
            pub fn af3(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF3)
            }
            #[doc = "AF4"]
            #[inline(always)]
            pub fn af4(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF4)
            }
            #[doc = "AF5"]
            #[inline(always)]
            pub fn af5(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF5)
            }
            #[doc = "AF6"]
            #[inline(always)]
            pub fn af6(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF6)
            }
            #[doc = "AF7"]
            #[inline(always)]
            pub fn af7(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF7)
            }
            #[doc = "AF8"]
            #[inline(always)]
            pub fn af8(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF8)
            }
            #[doc = "AF9"]
            #[inline(always)]
            pub fn af9(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF9)
            }
            #[doc = "AF10"]
            #[inline(always)]
            pub fn af10(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF10)
            }
            #[doc = "AF11"]
            #[inline(always)]
            pub fn af11(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF11)
            }
            #[doc = "AF12"]
            #[inline(always)]
            pub fn af12(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF12)
            }
            #[doc = "AF13"]
            #[inline(always)]
            pub fn af13(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF13)
            }
            #[doc = "AF14"]
            #[inline(always)]
            pub fn af14(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF14)
            }
            #[doc = "AF15"]
            #[inline(always)]
            pub fn af15(self) -> &'a mut W {
                self.variant(AFSEL15_A::AF15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel15(&self) -> AFSEL15_R {
                AFSEL15_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel14(&self) -> AFSEL14_R {
                AFSEL14_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel13(&self) -> AFSEL13_R {
                AFSEL13_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel12(&self) -> AFSEL12_R {
                AFSEL12_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel11(&self) -> AFSEL11_R {
                AFSEL11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel10(&self) -> AFSEL10_R {
                AFSEL10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel9(&self) -> AFSEL9_R {
                AFSEL9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel8(&self) -> AFSEL8_R {
                AFSEL8_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:31 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel15(&mut self) -> AFSEL15_W {
                AFSEL15_W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel14(&mut self) -> AFSEL14_W {
                AFSEL14_W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel13(&mut self) -> AFSEL13_W {
                AFSEL13_W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel12(&mut self) -> AFSEL12_W {
                AFSEL12_W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel11(&mut self) -> AFSEL11_W {
                AFSEL11_W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel10(&mut self) -> AFSEL10_W {
                AFSEL10_W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel9(&mut self) -> AFSEL9_W {
                AFSEL9_W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x pin y (y = 8..15)"]
            #[inline(always)]
            pub fn afsel8(&mut self) -> AFSEL8_W {
                AFSEL8_W { w: self }
            }
        }
    }
    #[doc = "GPIO port bit reset register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "GPIO port bit reset register"]
    pub mod brr {
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `BR15`"]
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR14`"]
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR13`"]
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR12`"]
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR11`"]
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR10`"]
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR9`"]
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR8`"]
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR7`"]
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR6`"]
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR5`"]
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR4`"]
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR3`"]
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR2`"]
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR1`"]
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Write proxy for field `BR0`"]
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 15 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
            #[doc = "Bit 14 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            #[doc = "Bit 13 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            #[doc = "Bit 12 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            #[doc = "Bit 11 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            #[doc = "Bit 10 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            #[doc = "Bit 9 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            #[doc = "Bit 8 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            #[doc = "Bit 7 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            #[doc = "Bit 6 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            #[doc = "Bit 5 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            #[doc = "Bit 4 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            #[doc = "Bit 3 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            #[doc = "Bit 2 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            #[doc = "Bit 1 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            #[doc = "Bit 0 - Port x Reset bit y (y= 0 .. 15)"]
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose I/Os"]
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        0x5000_0800 as *const _
    }
}
impl Deref for GPIOC {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOC::ptr() }
    }
}
#[doc = "General-purpose I/Os"]
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        0x5000_0c00 as *const _
    }
}
impl Deref for GPIOD {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOD::ptr() }
    }
}
#[doc = "General-purpose I/Os"]
pub struct GPIOH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOH {}
impl GPIOH {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        0x5000_1c00 as *const _
    }
}
impl Deref for GPIOH {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOH::ptr() }
    }
}
#[doc = "General-purpose I/Os"]
pub struct GPIOE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOE {}
impl GPIOE {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        0x5000_1000 as *const _
    }
}
impl Deref for GPIOE {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOE::ptr() }
    }
}
#[doc = "Low power timer"]
pub struct LPTIM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LPTIM {}
impl LPTIM {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lptim::RegisterBlock {
        0x4000_7c00 as *const _
    }
}
impl Deref for LPTIM {
    type Target = lptim::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*LPTIM::ptr() }
    }
}
#[doc = "Low power timer"]
pub mod lptim {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt and Status Register"]
        pub isr: ISR,
        #[doc = "0x04 - Interrupt Clear Register"]
        pub icr: ICR,
        #[doc = "0x08 - Interrupt Enable Register"]
        pub ier: IER,
        #[doc = "0x0c - Configuration Register"]
        pub cfgr: CFGR,
        #[doc = "0x10 - Control Register"]
        pub cr: CR,
        #[doc = "0x14 - Compare Register"]
        pub cmp: CMP,
        #[doc = "0x18 - Autoreload Register"]
        pub arr: ARR,
        #[doc = "0x1c - Counter Register"]
        pub cnt: CNT,
    }
    #[doc = "Interrupt and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "Interrupt and Status Register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Counter direction change up to down\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOWN_A {
            #[doc = "1: Counter direction change up to down"]
            SET = 1,
        }
        impl From<DOWN_A> for bool {
            #[inline(always)]
            fn from(variant: DOWN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DOWN`"]
        pub type DOWN_R = crate::R<bool, DOWN_A>;
        impl DOWN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, DOWN_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(DOWN_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == DOWN_A::SET
            }
        }
        #[doc = "Counter direction change down to up\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UP_A {
            #[doc = "1: Counter direction change down to up"]
            SET = 1,
        }
        impl From<UP_A> for bool {
            #[inline(always)]
            fn from(variant: UP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UP`"]
        pub type UP_R = crate::R<bool, UP_A>;
        impl UP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, UP_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(UP_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == UP_A::SET
            }
        }
        #[doc = "Autoreload register update OK\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARROK_A {
            #[doc = "1: Autoreload register update OK"]
            SET = 1,
        }
        impl From<ARROK_A> for bool {
            #[inline(always)]
            fn from(variant: ARROK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARROK`"]
        pub type ARROK_R = crate::R<bool, ARROK_A>;
        impl ARROK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, ARROK_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(ARROK_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == ARROK_A::SET
            }
        }
        #[doc = "Compare register update OK\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMPOK_A {
            #[doc = "1: Compare register update OK"]
            SET = 1,
        }
        impl From<CMPOK_A> for bool {
            #[inline(always)]
            fn from(variant: CMPOK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CMPOK`"]
        pub type CMPOK_R = crate::R<bool, CMPOK_A>;
        impl CMPOK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CMPOK_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CMPOK_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == CMPOK_A::SET
            }
        }
        #[doc = "External trigger edge event\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTTRIG_A {
            #[doc = "1: External trigger edge event"]
            SET = 1,
        }
        impl From<EXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: EXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EXTTRIG`"]
        pub type EXTTRIG_R = crate::R<bool, EXTTRIG_A>;
        impl EXTTRIG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, EXTTRIG_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(EXTTRIG_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == EXTTRIG_A::SET
            }
        }
        #[doc = "Autoreload match\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARRM_A {
            #[doc = "1: Autoreload match"]
            SET = 1,
        }
        impl From<ARRM_A> for bool {
            #[inline(always)]
            fn from(variant: ARRM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARRM`"]
        pub type ARRM_R = crate::R<bool, ARRM_A>;
        impl ARRM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, ARRM_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(ARRM_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == ARRM_A::SET
            }
        }
        #[doc = "Compare match\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMPM_A {
            #[doc = "1: Compare match"]
            SET = 1,
        }
        impl From<CMPM_A> for bool {
            #[inline(always)]
            fn from(variant: CMPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CMPM`"]
        pub type CMPM_R = crate::R<bool, CMPM_A>;
        impl CMPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CMPM_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CMPM_A::SET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET`"]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == CMPM_A::SET
            }
        }
        impl R {
            #[doc = "Bit 6 - Counter direction change up to down"]
            #[inline(always)]
            pub fn down(&self) -> DOWN_R {
                DOWN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Counter direction change down to up"]
            #[inline(always)]
            pub fn up(&self) -> UP_R {
                UP_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Autoreload register update OK"]
            #[inline(always)]
            pub fn arrok(&self) -> ARROK_R {
                ARROK_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Compare register update OK"]
            #[inline(always)]
            pub fn cmpok(&self) -> CMPOK_R {
                CMPOK_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - External trigger edge event"]
            #[inline(always)]
            pub fn exttrig(&self) -> EXTTRIG_R {
                EXTTRIG_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Autoreload match"]
            #[inline(always)]
            pub fn arrm(&self) -> ARRM_R {
                ARRM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Compare match"]
            #[inline(always)]
            pub fn cmpm(&self) -> CMPM_R {
                CMPM_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Interrupt Clear Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
    pub type ICR = crate::Reg<u32, _ICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICR;
    #[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
    impl crate::Writable for ICR {}
    #[doc = "Interrupt Clear Register"]
    pub mod icr {
        #[doc = "Writer for register ICR"]
        pub type W = crate::W<u32, super::ICR>;
        #[doc = "Register ICR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Direction change to down Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOWNCF_AW {
            #[doc = "1: Direction change to down Clear Flag"]
            CLEAR = 1,
        }
        impl From<DOWNCF_AW> for bool {
            #[inline(always)]
            fn from(variant: DOWNCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `DOWNCF`"]
        pub struct DOWNCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DOWNCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DOWNCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Direction change to down Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(DOWNCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Direction change to UP Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UPCF_AW {
            #[doc = "1: Direction change to up Clear Flag"]
            CLEAR = 1,
        }
        impl From<UPCF_AW> for bool {
            #[inline(always)]
            fn from(variant: UPCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UPCF`"]
        pub struct UPCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UPCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UPCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Direction change to up Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UPCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Autoreload register update OK Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARROKCF_AW {
            #[doc = "1: Autoreload register update OK Clear Flag"]
            CLEAR = 1,
        }
        impl From<ARROKCF_AW> for bool {
            #[inline(always)]
            fn from(variant: ARROKCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ARROKCF`"]
        pub struct ARROKCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARROKCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARROKCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Autoreload register update OK Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ARROKCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Compare register update OK Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMPOKCF_AW {
            #[doc = "1: Compare register update OK Clear Flag"]
            CLEAR = 1,
        }
        impl From<CMPOKCF_AW> for bool {
            #[inline(always)]
            fn from(variant: CMPOKCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CMPOKCF`"]
        pub struct CMPOKCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMPOKCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMPOKCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Compare register update OK Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CMPOKCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "External trigger valid edge Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTTRIGCF_AW {
            #[doc = "1: External trigger valid edge Clear Flag"]
            CLEAR = 1,
        }
        impl From<EXTTRIGCF_AW> for bool {
            #[inline(always)]
            fn from(variant: EXTTRIGCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EXTTRIGCF`"]
        pub struct EXTTRIGCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTTRIGCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTTRIGCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "External trigger valid edge Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EXTTRIGCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Autoreload match Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARRMCF_AW {
            #[doc = "1: Autoreload match Clear Flag"]
            CLEAR = 1,
        }
        impl From<ARRMCF_AW> for bool {
            #[inline(always)]
            fn from(variant: ARRMCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ARRMCF`"]
        pub struct ARRMCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARRMCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARRMCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Autoreload match Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ARRMCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "compare match Clear Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMPMCF_AW {
            #[doc = "1: Compare match Clear Flag"]
            CLEAR = 1,
        }
        impl From<CMPMCF_AW> for bool {
            #[inline(always)]
            fn from(variant: CMPMCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CMPMCF`"]
        pub struct CMPMCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMPMCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMPMCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Compare match Clear Flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CMPMCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 6 - Direction change to down Clear Flag"]
            #[inline(always)]
            pub fn downcf(&mut self) -> DOWNCF_W {
                DOWNCF_W { w: self }
            }
            #[doc = "Bit 5 - Direction change to UP Clear Flag"]
            #[inline(always)]
            pub fn upcf(&mut self) -> UPCF_W {
                UPCF_W { w: self }
            }
            #[doc = "Bit 4 - Autoreload register update OK Clear Flag"]
            #[inline(always)]
            pub fn arrokcf(&mut self) -> ARROKCF_W {
                ARROKCF_W { w: self }
            }
            #[doc = "Bit 3 - Compare register update OK Clear Flag"]
            #[inline(always)]
            pub fn cmpokcf(&mut self) -> CMPOKCF_W {
                CMPOKCF_W { w: self }
            }
            #[doc = "Bit 2 - External trigger valid edge Clear Flag"]
            #[inline(always)]
            pub fn exttrigcf(&mut self) -> EXTTRIGCF_W {
                EXTTRIGCF_W { w: self }
            }
            #[doc = "Bit 1 - Autoreload match Clear Flag"]
            #[inline(always)]
            pub fn arrmcf(&mut self) -> ARRMCF_W {
                ARRMCF_W { w: self }
            }
            #[doc = "Bit 0 - compare match Clear Flag"]
            #[inline(always)]
            pub fn cmpmcf(&mut self) -> CMPMCF_W {
                CMPMCF_W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ier](ier) module"]
    pub type IER = crate::Reg<u32, _IER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IER;
    #[doc = "`read()` method returns [ier::R](ier::R) reader structure"]
    impl crate::Readable for IER {}
    #[doc = "`write(|w| ..)` method takes [ier::W](ier::W) writer structure"]
    impl crate::Writable for IER {}
    #[doc = "Interrupt Enable Register"]
    pub mod ier {
        #[doc = "Reader of register IER"]
        pub type R = crate::R<u32, super::IER>;
        #[doc = "Writer for register IER"]
        pub type W = crate::W<u32, super::IER>;
        #[doc = "Register IER `reset()`'s with value 0"]
        impl crate::ResetValue for super::IER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Direction change to down Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOWNIE_A {
            #[doc = "0: DOWN interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: DOWN interrupt enabled"]
            ENABLED = 1,
        }
        impl From<DOWNIE_A> for bool {
            #[inline(always)]
            fn from(variant: DOWNIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DOWNIE`"]
        pub type DOWNIE_R = crate::R<bool, DOWNIE_A>;
        impl DOWNIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DOWNIE_A {
                match self.bits {
                    false => DOWNIE_A::DISABLED,
                    true => DOWNIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DOWNIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DOWNIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DOWNIE`"]
        pub struct DOWNIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DOWNIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DOWNIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DOWN interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DOWNIE_A::DISABLED)
            }
            #[doc = "DOWN interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DOWNIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Direction change to UP Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UPIE_A {
            #[doc = "0: UP interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: UP interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UPIE_A> for bool {
            #[inline(always)]
            fn from(variant: UPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UPIE`"]
        pub type UPIE_R = crate::R<bool, UPIE_A>;
        impl UPIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UPIE_A {
                match self.bits {
                    false => UPIE_A::DISABLED,
                    true => UPIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UPIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UPIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UPIE`"]
        pub struct UPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UPIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UPIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "UP interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UPIE_A::DISABLED)
            }
            #[doc = "UP interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UPIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Autoreload register update OK Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARROKIE_A {
            #[doc = "0: ARROK interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: ARROK interrupt enabled"]
            ENABLED = 1,
        }
        impl From<ARROKIE_A> for bool {
            #[inline(always)]
            fn from(variant: ARROKIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARROKIE`"]
        pub type ARROKIE_R = crate::R<bool, ARROKIE_A>;
        impl ARROKIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARROKIE_A {
                match self.bits {
                    false => ARROKIE_A::DISABLED,
                    true => ARROKIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARROKIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARROKIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARROKIE`"]
        pub struct ARROKIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARROKIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARROKIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ARROK interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARROKIE_A::DISABLED)
            }
            #[doc = "ARROK interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARROKIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Compare register update OK Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMPOKIE_A {
            #[doc = "0: CMPOK interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CMPOK interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CMPOKIE_A> for bool {
            #[inline(always)]
            fn from(variant: CMPOKIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CMPOKIE`"]
        pub type CMPOKIE_R = crate::R<bool, CMPOKIE_A>;
        impl CMPOKIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMPOKIE_A {
                match self.bits {
                    false => CMPOKIE_A::DISABLED,
                    true => CMPOKIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CMPOKIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CMPOKIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CMPOKIE`"]
        pub struct CMPOKIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMPOKIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMPOKIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CMPOK interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CMPOKIE_A::DISABLED)
            }
            #[doc = "CMPOK interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CMPOKIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "External trigger valid edge Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTTRIGIE_A {
            #[doc = "0: EXTTRIG interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: EXTTRIG interrupt enabled"]
            ENABLED = 1,
        }
        impl From<EXTTRIGIE_A> for bool {
            #[inline(always)]
            fn from(variant: EXTTRIGIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EXTTRIGIE`"]
        pub type EXTTRIGIE_R = crate::R<bool, EXTTRIGIE_A>;
        impl EXTTRIGIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTTRIGIE_A {
                match self.bits {
                    false => EXTTRIGIE_A::DISABLED,
                    true => EXTTRIGIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EXTTRIGIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EXTTRIGIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EXTTRIGIE`"]
        pub struct EXTTRIGIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTTRIGIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTTRIGIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "EXTTRIG interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTTRIGIE_A::DISABLED)
            }
            #[doc = "EXTTRIG interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTTRIGIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Autoreload match Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARRMIE_A {
            #[doc = "0: ARRM interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: ARRM interrupt enabled"]
            ENABLED = 1,
        }
        impl From<ARRMIE_A> for bool {
            #[inline(always)]
            fn from(variant: ARRMIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARRMIE`"]
        pub type ARRMIE_R = crate::R<bool, ARRMIE_A>;
        impl ARRMIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARRMIE_A {
                match self.bits {
                    false => ARRMIE_A::DISABLED,
                    true => ARRMIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARRMIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARRMIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARRMIE`"]
        pub struct ARRMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARRMIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARRMIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ARRM interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARRMIE_A::DISABLED)
            }
            #[doc = "ARRM interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARRMIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Compare match Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMPMIE_A {
            #[doc = "0: CMPM interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CMPM interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CMPMIE_A> for bool {
            #[inline(always)]
            fn from(variant: CMPMIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CMPMIE`"]
        pub type CMPMIE_R = crate::R<bool, CMPMIE_A>;
        impl CMPMIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMPMIE_A {
                match self.bits {
                    false => CMPMIE_A::DISABLED,
                    true => CMPMIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CMPMIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CMPMIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CMPMIE`"]
        pub struct CMPMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMPMIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMPMIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CMPM interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CMPMIE_A::DISABLED)
            }
            #[doc = "CMPM interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CMPMIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 6 - Direction change to down Interrupt Enable"]
            #[inline(always)]
            pub fn downie(&self) -> DOWNIE_R {
                DOWNIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Direction change to UP Interrupt Enable"]
            #[inline(always)]
            pub fn upie(&self) -> UPIE_R {
                UPIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Autoreload register update OK Interrupt Enable"]
            #[inline(always)]
            pub fn arrokie(&self) -> ARROKIE_R {
                ARROKIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Compare register update OK Interrupt Enable"]
            #[inline(always)]
            pub fn cmpokie(&self) -> CMPOKIE_R {
                CMPOKIE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - External trigger valid edge Interrupt Enable"]
            #[inline(always)]
            pub fn exttrigie(&self) -> EXTTRIGIE_R {
                EXTTRIGIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Autoreload match Interrupt Enable"]
            #[inline(always)]
            pub fn arrmie(&self) -> ARRMIE_R {
                ARRMIE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Compare match Interrupt Enable"]
            #[inline(always)]
            pub fn cmpmie(&self) -> CMPMIE_R {
                CMPMIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 6 - Direction change to down Interrupt Enable"]
            #[inline(always)]
            pub fn downie(&mut self) -> DOWNIE_W {
                DOWNIE_W { w: self }
            }
            #[doc = "Bit 5 - Direction change to UP Interrupt Enable"]
            #[inline(always)]
            pub fn upie(&mut self) -> UPIE_W {
                UPIE_W { w: self }
            }
            #[doc = "Bit 4 - Autoreload register update OK Interrupt Enable"]
            #[inline(always)]
            pub fn arrokie(&mut self) -> ARROKIE_W {
                ARROKIE_W { w: self }
            }
            #[doc = "Bit 3 - Compare register update OK Interrupt Enable"]
            #[inline(always)]
            pub fn cmpokie(&mut self) -> CMPOKIE_W {
                CMPOKIE_W { w: self }
            }
            #[doc = "Bit 2 - External trigger valid edge Interrupt Enable"]
            #[inline(always)]
            pub fn exttrigie(&mut self) -> EXTTRIGIE_W {
                EXTTRIGIE_W { w: self }
            }
            #[doc = "Bit 1 - Autoreload match Interrupt Enable"]
            #[inline(always)]
            pub fn arrmie(&mut self) -> ARRMIE_W {
                ARRMIE_W { w: self }
            }
            #[doc = "Bit 0 - Compare match Interrupt Enable"]
            #[inline(always)]
            pub fn cmpmie(&mut self) -> CMPMIE_W {
                CMPMIE_W { w: self }
            }
        }
    }
    #[doc = "Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr](cfgr) module"]
    pub type CFGR = crate::Reg<u32, _CFGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR;
    #[doc = "`read()` method returns [cfgr::R](cfgr::R) reader structure"]
    impl crate::Readable for CFGR {}
    #[doc = "`write(|w| ..)` method takes [cfgr::W](cfgr::W) writer structure"]
    impl crate::Writable for CFGR {}
    #[doc = "Configuration Register"]
    pub mod cfgr {
        #[doc = "Reader of register CFGR"]
        pub type R = crate::R<u32, super::CFGR>;
        #[doc = "Writer for register CFGR"]
        pub type W = crate::W<u32, super::CFGR>;
        #[doc = "Register CFGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Encoder mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENC_A {
            #[doc = "0: Encoder mode disabled"]
            DISABLED = 0,
            #[doc = "1: Encoder mode enabled"]
            ENABLED = 1,
        }
        impl From<ENC_A> for bool {
            #[inline(always)]
            fn from(variant: ENC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENC`"]
        pub type ENC_R = crate::R<bool, ENC_A>;
        impl ENC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENC_A {
                match self.bits {
                    false => ENC_A::DISABLED,
                    true => ENC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENC`"]
        pub struct ENC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Encoder mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENC_A::DISABLED)
            }
            #[doc = "Encoder mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "counter mode enabled\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COUNTMODE_A {
            #[doc = "0: The counter is incremented following each internal clock pulse"]
            INTERNAL = 0,
            #[doc = "1: The counter is incremented following each valid clock pulse on the LPTIM external Input1"]
            EXTERNAL = 1,
        }
        impl From<COUNTMODE_A> for bool {
            #[inline(always)]
            fn from(variant: COUNTMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COUNTMODE`"]
        pub type COUNTMODE_R = crate::R<bool, COUNTMODE_A>;
        impl COUNTMODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COUNTMODE_A {
                match self.bits {
                    false => COUNTMODE_A::INTERNAL,
                    true => COUNTMODE_A::EXTERNAL,
                }
            }
            #[doc = "Checks if the value of the field is `INTERNAL`"]
            #[inline(always)]
            pub fn is_internal(&self) -> bool {
                *self == COUNTMODE_A::INTERNAL
            }
            #[doc = "Checks if the value of the field is `EXTERNAL`"]
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == COUNTMODE_A::EXTERNAL
            }
        }
        #[doc = "Write proxy for field `COUNTMODE`"]
        pub struct COUNTMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNTMODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COUNTMODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The counter is incremented following each internal clock pulse"]
            #[inline(always)]
            pub fn internal(self) -> &'a mut W {
                self.variant(COUNTMODE_A::INTERNAL)
            }
            #[doc = "The counter is incremented following each valid clock pulse on the LPTIM external Input1"]
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(COUNTMODE_A::EXTERNAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Registers update mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRELOAD_A {
            #[doc = "0: Registers are updated after each APB bus write access"]
            IMMEDIATE = 0,
            #[doc = "1: Registers are updated at the end of the current LPTIM period"]
            ENDOFPERIOD = 1,
        }
        impl From<PRELOAD_A> for bool {
            #[inline(always)]
            fn from(variant: PRELOAD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PRELOAD`"]
        pub type PRELOAD_R = crate::R<bool, PRELOAD_A>;
        impl PRELOAD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PRELOAD_A {
                match self.bits {
                    false => PRELOAD_A::IMMEDIATE,
                    true => PRELOAD_A::ENDOFPERIOD,
                }
            }
            #[doc = "Checks if the value of the field is `IMMEDIATE`"]
            #[inline(always)]
            pub fn is_immediate(&self) -> bool {
                *self == PRELOAD_A::IMMEDIATE
            }
            #[doc = "Checks if the value of the field is `ENDOFPERIOD`"]
            #[inline(always)]
            pub fn is_end_of_period(&self) -> bool {
                *self == PRELOAD_A::ENDOFPERIOD
            }
        }
        #[doc = "Write proxy for field `PRELOAD`"]
        pub struct PRELOAD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRELOAD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRELOAD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Registers are updated after each APB bus write access"]
            #[inline(always)]
            pub fn immediate(self) -> &'a mut W {
                self.variant(PRELOAD_A::IMMEDIATE)
            }
            #[doc = "Registers are updated at the end of the current LPTIM period"]
            #[inline(always)]
            pub fn end_of_period(self) -> &'a mut W {
                self.variant(PRELOAD_A::ENDOFPERIOD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Waveform shape polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVPOL_A {
            #[doc = "0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers"]
            POSITIVE = 0,
            #[doc = "1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers"]
            NEGATIVE = 1,
        }
        impl From<WAVPOL_A> for bool {
            #[inline(always)]
            fn from(variant: WAVPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAVPOL`"]
        pub type WAVPOL_R = crate::R<bool, WAVPOL_A>;
        impl WAVPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAVPOL_A {
                match self.bits {
                    false => WAVPOL_A::POSITIVE,
                    true => WAVPOL_A::NEGATIVE,
                }
            }
            #[doc = "Checks if the value of the field is `POSITIVE`"]
            #[inline(always)]
            pub fn is_positive(&self) -> bool {
                *self == WAVPOL_A::POSITIVE
            }
            #[doc = "Checks if the value of the field is `NEGATIVE`"]
            #[inline(always)]
            pub fn is_negative(&self) -> bool {
                *self == WAVPOL_A::NEGATIVE
            }
        }
        #[doc = "Write proxy for field `WAVPOL`"]
        pub struct WAVPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAVPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAVPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(WAVPOL_A::POSITIVE)
            }
            #[doc = "The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(WAVPOL_A::NEGATIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Waveform shape\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVE_A {
            #[doc = "0: Deactivate Set-once mode, PWM / One Pulse waveform (depending on OPMODE bit)"]
            INACTIVE = 0,
            #[doc = "1: Activate the Set-once mode"]
            ACTIVE = 1,
        }
        impl From<WAVE_A> for bool {
            #[inline(always)]
            fn from(variant: WAVE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAVE`"]
        pub type WAVE_R = crate::R<bool, WAVE_A>;
        impl WAVE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAVE_A {
                match self.bits {
                    false => WAVE_A::INACTIVE,
                    true => WAVE_A::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline(always)]
            pub fn is_inactive(&self) -> bool {
                *self == WAVE_A::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == WAVE_A::ACTIVE
            }
        }
        #[doc = "Write proxy for field `WAVE`"]
        pub struct WAVE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAVE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAVE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Deactivate Set-once mode, PWM / One Pulse waveform (depending on OPMODE bit)"]
            #[inline(always)]
            pub fn inactive(self) -> &'a mut W {
                self.variant(WAVE_A::INACTIVE)
            }
            #[doc = "Activate the Set-once mode"]
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(WAVE_A::ACTIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Timeout enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMOUT_A {
            #[doc = "0: A trigger event arriving when the timer is already started will be ignored"]
            DISABLED = 0,
            #[doc = "1: A trigger event arriving when the timer is already started will reset and restart the counter"]
            ENABLED = 1,
        }
        impl From<TIMOUT_A> for bool {
            #[inline(always)]
            fn from(variant: TIMOUT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIMOUT`"]
        pub type TIMOUT_R = crate::R<bool, TIMOUT_A>;
        impl TIMOUT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIMOUT_A {
                match self.bits {
                    false => TIMOUT_A::DISABLED,
                    true => TIMOUT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIMOUT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIMOUT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIMOUT`"]
        pub struct TIMOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMOUT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIMOUT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "A trigger event arriving when the timer is already started will be ignored"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIMOUT_A::DISABLED)
            }
            #[doc = "A trigger event arriving when the timer is already started will reset and restart the counter"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIMOUT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Trigger enable and polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TRIGEN_A {
            #[doc = "0: Software trigger (counting start is initiated by software)"]
            SW = 0,
            #[doc = "1: Rising edge is the active edge"]
            RISINGEDGE = 1,
            #[doc = "2: Falling edge is the active edge"]
            FALLINGEDGE = 2,
            #[doc = "3: Both edges are active edges"]
            BOTHEDGES = 3,
        }
        impl From<TRIGEN_A> for u8 {
            #[inline(always)]
            fn from(variant: TRIGEN_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TRIGEN`"]
        pub type TRIGEN_R = crate::R<u8, TRIGEN_A>;
        impl TRIGEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TRIGEN_A {
                match self.bits {
                    0 => TRIGEN_A::SW,
                    1 => TRIGEN_A::RISINGEDGE,
                    2 => TRIGEN_A::FALLINGEDGE,
                    3 => TRIGEN_A::BOTHEDGES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SW`"]
            #[inline(always)]
            pub fn is_sw(&self) -> bool {
                *self == TRIGEN_A::SW
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == TRIGEN_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == TRIGEN_A::FALLINGEDGE
            }
            #[doc = "Checks if the value of the field is `BOTHEDGES`"]
            #[inline(always)]
            pub fn is_both_edges(&self) -> bool {
                *self == TRIGEN_A::BOTHEDGES
            }
        }
        #[doc = "Write proxy for field `TRIGEN`"]
        pub struct TRIGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRIGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TRIGEN_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Software trigger (counting start is initiated by software)"]
            #[inline(always)]
            pub fn sw(self) -> &'a mut W {
                self.variant(TRIGEN_A::SW)
            }
            #[doc = "Rising edge is the active edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(TRIGEN_A::RISINGEDGE)
            }
            #[doc = "Falling edge is the active edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(TRIGEN_A::FALLINGEDGE)
            }
            #[doc = "Both edges are active edges"]
            #[inline(always)]
            pub fn both_edges(self) -> &'a mut W {
                self.variant(TRIGEN_A::BOTHEDGES)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 17)) | (((value as u32) & 0x03) << 17);
                self.w
            }
        }
        #[doc = "Trigger selector\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TRIGSEL_A {
            #[doc = "0: lptim_ext_trig0"]
            TRIG0 = 0,
            #[doc = "1: lptim_ext_trig1"]
            TRIG1 = 1,
            #[doc = "2: lptim_ext_trig2"]
            TRIG2 = 2,
            #[doc = "3: lptim_ext_trig3"]
            TRIG3 = 3,
            #[doc = "4: lptim_ext_trig4"]
            TRIG4 = 4,
            #[doc = "5: lptim_ext_trig5"]
            TRIG5 = 5,
            #[doc = "6: lptim_ext_trig6"]
            TRIG6 = 6,
            #[doc = "7: lptim_ext_trig7"]
            TRIG7 = 7,
        }
        impl From<TRIGSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: TRIGSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TRIGSEL`"]
        pub type TRIGSEL_R = crate::R<u8, TRIGSEL_A>;
        impl TRIGSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TRIGSEL_A {
                match self.bits {
                    0 => TRIGSEL_A::TRIG0,
                    1 => TRIGSEL_A::TRIG1,
                    2 => TRIGSEL_A::TRIG2,
                    3 => TRIGSEL_A::TRIG3,
                    4 => TRIGSEL_A::TRIG4,
                    5 => TRIGSEL_A::TRIG5,
                    6 => TRIGSEL_A::TRIG6,
                    7 => TRIGSEL_A::TRIG7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TRIG0`"]
            #[inline(always)]
            pub fn is_trig0(&self) -> bool {
                *self == TRIGSEL_A::TRIG0
            }
            #[doc = "Checks if the value of the field is `TRIG1`"]
            #[inline(always)]
            pub fn is_trig1(&self) -> bool {
                *self == TRIGSEL_A::TRIG1
            }
            #[doc = "Checks if the value of the field is `TRIG2`"]
            #[inline(always)]
            pub fn is_trig2(&self) -> bool {
                *self == TRIGSEL_A::TRIG2
            }
            #[doc = "Checks if the value of the field is `TRIG3`"]
            #[inline(always)]
            pub fn is_trig3(&self) -> bool {
                *self == TRIGSEL_A::TRIG3
            }
            #[doc = "Checks if the value of the field is `TRIG4`"]
            #[inline(always)]
            pub fn is_trig4(&self) -> bool {
                *self == TRIGSEL_A::TRIG4
            }
            #[doc = "Checks if the value of the field is `TRIG5`"]
            #[inline(always)]
            pub fn is_trig5(&self) -> bool {
                *self == TRIGSEL_A::TRIG5
            }
            #[doc = "Checks if the value of the field is `TRIG6`"]
            #[inline(always)]
            pub fn is_trig6(&self) -> bool {
                *self == TRIGSEL_A::TRIG6
            }
            #[doc = "Checks if the value of the field is `TRIG7`"]
            #[inline(always)]
            pub fn is_trig7(&self) -> bool {
                *self == TRIGSEL_A::TRIG7
            }
        }
        #[doc = "Write proxy for field `TRIGSEL`"]
        pub struct TRIGSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRIGSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TRIGSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "lptim_ext_trig0"]
            #[inline(always)]
            pub fn trig0(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG0)
            }
            #[doc = "lptim_ext_trig1"]
            #[inline(always)]
            pub fn trig1(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG1)
            }
            #[doc = "lptim_ext_trig2"]
            #[inline(always)]
            pub fn trig2(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG2)
            }
            #[doc = "lptim_ext_trig3"]
            #[inline(always)]
            pub fn trig3(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG3)
            }
            #[doc = "lptim_ext_trig4"]
            #[inline(always)]
            pub fn trig4(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG4)
            }
            #[doc = "lptim_ext_trig5"]
            #[inline(always)]
            pub fn trig5(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG5)
            }
            #[doc = "lptim_ext_trig6"]
            #[inline(always)]
            pub fn trig6(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG6)
            }
            #[doc = "lptim_ext_trig7"]
            #[inline(always)]
            pub fn trig7(self) -> &'a mut W {
                self.variant(TRIGSEL_A::TRIG7)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 13)) | (((value as u32) & 0x07) << 13);
                self.w
            }
        }
        #[doc = "Clock prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PRESC_A {
            #[doc = "0: /1"]
            DIV1 = 0,
            #[doc = "1: /2"]
            DIV2 = 1,
            #[doc = "2: /4"]
            DIV4 = 2,
            #[doc = "3: /8"]
            DIV8 = 3,
            #[doc = "4: /16"]
            DIV16 = 4,
            #[doc = "5: /32"]
            DIV32 = 5,
            #[doc = "6: /64"]
            DIV64 = 6,
            #[doc = "7: /128"]
            DIV128 = 7,
        }
        impl From<PRESC_A> for u8 {
            #[inline(always)]
            fn from(variant: PRESC_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PRESC`"]
        pub type PRESC_R = crate::R<u8, PRESC_A>;
        impl PRESC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PRESC_A {
                match self.bits {
                    0 => PRESC_A::DIV1,
                    1 => PRESC_A::DIV2,
                    2 => PRESC_A::DIV4,
                    3 => PRESC_A::DIV8,
                    4 => PRESC_A::DIV16,
                    5 => PRESC_A::DIV32,
                    6 => PRESC_A::DIV64,
                    7 => PRESC_A::DIV128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PRESC_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PRESC_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PRESC_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PRESC_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PRESC_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == PRESC_A::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PRESC_A::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == PRESC_A::DIV128
            }
        }
        #[doc = "Write proxy for field `PRESC`"]
        pub struct PRESC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRESC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRESC_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "/1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PRESC_A::DIV1)
            }
            #[doc = "/2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PRESC_A::DIV2)
            }
            #[doc = "/4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PRESC_A::DIV4)
            }
            #[doc = "/8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PRESC_A::DIV8)
            }
            #[doc = "/16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PRESC_A::DIV16)
            }
            #[doc = "/32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(PRESC_A::DIV32)
            }
            #[doc = "/64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(PRESC_A::DIV64)
            }
            #[doc = "/128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(PRESC_A::DIV128)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 9)) | (((value as u32) & 0x07) << 9);
                self.w
            }
        }
        #[doc = "Configurable digital filter for trigger\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TRGFLT_A {
            #[doc = "0: Any trigger active level change is considered as a valid trigger"]
            IMMEDIATE = 0,
            #[doc = "1: Trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger"]
            CLOCKS2 = 1,
            #[doc = "2: Trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger"]
            CLOCKS4 = 2,
            #[doc = "3: Trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger"]
            CLOCKS8 = 3,
        }
        impl From<TRGFLT_A> for u8 {
            #[inline(always)]
            fn from(variant: TRGFLT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TRGFLT`"]
        pub type TRGFLT_R = crate::R<u8, TRGFLT_A>;
        impl TRGFLT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TRGFLT_A {
                match self.bits {
                    0 => TRGFLT_A::IMMEDIATE,
                    1 => TRGFLT_A::CLOCKS2,
                    2 => TRGFLT_A::CLOCKS4,
                    3 => TRGFLT_A::CLOCKS8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IMMEDIATE`"]
            #[inline(always)]
            pub fn is_immediate(&self) -> bool {
                *self == TRGFLT_A::IMMEDIATE
            }
            #[doc = "Checks if the value of the field is `CLOCKS2`"]
            #[inline(always)]
            pub fn is_clocks2(&self) -> bool {
                *self == TRGFLT_A::CLOCKS2
            }
            #[doc = "Checks if the value of the field is `CLOCKS4`"]
            #[inline(always)]
            pub fn is_clocks4(&self) -> bool {
                *self == TRGFLT_A::CLOCKS4
            }
            #[doc = "Checks if the value of the field is `CLOCKS8`"]
            #[inline(always)]
            pub fn is_clocks8(&self) -> bool {
                *self == TRGFLT_A::CLOCKS8
            }
        }
        #[doc = "Write proxy for field `TRGFLT`"]
        pub struct TRGFLT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRGFLT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TRGFLT_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Any trigger active level change is considered as a valid trigger"]
            #[inline(always)]
            pub fn immediate(self) -> &'a mut W {
                self.variant(TRGFLT_A::IMMEDIATE)
            }
            #[doc = "Trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger"]
            #[inline(always)]
            pub fn clocks2(self) -> &'a mut W {
                self.variant(TRGFLT_A::CLOCKS2)
            }
            #[doc = "Trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger"]
            #[inline(always)]
            pub fn clocks4(self) -> &'a mut W {
                self.variant(TRGFLT_A::CLOCKS4)
            }
            #[doc = "Trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger"]
            #[inline(always)]
            pub fn clocks8(self) -> &'a mut W {
                self.variant(TRGFLT_A::CLOCKS8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "Configurable digital filter for external clock\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKFLT_A {
            #[doc = "0: Any external clock signal level change is considered as a valid transition"]
            IMMEDIATE = 0,
            #[doc = "1: External clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition"]
            CLOCKS2 = 1,
            #[doc = "2: External clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition"]
            CLOCKS4 = 2,
            #[doc = "3: External clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition"]
            CLOCKS8 = 3,
        }
        impl From<CKFLT_A> for u8 {
            #[inline(always)]
            fn from(variant: CKFLT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKFLT`"]
        pub type CKFLT_R = crate::R<u8, CKFLT_A>;
        impl CKFLT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CKFLT_A {
                match self.bits {
                    0 => CKFLT_A::IMMEDIATE,
                    1 => CKFLT_A::CLOCKS2,
                    2 => CKFLT_A::CLOCKS4,
                    3 => CKFLT_A::CLOCKS8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IMMEDIATE`"]
            #[inline(always)]
            pub fn is_immediate(&self) -> bool {
                *self == CKFLT_A::IMMEDIATE
            }
            #[doc = "Checks if the value of the field is `CLOCKS2`"]
            #[inline(always)]
            pub fn is_clocks2(&self) -> bool {
                *self == CKFLT_A::CLOCKS2
            }
            #[doc = "Checks if the value of the field is `CLOCKS4`"]
            #[inline(always)]
            pub fn is_clocks4(&self) -> bool {
                *self == CKFLT_A::CLOCKS4
            }
            #[doc = "Checks if the value of the field is `CLOCKS8`"]
            #[inline(always)]
            pub fn is_clocks8(&self) -> bool {
                *self == CKFLT_A::CLOCKS8
            }
        }
        #[doc = "Write proxy for field `CKFLT`"]
        pub struct CKFLT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKFLT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKFLT_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Any external clock signal level change is considered as a valid transition"]
            #[inline(always)]
            pub fn immediate(self) -> &'a mut W {
                self.variant(CKFLT_A::IMMEDIATE)
            }
            #[doc = "External clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition"]
            #[inline(always)]
            pub fn clocks2(self) -> &'a mut W {
                self.variant(CKFLT_A::CLOCKS2)
            }
            #[doc = "External clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition"]
            #[inline(always)]
            pub fn clocks4(self) -> &'a mut W {
                self.variant(CKFLT_A::CLOCKS4)
            }
            #[doc = "External clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition"]
            #[inline(always)]
            pub fn clocks8(self) -> &'a mut W {
                self.variant(CKFLT_A::CLOCKS8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        #[doc = "Clock Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKPOL_A {
            #[doc = "0: The rising edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 1 is active."]
            RISINGEDGE = 0,
            #[doc = "1: The falling edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 2 is active."]
            FALLINGEDGE = 1,
            #[doc = "2: Both edges are active edge. If LPTIM is in encoder mode: Encoder sub-mode 3 is active."]
            BOTHEDGES = 2,
        }
        impl From<CKPOL_A> for u8 {
            #[inline(always)]
            fn from(variant: CKPOL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKPOL`"]
        pub type CKPOL_R = crate::R<u8, CKPOL_A>;
        impl CKPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKPOL_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKPOL_A::RISINGEDGE),
                    1 => Val(CKPOL_A::FALLINGEDGE),
                    2 => Val(CKPOL_A::BOTHEDGES),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == CKPOL_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == CKPOL_A::FALLINGEDGE
            }
            #[doc = "Checks if the value of the field is `BOTHEDGES`"]
            #[inline(always)]
            pub fn is_both_edges(&self) -> bool {
                *self == CKPOL_A::BOTHEDGES
            }
        }
        #[doc = "Write proxy for field `CKPOL`"]
        pub struct CKPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKPOL_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "The rising edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 1 is active."]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CKPOL_A::RISINGEDGE)
            }
            #[doc = "The falling edge is the active edge used for counting. If LPTIM is in encoder mode: Encoder sub-mode 2 is active."]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CKPOL_A::FALLINGEDGE)
            }
            #[doc = "Both edges are active edge. If LPTIM is in encoder mode: Encoder sub-mode 3 is active."]
            #[inline(always)]
            pub fn both_edges(self) -> &'a mut W {
                self.variant(CKPOL_A::BOTHEDGES)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 1)) | (((value as u32) & 0x03) << 1);
                self.w
            }
        }
        #[doc = "Clock selector\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CKSEL_A {
            #[doc = "0: LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)"]
            INTERNAL = 0,
            #[doc = "1: LPTIM is clocked by an external clock source through the LPTIM external Input1"]
            EXTERNAL = 1,
        }
        impl From<CKSEL_A> for bool {
            #[inline(always)]
            fn from(variant: CKSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CKSEL`"]
        pub type CKSEL_R = crate::R<bool, CKSEL_A>;
        impl CKSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CKSEL_A {
                match self.bits {
                    false => CKSEL_A::INTERNAL,
                    true => CKSEL_A::EXTERNAL,
                }
            }
            #[doc = "Checks if the value of the field is `INTERNAL`"]
            #[inline(always)]
            pub fn is_internal(&self) -> bool {
                *self == CKSEL_A::INTERNAL
            }
            #[doc = "Checks if the value of the field is `EXTERNAL`"]
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == CKSEL_A::EXTERNAL
            }
        }
        #[doc = "Write proxy for field `CKSEL`"]
        pub struct CKSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)"]
            #[inline(always)]
            pub fn internal(self) -> &'a mut W {
                self.variant(CKSEL_A::INTERNAL)
            }
            #[doc = "LPTIM is clocked by an external clock source through the LPTIM external Input1"]
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(CKSEL_A::EXTERNAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 24 - Encoder mode enable"]
            #[inline(always)]
            pub fn enc(&self) -> ENC_R {
                ENC_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 23 - counter mode enabled"]
            #[inline(always)]
            pub fn countmode(&self) -> COUNTMODE_R {
                COUNTMODE_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Registers update mode"]
            #[inline(always)]
            pub fn preload(&self) -> PRELOAD_R {
                PRELOAD_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Waveform shape polarity"]
            #[inline(always)]
            pub fn wavpol(&self) -> WAVPOL_R {
                WAVPOL_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Waveform shape"]
            #[inline(always)]
            pub fn wave(&self) -> WAVE_R {
                WAVE_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Timeout enable"]
            #[inline(always)]
            pub fn timout(&self) -> TIMOUT_R {
                TIMOUT_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bits 17:18 - Trigger enable and polarity"]
            #[inline(always)]
            pub fn trigen(&self) -> TRIGEN_R {
                TRIGEN_R::new(((self.bits >> 17) & 0x03) as u8)
            }
            #[doc = "Bits 13:15 - Trigger selector"]
            #[inline(always)]
            pub fn trigsel(&self) -> TRIGSEL_R {
                TRIGSEL_R::new(((self.bits >> 13) & 0x07) as u8)
            }
            #[doc = "Bits 9:11 - Clock prescaler"]
            #[inline(always)]
            pub fn presc(&self) -> PRESC_R {
                PRESC_R::new(((self.bits >> 9) & 0x07) as u8)
            }
            #[doc = "Bits 6:7 - Configurable digital filter for trigger"]
            #[inline(always)]
            pub fn trgflt(&self) -> TRGFLT_R {
                TRGFLT_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 3:4 - Configurable digital filter for external clock"]
            #[inline(always)]
            pub fn ckflt(&self) -> CKFLT_R {
                CKFLT_R::new(((self.bits >> 3) & 0x03) as u8)
            }
            #[doc = "Bits 1:2 - Clock Polarity"]
            #[inline(always)]
            pub fn ckpol(&self) -> CKPOL_R {
                CKPOL_R::new(((self.bits >> 1) & 0x03) as u8)
            }
            #[doc = "Bit 0 - Clock selector"]
            #[inline(always)]
            pub fn cksel(&self) -> CKSEL_R {
                CKSEL_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 24 - Encoder mode enable"]
            #[inline(always)]
            pub fn enc(&mut self) -> ENC_W {
                ENC_W { w: self }
            }
            #[doc = "Bit 23 - counter mode enabled"]
            #[inline(always)]
            pub fn countmode(&mut self) -> COUNTMODE_W {
                COUNTMODE_W { w: self }
            }
            #[doc = "Bit 22 - Registers update mode"]
            #[inline(always)]
            pub fn preload(&mut self) -> PRELOAD_W {
                PRELOAD_W { w: self }
            }
            #[doc = "Bit 21 - Waveform shape polarity"]
            #[inline(always)]
            pub fn wavpol(&mut self) -> WAVPOL_W {
                WAVPOL_W { w: self }
            }
            #[doc = "Bit 20 - Waveform shape"]
            #[inline(always)]
            pub fn wave(&mut self) -> WAVE_W {
                WAVE_W { w: self }
            }
            #[doc = "Bit 19 - Timeout enable"]
            #[inline(always)]
            pub fn timout(&mut self) -> TIMOUT_W {
                TIMOUT_W { w: self }
            }
            #[doc = "Bits 17:18 - Trigger enable and polarity"]
            #[inline(always)]
            pub fn trigen(&mut self) -> TRIGEN_W {
                TRIGEN_W { w: self }
            }
            #[doc = "Bits 13:15 - Trigger selector"]
            #[inline(always)]
            pub fn trigsel(&mut self) -> TRIGSEL_W {
                TRIGSEL_W { w: self }
            }
            #[doc = "Bits 9:11 - Clock prescaler"]
            #[inline(always)]
            pub fn presc(&mut self) -> PRESC_W {
                PRESC_W { w: self }
            }
            #[doc = "Bits 6:7 - Configurable digital filter for trigger"]
            #[inline(always)]
            pub fn trgflt(&mut self) -> TRGFLT_W {
                TRGFLT_W { w: self }
            }
            #[doc = "Bits 3:4 - Configurable digital filter for external clock"]
            #[inline(always)]
            pub fn ckflt(&mut self) -> CKFLT_W {
                CKFLT_W { w: self }
            }
            #[doc = "Bits 1:2 - Clock Polarity"]
            #[inline(always)]
            pub fn ckpol(&mut self) -> CKPOL_W {
                CKPOL_W { w: self }
            }
            #[doc = "Bit 0 - Clock selector"]
            #[inline(always)]
            pub fn cksel(&mut self) -> CKSEL_W {
                CKSEL_W { w: self }
            }
        }
    }
    #[doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control Register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Timer start in continuous mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CNTSTRT_A {
            #[doc = "1: Timer start in Continuous mode"]
            START = 1,
        }
        impl From<CNTSTRT_A> for bool {
            #[inline(always)]
            fn from(variant: CNTSTRT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CNTSTRT`"]
        pub type CNTSTRT_R = crate::R<bool, CNTSTRT_A>;
        impl CNTSTRT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CNTSTRT_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CNTSTRT_A::START),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == CNTSTRT_A::START
            }
        }
        #[doc = "Write proxy for field `CNTSTRT`"]
        pub struct CNTSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNTSTRT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CNTSTRT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Timer start in Continuous mode"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(CNTSTRT_A::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "LPTIM start in single mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SNGSTRT_A {
            #[doc = "1: LPTIM start in Single mode"]
            START = 1,
        }
        impl From<SNGSTRT_A> for bool {
            #[inline(always)]
            fn from(variant: SNGSTRT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SNGSTRT`"]
        pub type SNGSTRT_R = crate::R<bool, SNGSTRT_A>;
        impl SNGSTRT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, SNGSTRT_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(SNGSTRT_A::START),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == SNGSTRT_A::START
            }
        }
        #[doc = "Write proxy for field `SNGSTRT`"]
        pub struct SNGSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SNGSTRT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SNGSTRT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LPTIM start in Single mode"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(SNGSTRT_A::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "LPTIM Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLE_A {
            #[doc = "0: LPTIM is disabled"]
            DISABLED = 0,
            #[doc = "1: LPTIM is enabled"]
            ENABLED = 1,
        }
        impl From<ENABLE_A> for bool {
            #[inline(always)]
            fn from(variant: ENABLE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENABLE`"]
        pub type ENABLE_R = crate::R<bool, ENABLE_A>;
        impl ENABLE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENABLE_A {
                match self.bits {
                    false => ENABLE_A::DISABLED,
                    true => ENABLE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENABLE`"]
        pub struct ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENABLE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENABLE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LPTIM is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLE_A::DISABLED)
            }
            #[doc = "LPTIM is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 2 - Timer start in continuous mode"]
            #[inline(always)]
            pub fn cntstrt(&self) -> CNTSTRT_R {
                CNTSTRT_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - LPTIM start in single mode"]
            #[inline(always)]
            pub fn sngstrt(&self) -> SNGSTRT_R {
                SNGSTRT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - LPTIM Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - Timer start in continuous mode"]
            #[inline(always)]
            pub fn cntstrt(&mut self) -> CNTSTRT_W {
                CNTSTRT_W { w: self }
            }
            #[doc = "Bit 1 - LPTIM start in single mode"]
            #[inline(always)]
            pub fn sngstrt(&mut self) -> SNGSTRT_W {
                SNGSTRT_W { w: self }
            }
            #[doc = "Bit 0 - LPTIM Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W {
                ENABLE_W { w: self }
            }
        }
    }
    #[doc = "Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp](cmp) module"]
    pub type CMP = crate::Reg<u32, _CMP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CMP;
    #[doc = "`read()` method returns [cmp::R](cmp::R) reader structure"]
    impl crate::Readable for CMP {}
    #[doc = "`write(|w| ..)` method takes [cmp::W](cmp::W) writer structure"]
    impl crate::Writable for CMP {}
    #[doc = "Compare Register"]
    pub mod cmp {
        #[doc = "Reader of register CMP"]
        pub type R = crate::R<u32, super::CMP>;
        #[doc = "Writer for register CMP"]
        pub type W = crate::W<u32, super::CMP>;
        #[doc = "Register CMP `reset()`'s with value 0"]
        impl crate::ResetValue for super::CMP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CMP`"]
        pub type CMP_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CMP`"]
        pub struct CMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Compare value."]
            #[inline(always)]
            pub fn cmp(&self) -> CMP_R {
                CMP_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare value."]
            #[inline(always)]
            pub fn cmp(&mut self) -> CMP_W {
                CMP_W { w: self }
            }
        }
    }
    #[doc = "Autoreload Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "Autoreload Register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0x01"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x01
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto reload value."]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto reload value."]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "Counter Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "Counter Register"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Counter value."]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
}
#[doc = "Real-time clock"]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        0x4000_2800 as *const _
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*RTC::ptr() }
    }
}
#[doc = "Real-time clock"]
pub mod rtc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - RTC time register"]
        pub tr: TR,
        #[doc = "0x04 - RTC date register"]
        pub dr: DR,
        #[doc = "0x08 - RTC control register"]
        pub cr: CR,
        #[doc = "0x0c - RTC initialization and status register"]
        pub isr: ISR,
        #[doc = "0x10 - RTC prescaler register"]
        pub prer: PRER,
        #[doc = "0x14 - RTC wakeup timer register"]
        pub wutr: WUTR,
        _reserved6: [u8; 4usize],
        #[doc = "0x1c - RTC alarm A register"]
        pub alrmar: ALRMAR,
        #[doc = "0x20 - RTC alarm B register"]
        pub alrmbr: ALRMBR,
        #[doc = "0x24 - write protection register"]
        pub wpr: WPR,
        #[doc = "0x28 - RTC sub second register"]
        pub ssr: SSR,
        #[doc = "0x2c - RTC shift control register"]
        pub shiftr: SHIFTR,
        #[doc = "0x30 - RTC timestamp time register"]
        pub tstr: TSTR,
        #[doc = "0x34 - RTC timestamp date register"]
        pub tsdr: TSDR,
        #[doc = "0x38 - RTC time-stamp sub second register"]
        pub tsssr: TSSSR,
        #[doc = "0x3c - RTC calibration register"]
        pub calr: CALR,
        #[doc = "0x40 - RTC tamper configuration register"]
        pub tampcr: TAMPCR,
        #[doc = "0x44 - RTC alarm A sub second register"]
        pub alrmassr: ALRMASSR,
        #[doc = "0x48 - RTC alarm B sub second register"]
        pub alrmbssr: ALRMBSSR,
        #[doc = "0x4c - option register"]
        pub or: OR,
        #[doc = "0x50 - RTC backup registers"]
        pub bkpr: [BKPR; 5],
    }
    #[doc = "RTC time register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tr](tr) module"]
    pub type TR = crate::Reg<u32, _TR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TR;
    #[doc = "`read()` method returns [tr::R](tr::R) reader structure"]
    impl crate::Readable for TR {}
    #[doc = "`write(|w| ..)` method takes [tr::W](tr::W) writer structure"]
    impl crate::Writable for TR {}
    #[doc = "RTC time register"]
    pub mod tr {
        #[doc = "Reader of register TR"]
        pub type R = crate::R<u32, super::TR>;
        #[doc = "Writer for register TR"]
        pub type W = crate::W<u32, super::TR>;
        #[doc = "Register TR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "AM/PM notation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PM_A {
            #[doc = "0: AM or 24-hour format"]
            AM = 0,
            #[doc = "1: PM"]
            PM = 1,
        }
        impl From<PM_A> for bool {
            #[inline(always)]
            fn from(variant: PM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PM`"]
        pub type PM_R = crate::R<bool, PM_A>;
        impl PM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PM_A {
                match self.bits {
                    false => PM_A::AM,
                    true => PM_A::PM,
                }
            }
            #[doc = "Checks if the value of the field is `AM`"]
            #[inline(always)]
            pub fn is_am(&self) -> bool {
                *self == PM_A::AM
            }
            #[doc = "Checks if the value of the field is `PM`"]
            #[inline(always)]
            pub fn is_pm(&self) -> bool {
                *self == PM_A::PM
            }
        }
        #[doc = "Write proxy for field `PM`"]
        pub struct PM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "AM or 24-hour format"]
            #[inline(always)]
            pub fn am(self) -> &'a mut W {
                self.variant(PM_A::AM)
            }
            #[doc = "PM"]
            #[inline(always)]
            pub fn pm(self) -> &'a mut W {
                self.variant(PM_A::PM)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `HT`"]
        pub type HT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HT`"]
        pub struct HT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `HU`"]
        pub type HU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HU`"]
        pub struct HU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `MNT`"]
        pub type MNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MNT`"]
        pub struct MNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `MNU`"]
        pub type MNU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MNU`"]
        pub struct MNU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MNU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `ST`"]
        pub type ST_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ST`"]
        pub struct ST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `SU`"]
        pub type SU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SU`"]
        pub struct SU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&self) -> PM_R {
                PM_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format"]
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 16:19 - Hour units in BCD format"]
            #[inline(always)]
            pub fn hu(&self) -> HU_R {
                HU_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format"]
            #[inline(always)]
            pub fn mnt(&self) -> MNT_R {
                MNT_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 8:11 - Minute units in BCD format"]
            #[inline(always)]
            pub fn mnu(&self) -> MNU_R {
                MNU_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:6 - Second tens in BCD format"]
            #[inline(always)]
            pub fn st(&self) -> ST_R {
                ST_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:3 - Second units in BCD format"]
            #[inline(always)]
            pub fn su(&self) -> SU_R {
                SU_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&mut self) -> PM_W {
                PM_W { w: self }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format"]
            #[inline(always)]
            pub fn ht(&mut self) -> HT_W {
                HT_W { w: self }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format"]
            #[inline(always)]
            pub fn hu(&mut self) -> HU_W {
                HU_W { w: self }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format"]
            #[inline(always)]
            pub fn mnt(&mut self) -> MNT_W {
                MNT_W { w: self }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format"]
            #[inline(always)]
            pub fn mnu(&mut self) -> MNU_W {
                MNU_W { w: self }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format"]
            #[inline(always)]
            pub fn st(&mut self) -> ST_W {
                ST_W { w: self }
            }
            #[doc = "Bits 0:3 - Second units in BCD format"]
            #[inline(always)]
            pub fn su(&mut self) -> SU_W {
                SU_W { w: self }
            }
        }
    }
    #[doc = "RTC date register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "RTC date register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `YT`"]
        pub type YT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `YT`"]
        pub struct YT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> YT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `YU`"]
        pub type YU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `YU`"]
        pub struct YU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> YU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `WDU`"]
        pub type WDU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `WDU`"]
        pub struct WDU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 13)) | (((value as u32) & 0x07) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `MT`"]
        pub type MT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MT`"]
        pub struct MT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `MU`"]
        pub type MU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MU`"]
        pub struct MU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DT`"]
        pub type DT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DT`"]
        pub struct DT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `DU`"]
        pub type DU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DU`"]
        pub struct DU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 20:23 - Year tens in BCD format"]
            #[inline(always)]
            pub fn yt(&self) -> YT_R {
                YT_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19 - Year units in BCD format"]
            #[inline(always)]
            pub fn yu(&self) -> YU_R {
                YU_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 13:15 - Week day units"]
            #[inline(always)]
            pub fn wdu(&self) -> WDU_R {
                WDU_R::new(((self.bits >> 13) & 0x07) as u8)
            }
            #[doc = "Bit 12 - Month tens in BCD format"]
            #[inline(always)]
            pub fn mt(&self) -> MT_R {
                MT_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bits 8:11 - Month units in BCD format"]
            #[inline(always)]
            pub fn mu(&self) -> MU_R {
                MU_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:5 - Date tens in BCD format"]
            #[inline(always)]
            pub fn dt(&self) -> DT_R {
                DT_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 0:3 - Date units in BCD format"]
            #[inline(always)]
            pub fn du(&self) -> DU_R {
                DU_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 20:23 - Year tens in BCD format"]
            #[inline(always)]
            pub fn yt(&mut self) -> YT_W {
                YT_W { w: self }
            }
            #[doc = "Bits 16:19 - Year units in BCD format"]
            #[inline(always)]
            pub fn yu(&mut self) -> YU_W {
                YU_W { w: self }
            }
            #[doc = "Bits 13:15 - Week day units"]
            #[inline(always)]
            pub fn wdu(&mut self) -> WDU_W {
                WDU_W { w: self }
            }
            #[doc = "Bit 12 - Month tens in BCD format"]
            #[inline(always)]
            pub fn mt(&mut self) -> MT_W {
                MT_W { w: self }
            }
            #[doc = "Bits 8:11 - Month units in BCD format"]
            #[inline(always)]
            pub fn mu(&mut self) -> MU_W {
                MU_W { w: self }
            }
            #[doc = "Bits 4:5 - Date tens in BCD format"]
            #[inline(always)]
            pub fn dt(&mut self) -> DT_W {
                DT_W { w: self }
            }
            #[doc = "Bits 0:3 - Date units in BCD format"]
            #[inline(always)]
            pub fn du(&mut self) -> DU_W {
                DU_W { w: self }
            }
        }
    }
    #[doc = "RTC control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "RTC control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Calibration output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COE_A {
            #[doc = "0: Calibration output disabled"]
            DISABLED = 0,
            #[doc = "1: Calibration output enabled"]
            ENABLED = 1,
        }
        impl From<COE_A> for bool {
            #[inline(always)]
            fn from(variant: COE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COE`"]
        pub type COE_R = crate::R<bool, COE_A>;
        impl COE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COE_A {
                match self.bits {
                    false => COE_A::DISABLED,
                    true => COE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == COE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == COE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `COE`"]
        pub struct COE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Calibration output disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COE_A::DISABLED)
            }
            #[doc = "Calibration output enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Output selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OSEL_A {
            #[doc = "0: Output disabled"]
            DISABLED = 0,
            #[doc = "1: Alarm A output enabled"]
            ALARMA = 1,
            #[doc = "2: Alarm B output enabled"]
            ALARMB = 2,
            #[doc = "3: Wakeup output enabled"]
            WAKEUP = 3,
        }
        impl From<OSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: OSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OSEL`"]
        pub type OSEL_R = crate::R<u8, OSEL_A>;
        impl OSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OSEL_A {
                match self.bits {
                    0 => OSEL_A::DISABLED,
                    1 => OSEL_A::ALARMA,
                    2 => OSEL_A::ALARMB,
                    3 => OSEL_A::WAKEUP,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OSEL_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ALARMA`"]
            #[inline(always)]
            pub fn is_alarm_a(&self) -> bool {
                *self == OSEL_A::ALARMA
            }
            #[doc = "Checks if the value of the field is `ALARMB`"]
            #[inline(always)]
            pub fn is_alarm_b(&self) -> bool {
                *self == OSEL_A::ALARMB
            }
            #[doc = "Checks if the value of the field is `WAKEUP`"]
            #[inline(always)]
            pub fn is_wakeup(&self) -> bool {
                *self == OSEL_A::WAKEUP
            }
        }
        #[doc = "Write proxy for field `OSEL`"]
        pub struct OSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Output disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OSEL_A::DISABLED)
            }
            #[doc = "Alarm A output enabled"]
            #[inline(always)]
            pub fn alarm_a(self) -> &'a mut W {
                self.variant(OSEL_A::ALARMA)
            }
            #[doc = "Alarm B output enabled"]
            #[inline(always)]
            pub fn alarm_b(self) -> &'a mut W {
                self.variant(OSEL_A::ALARMB)
            }
            #[doc = "Wakeup output enabled"]
            #[inline(always)]
            pub fn wakeup(self) -> &'a mut W {
                self.variant(OSEL_A::WAKEUP)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 21)) | (((value as u32) & 0x03) << 21);
                self.w
            }
        }
        #[doc = "Output polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POL_A {
            #[doc = "0: The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"]
            HIGH = 0,
            #[doc = "1: The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"]
            LOW = 1,
        }
        impl From<POL_A> for bool {
            #[inline(always)]
            fn from(variant: POL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `POL`"]
        pub type POL_R = crate::R<bool, POL_A>;
        impl POL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> POL_A {
                match self.bits {
                    false => POL_A::HIGH,
                    true => POL_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == POL_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == POL_A::LOW
            }
        }
        #[doc = "Write proxy for field `POL`"]
        pub struct POL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: POL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(POL_A::HIGH)
            }
            #[doc = "The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(POL_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Calibration output selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COSEL_A {
            #[doc = "0: Calibration output is 512 Hz (with default prescaler setting)"]
            CALFREQ_512HZ = 0,
            #[doc = "1: Calibration output is 1 Hz (with default prescaler setting)"]
            CALFREQ_1HZ = 1,
        }
        impl From<COSEL_A> for bool {
            #[inline(always)]
            fn from(variant: COSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COSEL`"]
        pub type COSEL_R = crate::R<bool, COSEL_A>;
        impl COSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COSEL_A {
                match self.bits {
                    false => COSEL_A::CALFREQ_512HZ,
                    true => COSEL_A::CALFREQ_1HZ,
                }
            }
            #[doc = "Checks if the value of the field is `CALFREQ_512HZ`"]
            #[inline(always)]
            pub fn is_cal_freq_512hz(&self) -> bool {
                *self == COSEL_A::CALFREQ_512HZ
            }
            #[doc = "Checks if the value of the field is `CALFREQ_1HZ`"]
            #[inline(always)]
            pub fn is_cal_freq_1hz(&self) -> bool {
                *self == COSEL_A::CALFREQ_1HZ
            }
        }
        #[doc = "Write proxy for field `COSEL`"]
        pub struct COSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Calibration output is 512 Hz (with default prescaler setting)"]
            #[inline(always)]
            pub fn cal_freq_512hz(self) -> &'a mut W {
                self.variant(COSEL_A::CALFREQ_512HZ)
            }
            #[doc = "Calibration output is 1 Hz (with default prescaler setting)"]
            #[inline(always)]
            pub fn cal_freq_1hz(self) -> &'a mut W {
                self.variant(COSEL_A::CALFREQ_1HZ)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Backup\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BKP_A {
            #[doc = "0: Daylight Saving Time change has not been performed"]
            DST_NOT_CHANGED = 0,
            #[doc = "1: Daylight Saving Time change has been performed"]
            DST_CHANGED = 1,
        }
        impl From<BKP_A> for bool {
            #[inline(always)]
            fn from(variant: BKP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BKP`"]
        pub type BKP_R = crate::R<bool, BKP_A>;
        impl BKP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BKP_A {
                match self.bits {
                    false => BKP_A::DST_NOT_CHANGED,
                    true => BKP_A::DST_CHANGED,
                }
            }
            #[doc = "Checks if the value of the field is `DST_NOT_CHANGED`"]
            #[inline(always)]
            pub fn is_dst_not_changed(&self) -> bool {
                *self == BKP_A::DST_NOT_CHANGED
            }
            #[doc = "Checks if the value of the field is `DST_CHANGED`"]
            #[inline(always)]
            pub fn is_dst_changed(&self) -> bool {
                *self == BKP_A::DST_CHANGED
            }
        }
        #[doc = "Write proxy for field `BKP`"]
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BKP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Daylight Saving Time change has not been performed"]
            #[inline(always)]
            pub fn dst_not_changed(self) -> &'a mut W {
                self.variant(BKP_A::DST_NOT_CHANGED)
            }
            #[doc = "Daylight Saving Time change has been performed"]
            #[inline(always)]
            pub fn dst_changed(self) -> &'a mut W {
                self.variant(BKP_A::DST_CHANGED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Subtract 1 hour (winter time change)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SUB1H_AW {
            #[doc = "1: Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode"]
            SUB1 = 1,
        }
        impl From<SUB1H_AW> for bool {
            #[inline(always)]
            fn from(variant: SUB1H_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `SUB1H`"]
        pub struct SUB1H_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SUB1H_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SUB1H_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode"]
            #[inline(always)]
            pub fn sub1(self) -> &'a mut W {
                self.variant(SUB1H_AW::SUB1)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Add 1 hour (summer time change)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADD1H_AW {
            #[doc = "1: Adds 1 hour to the current time. This can be used for summer time change outside initialization mode"]
            ADD1 = 1,
        }
        impl From<ADD1H_AW> for bool {
            #[inline(always)]
            fn from(variant: ADD1H_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADD1H`"]
        pub struct ADD1H_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD1H_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADD1H_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Adds 1 hour to the current time. This can be used for summer time change outside initialization mode"]
            #[inline(always)]
            pub fn add1(self) -> &'a mut W {
                self.variant(ADD1H_AW::ADD1)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Time-stamp interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSIE_A {
            #[doc = "0: Time-stamp Interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Time-stamp Interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TSIE_A> for bool {
            #[inline(always)]
            fn from(variant: TSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSIE`"]
        pub type TSIE_R = crate::R<bool, TSIE_A>;
        impl TSIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TSIE_A {
                match self.bits {
                    false => TSIE_A::DISABLED,
                    true => TSIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TSIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TSIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TSIE`"]
        pub struct TSIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Time-stamp Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TSIE_A::DISABLED)
            }
            #[doc = "Time-stamp Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TSIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Wakeup timer interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUTIE_A {
            #[doc = "0: Wakeup timer interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Wakeup timer interrupt enabled"]
            ENABLED = 1,
        }
        impl From<WUTIE_A> for bool {
            #[inline(always)]
            fn from(variant: WUTIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUTIE`"]
        pub type WUTIE_R = crate::R<bool, WUTIE_A>;
        impl WUTIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUTIE_A {
                match self.bits {
                    false => WUTIE_A::DISABLED,
                    true => WUTIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WUTIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WUTIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WUTIE`"]
        pub struct WUTIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUTIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUTIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Wakeup timer interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WUTIE_A::DISABLED)
            }
            #[doc = "Wakeup timer interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WUTIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Alarm B interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRBIE_A {
            #[doc = "0: Alarm B Interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Alarm B Interrupt enabled"]
            ENABLED = 1,
        }
        impl From<ALRBIE_A> for bool {
            #[inline(always)]
            fn from(variant: ALRBIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRBIE`"]
        pub type ALRBIE_R = crate::R<bool, ALRBIE_A>;
        impl ALRBIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALRBIE_A {
                match self.bits {
                    false => ALRBIE_A::DISABLED,
                    true => ALRBIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ALRBIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ALRBIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ALRBIE`"]
        pub struct ALRBIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRBIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALRBIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm B Interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ALRBIE_A::DISABLED)
            }
            #[doc = "Alarm B Interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ALRBIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Alarm A interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRAIE_A {
            #[doc = "0: Alarm A interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Alarm A interrupt enabled"]
            ENABLED = 1,
        }
        impl From<ALRAIE_A> for bool {
            #[inline(always)]
            fn from(variant: ALRAIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRAIE`"]
        pub type ALRAIE_R = crate::R<bool, ALRAIE_A>;
        impl ALRAIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALRAIE_A {
                match self.bits {
                    false => ALRAIE_A::DISABLED,
                    true => ALRAIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ALRAIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ALRAIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ALRAIE`"]
        pub struct ALRAIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRAIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALRAIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm A interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ALRAIE_A::DISABLED)
            }
            #[doc = "Alarm A interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ALRAIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "timestamp enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSE_A {
            #[doc = "0: Timestamp disabled"]
            DISABLED = 0,
            #[doc = "1: Timestamp enabled"]
            ENABLED = 1,
        }
        impl From<TSE_A> for bool {
            #[inline(always)]
            fn from(variant: TSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSE`"]
        pub type TSE_R = crate::R<bool, TSE_A>;
        impl TSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TSE_A {
                match self.bits {
                    false => TSE_A::DISABLED,
                    true => TSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TSE`"]
        pub struct TSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Timestamp disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TSE_A::DISABLED)
            }
            #[doc = "Timestamp enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Wakeup timer enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUTE_A {
            #[doc = "0: Wakeup timer disabled"]
            DISABLED = 0,
            #[doc = "1: Wakeup timer enabled"]
            ENABLED = 1,
        }
        impl From<WUTE_A> for bool {
            #[inline(always)]
            fn from(variant: WUTE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUTE`"]
        pub type WUTE_R = crate::R<bool, WUTE_A>;
        impl WUTE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUTE_A {
                match self.bits {
                    false => WUTE_A::DISABLED,
                    true => WUTE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WUTE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WUTE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WUTE`"]
        pub struct WUTE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUTE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUTE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Wakeup timer disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WUTE_A::DISABLED)
            }
            #[doc = "Wakeup timer enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WUTE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Alarm B enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRBE_A {
            #[doc = "0: Alarm B disabled"]
            DISABLED = 0,
            #[doc = "1: Alarm B enabled"]
            ENABLED = 1,
        }
        impl From<ALRBE_A> for bool {
            #[inline(always)]
            fn from(variant: ALRBE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRBE`"]
        pub type ALRBE_R = crate::R<bool, ALRBE_A>;
        impl ALRBE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALRBE_A {
                match self.bits {
                    false => ALRBE_A::DISABLED,
                    true => ALRBE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ALRBE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ALRBE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ALRBE`"]
        pub struct ALRBE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRBE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALRBE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm B disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ALRBE_A::DISABLED)
            }
            #[doc = "Alarm B enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ALRBE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Alarm A enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRAE_A {
            #[doc = "0: Alarm A disabled"]
            DISABLED = 0,
            #[doc = "1: Alarm A enabled"]
            ENABLED = 1,
        }
        impl From<ALRAE_A> for bool {
            #[inline(always)]
            fn from(variant: ALRAE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRAE`"]
        pub type ALRAE_R = crate::R<bool, ALRAE_A>;
        impl ALRAE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALRAE_A {
                match self.bits {
                    false => ALRAE_A::DISABLED,
                    true => ALRAE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ALRAE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ALRAE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ALRAE`"]
        pub struct ALRAE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRAE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALRAE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm A disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ALRAE_A::DISABLED)
            }
            #[doc = "Alarm A enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ALRAE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Hour format\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FMT_A {
            #[doc = "0: 24 hour/day format"]
            TWENTY_FOUR_HOUR = 0,
            #[doc = "1: AM/PM hour format"]
            AM_PM = 1,
        }
        impl From<FMT_A> for bool {
            #[inline(always)]
            fn from(variant: FMT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FMT`"]
        pub type FMT_R = crate::R<bool, FMT_A>;
        impl FMT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FMT_A {
                match self.bits {
                    false => FMT_A::TWENTY_FOUR_HOUR,
                    true => FMT_A::AM_PM,
                }
            }
            #[doc = "Checks if the value of the field is `TWENTY_FOUR_HOUR`"]
            #[inline(always)]
            pub fn is_twenty_four_hour(&self) -> bool {
                *self == FMT_A::TWENTY_FOUR_HOUR
            }
            #[doc = "Checks if the value of the field is `AM_PM`"]
            #[inline(always)]
            pub fn is_am_pm(&self) -> bool {
                *self == FMT_A::AM_PM
            }
        }
        #[doc = "Write proxy for field `FMT`"]
        pub struct FMT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FMT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FMT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "24 hour/day format"]
            #[inline(always)]
            pub fn twenty_four_hour(self) -> &'a mut W {
                self.variant(FMT_A::TWENTY_FOUR_HOUR)
            }
            #[doc = "AM/PM hour format"]
            #[inline(always)]
            pub fn am_pm(self) -> &'a mut W {
                self.variant(FMT_A::AM_PM)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Bypass the shadow registers\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BYPSHAD_A {
            #[doc = "0: Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles"]
            SHADOWREG = 0,
            #[doc = "1: Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters"]
            BYPASSSHADOWREG = 1,
        }
        impl From<BYPSHAD_A> for bool {
            #[inline(always)]
            fn from(variant: BYPSHAD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BYPSHAD`"]
        pub type BYPSHAD_R = crate::R<bool, BYPSHAD_A>;
        impl BYPSHAD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BYPSHAD_A {
                match self.bits {
                    false => BYPSHAD_A::SHADOWREG,
                    true => BYPSHAD_A::BYPASSSHADOWREG,
                }
            }
            #[doc = "Checks if the value of the field is `SHADOWREG`"]
            #[inline(always)]
            pub fn is_shadow_reg(&self) -> bool {
                *self == BYPSHAD_A::SHADOWREG
            }
            #[doc = "Checks if the value of the field is `BYPASSSHADOWREG`"]
            #[inline(always)]
            pub fn is_bypass_shadow_reg(&self) -> bool {
                *self == BYPSHAD_A::BYPASSSHADOWREG
            }
        }
        #[doc = "Write proxy for field `BYPSHAD`"]
        pub struct BYPSHAD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BYPSHAD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BYPSHAD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles"]
            #[inline(always)]
            pub fn shadow_reg(self) -> &'a mut W {
                self.variant(BYPSHAD_A::SHADOWREG)
            }
            #[doc = "Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters"]
            #[inline(always)]
            pub fn bypass_shadow_reg(self) -> &'a mut W {
                self.variant(BYPSHAD_A::BYPASSSHADOWREG)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "RTC_REFIN reference clock detection enable (50 or 60 Hz)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFCKON_A {
            #[doc = "0: RTC_REFIN detection disabled"]
            DISABLED = 0,
            #[doc = "1: RTC_REFIN detection enabled"]
            ENABLED = 1,
        }
        impl From<REFCKON_A> for bool {
            #[inline(always)]
            fn from(variant: REFCKON_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `REFCKON`"]
        pub type REFCKON_R = crate::R<bool, REFCKON_A>;
        impl REFCKON_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> REFCKON_A {
                match self.bits {
                    false => REFCKON_A::DISABLED,
                    true => REFCKON_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == REFCKON_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == REFCKON_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `REFCKON`"]
        pub struct REFCKON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REFCKON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REFCKON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC_REFIN detection disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(REFCKON_A::DISABLED)
            }
            #[doc = "RTC_REFIN detection enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(REFCKON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Time-stamp event active edge\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSEDGE_A {
            #[doc = "0: RTC_TS input rising edge generates a time-stamp event"]
            RISINGEDGE = 0,
            #[doc = "1: RTC_TS input falling edge generates a time-stamp event"]
            FALLINGEDGE = 1,
        }
        impl From<TSEDGE_A> for bool {
            #[inline(always)]
            fn from(variant: TSEDGE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSEDGE`"]
        pub type TSEDGE_R = crate::R<bool, TSEDGE_A>;
        impl TSEDGE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TSEDGE_A {
                match self.bits {
                    false => TSEDGE_A::RISINGEDGE,
                    true => TSEDGE_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == TSEDGE_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == TSEDGE_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `TSEDGE`"]
        pub struct TSEDGE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSEDGE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSEDGE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC_TS input rising edge generates a time-stamp event"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(TSEDGE_A::RISINGEDGE)
            }
            #[doc = "RTC_TS input falling edge generates a time-stamp event"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(TSEDGE_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Wakeup clock selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WUCKSEL_A {
            #[doc = "0: RTC/16 clock is selected"]
            DIV16 = 0,
            #[doc = "1: RTC/8 clock is selected"]
            DIV8 = 1,
            #[doc = "2: RTC/4 clock is selected"]
            DIV4 = 2,
            #[doc = "3: RTC/2 clock is selected"]
            DIV2 = 3,
            #[doc = "4: ck_spre (usually 1 Hz) clock is selected"]
            CLOCKSPARE = 4,
            #[doc = "6: ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value"]
            CLOCKSPAREWITHOFFSET = 6,
        }
        impl From<WUCKSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: WUCKSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WUCKSEL`"]
        pub type WUCKSEL_R = crate::R<u8, WUCKSEL_A>;
        impl WUCKSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, WUCKSEL_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(WUCKSEL_A::DIV16),
                    1 => Val(WUCKSEL_A::DIV8),
                    2 => Val(WUCKSEL_A::DIV4),
                    3 => Val(WUCKSEL_A::DIV2),
                    4 => Val(WUCKSEL_A::CLOCKSPARE),
                    6 => Val(WUCKSEL_A::CLOCKSPAREWITHOFFSET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == WUCKSEL_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == WUCKSEL_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == WUCKSEL_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == WUCKSEL_A::DIV2
            }
            #[doc = "Checks if the value of the field is `CLOCKSPARE`"]
            #[inline(always)]
            pub fn is_clock_spare(&self) -> bool {
                *self == WUCKSEL_A::CLOCKSPARE
            }
            #[doc = "Checks if the value of the field is `CLOCKSPAREWITHOFFSET`"]
            #[inline(always)]
            pub fn is_clock_spare_with_offset(&self) -> bool {
                *self == WUCKSEL_A::CLOCKSPAREWITHOFFSET
            }
        }
        #[doc = "Write proxy for field `WUCKSEL`"]
        pub struct WUCKSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUCKSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUCKSEL_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "RTC/16 clock is selected"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(WUCKSEL_A::DIV16)
            }
            #[doc = "RTC/8 clock is selected"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(WUCKSEL_A::DIV8)
            }
            #[doc = "RTC/4 clock is selected"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(WUCKSEL_A::DIV4)
            }
            #[doc = "RTC/2 clock is selected"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(WUCKSEL_A::DIV2)
            }
            #[doc = "ck_spre (usually 1 Hz) clock is selected"]
            #[inline(always)]
            pub fn clock_spare(self) -> &'a mut W {
                self.variant(WUCKSEL_A::CLOCKSPARE)
            }
            #[doc = "ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value"]
            #[inline(always)]
            pub fn clock_spare_with_offset(self) -> &'a mut W {
                self.variant(WUCKSEL_A::CLOCKSPAREWITHOFFSET)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 23 - Calibration output enable"]
            #[inline(always)]
            pub fn coe(&self) -> COE_R {
                COE_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bits 21:22 - Output selection"]
            #[inline(always)]
            pub fn osel(&self) -> OSEL_R {
                OSEL_R::new(((self.bits >> 21) & 0x03) as u8)
            }
            #[doc = "Bit 20 - Output polarity"]
            #[inline(always)]
            pub fn pol(&self) -> POL_R {
                POL_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Calibration output selection"]
            #[inline(always)]
            pub fn cosel(&self) -> COSEL_R {
                COSEL_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Backup"]
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Time-stamp interrupt enable"]
            #[inline(always)]
            pub fn tsie(&self) -> TSIE_R {
                TSIE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Wakeup timer interrupt enable"]
            #[inline(always)]
            pub fn wutie(&self) -> WUTIE_R {
                WUTIE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Alarm B interrupt enable"]
            #[inline(always)]
            pub fn alrbie(&self) -> ALRBIE_R {
                ALRBIE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Alarm A interrupt enable"]
            #[inline(always)]
            pub fn alraie(&self) -> ALRAIE_R {
                ALRAIE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - timestamp enable"]
            #[inline(always)]
            pub fn tse(&self) -> TSE_R {
                TSE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Wakeup timer enable"]
            #[inline(always)]
            pub fn wute(&self) -> WUTE_R {
                WUTE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Alarm B enable"]
            #[inline(always)]
            pub fn alrbe(&self) -> ALRBE_R {
                ALRBE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Alarm A enable"]
            #[inline(always)]
            pub fn alrae(&self) -> ALRAE_R {
                ALRAE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Hour format"]
            #[inline(always)]
            pub fn fmt(&self) -> FMT_R {
                FMT_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Bypass the shadow registers"]
            #[inline(always)]
            pub fn bypshad(&self) -> BYPSHAD_R {
                BYPSHAD_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - RTC_REFIN reference clock detection enable (50 or 60 Hz)"]
            #[inline(always)]
            pub fn refckon(&self) -> REFCKON_R {
                REFCKON_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Time-stamp event active edge"]
            #[inline(always)]
            pub fn tsedge(&self) -> TSEDGE_R {
                TSEDGE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 0:2 - Wakeup clock selection"]
            #[inline(always)]
            pub fn wucksel(&self) -> WUCKSEL_R {
                WUCKSEL_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 23 - Calibration output enable"]
            #[inline(always)]
            pub fn coe(&mut self) -> COE_W {
                COE_W { w: self }
            }
            #[doc = "Bits 21:22 - Output selection"]
            #[inline(always)]
            pub fn osel(&mut self) -> OSEL_W {
                OSEL_W { w: self }
            }
            #[doc = "Bit 20 - Output polarity"]
            #[inline(always)]
            pub fn pol(&mut self) -> POL_W {
                POL_W { w: self }
            }
            #[doc = "Bit 19 - Calibration output selection"]
            #[inline(always)]
            pub fn cosel(&mut self) -> COSEL_W {
                COSEL_W { w: self }
            }
            #[doc = "Bit 18 - Backup"]
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            #[doc = "Bit 17 - Subtract 1 hour (winter time change)"]
            #[inline(always)]
            pub fn sub1h(&mut self) -> SUB1H_W {
                SUB1H_W { w: self }
            }
            #[doc = "Bit 16 - Add 1 hour (summer time change)"]
            #[inline(always)]
            pub fn add1h(&mut self) -> ADD1H_W {
                ADD1H_W { w: self }
            }
            #[doc = "Bit 15 - Time-stamp interrupt enable"]
            #[inline(always)]
            pub fn tsie(&mut self) -> TSIE_W {
                TSIE_W { w: self }
            }
            #[doc = "Bit 14 - Wakeup timer interrupt enable"]
            #[inline(always)]
            pub fn wutie(&mut self) -> WUTIE_W {
                WUTIE_W { w: self }
            }
            #[doc = "Bit 13 - Alarm B interrupt enable"]
            #[inline(always)]
            pub fn alrbie(&mut self) -> ALRBIE_W {
                ALRBIE_W { w: self }
            }
            #[doc = "Bit 12 - Alarm A interrupt enable"]
            #[inline(always)]
            pub fn alraie(&mut self) -> ALRAIE_W {
                ALRAIE_W { w: self }
            }
            #[doc = "Bit 11 - timestamp enable"]
            #[inline(always)]
            pub fn tse(&mut self) -> TSE_W {
                TSE_W { w: self }
            }
            #[doc = "Bit 10 - Wakeup timer enable"]
            #[inline(always)]
            pub fn wute(&mut self) -> WUTE_W {
                WUTE_W { w: self }
            }
            #[doc = "Bit 9 - Alarm B enable"]
            #[inline(always)]
            pub fn alrbe(&mut self) -> ALRBE_W {
                ALRBE_W { w: self }
            }
            #[doc = "Bit 8 - Alarm A enable"]
            #[inline(always)]
            pub fn alrae(&mut self) -> ALRAE_W {
                ALRAE_W { w: self }
            }
            #[doc = "Bit 6 - Hour format"]
            #[inline(always)]
            pub fn fmt(&mut self) -> FMT_W {
                FMT_W { w: self }
            }
            #[doc = "Bit 5 - Bypass the shadow registers"]
            #[inline(always)]
            pub fn bypshad(&mut self) -> BYPSHAD_W {
                BYPSHAD_W { w: self }
            }
            #[doc = "Bit 4 - RTC_REFIN reference clock detection enable (50 or 60 Hz)"]
            #[inline(always)]
            pub fn refckon(&mut self) -> REFCKON_W {
                REFCKON_W { w: self }
            }
            #[doc = "Bit 3 - Time-stamp event active edge"]
            #[inline(always)]
            pub fn tsedge(&mut self) -> TSEDGE_W {
                TSEDGE_W { w: self }
            }
            #[doc = "Bits 0:2 - Wakeup clock selection"]
            #[inline(always)]
            pub fn wucksel(&mut self) -> WUCKSEL_W {
                WUCKSEL_W { w: self }
            }
        }
    }
    #[doc = "RTC initialization and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "`write(|w| ..)` method takes [isr::W](isr::W) writer structure"]
    impl crate::Writable for ISR {}
    #[doc = "RTC initialization and status register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Writer for register ISR"]
        pub type W = crate::W<u32, super::ISR>;
        #[doc = "Register ISR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "RTC_TAMP2 detection flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2F_A {
            #[doc = "1: This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input"]
            TAMPERED = 1,
        }
        impl From<TAMP2F_A> for bool {
            #[inline(always)]
            fn from(variant: TAMP2F_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMP2F`"]
        pub type TAMP2F_R = crate::R<bool, TAMP2F_A>;
        impl TAMP2F_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, TAMP2F_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(TAMP2F_A::TAMPERED),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TAMPERED`"]
            #[inline(always)]
            pub fn is_tampered(&self) -> bool {
                *self == TAMP2F_A::TAMPERED
            }
        }
        #[doc = "RTC_TAMP2 detection flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2F_AW {
            #[doc = "0: Flag cleared by software writing 0"]
            CLEAR = 0,
        }
        impl From<TAMP2F_AW> for bool {
            #[inline(always)]
            fn from(variant: TAMP2F_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TAMP2F`"]
        pub struct TAMP2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP2F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP2F_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Flag cleared by software writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TAMP2F_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "RTC_TAMP1 detection flag"]
        pub type TAMP1F_A = TAMP2F_A;
        #[doc = "Reader of field `TAMP1F`"]
        pub type TAMP1F_R = crate::R<bool, TAMP2F_A>;
        #[doc = "RTC_TAMP1 detection flag"]
        pub type TAMP1F_AW = TAMP2F_AW;
        #[doc = "Write proxy for field `TAMP1F`"]
        pub struct TAMP1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP1F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP1F_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Flag cleared by software writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TAMP2F_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Time-stamp overflow flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSOVF_A {
            #[doc = "1: This flag is set by hardware when a time-stamp event occurs while TSF is already set"]
            OVERFLOW = 1,
        }
        impl From<TSOVF_A> for bool {
            #[inline(always)]
            fn from(variant: TSOVF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSOVF`"]
        pub type TSOVF_R = crate::R<bool, TSOVF_A>;
        impl TSOVF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, TSOVF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(TSOVF_A::OVERFLOW),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERFLOW`"]
            #[inline(always)]
            pub fn is_overflow(&self) -> bool {
                *self == TSOVF_A::OVERFLOW
            }
        }
        #[doc = "Time-stamp overflow flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSOVF_AW {
            #[doc = "0: This flag is cleared by software by writing 0"]
            CLEAR = 0,
        }
        impl From<TSOVF_AW> for bool {
            #[inline(always)]
            fn from(variant: TSOVF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TSOVF`"]
        pub struct TSOVF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSOVF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSOVF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "This flag is cleared by software by writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TSOVF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Time-stamp flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSF_A {
            #[doc = "1: This flag is set by hardware when a time-stamp event occurs"]
            TIMESTAMPEVENT = 1,
        }
        impl From<TSF_A> for bool {
            #[inline(always)]
            fn from(variant: TSF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSF`"]
        pub type TSF_R = crate::R<bool, TSF_A>;
        impl TSF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, TSF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(TSF_A::TIMESTAMPEVENT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TIMESTAMPEVENT`"]
            #[inline(always)]
            pub fn is_timestamp_event(&self) -> bool {
                *self == TSF_A::TIMESTAMPEVENT
            }
        }
        #[doc = "Time-stamp flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSF_AW {
            #[doc = "0: This flag is cleared by software by writing 0"]
            CLEAR = 0,
        }
        impl From<TSF_AW> for bool {
            #[inline(always)]
            fn from(variant: TSF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TSF`"]
        pub struct TSF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "This flag is cleared by software by writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TSF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Wakeup timer flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUTF_A {
            #[doc = "1: This flag is set by hardware when the wakeup auto-reload counter reaches 0"]
            ZERO = 1,
        }
        impl From<WUTF_A> for bool {
            #[inline(always)]
            fn from(variant: WUTF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUTF`"]
        pub type WUTF_R = crate::R<bool, WUTF_A>;
        impl WUTF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, WUTF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(WUTF_A::ZERO),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ZERO`"]
            #[inline(always)]
            pub fn is_zero(&self) -> bool {
                *self == WUTF_A::ZERO
            }
        }
        #[doc = "Wakeup timer flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUTF_AW {
            #[doc = "0: This flag is cleared by software by writing 0"]
            CLEAR = 0,
        }
        impl From<WUTF_AW> for bool {
            #[inline(always)]
            fn from(variant: WUTF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `WUTF`"]
        pub struct WUTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUTF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "This flag is cleared by software by writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(WUTF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Alarm B flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRBF_A {
            #[doc = "1: This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR)"]
            MATCH = 1,
        }
        impl From<ALRBF_A> for bool {
            #[inline(always)]
            fn from(variant: ALRBF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRBF`"]
        pub type ALRBF_R = crate::R<bool, ALRBF_A>;
        impl ALRBF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, ALRBF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(ALRBF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == ALRBF_A::MATCH
            }
        }
        #[doc = "Alarm B flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRBF_AW {
            #[doc = "0: This flag is cleared by software by writing 0"]
            CLEAR = 0,
        }
        impl From<ALRBF_AW> for bool {
            #[inline(always)]
            fn from(variant: ALRBF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ALRBF`"]
        pub struct ALRBF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRBF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALRBF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "This flag is cleared by software by writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ALRBF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Alarm A flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRAF_A {
            #[doc = "1: This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR)"]
            MATCH = 1,
        }
        impl From<ALRAF_A> for bool {
            #[inline(always)]
            fn from(variant: ALRAF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRAF`"]
        pub type ALRAF_R = crate::R<bool, ALRAF_A>;
        impl ALRAF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, ALRAF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(ALRAF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == ALRAF_A::MATCH
            }
        }
        #[doc = "Alarm A flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRAF_AW {
            #[doc = "0: This flag is cleared by software by writing 0"]
            CLEAR = 0,
        }
        impl From<ALRAF_AW> for bool {
            #[inline(always)]
            fn from(variant: ALRAF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ALRAF`"]
        pub struct ALRAF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRAF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALRAF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "This flag is cleared by software by writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ALRAF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Initialization mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INIT_A {
            #[doc = "0: Free running mode"]
            FREERUNNINGMODE = 0,
            #[doc = "1: Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset."]
            INITMODE = 1,
        }
        impl From<INIT_A> for bool {
            #[inline(always)]
            fn from(variant: INIT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `INIT`"]
        pub type INIT_R = crate::R<bool, INIT_A>;
        impl INIT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> INIT_A {
                match self.bits {
                    false => INIT_A::FREERUNNINGMODE,
                    true => INIT_A::INITMODE,
                }
            }
            #[doc = "Checks if the value of the field is `FREERUNNINGMODE`"]
            #[inline(always)]
            pub fn is_free_running_mode(&self) -> bool {
                *self == INIT_A::FREERUNNINGMODE
            }
            #[doc = "Checks if the value of the field is `INITMODE`"]
            #[inline(always)]
            pub fn is_init_mode(&self) -> bool {
                *self == INIT_A::INITMODE
            }
        }
        #[doc = "Write proxy for field `INIT`"]
        pub struct INIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INIT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INIT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Free running mode"]
            #[inline(always)]
            pub fn free_running_mode(self) -> &'a mut W {
                self.variant(INIT_A::FREERUNNINGMODE)
            }
            #[doc = "Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset."]
            #[inline(always)]
            pub fn init_mode(self) -> &'a mut W {
                self.variant(INIT_A::INITMODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Initialization flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INITF_A {
            #[doc = "0: Calendar registers update is not allowed"]
            NOTALLOWED = 0,
            #[doc = "1: Calendar registers update is allowed"]
            ALLOWED = 1,
        }
        impl From<INITF_A> for bool {
            #[inline(always)]
            fn from(variant: INITF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `INITF`"]
        pub type INITF_R = crate::R<bool, INITF_A>;
        impl INITF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> INITF_A {
                match self.bits {
                    false => INITF_A::NOTALLOWED,
                    true => INITF_A::ALLOWED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTALLOWED`"]
            #[inline(always)]
            pub fn is_not_allowed(&self) -> bool {
                *self == INITF_A::NOTALLOWED
            }
            #[doc = "Checks if the value of the field is `ALLOWED`"]
            #[inline(always)]
            pub fn is_allowed(&self) -> bool {
                *self == INITF_A::ALLOWED
            }
        }
        #[doc = "Registers synchronization flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSF_A {
            #[doc = "0: Calendar shadow registers not yet synchronized"]
            NOTSYNCED = 0,
            #[doc = "1: Calendar shadow registers synchronized"]
            SYNCED = 1,
        }
        impl From<RSF_A> for bool {
            #[inline(always)]
            fn from(variant: RSF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RSF`"]
        pub type RSF_R = crate::R<bool, RSF_A>;
        impl RSF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RSF_A {
                match self.bits {
                    false => RSF_A::NOTSYNCED,
                    true => RSF_A::SYNCED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSYNCED`"]
            #[inline(always)]
            pub fn is_not_synced(&self) -> bool {
                *self == RSF_A::NOTSYNCED
            }
            #[doc = "Checks if the value of the field is `SYNCED`"]
            #[inline(always)]
            pub fn is_synced(&self) -> bool {
                *self == RSF_A::SYNCED
            }
        }
        #[doc = "Registers synchronization flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSF_AW {
            #[doc = "0: This flag is cleared by software by writing 0"]
            CLEAR = 0,
        }
        impl From<RSF_AW> for bool {
            #[inline(always)]
            fn from(variant: RSF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RSF`"]
        pub struct RSF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RSF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "This flag is cleared by software by writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RSF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Initialization status flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INITS_A {
            #[doc = "0: Calendar has not been initialized"]
            NOTINITALIZED = 0,
            #[doc = "1: Calendar has been initialized"]
            INITALIZED = 1,
        }
        impl From<INITS_A> for bool {
            #[inline(always)]
            fn from(variant: INITS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `INITS`"]
        pub type INITS_R = crate::R<bool, INITS_A>;
        impl INITS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> INITS_A {
                match self.bits {
                    false => INITS_A::NOTINITALIZED,
                    true => INITS_A::INITALIZED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINITALIZED`"]
            #[inline(always)]
            pub fn is_not_initalized(&self) -> bool {
                *self == INITS_A::NOTINITALIZED
            }
            #[doc = "Checks if the value of the field is `INITALIZED`"]
            #[inline(always)]
            pub fn is_initalized(&self) -> bool {
                *self == INITS_A::INITALIZED
            }
        }
        #[doc = "Shift operation pending\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SHPF_A {
            #[doc = "0: No shift operation is pending"]
            NOSHIFTPENDING = 0,
            #[doc = "1: A shift operation is pending"]
            SHIFTPENDING = 1,
        }
        impl From<SHPF_A> for bool {
            #[inline(always)]
            fn from(variant: SHPF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SHPF`"]
        pub type SHPF_R = crate::R<bool, SHPF_A>;
        impl SHPF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SHPF_A {
                match self.bits {
                    false => SHPF_A::NOSHIFTPENDING,
                    true => SHPF_A::SHIFTPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `NOSHIFTPENDING`"]
            #[inline(always)]
            pub fn is_no_shift_pending(&self) -> bool {
                *self == SHPF_A::NOSHIFTPENDING
            }
            #[doc = "Checks if the value of the field is `SHIFTPENDING`"]
            #[inline(always)]
            pub fn is_shift_pending(&self) -> bool {
                *self == SHPF_A::SHIFTPENDING
            }
        }
        #[doc = "Wakeup timer write flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUTWF_A {
            #[doc = "0: Wakeup timer configuration update not allowed"]
            UPDATENOTALLOWED = 0,
            #[doc = "1: Wakeup timer configuration update allowed"]
            UPDATEALLOWED = 1,
        }
        impl From<WUTWF_A> for bool {
            #[inline(always)]
            fn from(variant: WUTWF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUTWF`"]
        pub type WUTWF_R = crate::R<bool, WUTWF_A>;
        impl WUTWF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUTWF_A {
                match self.bits {
                    false => WUTWF_A::UPDATENOTALLOWED,
                    true => WUTWF_A::UPDATEALLOWED,
                }
            }
            #[doc = "Checks if the value of the field is `UPDATENOTALLOWED`"]
            #[inline(always)]
            pub fn is_update_not_allowed(&self) -> bool {
                *self == WUTWF_A::UPDATENOTALLOWED
            }
            #[doc = "Checks if the value of the field is `UPDATEALLOWED`"]
            #[inline(always)]
            pub fn is_update_allowed(&self) -> bool {
                *self == WUTWF_A::UPDATEALLOWED
            }
        }
        #[doc = "Alarm B write flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALRBWF_A {
            #[doc = "0: Alarm update not allowed"]
            UPDATENOTALLOWED = 0,
            #[doc = "1: Alarm update allowed"]
            UPDATEALLOWED = 1,
        }
        impl From<ALRBWF_A> for bool {
            #[inline(always)]
            fn from(variant: ALRBWF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALRBWF`"]
        pub type ALRBWF_R = crate::R<bool, ALRBWF_A>;
        impl ALRBWF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALRBWF_A {
                match self.bits {
                    false => ALRBWF_A::UPDATENOTALLOWED,
                    true => ALRBWF_A::UPDATEALLOWED,
                }
            }
            #[doc = "Checks if the value of the field is `UPDATENOTALLOWED`"]
            #[inline(always)]
            pub fn is_update_not_allowed(&self) -> bool {
                *self == ALRBWF_A::UPDATENOTALLOWED
            }
            #[doc = "Checks if the value of the field is `UPDATEALLOWED`"]
            #[inline(always)]
            pub fn is_update_allowed(&self) -> bool {
                *self == ALRBWF_A::UPDATEALLOWED
            }
        }
        #[doc = "Alarm A write flag"]
        pub type ALRAWF_A = ALRBWF_A;
        #[doc = "Reader of field `ALRAWF`"]
        pub type ALRAWF_R = crate::R<bool, ALRBWF_A>;
        #[doc = "Recalibration pending flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RECALPF_A {
            #[doc = "1: The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0"]
            PENDING = 1,
        }
        impl From<RECALPF_A> for bool {
            #[inline(always)]
            fn from(variant: RECALPF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RECALPF`"]
        pub type RECALPF_R = crate::R<bool, RECALPF_A>;
        impl RECALPF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, RECALPF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(RECALPF_A::PENDING),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                *self == RECALPF_A::PENDING
            }
        }
        #[doc = "Write proxy for field `RECALPF`"]
        pub struct RECALPF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RECALPF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RECALPF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0"]
            #[inline(always)]
            pub fn pending(self) -> &'a mut W {
                self.variant(RECALPF_A::PENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "RTC_TAMP3 detection flag"]
        pub type TAMP3F_A = TAMP2F_A;
        #[doc = "Reader of field `TAMP3F`"]
        pub type TAMP3F_R = crate::R<bool, TAMP2F_A>;
        #[doc = "RTC_TAMP3 detection flag"]
        pub type TAMP3F_AW = TAMP2F_AW;
        #[doc = "Write proxy for field `TAMP3F`"]
        pub struct TAMP3F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP3F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP3F_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Flag cleared by software writing 0"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TAMP2F_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - RTC_TAMP2 detection flag"]
            #[inline(always)]
            pub fn tamp2f(&self) -> TAMP2F_R {
                TAMP2F_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - RTC_TAMP1 detection flag"]
            #[inline(always)]
            pub fn tamp1f(&self) -> TAMP1F_R {
                TAMP1F_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Time-stamp overflow flag"]
            #[inline(always)]
            pub fn tsovf(&self) -> TSOVF_R {
                TSOVF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Time-stamp flag"]
            #[inline(always)]
            pub fn tsf(&self) -> TSF_R {
                TSF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Wakeup timer flag"]
            #[inline(always)]
            pub fn wutf(&self) -> WUTF_R {
                WUTF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Alarm B flag"]
            #[inline(always)]
            pub fn alrbf(&self) -> ALRBF_R {
                ALRBF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Alarm A flag"]
            #[inline(always)]
            pub fn alraf(&self) -> ALRAF_R {
                ALRAF_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Initialization mode"]
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Initialization flag"]
            #[inline(always)]
            pub fn initf(&self) -> INITF_R {
                INITF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Registers synchronization flag"]
            #[inline(always)]
            pub fn rsf(&self) -> RSF_R {
                RSF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Initialization status flag"]
            #[inline(always)]
            pub fn inits(&self) -> INITS_R {
                INITS_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Shift operation pending"]
            #[inline(always)]
            pub fn shpf(&self) -> SHPF_R {
                SHPF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Wakeup timer write flag"]
            #[inline(always)]
            pub fn wutwf(&self) -> WUTWF_R {
                WUTWF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Alarm B write flag"]
            #[inline(always)]
            pub fn alrbwf(&self) -> ALRBWF_R {
                ALRBWF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Alarm A write flag"]
            #[inline(always)]
            pub fn alrawf(&self) -> ALRAWF_R {
                ALRAWF_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 16 - Recalibration pending flag"]
            #[inline(always)]
            pub fn recalpf(&self) -> RECALPF_R {
                RECALPF_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - RTC_TAMP3 detection flag"]
            #[inline(always)]
            pub fn tamp3f(&self) -> TAMP3F_R {
                TAMP3F_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 14 - RTC_TAMP2 detection flag"]
            #[inline(always)]
            pub fn tamp2f(&mut self) -> TAMP2F_W {
                TAMP2F_W { w: self }
            }
            #[doc = "Bit 13 - RTC_TAMP1 detection flag"]
            #[inline(always)]
            pub fn tamp1f(&mut self) -> TAMP1F_W {
                TAMP1F_W { w: self }
            }
            #[doc = "Bit 12 - Time-stamp overflow flag"]
            #[inline(always)]
            pub fn tsovf(&mut self) -> TSOVF_W {
                TSOVF_W { w: self }
            }
            #[doc = "Bit 11 - Time-stamp flag"]
            #[inline(always)]
            pub fn tsf(&mut self) -> TSF_W {
                TSF_W { w: self }
            }
            #[doc = "Bit 10 - Wakeup timer flag"]
            #[inline(always)]
            pub fn wutf(&mut self) -> WUTF_W {
                WUTF_W { w: self }
            }
            #[doc = "Bit 9 - Alarm B flag"]
            #[inline(always)]
            pub fn alrbf(&mut self) -> ALRBF_W {
                ALRBF_W { w: self }
            }
            #[doc = "Bit 8 - Alarm A flag"]
            #[inline(always)]
            pub fn alraf(&mut self) -> ALRAF_W {
                ALRAF_W { w: self }
            }
            #[doc = "Bit 7 - Initialization mode"]
            #[inline(always)]
            pub fn init(&mut self) -> INIT_W {
                INIT_W { w: self }
            }
            #[doc = "Bit 5 - Registers synchronization flag"]
            #[inline(always)]
            pub fn rsf(&mut self) -> RSF_W {
                RSF_W { w: self }
            }
            #[doc = "Bit 16 - Recalibration pending flag"]
            #[inline(always)]
            pub fn recalpf(&mut self) -> RECALPF_W {
                RECALPF_W { w: self }
            }
            #[doc = "Bit 15 - RTC_TAMP3 detection flag"]
            #[inline(always)]
            pub fn tamp3f(&mut self) -> TAMP3F_W {
                TAMP3F_W { w: self }
            }
        }
    }
    #[doc = "RTC prescaler register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prer](prer) module"]
    pub type PRER = crate::Reg<u32, _PRER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRER;
    #[doc = "`read()` method returns [prer::R](prer::R) reader structure"]
    impl crate::Readable for PRER {}
    #[doc = "`write(|w| ..)` method takes [prer::W](prer::W) writer structure"]
    impl crate::Writable for PRER {}
    #[doc = "RTC prescaler register"]
    pub mod prer {
        #[doc = "Reader of register PRER"]
        pub type R = crate::R<u32, super::PRER>;
        #[doc = "Writer for register PRER"]
        pub type W = crate::W<u32, super::PRER>;
        #[doc = "Register PRER `reset()`'s with value 0"]
        impl crate::ResetValue for super::PRER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PREDIV_A`"]
        pub type PREDIV_A_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PREDIV_A`"]
        pub struct PREDIV_A_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PREDIV_A_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x7f << 16)) | (((value as u32) & 0x7f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `PREDIV_S`"]
        pub type PREDIV_S_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PREDIV_S`"]
        pub struct PREDIV_S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PREDIV_S_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 16:22 - Asynchronous prescaler factor"]
            #[inline(always)]
            pub fn prediv_a(&self) -> PREDIV_A_R {
                PREDIV_A_R::new(((self.bits >> 16) & 0x7f) as u8)
            }
            #[doc = "Bits 0:15 - Synchronous prescaler factor"]
            #[inline(always)]
            pub fn prediv_s(&self) -> PREDIV_S_R {
                PREDIV_S_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 16:22 - Asynchronous prescaler factor"]
            #[inline(always)]
            pub fn prediv_a(&mut self) -> PREDIV_A_W {
                PREDIV_A_W { w: self }
            }
            #[doc = "Bits 0:15 - Synchronous prescaler factor"]
            #[inline(always)]
            pub fn prediv_s(&mut self) -> PREDIV_S_W {
                PREDIV_S_W { w: self }
            }
        }
    }
    #[doc = "RTC wakeup timer register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wutr](wutr) module"]
    pub type WUTR = crate::Reg<u32, _WUTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _WUTR;
    #[doc = "`read()` method returns [wutr::R](wutr::R) reader structure"]
    impl crate::Readable for WUTR {}
    #[doc = "`write(|w| ..)` method takes [wutr::W](wutr::W) writer structure"]
    impl crate::Writable for WUTR {}
    #[doc = "RTC wakeup timer register"]
    pub mod wutr {
        #[doc = "Reader of register WUTR"]
        pub type R = crate::R<u32, super::WUTR>;
        #[doc = "Writer for register WUTR"]
        pub type W = crate::W<u32, super::WUTR>;
        #[doc = "Register WUTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::WUTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `WUT`"]
        pub type WUT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `WUT`"]
        pub struct WUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Wakeup auto-reload value bits"]
            #[inline(always)]
            pub fn wut(&self) -> WUT_R {
                WUT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup auto-reload value bits"]
            #[inline(always)]
            pub fn wut(&mut self) -> WUT_W {
                WUT_W { w: self }
            }
        }
    }
    #[doc = "RTC alarm A register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alrmar](alrmar) module"]
    pub type ALRMAR = crate::Reg<u32, _ALRMAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALRMAR;
    #[doc = "`read()` method returns [alrmar::R](alrmar::R) reader structure"]
    impl crate::Readable for ALRMAR {}
    #[doc = "`write(|w| ..)` method takes [alrmar::W](alrmar::W) writer structure"]
    impl crate::Writable for ALRMAR {}
    #[doc = "RTC alarm A register"]
    pub mod alrmar {
        #[doc = "Reader of register ALRMAR"]
        pub type R = crate::R<u32, super::ALRMAR>;
        #[doc = "Writer for register ALRMAR"]
        pub type W = crate::W<u32, super::ALRMAR>;
        #[doc = "Register ALRMAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ALRMAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alarm A date mask\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSK4_A {
            #[doc = "0: Alarm set if the date/day match"]
            MASK = 0,
            #[doc = "1: Date/day dont care in Alarm comparison"]
            NOTMASK = 1,
        }
        impl From<MSK4_A> for bool {
            #[inline(always)]
            fn from(variant: MSK4_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSK4`"]
        pub type MSK4_R = crate::R<bool, MSK4_A>;
        impl MSK4_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSK4_A {
                match self.bits {
                    false => MSK4_A::MASK,
                    true => MSK4_A::NOTMASK,
                }
            }
            #[doc = "Checks if the value of the field is `MASK`"]
            #[inline(always)]
            pub fn is_mask(&self) -> bool {
                *self == MSK4_A::MASK
            }
            #[doc = "Checks if the value of the field is `NOTMASK`"]
            #[inline(always)]
            pub fn is_not_mask(&self) -> bool {
                *self == MSK4_A::NOTMASK
            }
        }
        #[doc = "Write proxy for field `MSK4`"]
        pub struct MSK4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Week day selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDSEL_A {
            #[doc = "0: DU\\[3:0\\]
represents the date units"]
            DATEUNITS = 0,
            #[doc = "1: DU\\[3:0\\]
represents the week day. DT\\[1:0\\]
is dont care."]
            WEEKDAY = 1,
        }
        impl From<WDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: WDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WDSEL`"]
        pub type WDSEL_R = crate::R<bool, WDSEL_A>;
        impl WDSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WDSEL_A {
                match self.bits {
                    false => WDSEL_A::DATEUNITS,
                    true => WDSEL_A::WEEKDAY,
                }
            }
            #[doc = "Checks if the value of the field is `DATEUNITS`"]
            #[inline(always)]
            pub fn is_date_units(&self) -> bool {
                *self == WDSEL_A::DATEUNITS
            }
            #[doc = "Checks if the value of the field is `WEEKDAY`"]
            #[inline(always)]
            pub fn is_week_day(&self) -> bool {
                *self == WDSEL_A::WEEKDAY
            }
        }
        #[doc = "Write proxy for field `WDSEL`"]
        pub struct WDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DU\\[3:0\\]
represents the date units"]
            #[inline(always)]
            pub fn date_units(self) -> &'a mut W {
                self.variant(WDSEL_A::DATEUNITS)
            }
            #[doc = "DU\\[3:0\\]
represents the week day. DT\\[1:0\\]
is dont care."]
            #[inline(always)]
            pub fn week_day(self) -> &'a mut W {
                self.variant(WDSEL_A::WEEKDAY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Reader of field `DT`"]
        pub type DT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DT`"]
        pub struct DT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Reader of field `DU`"]
        pub type DU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DU`"]
        pub struct DU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Alarm A hours mask"]
        pub type MSK3_A = MSK4_A;
        #[doc = "Reader of field `MSK3`"]
        pub type MSK3_R = crate::R<bool, MSK4_A>;
        #[doc = "Write proxy for field `MSK3`"]
        pub struct MSK3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "AM/PM notation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PM_A {
            #[doc = "0: AM or 24-hour format"]
            AM = 0,
            #[doc = "1: PM"]
            PM = 1,
        }
        impl From<PM_A> for bool {
            #[inline(always)]
            fn from(variant: PM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PM`"]
        pub type PM_R = crate::R<bool, PM_A>;
        impl PM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PM_A {
                match self.bits {
                    false => PM_A::AM,
                    true => PM_A::PM,
                }
            }
            #[doc = "Checks if the value of the field is `AM`"]
            #[inline(always)]
            pub fn is_am(&self) -> bool {
                *self == PM_A::AM
            }
            #[doc = "Checks if the value of the field is `PM`"]
            #[inline(always)]
            pub fn is_pm(&self) -> bool {
                *self == PM_A::PM
            }
        }
        #[doc = "Write proxy for field `PM`"]
        pub struct PM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "AM or 24-hour format"]
            #[inline(always)]
            pub fn am(self) -> &'a mut W {
                self.variant(PM_A::AM)
            }
            #[doc = "PM"]
            #[inline(always)]
            pub fn pm(self) -> &'a mut W {
                self.variant(PM_A::PM)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `HT`"]
        pub type HT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HT`"]
        pub struct HT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `HU`"]
        pub type HU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HU`"]
        pub struct HU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Alarm A minutes mask"]
        pub type MSK2_A = MSK4_A;
        #[doc = "Reader of field `MSK2`"]
        pub type MSK2_R = crate::R<bool, MSK4_A>;
        #[doc = "Write proxy for field `MSK2`"]
        pub struct MSK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `MNT`"]
        pub type MNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MNT`"]
        pub struct MNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `MNU`"]
        pub type MNU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MNU`"]
        pub struct MNU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MNU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Alarm A seconds mask"]
        pub type MSK1_A = MSK4_A;
        #[doc = "Reader of field `MSK1`"]
        pub type MSK1_R = crate::R<bool, MSK4_A>;
        #[doc = "Write proxy for field `MSK1`"]
        pub struct MSK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `ST`"]
        pub type ST_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ST`"]
        pub struct ST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `SU`"]
        pub type SU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SU`"]
        pub struct SU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 31 - Alarm A date mask"]
            #[inline(always)]
            pub fn msk4(&self) -> MSK4_R {
                MSK4_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 30 - Week day selection"]
            #[inline(always)]
            pub fn wdsel(&self) -> WDSEL_R {
                WDSEL_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bits 28:29 - Date tens in BCD format."]
            #[inline(always)]
            pub fn dt(&self) -> DT_R {
                DT_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 24:27 - Date units or day in BCD format."]
            #[inline(always)]
            pub fn du(&self) -> DU_R {
                DU_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bit 23 - Alarm A hours mask"]
            #[inline(always)]
            pub fn msk3(&self) -> MSK3_R {
                MSK3_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&self) -> PM_R {
                PM_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format."]
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 16:19 - Hour units in BCD format."]
            #[inline(always)]
            pub fn hu(&self) -> HU_R {
                HU_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bit 15 - Alarm A minutes mask"]
            #[inline(always)]
            pub fn msk2(&self) -> MSK2_R {
                MSK2_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format."]
            #[inline(always)]
            pub fn mnt(&self) -> MNT_R {
                MNT_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 8:11 - Minute units in BCD format."]
            #[inline(always)]
            pub fn mnu(&self) -> MNU_R {
                MNU_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 7 - Alarm A seconds mask"]
            #[inline(always)]
            pub fn msk1(&self) -> MSK1_R {
                MSK1_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Second tens in BCD format."]
            #[inline(always)]
            pub fn st(&self) -> ST_R {
                ST_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:3 - Second units in BCD format."]
            #[inline(always)]
            pub fn su(&self) -> SU_R {
                SU_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 31 - Alarm A date mask"]
            #[inline(always)]
            pub fn msk4(&mut self) -> MSK4_W {
                MSK4_W { w: self }
            }
            #[doc = "Bit 30 - Week day selection"]
            #[inline(always)]
            pub fn wdsel(&mut self) -> WDSEL_W {
                WDSEL_W { w: self }
            }
            #[doc = "Bits 28:29 - Date tens in BCD format."]
            #[inline(always)]
            pub fn dt(&mut self) -> DT_W {
                DT_W { w: self }
            }
            #[doc = "Bits 24:27 - Date units or day in BCD format."]
            #[inline(always)]
            pub fn du(&mut self) -> DU_W {
                DU_W { w: self }
            }
            #[doc = "Bit 23 - Alarm A hours mask"]
            #[inline(always)]
            pub fn msk3(&mut self) -> MSK3_W {
                MSK3_W { w: self }
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&mut self) -> PM_W {
                PM_W { w: self }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format."]
            #[inline(always)]
            pub fn ht(&mut self) -> HT_W {
                HT_W { w: self }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format."]
            #[inline(always)]
            pub fn hu(&mut self) -> HU_W {
                HU_W { w: self }
            }
            #[doc = "Bit 15 - Alarm A minutes mask"]
            #[inline(always)]
            pub fn msk2(&mut self) -> MSK2_W {
                MSK2_W { w: self }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format."]
            #[inline(always)]
            pub fn mnt(&mut self) -> MNT_W {
                MNT_W { w: self }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format."]
            #[inline(always)]
            pub fn mnu(&mut self) -> MNU_W {
                MNU_W { w: self }
            }
            #[doc = "Bit 7 - Alarm A seconds mask"]
            #[inline(always)]
            pub fn msk1(&mut self) -> MSK1_W {
                MSK1_W { w: self }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format."]
            #[inline(always)]
            pub fn st(&mut self) -> ST_W {
                ST_W { w: self }
            }
            #[doc = "Bits 0:3 - Second units in BCD format."]
            #[inline(always)]
            pub fn su(&mut self) -> SU_W {
                SU_W { w: self }
            }
        }
    }
    #[doc = "RTC alarm B register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alrmbr](alrmbr) module"]
    pub type ALRMBR = crate::Reg<u32, _ALRMBR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALRMBR;
    #[doc = "`read()` method returns [alrmbr::R](alrmbr::R) reader structure"]
    impl crate::Readable for ALRMBR {}
    #[doc = "`write(|w| ..)` method takes [alrmbr::W](alrmbr::W) writer structure"]
    impl crate::Writable for ALRMBR {}
    #[doc = "RTC alarm B register"]
    pub mod alrmbr {
        #[doc = "Reader of register ALRMBR"]
        pub type R = crate::R<u32, super::ALRMBR>;
        #[doc = "Writer for register ALRMBR"]
        pub type W = crate::W<u32, super::ALRMBR>;
        #[doc = "Register ALRMBR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ALRMBR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alarm B date mask\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSK4_A {
            #[doc = "0: Alarm set if the date/day match"]
            MASK = 0,
            #[doc = "1: Date/day dont care in Alarm comparison"]
            NOTMASK = 1,
        }
        impl From<MSK4_A> for bool {
            #[inline(always)]
            fn from(variant: MSK4_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSK4`"]
        pub type MSK4_R = crate::R<bool, MSK4_A>;
        impl MSK4_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSK4_A {
                match self.bits {
                    false => MSK4_A::MASK,
                    true => MSK4_A::NOTMASK,
                }
            }
            #[doc = "Checks if the value of the field is `MASK`"]
            #[inline(always)]
            pub fn is_mask(&self) -> bool {
                *self == MSK4_A::MASK
            }
            #[doc = "Checks if the value of the field is `NOTMASK`"]
            #[inline(always)]
            pub fn is_not_mask(&self) -> bool {
                *self == MSK4_A::NOTMASK
            }
        }
        #[doc = "Write proxy for field `MSK4`"]
        pub struct MSK4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Week day selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDSEL_A {
            #[doc = "0: DU\\[3:0\\]
represents the date units"]
            DATEUNITS = 0,
            #[doc = "1: DU\\[3:0\\]
represents the week day. DT\\[1:0\\]
is dont care."]
            WEEKDAY = 1,
        }
        impl From<WDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: WDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WDSEL`"]
        pub type WDSEL_R = crate::R<bool, WDSEL_A>;
        impl WDSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WDSEL_A {
                match self.bits {
                    false => WDSEL_A::DATEUNITS,
                    true => WDSEL_A::WEEKDAY,
                }
            }
            #[doc = "Checks if the value of the field is `DATEUNITS`"]
            #[inline(always)]
            pub fn is_date_units(&self) -> bool {
                *self == WDSEL_A::DATEUNITS
            }
            #[doc = "Checks if the value of the field is `WEEKDAY`"]
            #[inline(always)]
            pub fn is_week_day(&self) -> bool {
                *self == WDSEL_A::WEEKDAY
            }
        }
        #[doc = "Write proxy for field `WDSEL`"]
        pub struct WDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DU\\[3:0\\]
represents the date units"]
            #[inline(always)]
            pub fn date_units(self) -> &'a mut W {
                self.variant(WDSEL_A::DATEUNITS)
            }
            #[doc = "DU\\[3:0\\]
represents the week day. DT\\[1:0\\]
is dont care."]
            #[inline(always)]
            pub fn week_day(self) -> &'a mut W {
                self.variant(WDSEL_A::WEEKDAY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Reader of field `DT`"]
        pub type DT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DT`"]
        pub struct DT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | (((value as u32) & 0x03) << 28);
                self.w
            }
        }
        #[doc = "Reader of field `DU`"]
        pub type DU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DU`"]
        pub struct DU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Alarm B hours mask"]
        pub type MSK3_A = MSK4_A;
        #[doc = "Reader of field `MSK3`"]
        pub type MSK3_R = crate::R<bool, MSK4_A>;
        #[doc = "Write proxy for field `MSK3`"]
        pub struct MSK3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "AM/PM notation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PM_A {
            #[doc = "0: AM or 24-hour format"]
            AM = 0,
            #[doc = "1: PM"]
            PM = 1,
        }
        impl From<PM_A> for bool {
            #[inline(always)]
            fn from(variant: PM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PM`"]
        pub type PM_R = crate::R<bool, PM_A>;
        impl PM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PM_A {
                match self.bits {
                    false => PM_A::AM,
                    true => PM_A::PM,
                }
            }
            #[doc = "Checks if the value of the field is `AM`"]
            #[inline(always)]
            pub fn is_am(&self) -> bool {
                *self == PM_A::AM
            }
            #[doc = "Checks if the value of the field is `PM`"]
            #[inline(always)]
            pub fn is_pm(&self) -> bool {
                *self == PM_A::PM
            }
        }
        #[doc = "Write proxy for field `PM`"]
        pub struct PM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "AM or 24-hour format"]
            #[inline(always)]
            pub fn am(self) -> &'a mut W {
                self.variant(PM_A::AM)
            }
            #[doc = "PM"]
            #[inline(always)]
            pub fn pm(self) -> &'a mut W {
                self.variant(PM_A::PM)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `HT`"]
        pub type HT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HT`"]
        pub struct HT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `HU`"]
        pub type HU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HU`"]
        pub struct HU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Alarm B minutes mask"]
        pub type MSK2_A = MSK4_A;
        #[doc = "Reader of field `MSK2`"]
        pub type MSK2_R = crate::R<bool, MSK4_A>;
        #[doc = "Write proxy for field `MSK2`"]
        pub struct MSK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `MNT`"]
        pub type MNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MNT`"]
        pub struct MNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `MNU`"]
        pub type MNU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MNU`"]
        pub struct MNU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MNU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Alarm B seconds mask"]
        pub type MSK1_A = MSK4_A;
        #[doc = "Reader of field `MSK1`"]
        pub type MSK1_R = crate::R<bool, MSK4_A>;
        #[doc = "Write proxy for field `MSK1`"]
        pub struct MSK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSK1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSK1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Alarm set if the date/day match"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut W {
                self.variant(MSK4_A::MASK)
            }
            #[doc = "Date/day dont care in Alarm comparison"]
            #[inline(always)]
            pub fn not_mask(self) -> &'a mut W {
                self.variant(MSK4_A::NOTMASK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `ST`"]
        pub type ST_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ST`"]
        pub struct ST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `SU`"]
        pub type SU_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SU`"]
        pub struct SU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SU_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 31 - Alarm B date mask"]
            #[inline(always)]
            pub fn msk4(&self) -> MSK4_R {
                MSK4_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 30 - Week day selection"]
            #[inline(always)]
            pub fn wdsel(&self) -> WDSEL_R {
                WDSEL_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bits 28:29 - Date tens in BCD format"]
            #[inline(always)]
            pub fn dt(&self) -> DT_R {
                DT_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            #[doc = "Bits 24:27 - Date units or day in BCD format"]
            #[inline(always)]
            pub fn du(&self) -> DU_R {
                DU_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bit 23 - Alarm B hours mask"]
            #[inline(always)]
            pub fn msk3(&self) -> MSK3_R {
                MSK3_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&self) -> PM_R {
                PM_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format"]
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 16:19 - Hour units in BCD format"]
            #[inline(always)]
            pub fn hu(&self) -> HU_R {
                HU_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bit 15 - Alarm B minutes mask"]
            #[inline(always)]
            pub fn msk2(&self) -> MSK2_R {
                MSK2_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format"]
            #[inline(always)]
            pub fn mnt(&self) -> MNT_R {
                MNT_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 8:11 - Minute units in BCD format"]
            #[inline(always)]
            pub fn mnu(&self) -> MNU_R {
                MNU_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 7 - Alarm B seconds mask"]
            #[inline(always)]
            pub fn msk1(&self) -> MSK1_R {
                MSK1_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Second tens in BCD format"]
            #[inline(always)]
            pub fn st(&self) -> ST_R {
                ST_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:3 - Second units in BCD format"]
            #[inline(always)]
            pub fn su(&self) -> SU_R {
                SU_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 31 - Alarm B date mask"]
            #[inline(always)]
            pub fn msk4(&mut self) -> MSK4_W {
                MSK4_W { w: self }
            }
            #[doc = "Bit 30 - Week day selection"]
            #[inline(always)]
            pub fn wdsel(&mut self) -> WDSEL_W {
                WDSEL_W { w: self }
            }
            #[doc = "Bits 28:29 - Date tens in BCD format"]
            #[inline(always)]
            pub fn dt(&mut self) -> DT_W {
                DT_W { w: self }
            }
            #[doc = "Bits 24:27 - Date units or day in BCD format"]
            #[inline(always)]
            pub fn du(&mut self) -> DU_W {
                DU_W { w: self }
            }
            #[doc = "Bit 23 - Alarm B hours mask"]
            #[inline(always)]
            pub fn msk3(&mut self) -> MSK3_W {
                MSK3_W { w: self }
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&mut self) -> PM_W {
                PM_W { w: self }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format"]
            #[inline(always)]
            pub fn ht(&mut self) -> HT_W {
                HT_W { w: self }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format"]
            #[inline(always)]
            pub fn hu(&mut self) -> HU_W {
                HU_W { w: self }
            }
            #[doc = "Bit 15 - Alarm B minutes mask"]
            #[inline(always)]
            pub fn msk2(&mut self) -> MSK2_W {
                MSK2_W { w: self }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format"]
            #[inline(always)]
            pub fn mnt(&mut self) -> MNT_W {
                MNT_W { w: self }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format"]
            #[inline(always)]
            pub fn mnu(&mut self) -> MNU_W {
                MNU_W { w: self }
            }
            #[doc = "Bit 7 - Alarm B seconds mask"]
            #[inline(always)]
            pub fn msk1(&mut self) -> MSK1_W {
                MSK1_W { w: self }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format"]
            #[inline(always)]
            pub fn st(&mut self) -> ST_W {
                ST_W { w: self }
            }
            #[doc = "Bits 0:3 - Second units in BCD format"]
            #[inline(always)]
            pub fn su(&mut self) -> SU_W {
                SU_W { w: self }
            }
        }
    }
    #[doc = "write protection register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wpr](wpr) module"]
    pub type WPR = crate::Reg<u32, _WPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _WPR;
    #[doc = "`write(|w| ..)` method takes [wpr::W](wpr::W) writer structure"]
    impl crate::Writable for WPR {}
    #[doc = "write protection register"]
    pub mod wpr {
        #[doc = "Writer for register WPR"]
        pub type W = crate::W<u32, super::WPR>;
        #[doc = "Register WPR `reset()`'s with value 0"]
        impl crate::ResetValue for super::WPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `KEY`"]
        pub struct KEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Write protection key"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W {
                KEY_W { w: self }
            }
        }
    }
    #[doc = "RTC sub second register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ssr](ssr) module"]
    pub type SSR = crate::Reg<u32, _SSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SSR;
    #[doc = "`read()` method returns [ssr::R](ssr::R) reader structure"]
    impl crate::Readable for SSR {}
    #[doc = "RTC sub second register"]
    pub mod ssr {
        #[doc = "Reader of register SSR"]
        pub type R = crate::R<u32, super::SSR>;
        #[doc = "Reader of field `SS`"]
        pub type SS_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Sub second value"]
            #[inline(always)]
            pub fn ss(&self) -> SS_R {
                SS_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "RTC shift control register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [shiftr](shiftr) module"]
    pub type SHIFTR = crate::Reg<u32, _SHIFTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SHIFTR;
    #[doc = "`write(|w| ..)` method takes [shiftr::W](shiftr::W) writer structure"]
    impl crate::Writable for SHIFTR {}
    #[doc = "RTC shift control register"]
    pub mod shiftr {
        #[doc = "Writer for register SHIFTR"]
        pub type W = crate::W<u32, super::SHIFTR>;
        #[doc = "Register SHIFTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SHIFTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Add one second\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADD1S_AW {
            #[doc = "1: Add one second to the clock/calendar"]
            ADD1 = 1,
        }
        impl From<ADD1S_AW> for bool {
            #[inline(always)]
            fn from(variant: ADD1S_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADD1S`"]
        pub struct ADD1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADD1S_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Add one second to the clock/calendar"]
            #[inline(always)]
            pub fn add1(self) -> &'a mut W {
                self.variant(ADD1S_AW::ADD1)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Write proxy for field `SUBFS`"]
        pub struct SUBFS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SUBFS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7fff) | ((value as u32) & 0x7fff);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 31 - Add one second"]
            #[inline(always)]
            pub fn add1s(&mut self) -> ADD1S_W {
                ADD1S_W { w: self }
            }
            #[doc = "Bits 0:14 - Subtract a fraction of a second"]
            #[inline(always)]
            pub fn subfs(&mut self) -> SUBFS_W {
                SUBFS_W { w: self }
            }
        }
    }
    #[doc = "RTC timestamp time register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tstr](tstr) module"]
    pub type TSTR = crate::Reg<u32, _TSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TSTR;
    #[doc = "`read()` method returns [tstr::R](tstr::R) reader structure"]
    impl crate::Readable for TSTR {}
    #[doc = "RTC timestamp time register"]
    pub mod tstr {
        #[doc = "Reader of register TSTR"]
        pub type R = crate::R<u32, super::TSTR>;
        #[doc = "Reader of field `PM`"]
        pub type PM_R = crate::R<bool, bool>;
        #[doc = "Reader of field `HT`"]
        pub type HT_R = crate::R<u8, u8>;
        #[doc = "Reader of field `HU`"]
        pub type HU_R = crate::R<u8, u8>;
        #[doc = "Reader of field `MNT`"]
        pub type MNT_R = crate::R<u8, u8>;
        #[doc = "Reader of field `MNU`"]
        pub type MNU_R = crate::R<u8, u8>;
        #[doc = "Reader of field `ST`"]
        pub type ST_R = crate::R<u8, u8>;
        #[doc = "Reader of field `SU`"]
        pub type SU_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline(always)]
            pub fn pm(&self) -> PM_R {
                PM_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format."]
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 16:19 - Hour units in BCD format."]
            #[inline(always)]
            pub fn hu(&self) -> HU_R {
                HU_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format."]
            #[inline(always)]
            pub fn mnt(&self) -> MNT_R {
                MNT_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bits 8:11 - Minute units in BCD format."]
            #[inline(always)]
            pub fn mnu(&self) -> MNU_R {
                MNU_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:6 - Second tens in BCD format."]
            #[inline(always)]
            pub fn st(&self) -> ST_R {
                ST_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:3 - Second units in BCD format."]
            #[inline(always)]
            pub fn su(&self) -> SU_R {
                SU_R::new((self.bits & 0x0f) as u8)
            }
        }
    }
    #[doc = "RTC timestamp date register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tsdr](tsdr) module"]
    pub type TSDR = crate::Reg<u32, _TSDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TSDR;
    #[doc = "`read()` method returns [tsdr::R](tsdr::R) reader structure"]
    impl crate::Readable for TSDR {}
    #[doc = "RTC timestamp date register"]
    pub mod tsdr {
        #[doc = "Reader of register TSDR"]
        pub type R = crate::R<u32, super::TSDR>;
        #[doc = "Reader of field `WDU`"]
        pub type WDU_R = crate::R<u8, u8>;
        #[doc = "Reader of field `MT`"]
        pub type MT_R = crate::R<bool, bool>;
        #[doc = "Reader of field `MU`"]
        pub type MU_R = crate::R<u8, u8>;
        #[doc = "Reader of field `DT`"]
        pub type DT_R = crate::R<u8, u8>;
        #[doc = "Reader of field `DU`"]
        pub type DU_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 13:15 - Week day units"]
            #[inline(always)]
            pub fn wdu(&self) -> WDU_R {
                WDU_R::new(((self.bits >> 13) & 0x07) as u8)
            }
            #[doc = "Bit 12 - Month tens in BCD format"]
            #[inline(always)]
            pub fn mt(&self) -> MT_R {
                MT_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bits 8:11 - Month units in BCD format"]
            #[inline(always)]
            pub fn mu(&self) -> MU_R {
                MU_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:5 - Date tens in BCD format"]
            #[inline(always)]
            pub fn dt(&self) -> DT_R {
                DT_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bits 0:3 - Date units in BCD format"]
            #[inline(always)]
            pub fn du(&self) -> DU_R {
                DU_R::new((self.bits & 0x0f) as u8)
            }
        }
    }
    #[doc = "RTC time-stamp sub second register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tsssr](tsssr) module"]
    pub type TSSSR = crate::Reg<u32, _TSSSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TSSSR;
    #[doc = "`read()` method returns [tsssr::R](tsssr::R) reader structure"]
    impl crate::Readable for TSSSR {}
    #[doc = "RTC time-stamp sub second register"]
    pub mod tsssr {
        #[doc = "Reader of register TSSSR"]
        pub type R = crate::R<u32, super::TSSSR>;
        #[doc = "Reader of field `SS`"]
        pub type SS_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Sub second value"]
            #[inline(always)]
            pub fn ss(&self) -> SS_R {
                SS_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "RTC calibration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calr](calr) module"]
    pub type CALR = crate::Reg<u32, _CALR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CALR;
    #[doc = "`read()` method returns [calr::R](calr::R) reader structure"]
    impl crate::Readable for CALR {}
    #[doc = "`write(|w| ..)` method takes [calr::W](calr::W) writer structure"]
    impl crate::Writable for CALR {}
    #[doc = "RTC calibration register"]
    pub mod calr {
        #[doc = "Reader of register CALR"]
        pub type R = crate::R<u32, super::CALR>;
        #[doc = "Writer for register CALR"]
        pub type W = crate::W<u32, super::CALR>;
        #[doc = "Register CALR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CALR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Increase frequency of RTC by 488.5 ppm\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CALP_A {
            #[doc = "0: No RTCCLK pulses are added"]
            NOCHANGE = 0,
            #[doc = "1: One RTCCLK pulse is effectively inserted every 2^11 pulses (frequency increased by 488.5 ppm)"]
            INCREASEFREQ = 1,
        }
        impl From<CALP_A> for bool {
            #[inline(always)]
            fn from(variant: CALP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CALP`"]
        pub type CALP_R = crate::R<bool, CALP_A>;
        impl CALP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CALP_A {
                match self.bits {
                    false => CALP_A::NOCHANGE,
                    true => CALP_A::INCREASEFREQ,
                }
            }
            #[doc = "Checks if the value of the field is `NOCHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == CALP_A::NOCHANGE
            }
            #[doc = "Checks if the value of the field is `INCREASEFREQ`"]
            #[inline(always)]
            pub fn is_increase_freq(&self) -> bool {
                *self == CALP_A::INCREASEFREQ
            }
        }
        #[doc = "Write proxy for field `CALP`"]
        pub struct CALP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CALP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No RTCCLK pulses are added"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(CALP_A::NOCHANGE)
            }
            #[doc = "One RTCCLK pulse is effectively inserted every 2^11 pulses (frequency increased by 488.5 ppm)"]
            #[inline(always)]
            pub fn increase_freq(self) -> &'a mut W {
                self.variant(CALP_A::INCREASEFREQ)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Use an 8-second calibration cycle period\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CALW8_A {
            #[doc = "1: When CALW8 is set to 1, the 8-second calibration cycle period is selected"]
            EIGHT_SECOND = 1,
        }
        impl From<CALW8_A> for bool {
            #[inline(always)]
            fn from(variant: CALW8_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CALW8`"]
        pub type CALW8_R = crate::R<bool, CALW8_A>;
        impl CALW8_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CALW8_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CALW8_A::EIGHT_SECOND),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `EIGHT_SECOND`"]
            #[inline(always)]
            pub fn is_eight_second(&self) -> bool {
                *self == CALW8_A::EIGHT_SECOND
            }
        }
        #[doc = "Write proxy for field `CALW8`"]
        pub struct CALW8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALW8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CALW8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "When CALW8 is set to 1, the 8-second calibration cycle period is selected"]
            #[inline(always)]
            pub fn eight_second(self) -> &'a mut W {
                self.variant(CALW8_A::EIGHT_SECOND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Use a 16-second calibration cycle period\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CALW16_A {
            #[doc = "1: When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1"]
            SIXTEEN_SECOND = 1,
        }
        impl From<CALW16_A> for bool {
            #[inline(always)]
            fn from(variant: CALW16_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CALW16`"]
        pub type CALW16_R = crate::R<bool, CALW16_A>;
        impl CALW16_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CALW16_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CALW16_A::SIXTEEN_SECOND),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SIXTEEN_SECOND`"]
            #[inline(always)]
            pub fn is_sixteen_second(&self) -> bool {
                *self == CALW16_A::SIXTEEN_SECOND
            }
        }
        #[doc = "Write proxy for field `CALW16`"]
        pub struct CALW16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALW16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CALW16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1"]
            #[inline(always)]
            pub fn sixteen_second(self) -> &'a mut W {
                self.variant(CALW16_A::SIXTEEN_SECOND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `CALM`"]
        pub type CALM_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CALM`"]
        pub struct CALM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | ((value as u32) & 0x01ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Increase frequency of RTC by 488.5 ppm"]
            #[inline(always)]
            pub fn calp(&self) -> CALP_R {
                CALP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Use an 8-second calibration cycle period"]
            #[inline(always)]
            pub fn calw8(&self) -> CALW8_R {
                CALW8_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Use a 16-second calibration cycle period"]
            #[inline(always)]
            pub fn calw16(&self) -> CALW16_R {
                CALW16_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bits 0:8 - Calibration minus"]
            #[inline(always)]
            pub fn calm(&self) -> CALM_R {
                CALM_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bit 15 - Increase frequency of RTC by 488.5 ppm"]
            #[inline(always)]
            pub fn calp(&mut self) -> CALP_W {
                CALP_W { w: self }
            }
            #[doc = "Bit 14 - Use an 8-second calibration cycle period"]
            #[inline(always)]
            pub fn calw8(&mut self) -> CALW8_W {
                CALW8_W { w: self }
            }
            #[doc = "Bit 13 - Use a 16-second calibration cycle period"]
            #[inline(always)]
            pub fn calw16(&mut self) -> CALW16_W {
                CALW16_W { w: self }
            }
            #[doc = "Bits 0:8 - Calibration minus"]
            #[inline(always)]
            pub fn calm(&mut self) -> CALM_W {
                CALM_W { w: self }
            }
        }
    }
    #[doc = "RTC tamper configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tampcr](tampcr) module"]
    pub type TAMPCR = crate::Reg<u32, _TAMPCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAMPCR;
    #[doc = "`read()` method returns [tampcr::R](tampcr::R) reader structure"]
    impl crate::Readable for TAMPCR {}
    #[doc = "`write(|w| ..)` method takes [tampcr::W](tampcr::W) writer structure"]
    impl crate::Writable for TAMPCR {}
    #[doc = "RTC tamper configuration register"]
    pub mod tampcr {
        #[doc = "Reader of register TAMPCR"]
        pub type R = crate::R<u32, super::TAMPCR>;
        #[doc = "Writer for register TAMPCR"]
        pub type W = crate::W<u32, super::TAMPCR>;
        #[doc = "Register TAMPCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAMPCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Tamper 2 mask flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2MF_A {
            #[doc = "0: Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection"]
            NOTMASKED = 0,
            #[doc = "1: Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased."]
            MASKED = 1,
        }
        impl From<TAMP2MF_A> for bool {
            #[inline(always)]
            fn from(variant: TAMP2MF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMP2MF`"]
        pub type TAMP2MF_R = crate::R<bool, TAMP2MF_A>;
        impl TAMP2MF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMP2MF_A {
                match self.bits {
                    false => TAMP2MF_A::NOTMASKED,
                    true => TAMP2MF_A::MASKED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == TAMP2MF_A::NOTMASKED
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == TAMP2MF_A::MASKED
            }
        }
        #[doc = "Write proxy for field `TAMP2MF`"]
        pub struct TAMP2MF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP2MF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP2MF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(TAMP2MF_A::NOTMASKED)
            }
            #[doc = "Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased."]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(TAMP2MF_A::MASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Tamper 2 no erase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2NOERASE_A {
            #[doc = "0: Tamper x event erases the backup registers"]
            ERASE = 0,
            #[doc = "1: Tamper x event does not erase the backup registers"]
            NOERASE = 1,
        }
        impl From<TAMP2NOERASE_A> for bool {
            #[inline(always)]
            fn from(variant: TAMP2NOERASE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMP2NOERASE`"]
        pub type TAMP2NOERASE_R = crate::R<bool, TAMP2NOERASE_A>;
        impl TAMP2NOERASE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMP2NOERASE_A {
                match self.bits {
                    false => TAMP2NOERASE_A::ERASE,
                    true => TAMP2NOERASE_A::NOERASE,
                }
            }
            #[doc = "Checks if the value of the field is `ERASE`"]
            #[inline(always)]
            pub fn is_erase(&self) -> bool {
                *self == TAMP2NOERASE_A::ERASE
            }
            #[doc = "Checks if the value of the field is `NOERASE`"]
            #[inline(always)]
            pub fn is_no_erase(&self) -> bool {
                *self == TAMP2NOERASE_A::NOERASE
            }
        }
        #[doc = "Write proxy for field `TAMP2NOERASE`"]
        pub struct TAMP2NOERASE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP2NOERASE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP2NOERASE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x event erases the backup registers"]
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(TAMP2NOERASE_A::ERASE)
            }
            #[doc = "Tamper x event does not erase the backup registers"]
            #[inline(always)]
            pub fn no_erase(self) -> &'a mut W {
                self.variant(TAMP2NOERASE_A::NOERASE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Tamper 2 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2IE_A {
            #[doc = "0: Tamper x interrupt is disabled if TAMPIE = 0"]
            DISABLED = 0,
            #[doc = "1: Tamper x interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TAMP2IE_A> for bool {
            #[inline(always)]
            fn from(variant: TAMP2IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMP2IE`"]
        pub type TAMP2IE_R = crate::R<bool, TAMP2IE_A>;
        impl TAMP2IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMP2IE_A {
                match self.bits {
                    false => TAMP2IE_A::DISABLED,
                    true => TAMP2IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TAMP2IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TAMP2IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TAMP2IE`"]
        pub struct TAMP2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP2IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP2IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x interrupt is disabled if TAMPIE = 0"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMP2IE_A::DISABLED)
            }
            #[doc = "Tamper x interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMP2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Tamper 1 mask flag"]
        pub type TAMP1MF_A = TAMP2MF_A;
        #[doc = "Reader of field `TAMP1MF`"]
        pub type TAMP1MF_R = crate::R<bool, TAMP2MF_A>;
        #[doc = "Write proxy for field `TAMP1MF`"]
        pub struct TAMP1MF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP1MF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP1MF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(TAMP2MF_A::NOTMASKED)
            }
            #[doc = "Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased."]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(TAMP2MF_A::MASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Tamper 1 no erase"]
        pub type TAMP1NOERASE_A = TAMP2NOERASE_A;
        #[doc = "Reader of field `TAMP1NOERASE`"]
        pub type TAMP1NOERASE_R = crate::R<bool, TAMP2NOERASE_A>;
        #[doc = "Write proxy for field `TAMP1NOERASE`"]
        pub struct TAMP1NOERASE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP1NOERASE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP1NOERASE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x event erases the backup registers"]
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(TAMP2NOERASE_A::ERASE)
            }
            #[doc = "Tamper x event does not erase the backup registers"]
            #[inline(always)]
            pub fn no_erase(self) -> &'a mut W {
                self.variant(TAMP2NOERASE_A::NOERASE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Tamper 1 interrupt enable"]
        pub type TAMP1IE_A = TAMP2IE_A;
        #[doc = "Reader of field `TAMP1IE`"]
        pub type TAMP1IE_R = crate::R<bool, TAMP2IE_A>;
        #[doc = "Write proxy for field `TAMP1IE`"]
        pub struct TAMP1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x interrupt is disabled if TAMPIE = 0"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMP2IE_A::DISABLED)
            }
            #[doc = "Tamper x interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMP2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "RTC_TAMPx pull-up disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMPPUDIS_A {
            #[doc = "0: Precharge RTC_TAMPx pins before sampling (enable internal pull-up)"]
            ENABLED = 0,
            #[doc = "1: Disable precharge of RTC_TAMPx pins"]
            DISABLED = 1,
        }
        impl From<TAMPPUDIS_A> for bool {
            #[inline(always)]
            fn from(variant: TAMPPUDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMPPUDIS`"]
        pub type TAMPPUDIS_R = crate::R<bool, TAMPPUDIS_A>;
        impl TAMPPUDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMPPUDIS_A {
                match self.bits {
                    false => TAMPPUDIS_A::ENABLED,
                    true => TAMPPUDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TAMPPUDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TAMPPUDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `TAMPPUDIS`"]
        pub struct TAMPPUDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMPPUDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMPPUDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Precharge RTC_TAMPx pins before sampling (enable internal pull-up)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMPPUDIS_A::ENABLED)
            }
            #[doc = "Disable precharge of RTC_TAMPx pins"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMPPUDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "RTC_TAMPx precharge duration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TAMPPRCH_A {
            #[doc = "0: 1 RTCCLK cycle"]
            CYCLES1 = 0,
            #[doc = "1: 2 RTCCLK cycles"]
            CYCLES2 = 1,
            #[doc = "2: 4 RTCCLK cycles"]
            CYCLES4 = 2,
            #[doc = "3: 8 RTCCLK cycles"]
            CYCLES8 = 3,
        }
        impl From<TAMPPRCH_A> for u8 {
            #[inline(always)]
            fn from(variant: TAMPPRCH_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TAMPPRCH`"]
        pub type TAMPPRCH_R = crate::R<u8, TAMPPRCH_A>;
        impl TAMPPRCH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMPPRCH_A {
                match self.bits {
                    0 => TAMPPRCH_A::CYCLES1,
                    1 => TAMPPRCH_A::CYCLES2,
                    2 => TAMPPRCH_A::CYCLES4,
                    3 => TAMPPRCH_A::CYCLES8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CYCLES1`"]
            #[inline(always)]
            pub fn is_cycles1(&self) -> bool {
                *self == TAMPPRCH_A::CYCLES1
            }
            #[doc = "Checks if the value of the field is `CYCLES2`"]
            #[inline(always)]
            pub fn is_cycles2(&self) -> bool {
                *self == TAMPPRCH_A::CYCLES2
            }
            #[doc = "Checks if the value of the field is `CYCLES4`"]
            #[inline(always)]
            pub fn is_cycles4(&self) -> bool {
                *self == TAMPPRCH_A::CYCLES4
            }
            #[doc = "Checks if the value of the field is `CYCLES8`"]
            #[inline(always)]
            pub fn is_cycles8(&self) -> bool {
                *self == TAMPPRCH_A::CYCLES8
            }
        }
        #[doc = "Write proxy for field `TAMPPRCH`"]
        pub struct TAMPPRCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMPPRCH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMPPRCH_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1 RTCCLK cycle"]
            #[inline(always)]
            pub fn cycles1(self) -> &'a mut W {
                self.variant(TAMPPRCH_A::CYCLES1)
            }
            #[doc = "2 RTCCLK cycles"]
            #[inline(always)]
            pub fn cycles2(self) -> &'a mut W {
                self.variant(TAMPPRCH_A::CYCLES2)
            }
            #[doc = "4 RTCCLK cycles"]
            #[inline(always)]
            pub fn cycles4(self) -> &'a mut W {
                self.variant(TAMPPRCH_A::CYCLES4)
            }
            #[doc = "8 RTCCLK cycles"]
            #[inline(always)]
            pub fn cycles8(self) -> &'a mut W {
                self.variant(TAMPPRCH_A::CYCLES8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 13)) | (((value as u32) & 0x03) << 13);
                self.w
            }
        }
        #[doc = "RTC_TAMPx filter count\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TAMPFLT_A {
            #[doc = "0: Tamper event is activated on edge of RTC_TAMPx input transitions to the active level (no internal pull-up on RTC_TAMPx input)"]
            IMMEDIATE = 0,
            #[doc = "1: Tamper event is activated after 2 consecutive samples at the active level"]
            SAMPLES2 = 1,
            #[doc = "2: Tamper event is activated after 4 consecutive samples at the active level"]
            SAMPLES4 = 2,
            #[doc = "3: Tamper event is activated after 8 consecutive samples at the active level"]
            SAMPLES8 = 3,
        }
        impl From<TAMPFLT_A> for u8 {
            #[inline(always)]
            fn from(variant: TAMPFLT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TAMPFLT`"]
        pub type TAMPFLT_R = crate::R<u8, TAMPFLT_A>;
        impl TAMPFLT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMPFLT_A {
                match self.bits {
                    0 => TAMPFLT_A::IMMEDIATE,
                    1 => TAMPFLT_A::SAMPLES2,
                    2 => TAMPFLT_A::SAMPLES4,
                    3 => TAMPFLT_A::SAMPLES8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IMMEDIATE`"]
            #[inline(always)]
            pub fn is_immediate(&self) -> bool {
                *self == TAMPFLT_A::IMMEDIATE
            }
            #[doc = "Checks if the value of the field is `SAMPLES2`"]
            #[inline(always)]
            pub fn is_samples2(&self) -> bool {
                *self == TAMPFLT_A::SAMPLES2
            }
            #[doc = "Checks if the value of the field is `SAMPLES4`"]
            #[inline(always)]
            pub fn is_samples4(&self) -> bool {
                *self == TAMPFLT_A::SAMPLES4
            }
            #[doc = "Checks if the value of the field is `SAMPLES8`"]
            #[inline(always)]
            pub fn is_samples8(&self) -> bool {
                *self == TAMPFLT_A::SAMPLES8
            }
        }
        #[doc = "Write proxy for field `TAMPFLT`"]
        pub struct TAMPFLT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMPFLT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMPFLT_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Tamper event is activated on edge of RTC_TAMPx input transitions to the active level (no internal pull-up on RTC_TAMPx input)"]
            #[inline(always)]
            pub fn immediate(self) -> &'a mut W {
                self.variant(TAMPFLT_A::IMMEDIATE)
            }
            #[doc = "Tamper event is activated after 2 consecutive samples at the active level"]
            #[inline(always)]
            pub fn samples2(self) -> &'a mut W {
                self.variant(TAMPFLT_A::SAMPLES2)
            }
            #[doc = "Tamper event is activated after 4 consecutive samples at the active level"]
            #[inline(always)]
            pub fn samples4(self) -> &'a mut W {
                self.variant(TAMPFLT_A::SAMPLES4)
            }
            #[doc = "Tamper event is activated after 8 consecutive samples at the active level"]
            #[inline(always)]
            pub fn samples8(self) -> &'a mut W {
                self.variant(TAMPFLT_A::SAMPLES8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 11)) | (((value as u32) & 0x03) << 11);
                self.w
            }
        }
        #[doc = "Tamper sampling frequency\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TAMPFREQ_A {
            #[doc = "0: RTCCLK / 32768 (1 Hz when RTCCLK = 32768 Hz)"]
            DIV32768 = 0,
            #[doc = "1: RTCCLK / 16384 (2 Hz when RTCCLK = 32768 Hz)"]
            DIV16384 = 1,
            #[doc = "2: RTCCLK / 8192 (4 Hz when RTCCLK = 32768 Hz)"]
            DIV8192 = 2,
            #[doc = "3: RTCCLK / 4096 (8 Hz when RTCCLK = 32768 Hz)"]
            DIV4096 = 3,
            #[doc = "4: RTCCLK / 2048 (16 Hz when RTCCLK = 32768 Hz)"]
            DIV2048 = 4,
            #[doc = "5: RTCCLK / 1024 (32 Hz when RTCCLK = 32768 Hz)"]
            DIV1024 = 5,
            #[doc = "6: RTCCLK / 512 (64 Hz when RTCCLK = 32768 Hz)"]
            DIV512 = 6,
            #[doc = "7: RTCCLK / 256 (128 Hz when RTCCLK = 32768 Hz)"]
            DIV256 = 7,
        }
        impl From<TAMPFREQ_A> for u8 {
            #[inline(always)]
            fn from(variant: TAMPFREQ_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TAMPFREQ`"]
        pub type TAMPFREQ_R = crate::R<u8, TAMPFREQ_A>;
        impl TAMPFREQ_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMPFREQ_A {
                match self.bits {
                    0 => TAMPFREQ_A::DIV32768,
                    1 => TAMPFREQ_A::DIV16384,
                    2 => TAMPFREQ_A::DIV8192,
                    3 => TAMPFREQ_A::DIV4096,
                    4 => TAMPFREQ_A::DIV2048,
                    5 => TAMPFREQ_A::DIV1024,
                    6 => TAMPFREQ_A::DIV512,
                    7 => TAMPFREQ_A::DIV256,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV32768`"]
            #[inline(always)]
            pub fn is_div32768(&self) -> bool {
                *self == TAMPFREQ_A::DIV32768
            }
            #[doc = "Checks if the value of the field is `DIV16384`"]
            #[inline(always)]
            pub fn is_div16384(&self) -> bool {
                *self == TAMPFREQ_A::DIV16384
            }
            #[doc = "Checks if the value of the field is `DIV8192`"]
            #[inline(always)]
            pub fn is_div8192(&self) -> bool {
                *self == TAMPFREQ_A::DIV8192
            }
            #[doc = "Checks if the value of the field is `DIV4096`"]
            #[inline(always)]
            pub fn is_div4096(&self) -> bool {
                *self == TAMPFREQ_A::DIV4096
            }
            #[doc = "Checks if the value of the field is `DIV2048`"]
            #[inline(always)]
            pub fn is_div2048(&self) -> bool {
                *self == TAMPFREQ_A::DIV2048
            }
            #[doc = "Checks if the value of the field is `DIV1024`"]
            #[inline(always)]
            pub fn is_div1024(&self) -> bool {
                *self == TAMPFREQ_A::DIV1024
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                *self == TAMPFREQ_A::DIV512
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == TAMPFREQ_A::DIV256
            }
        }
        #[doc = "Write proxy for field `TAMPFREQ`"]
        pub struct TAMPFREQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMPFREQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMPFREQ_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "RTCCLK / 32768 (1 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div32768(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV32768)
            }
            #[doc = "RTCCLK / 16384 (2 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div16384(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV16384)
            }
            #[doc = "RTCCLK / 8192 (4 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div8192(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV8192)
            }
            #[doc = "RTCCLK / 4096 (8 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div4096(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV4096)
            }
            #[doc = "RTCCLK / 2048 (16 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div2048(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV2048)
            }
            #[doc = "RTCCLK / 1024 (32 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div1024(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV1024)
            }
            #[doc = "RTCCLK / 512 (64 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV512)
            }
            #[doc = "RTCCLK / 256 (128 Hz when RTCCLK = 32768 Hz)"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(TAMPFREQ_A::DIV256)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 8)) | (((value as u32) & 0x07) << 8);
                self.w
            }
        }
        #[doc = "Activate timestamp on tamper detection event\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMPTS_A {
            #[doc = "0: Tamper detection event does not cause a timestamp to be saved"]
            NOSAVE = 0,
            #[doc = "1: Save timestamp on tamper detection event"]
            SAVE = 1,
        }
        impl From<TAMPTS_A> for bool {
            #[inline(always)]
            fn from(variant: TAMPTS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMPTS`"]
        pub type TAMPTS_R = crate::R<bool, TAMPTS_A>;
        impl TAMPTS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMPTS_A {
                match self.bits {
                    false => TAMPTS_A::NOSAVE,
                    true => TAMPTS_A::SAVE,
                }
            }
            #[doc = "Checks if the value of the field is `NOSAVE`"]
            #[inline(always)]
            pub fn is_no_save(&self) -> bool {
                *self == TAMPTS_A::NOSAVE
            }
            #[doc = "Checks if the value of the field is `SAVE`"]
            #[inline(always)]
            pub fn is_save(&self) -> bool {
                *self == TAMPTS_A::SAVE
            }
        }
        #[doc = "Write proxy for field `TAMPTS`"]
        pub struct TAMPTS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMPTS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMPTS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper detection event does not cause a timestamp to be saved"]
            #[inline(always)]
            pub fn no_save(self) -> &'a mut W {
                self.variant(TAMPTS_A::NOSAVE)
            }
            #[doc = "Save timestamp on tamper detection event"]
            #[inline(always)]
            pub fn save(self) -> &'a mut W {
                self.variant(TAMPTS_A::SAVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Active level for RTC_TAMP2 input\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2TRG_A {
            #[doc = "0: If TAMPFLT = 00: RTC_TAMPx input rising edge triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input staying low triggers a tamper detection event."]
            RISINGEDGE = 0,
            #[doc = "1: If TAMPFLT = 00: RTC_TAMPx input staying high triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input falling edge triggers a tamper detection event"]
            FALLINGEDGE = 1,
        }
        impl From<TAMP2TRG_A> for bool {
            #[inline(always)]
            fn from(variant: TAMP2TRG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMP2TRG`"]
        pub type TAMP2TRG_R = crate::R<bool, TAMP2TRG_A>;
        impl TAMP2TRG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMP2TRG_A {
                match self.bits {
                    false => TAMP2TRG_A::RISINGEDGE,
                    true => TAMP2TRG_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == TAMP2TRG_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == TAMP2TRG_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `TAMP2TRG`"]
        pub struct TAMP2TRG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP2TRG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP2TRG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If TAMPFLT = 00: RTC_TAMPx input rising edge triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input staying low triggers a tamper detection event."]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(TAMP2TRG_A::RISINGEDGE)
            }
            #[doc = "If TAMPFLT = 00: RTC_TAMPx input staying high triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input falling edge triggers a tamper detection event"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(TAMP2TRG_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "RTC_TAMP2 input detection enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMP2E_A {
            #[doc = "0: RTC_TAMPx input detection disabled"]
            DISABLED = 0,
            #[doc = "1: RTC_TAMPx input detection enabled"]
            ENABLED = 1,
        }
        impl From<TAMP2E_A> for bool {
            #[inline(always)]
            fn from(variant: TAMP2E_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMP2E`"]
        pub type TAMP2E_R = crate::R<bool, TAMP2E_A>;
        impl TAMP2E_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMP2E_A {
                match self.bits {
                    false => TAMP2E_A::DISABLED,
                    true => TAMP2E_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TAMP2E_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TAMP2E_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TAMP2E`"]
        pub struct TAMP2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP2E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP2E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC_TAMPx input detection disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMP2E_A::DISABLED)
            }
            #[doc = "RTC_TAMPx input detection enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMP2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Tamper interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAMPIE_A {
            #[doc = "0: Tamper interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Tamper interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TAMPIE_A> for bool {
            #[inline(always)]
            fn from(variant: TAMPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TAMPIE`"]
        pub type TAMPIE_R = crate::R<bool, TAMPIE_A>;
        impl TAMPIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TAMPIE_A {
                match self.bits {
                    false => TAMPIE_A::DISABLED,
                    true => TAMPIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TAMPIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TAMPIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TAMPIE`"]
        pub struct TAMPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMPIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMPIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMPIE_A::DISABLED)
            }
            #[doc = "Tamper interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMPIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Active level for RTC_TAMP1 input"]
        pub type TAMP1TRG_A = TAMP2TRG_A;
        #[doc = "Reader of field `TAMP1TRG`"]
        pub type TAMP1TRG_R = crate::R<bool, TAMP2TRG_A>;
        #[doc = "Write proxy for field `TAMP1TRG`"]
        pub struct TAMP1TRG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP1TRG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP1TRG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If TAMPFLT = 00: RTC_TAMPx input rising edge triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input staying low triggers a tamper detection event."]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(TAMP2TRG_A::RISINGEDGE)
            }
            #[doc = "If TAMPFLT = 00: RTC_TAMPx input staying high triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input falling edge triggers a tamper detection event"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(TAMP2TRG_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "RTC_TAMP1 input detection enable"]
        pub type TAMP1E_A = TAMP2E_A;
        #[doc = "Reader of field `TAMP1E`"]
        pub type TAMP1E_R = crate::R<bool, TAMP2E_A>;
        #[doc = "Write proxy for field `TAMP1E`"]
        pub struct TAMP1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP1E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP1E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC_TAMPx input detection disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMP2E_A::DISABLED)
            }
            #[doc = "RTC_TAMPx input detection enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMP2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Tamper 3 mask flag"]
        pub type TAMP3MF_A = TAMP2MF_A;
        #[doc = "Reader of field `TAMP3MF`"]
        pub type TAMP3MF_R = crate::R<bool, TAMP2MF_A>;
        #[doc = "Write proxy for field `TAMP3MF`"]
        pub struct TAMP3MF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP3MF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP3MF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x event generates a trigger event and TAMPxF must be cleared by software to allow next tamper event detection"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(TAMP2MF_A::NOTMASKED)
            }
            #[doc = "Tamper x event generates a trigger event. TAMPxF is masked and internally cleared by hardware. The backup registers are not erased."]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(TAMP2MF_A::MASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Tamper 3 no erase"]
        pub type TAMP3NOERASE_A = TAMP2NOERASE_A;
        #[doc = "Reader of field `TAMP3NOERASE`"]
        pub type TAMP3NOERASE_R = crate::R<bool, TAMP2NOERASE_A>;
        #[doc = "Write proxy for field `TAMP3NOERASE`"]
        pub struct TAMP3NOERASE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP3NOERASE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP3NOERASE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x event erases the backup registers"]
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(TAMP2NOERASE_A::ERASE)
            }
            #[doc = "Tamper x event does not erase the backup registers"]
            #[inline(always)]
            pub fn no_erase(self) -> &'a mut W {
                self.variant(TAMP2NOERASE_A::NOERASE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Tamper 3 interrupt enable"]
        pub type TAMP3IE_A = TAMP2IE_A;
        #[doc = "Reader of field `TAMP3IE`"]
        pub type TAMP3IE_R = crate::R<bool, TAMP2IE_A>;
        #[doc = "Write proxy for field `TAMP3IE`"]
        pub struct TAMP3IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP3IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP3IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tamper x interrupt is disabled if TAMPIE = 0"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMP2IE_A::DISABLED)
            }
            #[doc = "Tamper x interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMP2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Active level for RTC_TAMP3 input"]
        pub type TAMP3TRG_A = TAMP2TRG_A;
        #[doc = "Reader of field `TAMP3TRG`"]
        pub type TAMP3TRG_R = crate::R<bool, TAMP2TRG_A>;
        #[doc = "Write proxy for field `TAMP3TRG`"]
        pub struct TAMP3TRG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP3TRG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP3TRG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If TAMPFLT = 00: RTC_TAMPx input rising edge triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input staying low triggers a tamper detection event."]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(TAMP2TRG_A::RISINGEDGE)
            }
            #[doc = "If TAMPFLT = 00: RTC_TAMPx input staying high triggers a tamper detection event. If TAMPFLT =\u{338} 00: RTC_TAMPx input falling edge triggers a tamper detection event"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(TAMP2TRG_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "RTC_TAMP3 detection enable"]
        pub type TAMP3E_A = TAMP2E_A;
        #[doc = "Reader of field `TAMP3E`"]
        pub type TAMP3E_R = crate::R<bool, TAMP2E_A>;
        #[doc = "Write proxy for field `TAMP3E`"]
        pub struct TAMP3E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAMP3E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAMP3E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC_TAMPx input detection disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TAMP2E_A::DISABLED)
            }
            #[doc = "RTC_TAMPx input detection enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TAMP2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 21 - Tamper 2 mask flag"]
            #[inline(always)]
            pub fn tamp2mf(&self) -> TAMP2MF_R {
                TAMP2MF_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Tamper 2 no erase"]
            #[inline(always)]
            pub fn tamp2noerase(&self) -> TAMP2NOERASE_R {
                TAMP2NOERASE_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Tamper 2 interrupt enable"]
            #[inline(always)]
            pub fn tamp2ie(&self) -> TAMP2IE_R {
                TAMP2IE_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Tamper 1 mask flag"]
            #[inline(always)]
            pub fn tamp1mf(&self) -> TAMP1MF_R {
                TAMP1MF_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Tamper 1 no erase"]
            #[inline(always)]
            pub fn tamp1noerase(&self) -> TAMP1NOERASE_R {
                TAMP1NOERASE_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Tamper 1 interrupt enable"]
            #[inline(always)]
            pub fn tamp1ie(&self) -> TAMP1IE_R {
                TAMP1IE_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - RTC_TAMPx pull-up disable"]
            #[inline(always)]
            pub fn tamppudis(&self) -> TAMPPUDIS_R {
                TAMPPUDIS_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 13:14 - RTC_TAMPx precharge duration"]
            #[inline(always)]
            pub fn tampprch(&self) -> TAMPPRCH_R {
                TAMPPRCH_R::new(((self.bits >> 13) & 0x03) as u8)
            }
            #[doc = "Bits 11:12 - RTC_TAMPx filter count"]
            #[inline(always)]
            pub fn tampflt(&self) -> TAMPFLT_R {
                TAMPFLT_R::new(((self.bits >> 11) & 0x03) as u8)
            }
            #[doc = "Bits 8:10 - Tamper sampling frequency"]
            #[inline(always)]
            pub fn tampfreq(&self) -> TAMPFREQ_R {
                TAMPFREQ_R::new(((self.bits >> 8) & 0x07) as u8)
            }
            #[doc = "Bit 7 - Activate timestamp on tamper detection event"]
            #[inline(always)]
            pub fn tampts(&self) -> TAMPTS_R {
                TAMPTS_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Active level for RTC_TAMP2 input"]
            #[inline(always)]
            pub fn tamp2trg(&self) -> TAMP2TRG_R {
                TAMP2TRG_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - RTC_TAMP2 input detection enable"]
            #[inline(always)]
            pub fn tamp2e(&self) -> TAMP2E_R {
                TAMP2E_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Tamper interrupt enable"]
            #[inline(always)]
            pub fn tampie(&self) -> TAMPIE_R {
                TAMPIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Active level for RTC_TAMP1 input"]
            #[inline(always)]
            pub fn tamp1trg(&self) -> TAMP1TRG_R {
                TAMP1TRG_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - RTC_TAMP1 input detection enable"]
            #[inline(always)]
            pub fn tamp1e(&self) -> TAMP1E_R {
                TAMP1E_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 24 - Tamper 3 mask flag"]
            #[inline(always)]
            pub fn tamp3mf(&self) -> TAMP3MF_R {
                TAMP3MF_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Tamper 3 no erase"]
            #[inline(always)]
            pub fn tamp3noerase(&self) -> TAMP3NOERASE_R {
                TAMP3NOERASE_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Tamper 3 interrupt enable"]
            #[inline(always)]
            pub fn tamp3ie(&self) -> TAMP3IE_R {
                TAMP3IE_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Active level for RTC_TAMP3 input"]
            #[inline(always)]
            pub fn tamp3trg(&self) -> TAMP3TRG_R {
                TAMP3TRG_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RTC_TAMP3 detection enable"]
            #[inline(always)]
            pub fn tamp3e(&self) -> TAMP3E_R {
                TAMP3E_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 21 - Tamper 2 mask flag"]
            #[inline(always)]
            pub fn tamp2mf(&mut self) -> TAMP2MF_W {
                TAMP2MF_W { w: self }
            }
            #[doc = "Bit 20 - Tamper 2 no erase"]
            #[inline(always)]
            pub fn tamp2noerase(&mut self) -> TAMP2NOERASE_W {
                TAMP2NOERASE_W { w: self }
            }
            #[doc = "Bit 19 - Tamper 2 interrupt enable"]
            #[inline(always)]
            pub fn tamp2ie(&mut self) -> TAMP2IE_W {
                TAMP2IE_W { w: self }
            }
            #[doc = "Bit 18 - Tamper 1 mask flag"]
            #[inline(always)]
            pub fn tamp1mf(&mut self) -> TAMP1MF_W {
                TAMP1MF_W { w: self }
            }
            #[doc = "Bit 17 - Tamper 1 no erase"]
            #[inline(always)]
            pub fn tamp1noerase(&mut self) -> TAMP1NOERASE_W {
                TAMP1NOERASE_W { w: self }
            }
            #[doc = "Bit 16 - Tamper 1 interrupt enable"]
            #[inline(always)]
            pub fn tamp1ie(&mut self) -> TAMP1IE_W {
                TAMP1IE_W { w: self }
            }
            #[doc = "Bit 15 - RTC_TAMPx pull-up disable"]
            #[inline(always)]
            pub fn tamppudis(&mut self) -> TAMPPUDIS_W {
                TAMPPUDIS_W { w: self }
            }
            #[doc = "Bits 13:14 - RTC_TAMPx precharge duration"]
            #[inline(always)]
            pub fn tampprch(&mut self) -> TAMPPRCH_W {
                TAMPPRCH_W { w: self }
            }
            #[doc = "Bits 11:12 - RTC_TAMPx filter count"]
            #[inline(always)]
            pub fn tampflt(&mut self) -> TAMPFLT_W {
                TAMPFLT_W { w: self }
            }
            #[doc = "Bits 8:10 - Tamper sampling frequency"]
            #[inline(always)]
            pub fn tampfreq(&mut self) -> TAMPFREQ_W {
                TAMPFREQ_W { w: self }
            }
            #[doc = "Bit 7 - Activate timestamp on tamper detection event"]
            #[inline(always)]
            pub fn tampts(&mut self) -> TAMPTS_W {
                TAMPTS_W { w: self }
            }
            #[doc = "Bit 4 - Active level for RTC_TAMP2 input"]
            #[inline(always)]
            pub fn tamp2trg(&mut self) -> TAMP2TRG_W {
                TAMP2TRG_W { w: self }
            }
            #[doc = "Bit 3 - RTC_TAMP2 input detection enable"]
            #[inline(always)]
            pub fn tamp2e(&mut self) -> TAMP2E_W {
                TAMP2E_W { w: self }
            }
            #[doc = "Bit 2 - Tamper interrupt enable"]
            #[inline(always)]
            pub fn tampie(&mut self) -> TAMPIE_W {
                TAMPIE_W { w: self }
            }
            #[doc = "Bit 1 - Active level for RTC_TAMP1 input"]
            #[inline(always)]
            pub fn tamp1trg(&mut self) -> TAMP1TRG_W {
                TAMP1TRG_W { w: self }
            }
            #[doc = "Bit 0 - RTC_TAMP1 input detection enable"]
            #[inline(always)]
            pub fn tamp1e(&mut self) -> TAMP1E_W {
                TAMP1E_W { w: self }
            }
            #[doc = "Bit 24 - Tamper 3 mask flag"]
            #[inline(always)]
            pub fn tamp3mf(&mut self) -> TAMP3MF_W {
                TAMP3MF_W { w: self }
            }
            #[doc = "Bit 23 - Tamper 3 no erase"]
            #[inline(always)]
            pub fn tamp3noerase(&mut self) -> TAMP3NOERASE_W {
                TAMP3NOERASE_W { w: self }
            }
            #[doc = "Bit 22 - Tamper 3 interrupt enable"]
            #[inline(always)]
            pub fn tamp3ie(&mut self) -> TAMP3IE_W {
                TAMP3IE_W { w: self }
            }
            #[doc = "Bit 6 - Active level for RTC_TAMP3 input"]
            #[inline(always)]
            pub fn tamp3trg(&mut self) -> TAMP3TRG_W {
                TAMP3TRG_W { w: self }
            }
            #[doc = "Bit 5 - RTC_TAMP3 detection enable"]
            #[inline(always)]
            pub fn tamp3e(&mut self) -> TAMP3E_W {
                TAMP3E_W { w: self }
            }
        }
    }
    #[doc = "RTC alarm A sub second register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alrmassr](alrmassr) module"]
    pub type ALRMASSR = crate::Reg<u32, _ALRMASSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALRMASSR;
    #[doc = "`read()` method returns [alrmassr::R](alrmassr::R) reader structure"]
    impl crate::Readable for ALRMASSR {}
    #[doc = "`write(|w| ..)` method takes [alrmassr::W](alrmassr::W) writer structure"]
    impl crate::Writable for ALRMASSR {}
    #[doc = "RTC alarm A sub second register"]
    pub mod alrmassr {
        #[doc = "Reader of register ALRMASSR"]
        pub type R = crate::R<u32, super::ALRMASSR>;
        #[doc = "Writer for register ALRMASSR"]
        pub type W = crate::W<u32, super::ALRMASSR>;
        #[doc = "Register ALRMASSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ALRMASSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MASKSS`"]
        pub type MASKSS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MASKSS`"]
        pub struct MASKSS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MASKSS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `SS`"]
        pub type SS_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `SS`"]
        pub struct SS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7fff) | ((value as u32) & 0x7fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
            #[inline(always)]
            pub fn maskss(&self) -> MASKSS_R {
                MASKSS_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 0:14 - Sub seconds value"]
            #[inline(always)]
            pub fn ss(&self) -> SS_R {
                SS_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
            #[inline(always)]
            pub fn maskss(&mut self) -> MASKSS_W {
                MASKSS_W { w: self }
            }
            #[doc = "Bits 0:14 - Sub seconds value"]
            #[inline(always)]
            pub fn ss(&mut self) -> SS_W {
                SS_W { w: self }
            }
        }
    }
    #[doc = "RTC alarm B sub second register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alrmbssr](alrmbssr) module"]
    pub type ALRMBSSR = crate::Reg<u32, _ALRMBSSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALRMBSSR;
    #[doc = "`read()` method returns [alrmbssr::R](alrmbssr::R) reader structure"]
    impl crate::Readable for ALRMBSSR {}
    #[doc = "`write(|w| ..)` method takes [alrmbssr::W](alrmbssr::W) writer structure"]
    impl crate::Writable for ALRMBSSR {}
    #[doc = "RTC alarm B sub second register"]
    pub mod alrmbssr {
        #[doc = "Reader of register ALRMBSSR"]
        pub type R = crate::R<u32, super::ALRMBSSR>;
        #[doc = "Writer for register ALRMBSSR"]
        pub type W = crate::W<u32, super::ALRMBSSR>;
        #[doc = "Register ALRMBSSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ALRMBSSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `MASKSS`"]
        pub type MASKSS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MASKSS`"]
        pub struct MASKSS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MASKSS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | (((value as u32) & 0x0f) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `SS`"]
        pub type SS_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `SS`"]
        pub struct SS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7fff) | ((value as u32) & 0x7fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
            #[inline(always)]
            pub fn maskss(&self) -> MASKSS_R {
                MASKSS_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            #[doc = "Bits 0:14 - Sub seconds value"]
            #[inline(always)]
            pub fn ss(&self) -> SS_R {
                SS_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
            #[inline(always)]
            pub fn maskss(&mut self) -> MASKSS_W {
                MASKSS_W { w: self }
            }
            #[doc = "Bits 0:14 - Sub seconds value"]
            #[inline(always)]
            pub fn ss(&mut self) -> SS_W {
                SS_W { w: self }
            }
        }
    }
    #[doc = "option register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [or](or) module"]
    pub type OR = crate::Reg<u32, _OR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OR;
    #[doc = "`read()` method returns [or::R](or::R) reader structure"]
    impl crate::Readable for OR {}
    #[doc = "`write(|w| ..)` method takes [or::W](or::W) writer structure"]
    impl crate::Writable for OR {}
    #[doc = "option register"]
    pub mod or {
        #[doc = "Reader of register OR"]
        pub type R = crate::R<u32, super::OR>;
        #[doc = "Writer for register OR"]
        pub type W = crate::W<u32, super::OR>;
        #[doc = "Register OR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `RTC_OUT_RMP`"]
        pub type RTC_OUT_RMP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RTC_OUT_RMP`"]
        pub struct RTC_OUT_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTC_OUT_RMP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `RTC_ALARM_TYPE`"]
        pub type RTC_ALARM_TYPE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RTC_ALARM_TYPE`"]
        pub struct RTC_ALARM_TYPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTC_ALARM_TYPE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 1 - RTC_ALARM on PC13 output type"]
            #[inline(always)]
            pub fn rtc_out_rmp(&self) -> RTC_OUT_RMP_R {
                RTC_OUT_RMP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - RTC_ALARM on PC13 output type"]
            #[inline(always)]
            pub fn rtc_alarm_type(&self) -> RTC_ALARM_TYPE_R {
                RTC_ALARM_TYPE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - RTC_ALARM on PC13 output type"]
            #[inline(always)]
            pub fn rtc_out_rmp(&mut self) -> RTC_OUT_RMP_W {
                RTC_OUT_RMP_W { w: self }
            }
            #[doc = "Bit 0 - RTC_ALARM on PC13 output type"]
            #[inline(always)]
            pub fn rtc_alarm_type(&mut self) -> RTC_ALARM_TYPE_W {
                RTC_ALARM_TYPE_W { w: self }
            }
        }
    }
    #[doc = "RTC backup registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bkpr](bkpr) module"]
    pub type BKPR = crate::Reg<u32, _BKPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BKPR;
    #[doc = "`read()` method returns [bkpr::R](bkpr::R) reader structure"]
    impl crate::Readable for BKPR {}
    #[doc = "`write(|w| ..)` method takes [bkpr::W](bkpr::W) writer structure"]
    impl crate::Writable for BKPR {}
    #[doc = "RTC backup registers"]
    pub mod bkpr {
        #[doc = "Reader of register BKP%sR"]
        pub type R = crate::R<u32, super::BKPR>;
        #[doc = "Writer for register BKP%sR"]
        pub type W = crate::W<u32, super::BKPR>;
        #[doc = "Register BKP%sR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BKPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `BKP`"]
        pub type BKP_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `BKP`"]
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - BKP"]
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - BKP"]
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
        }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4001_3800 as *const _
    }
}
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART1::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub mod usart1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - Control register 3"]
        pub cr3: CR3,
        #[doc = "0x0c - Baud rate register"]
        pub brr: BRR,
        #[doc = "0x10 - Guard time and prescaler register"]
        pub gtpr: GTPR,
        #[doc = "0x14 - Receiver timeout register"]
        pub rtor: RTOR,
        #[doc = "0x18 - Request register"]
        pub rqr: RQR,
        #[doc = "0x1c - Interrupt & status register"]
        pub isr: ISR,
        #[doc = "0x20 - Interrupt flag clear register"]
        pub icr: ICR,
        #[doc = "0x24 - Receive data register"]
        pub rdr: RDR,
        #[doc = "0x28 - Transmit data register"]
        pub tdr: TDR,
    }
    #[doc = "Control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Word length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M1_A {
            #[doc = "0: Use M0 to set the data bits"]
            M0 = 0,
            #[doc = "1: 1 start bit, 7 data bits, n stop bits"]
            BIT7 = 1,
        }
        impl From<M1_A> for bool {
            #[inline(always)]
            fn from(variant: M1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `M1`"]
        pub type M1_R = crate::R<bool, M1_A>;
        impl M1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> M1_A {
                match self.bits {
                    false => M1_A::M0,
                    true => M1_A::BIT7,
                }
            }
            #[doc = "Checks if the value of the field is `M0`"]
            #[inline(always)]
            pub fn is_m0(&self) -> bool {
                *self == M1_A::M0
            }
            #[doc = "Checks if the value of the field is `BIT7`"]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == M1_A::BIT7
            }
        }
        #[doc = "Write proxy for field `M1`"]
        pub struct M1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: M1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Use M0 to set the data bits"]
            #[inline(always)]
            pub fn m0(self) -> &'a mut W {
                self.variant(M1_A::M0)
            }
            #[doc = "1 start bit, 7 data bits, n stop bits"]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut W {
                self.variant(M1_A::BIT7)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "End of Block interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOBIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: A USART interrupt is generated when the EOBF flag is set in the ISR register"]
            ENABLED = 1,
        }
        impl From<EOBIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOBIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOBIE`"]
        pub type EOBIE_R = crate::R<bool, EOBIE_A>;
        impl EOBIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOBIE_A {
                match self.bits {
                    false => EOBIE_A::DISABLED,
                    true => EOBIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOBIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOBIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOBIE`"]
        pub struct EOBIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOBIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOBIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOBIE_A::DISABLED)
            }
            #[doc = "A USART interrupt is generated when the EOBF flag is set in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOBIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Receiver timeout interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTOIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An USART interrupt is generated when the RTOF bit is set in the ISR register"]
            ENABLED = 1,
        }
        impl From<RTOIE_A> for bool {
            #[inline(always)]
            fn from(variant: RTOIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTOIE`"]
        pub type RTOIE_R = crate::R<bool, RTOIE_A>;
        impl RTOIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTOIE_A {
                match self.bits {
                    false => RTOIE_A::DISABLED,
                    true => RTOIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTOIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTOIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTOIE`"]
        pub struct RTOIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTOIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTOIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTOIE_A::DISABLED)
            }
            #[doc = "An USART interrupt is generated when the RTOF bit is set in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTOIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Oversampling mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVER8_A {
            #[doc = "0: Oversampling by 16"]
            OVERSAMPLING16 = 0,
            #[doc = "1: Oversampling by 8"]
            OVERSAMPLING8 = 1,
        }
        impl From<OVER8_A> for bool {
            #[inline(always)]
            fn from(variant: OVER8_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVER8`"]
        pub type OVER8_R = crate::R<bool, OVER8_A>;
        impl OVER8_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVER8_A {
                match self.bits {
                    false => OVER8_A::OVERSAMPLING16,
                    true => OVER8_A::OVERSAMPLING8,
                }
            }
            #[doc = "Checks if the value of the field is `OVERSAMPLING16`"]
            #[inline(always)]
            pub fn is_oversampling16(&self) -> bool {
                *self == OVER8_A::OVERSAMPLING16
            }
            #[doc = "Checks if the value of the field is `OVERSAMPLING8`"]
            #[inline(always)]
            pub fn is_oversampling8(&self) -> bool {
                *self == OVER8_A::OVERSAMPLING8
            }
        }
        #[doc = "Write proxy for field `OVER8`"]
        pub struct OVER8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVER8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVER8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Oversampling by 16"]
            #[inline(always)]
            pub fn oversampling16(self) -> &'a mut W {
                self.variant(OVER8_A::OVERSAMPLING16)
            }
            #[doc = "Oversampling by 8"]
            #[inline(always)]
            pub fn oversampling8(self) -> &'a mut W {
                self.variant(OVER8_A::OVERSAMPLING8)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Character match interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated when the CMF bit is set in the ISR register"]
            ENABLED = 1,
        }
        impl From<CMIE_A> for bool {
            #[inline(always)]
            fn from(variant: CMIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CMIE`"]
        pub type CMIE_R = crate::R<bool, CMIE_A>;
        impl CMIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMIE_A {
                match self.bits {
                    false => CMIE_A::DISABLED,
                    true => CMIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CMIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CMIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CMIE`"]
        pub struct CMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CMIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated when the CMF bit is set in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CMIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Mute mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MME_A {
            #[doc = "0: Receiver in active mode permanently"]
            DISABLED = 0,
            #[doc = "1: Receiver can switch between mute mode and active mode"]
            ENABLED = 1,
        }
        impl From<MME_A> for bool {
            #[inline(always)]
            fn from(variant: MME_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MME`"]
        pub type MME_R = crate::R<bool, MME_A>;
        impl MME_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MME_A {
                match self.bits {
                    false => MME_A::DISABLED,
                    true => MME_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MME_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MME_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MME`"]
        pub struct MME_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MME_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MME_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver in active mode permanently"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MME_A::DISABLED)
            }
            #[doc = "Receiver can switch between mute mode and active mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MME_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Word length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M0_A {
            #[doc = "0: 1 start bit, 8 data bits, n stop bits"]
            BIT8 = 0,
            #[doc = "1: 1 start bit, 9 data bits, n stop bits"]
            BIT9 = 1,
        }
        impl From<M0_A> for bool {
            #[inline(always)]
            fn from(variant: M0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `M0`"]
        pub type M0_R = crate::R<bool, M0_A>;
        impl M0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> M0_A {
                match self.bits {
                    false => M0_A::BIT8,
                    true => M0_A::BIT9,
                }
            }
            #[doc = "Checks if the value of the field is `BIT8`"]
            #[inline(always)]
            pub fn is_bit8(&self) -> bool {
                *self == M0_A::BIT8
            }
            #[doc = "Checks if the value of the field is `BIT9`"]
            #[inline(always)]
            pub fn is_bit9(&self) -> bool {
                *self == M0_A::BIT9
            }
        }
        #[doc = "Write proxy for field `M0`"]
        pub struct M0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: M0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "1 start bit, 8 data bits, n stop bits"]
            #[inline(always)]
            pub fn bit8(self) -> &'a mut W {
                self.variant(M0_A::BIT8)
            }
            #[doc = "1 start bit, 9 data bits, n stop bits"]
            #[inline(always)]
            pub fn bit9(self) -> &'a mut W {
                self.variant(M0_A::BIT9)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Receiver wakeup method\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKE_A {
            #[doc = "0: Idle line"]
            IDLE = 0,
            #[doc = "1: Address mask"]
            ADDRESS = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAKE`"]
        pub type WAKE_R = crate::R<bool, WAKE_A>;
        impl WAKE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IDLE,
                    true => WAKE_A::ADDRESS,
                }
            }
            #[doc = "Checks if the value of the field is `IDLE`"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == WAKE_A::IDLE
            }
            #[doc = "Checks if the value of the field is `ADDRESS`"]
            #[inline(always)]
            pub fn is_address(&self) -> bool {
                *self == WAKE_A::ADDRESS
            }
        }
        #[doc = "Write proxy for field `WAKE`"]
        pub struct WAKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAKE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAKE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Idle line"]
            #[inline(always)]
            pub fn idle(self) -> &'a mut W {
                self.variant(WAKE_A::IDLE)
            }
            #[doc = "Address mask"]
            #[inline(always)]
            pub fn address(self) -> &'a mut W {
                self.variant(WAKE_A::ADDRESS)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Parity control enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PCE_A {
            #[doc = "0: Parity control disabled"]
            DISABLED = 0,
            #[doc = "1: Parity control enabled"]
            ENABLED = 1,
        }
        impl From<PCE_A> for bool {
            #[inline(always)]
            fn from(variant: PCE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PCE`"]
        pub type PCE_R = crate::R<bool, PCE_A>;
        impl PCE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PCE_A {
                match self.bits {
                    false => PCE_A::DISABLED,
                    true => PCE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PCE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PCE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PCE`"]
        pub struct PCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PCE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Parity control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PCE_A::DISABLED)
            }
            #[doc = "Parity control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PCE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Parity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PS_A {
            #[doc = "0: Even parity"]
            EVEN = 0,
            #[doc = "1: Odd parity"]
            ODD = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PS`"]
        pub type PS_R = crate::R<bool, PS_A>;
        impl PS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::EVEN,
                    true => PS_A::ODD,
                }
            }
            #[doc = "Checks if the value of the field is `EVEN`"]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == PS_A::EVEN
            }
            #[doc = "Checks if the value of the field is `ODD`"]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == PS_A::ODD
            }
        }
        #[doc = "Write proxy for field `PS`"]
        pub struct PS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Even parity"]
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::EVEN)
            }
            #[doc = "Odd parity"]
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::ODD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "PE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever PE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<PEIE_A> for bool {
            #[inline(always)]
            fn from(variant: PEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PEIE`"]
        pub type PEIE_R = crate::R<bool, PEIE_A>;
        impl PEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PEIE_A {
                match self.bits {
                    false => PEIE_A::DISABLED,
                    true => PEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PEIE`"]
        pub struct PEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever PE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever TXE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXEIE`"]
        pub type TXEIE_R = crate::R<bool, TXEIE_A>;
        impl TXEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::DISABLED,
                    true => TXEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXEIE`"]
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever TXE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Transmission complete interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever TC=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIE`"]
        pub type TCIE_R = crate::R<bool, TCIE_A>;
        impl TCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TCIE`"]
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever TC=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "RXNE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNEIE`"]
        pub type RXNEIE_R = crate::R<bool, RXNEIE_A>;
        impl RXNEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::DISABLED,
                    true => RXNEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXNEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXNEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXNEIE`"]
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "IDLE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever IDLE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IDLEIE`"]
        pub type IDLEIE_R = crate::R<bool, IDLEIE_A>;
        impl IDLEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::DISABLED,
                    true => IDLEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IDLEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IDLEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IDLEIE`"]
        pub struct IDLEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever IDLE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Transmitter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TE_A {
            #[doc = "0: Transmitter is disabled"]
            DISABLED = 0,
            #[doc = "1: Transmitter is enabled"]
            ENABLED = 1,
        }
        impl From<TE_A> for bool {
            #[inline(always)]
            fn from(variant: TE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TE`"]
        pub type TE_R = crate::R<bool, TE_A>;
        impl TE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TE_A {
                match self.bits {
                    false => TE_A::DISABLED,
                    true => TE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TE`"]
        pub struct TE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Transmitter is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TE_A::DISABLED)
            }
            #[doc = "Transmitter is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Receiver enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RE_A {
            #[doc = "0: Receiver is disabled"]
            DISABLED = 0,
            #[doc = "1: Receiver is enabled"]
            ENABLED = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RE`"]
        pub type RE_R = crate::R<bool, RE_A>;
        impl RE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::DISABLED,
                    true => RE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RE`"]
        pub struct RE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::DISABLED)
            }
            #[doc = "Receiver is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "USART enable in Stop mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UESM_A {
            #[doc = "0: USART not able to wake up the MCU from Stop mode"]
            DISABLED = 0,
            #[doc = "1: USART able to wake up the MCU from Stop mode"]
            ENABLED = 1,
        }
        impl From<UESM_A> for bool {
            #[inline(always)]
            fn from(variant: UESM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UESM`"]
        pub type UESM_R = crate::R<bool, UESM_A>;
        impl UESM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UESM_A {
                match self.bits {
                    false => UESM_A::DISABLED,
                    true => UESM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UESM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UESM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UESM`"]
        pub struct UESM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UESM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UESM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "USART not able to wake up the MCU from Stop mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UESM_A::DISABLED)
            }
            #[doc = "USART able to wake up the MCU from Stop mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UESM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "USART enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UE_A {
            #[doc = "0: UART is disabled"]
            DISABLED = 0,
            #[doc = "1: UART is enabled"]
            ENABLED = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UE`"]
        pub type UE_R = crate::R<bool, UE_A>;
        impl UE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::DISABLED,
                    true => UE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UE`"]
        pub struct UE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "UART is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::DISABLED)
            }
            #[doc = "UART is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `DEAT`"]
        pub type DEAT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DEAT`"]
        pub struct DEAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEAT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 21)) | (((value as u32) & 0x1f) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `DEDT`"]
        pub type DEDT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DEDT`"]
        pub struct DEDT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEDT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 16)) | (((value as u32) & 0x1f) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 28 - Word length"]
            #[inline(always)]
            pub fn m1(&self) -> M1_R {
                M1_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 27 - End of Block interrupt enable"]
            #[inline(always)]
            pub fn eobie(&self) -> EOBIE_R {
                EOBIE_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 26 - Receiver timeout interrupt enable"]
            #[inline(always)]
            pub fn rtoie(&self) -> RTOIE_R {
                RTOIE_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Oversampling mode"]
            #[inline(always)]
            pub fn over8(&self) -> OVER8_R {
                OVER8_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Character match interrupt enable"]
            #[inline(always)]
            pub fn cmie(&self) -> CMIE_R {
                CMIE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Mute mode enable"]
            #[inline(always)]
            pub fn mme(&self) -> MME_R {
                MME_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m0(&self) -> M0_R {
                M0_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Receiver wakeup method"]
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - interrupt enable"]
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - USART enable in Stop mode"]
            #[inline(always)]
            pub fn uesm(&self) -> UESM_R {
                UESM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - USART enable"]
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 21:25 - Driver Enable assertion time"]
            #[inline(always)]
            pub fn deat(&self) -> DEAT_R {
                DEAT_R::new(((self.bits >> 21) & 0x1f) as u8)
            }
            #[doc = "Bits 16:20 - Driver Enable de-assertion time"]
            #[inline(always)]
            pub fn dedt(&self) -> DEDT_R {
                DEDT_R::new(((self.bits >> 16) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 28 - Word length"]
            #[inline(always)]
            pub fn m1(&mut self) -> M1_W {
                M1_W { w: self }
            }
            #[doc = "Bit 27 - End of Block interrupt enable"]
            #[inline(always)]
            pub fn eobie(&mut self) -> EOBIE_W {
                EOBIE_W { w: self }
            }
            #[doc = "Bit 26 - Receiver timeout interrupt enable"]
            #[inline(always)]
            pub fn rtoie(&mut self) -> RTOIE_W {
                RTOIE_W { w: self }
            }
            #[doc = "Bit 15 - Oversampling mode"]
            #[inline(always)]
            pub fn over8(&mut self) -> OVER8_W {
                OVER8_W { w: self }
            }
            #[doc = "Bit 14 - Character match interrupt enable"]
            #[inline(always)]
            pub fn cmie(&mut self) -> CMIE_W {
                CMIE_W { w: self }
            }
            #[doc = "Bit 13 - Mute mode enable"]
            #[inline(always)]
            pub fn mme(&mut self) -> MME_W {
                MME_W { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m0(&mut self) -> M0_W {
                M0_W { w: self }
            }
            #[doc = "Bit 11 - Receiver wakeup method"]
            #[inline(always)]
            pub fn wake(&mut self) -> WAKE_W {
                WAKE_W { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&mut self) -> PCE_W {
                PCE_W { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W {
                PS_W { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&mut self) -> PEIE_W {
                PEIE_W { w: self }
            }
            #[doc = "Bit 7 - interrupt enable"]
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&mut self) -> IDLEIE_W {
                IDLEIE_W { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&mut self) -> TE_W {
                TE_W { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&mut self) -> RE_W {
                RE_W { w: self }
            }
            #[doc = "Bit 1 - USART enable in Stop mode"]
            #[inline(always)]
            pub fn uesm(&mut self) -> UESM_W {
                UESM_W { w: self }
            }
            #[doc = "Bit 0 - USART enable"]
            #[inline(always)]
            pub fn ue(&mut self) -> UE_W {
                UE_W { w: self }
            }
            #[doc = "Bits 21:25 - Driver Enable assertion time"]
            #[inline(always)]
            pub fn deat(&mut self) -> DEAT_W {
                DEAT_W { w: self }
            }
            #[doc = "Bits 16:20 - Driver Enable de-assertion time"]
            #[inline(always)]
            pub fn dedt(&mut self) -> DEDT_W {
                DEDT_W { w: self }
            }
        }
    }
    #[doc = "Control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Receiver timeout enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTOEN_A {
            #[doc = "0: Receiver timeout feature disabled"]
            DISABLED = 0,
            #[doc = "1: Receiver timeout feature enabled"]
            ENABLED = 1,
        }
        impl From<RTOEN_A> for bool {
            #[inline(always)]
            fn from(variant: RTOEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTOEN`"]
        pub type RTOEN_R = crate::R<bool, RTOEN_A>;
        impl RTOEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTOEN_A {
                match self.bits {
                    false => RTOEN_A::DISABLED,
                    true => RTOEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTOEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTOEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTOEN`"]
        pub struct RTOEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTOEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTOEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver timeout feature disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTOEN_A::DISABLED)
            }
            #[doc = "Receiver timeout feature enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTOEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Auto baud rate enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ABREN_A {
            #[doc = "0: Auto baud rate detection is disabled"]
            DISABLED = 0,
            #[doc = "1: Auto baud rate detection is enabled"]
            ENABLED = 1,
        }
        impl From<ABREN_A> for bool {
            #[inline(always)]
            fn from(variant: ABREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ABREN`"]
        pub type ABREN_R = crate::R<bool, ABREN_A>;
        impl ABREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ABREN_A {
                match self.bits {
                    false => ABREN_A::DISABLED,
                    true => ABREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ABREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ABREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ABREN`"]
        pub struct ABREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ABREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ABREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Auto baud rate detection is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ABREN_A::DISABLED)
            }
            #[doc = "Auto baud rate detection is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ABREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Most significant bit first\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSBFIRST_A {
            #[doc = "0: data is transmitted/received with data bit 0 first, following the start bit"]
            LSB = 0,
            #[doc = "1: data is transmitted/received with MSB (bit 7/8/9) first, following the start bit"]
            MSB = 1,
        }
        impl From<MSBFIRST_A> for bool {
            #[inline(always)]
            fn from(variant: MSBFIRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSBFIRST`"]
        pub type MSBFIRST_R = crate::R<bool, MSBFIRST_A>;
        impl MSBFIRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSBFIRST_A {
                match self.bits {
                    false => MSBFIRST_A::LSB,
                    true => MSBFIRST_A::MSB,
                }
            }
            #[doc = "Checks if the value of the field is `LSB`"]
            #[inline(always)]
            pub fn is_lsb(&self) -> bool {
                *self == MSBFIRST_A::LSB
            }
            #[doc = "Checks if the value of the field is `MSB`"]
            #[inline(always)]
            pub fn is_msb(&self) -> bool {
                *self == MSBFIRST_A::MSB
            }
        }
        #[doc = "Write proxy for field `MSBFIRST`"]
        pub struct MSBFIRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSBFIRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSBFIRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "data is transmitted/received with data bit 0 first, following the start bit"]
            #[inline(always)]
            pub fn lsb(self) -> &'a mut W {
                self.variant(MSBFIRST_A::LSB)
            }
            #[doc = "data is transmitted/received with MSB (bit 7/8/9) first, following the start bit"]
            #[inline(always)]
            pub fn msb(self) -> &'a mut W {
                self.variant(MSBFIRST_A::MSB)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Binary data inversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATAINV_A {
            #[doc = "0: Logical data from the data register are send/received in positive/direct logic"]
            POSITIVE = 0,
            #[doc = "1: Logical data from the data register are send/received in negative/inverse logic"]
            NEGATIVE = 1,
        }
        impl From<DATAINV_A> for bool {
            #[inline(always)]
            fn from(variant: DATAINV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DATAINV`"]
        pub type DATAINV_R = crate::R<bool, DATAINV_A>;
        impl DATAINV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATAINV_A {
                match self.bits {
                    false => DATAINV_A::POSITIVE,
                    true => DATAINV_A::NEGATIVE,
                }
            }
            #[doc = "Checks if the value of the field is `POSITIVE`"]
            #[inline(always)]
            pub fn is_positive(&self) -> bool {
                *self == DATAINV_A::POSITIVE
            }
            #[doc = "Checks if the value of the field is `NEGATIVE`"]
            #[inline(always)]
            pub fn is_negative(&self) -> bool {
                *self == DATAINV_A::NEGATIVE
            }
        }
        #[doc = "Write proxy for field `DATAINV`"]
        pub struct DATAINV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATAINV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATAINV_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Logical data from the data register are send/received in positive/direct logic"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(DATAINV_A::POSITIVE)
            }
            #[doc = "Logical data from the data register are send/received in negative/inverse logic"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(DATAINV_A::NEGATIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "TX pin active level inversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXINV_A {
            #[doc = "0: TX pin signal works using the standard logic levels"]
            STANDARD = 0,
            #[doc = "1: TX pin signal values are inverted"]
            INVERTED = 1,
        }
        impl From<TXINV_A> for bool {
            #[inline(always)]
            fn from(variant: TXINV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXINV`"]
        pub type TXINV_R = crate::R<bool, TXINV_A>;
        impl TXINV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXINV_A {
                match self.bits {
                    false => TXINV_A::STANDARD,
                    true => TXINV_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == TXINV_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == TXINV_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `TXINV`"]
        pub struct TXINV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXINV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXINV_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TX pin signal works using the standard logic levels"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(TXINV_A::STANDARD)
            }
            #[doc = "TX pin signal values are inverted"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(TXINV_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "RX pin active level inversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXINV_A {
            #[doc = "0: RX pin signal works using the standard logic levels"]
            STANDARD = 0,
            #[doc = "1: RX pin signal values are inverted"]
            INVERTED = 1,
        }
        impl From<RXINV_A> for bool {
            #[inline(always)]
            fn from(variant: RXINV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXINV`"]
        pub type RXINV_R = crate::R<bool, RXINV_A>;
        impl RXINV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXINV_A {
                match self.bits {
                    false => RXINV_A::STANDARD,
                    true => RXINV_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == RXINV_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == RXINV_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `RXINV`"]
        pub struct RXINV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXINV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXINV_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RX pin signal works using the standard logic levels"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(RXINV_A::STANDARD)
            }
            #[doc = "RX pin signal values are inverted"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(RXINV_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Swap TX/RX pins\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWAP_A {
            #[doc = "0: TX/RX pins are used as defined in standard pinout"]
            STANDARD = 0,
            #[doc = "1: The TX and RX pins functions are swapped"]
            SWAPPED = 1,
        }
        impl From<SWAP_A> for bool {
            #[inline(always)]
            fn from(variant: SWAP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SWAP`"]
        pub type SWAP_R = crate::R<bool, SWAP_A>;
        impl SWAP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SWAP_A {
                match self.bits {
                    false => SWAP_A::STANDARD,
                    true => SWAP_A::SWAPPED,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == SWAP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `SWAPPED`"]
            #[inline(always)]
            pub fn is_swapped(&self) -> bool {
                *self == SWAP_A::SWAPPED
            }
        }
        #[doc = "Write proxy for field `SWAP`"]
        pub struct SWAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWAP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWAP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TX/RX pins are used as defined in standard pinout"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(SWAP_A::STANDARD)
            }
            #[doc = "The TX and RX pins functions are swapped"]
            #[inline(always)]
            pub fn swapped(self) -> &'a mut W {
                self.variant(SWAP_A::SWAPPED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "LIN mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LINEN_A {
            #[doc = "0: LIN mode disabled"]
            DISABLED = 0,
            #[doc = "1: LIN mode enabled"]
            ENABLED = 1,
        }
        impl From<LINEN_A> for bool {
            #[inline(always)]
            fn from(variant: LINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LINEN`"]
        pub type LINEN_R = crate::R<bool, LINEN_A>;
        impl LINEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LINEN_A {
                match self.bits {
                    false => LINEN_A::DISABLED,
                    true => LINEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LINEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LINEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LINEN`"]
        pub struct LINEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LINEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LINEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LIN mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LINEN_A::DISABLED)
            }
            #[doc = "LIN mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LINEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "STOP bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum STOP_A {
            #[doc = "0: 1 stop bit"]
            STOP1 = 0,
            #[doc = "1: 0.5 stop bit"]
            STOP0P5 = 1,
            #[doc = "2: 2 stop bit"]
            STOP2 = 2,
            #[doc = "3: 1.5 stop bit"]
            STOP1P5 = 3,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `STOP`"]
        pub type STOP_R = crate::R<u8, STOP_A>;
        impl STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    0 => STOP_A::STOP1,
                    1 => STOP_A::STOP0P5,
                    2 => STOP_A::STOP2,
                    3 => STOP_A::STOP1P5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STOP1`"]
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                *self == STOP_A::STOP1
            }
            #[doc = "Checks if the value of the field is `STOP0P5`"]
            #[inline(always)]
            pub fn is_stop0p5(&self) -> bool {
                *self == STOP_A::STOP0P5
            }
            #[doc = "Checks if the value of the field is `STOP2`"]
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                *self == STOP_A::STOP2
            }
            #[doc = "Checks if the value of the field is `STOP1P5`"]
            #[inline(always)]
            pub fn is_stop1p5(&self) -> bool {
                *self == STOP_A::STOP1P5
            }
        }
        #[doc = "Write proxy for field `STOP`"]
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1 stop bit"]
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::STOP1)
            }
            #[doc = "0.5 stop bit"]
            #[inline(always)]
            pub fn stop0p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP0P5)
            }
            #[doc = "2 stop bit"]
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::STOP2)
            }
            #[doc = "1.5 stop bit"]
            #[inline(always)]
            pub fn stop1p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP1P5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKEN_A {
            #[doc = "0: CK pin disabled"]
            DISABLED = 0,
            #[doc = "1: CK pin enabled"]
            ENABLED = 1,
        }
        impl From<CLKEN_A> for bool {
            #[inline(always)]
            fn from(variant: CLKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CLKEN`"]
        pub type CLKEN_R = crate::R<bool, CLKEN_A>;
        impl CLKEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CLKEN_A {
                match self.bits {
                    false => CLKEN_A::DISABLED,
                    true => CLKEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CLKEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CLKEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CLKEN`"]
        pub struct CLKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CK pin disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CLKEN_A::DISABLED)
            }
            #[doc = "CK pin enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CLKEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Clock polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOL_A {
            #[doc = "0: Steady low value on CK pin outside transmission window"]
            LOW = 0,
            #[doc = "1: Steady high value on CK pin outside transmission window"]
            HIGH = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPOL`"]
        pub type CPOL_R = crate::R<bool, CPOL_A>;
        impl CPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::LOW,
                    true => CPOL_A::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == CPOL_A::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == CPOL_A::HIGH
            }
        }
        #[doc = "Write proxy for field `CPOL`"]
        pub struct CPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Steady low value on CK pin outside transmission window"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(CPOL_A::LOW)
            }
            #[doc = "Steady high value on CK pin outside transmission window"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(CPOL_A::HIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Clock phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHA_A {
            #[doc = "0: The first clock transition is the first data capture edge"]
            FIRST = 0,
            #[doc = "1: The second clock transition is the first data capture edge"]
            SECOND = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPHA`"]
        pub type CPHA_R = crate::R<bool, CPHA_A>;
        impl CPHA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FIRST,
                    true => CPHA_A::SECOND,
                }
            }
            #[doc = "Checks if the value of the field is `FIRST`"]
            #[inline(always)]
            pub fn is_first(&self) -> bool {
                *self == CPHA_A::FIRST
            }
            #[doc = "Checks if the value of the field is `SECOND`"]
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == CPHA_A::SECOND
            }
        }
        #[doc = "Write proxy for field `CPHA`"]
        pub struct CPHA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPHA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPHA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The first clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn first(self) -> &'a mut W {
                self.variant(CPHA_A::FIRST)
            }
            #[doc = "The second clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(CPHA_A::SECOND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Last bit clock pulse\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBCL_A {
            #[doc = "0: The clock pulse of the last data bit is not output to the CK pin"]
            NOTOUTPUT = 0,
            #[doc = "1: The clock pulse of the last data bit is output to the CK pin"]
            OUTPUT = 1,
        }
        impl From<LBCL_A> for bool {
            #[inline(always)]
            fn from(variant: LBCL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBCL`"]
        pub type LBCL_R = crate::R<bool, LBCL_A>;
        impl LBCL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBCL_A {
                match self.bits {
                    false => LBCL_A::NOTOUTPUT,
                    true => LBCL_A::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTOUTPUT`"]
            #[inline(always)]
            pub fn is_not_output(&self) -> bool {
                *self == LBCL_A::NOTOUTPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == LBCL_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `LBCL`"]
        pub struct LBCL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBCL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBCL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The clock pulse of the last data bit is not output to the CK pin"]
            #[inline(always)]
            pub fn not_output(self) -> &'a mut W {
                self.variant(LBCL_A::NOTOUTPUT)
            }
            #[doc = "The clock pulse of the last data bit is output to the CK pin"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(LBCL_A::OUTPUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "LIN break detection interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An interrupt is generated whenever LBDF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<LBDIE_A> for bool {
            #[inline(always)]
            fn from(variant: LBDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBDIE`"]
        pub type LBDIE_R = crate::R<bool, LBDIE_A>;
        impl LBDIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBDIE_A {
                match self.bits {
                    false => LBDIE_A::DISABLED,
                    true => LBDIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LBDIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LBDIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LBDIE`"]
        pub struct LBDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LBDIE_A::DISABLED)
            }
            #[doc = "An interrupt is generated whenever LBDF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LBDIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "LIN break detection length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDL_A {
            #[doc = "0: 10-bit break detection"]
            BIT10 = 0,
            #[doc = "1: 11-bit break detection"]
            BIT11 = 1,
        }
        impl From<LBDL_A> for bool {
            #[inline(always)]
            fn from(variant: LBDL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LBDL`"]
        pub type LBDL_R = crate::R<bool, LBDL_A>;
        impl LBDL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LBDL_A {
                match self.bits {
                    false => LBDL_A::BIT10,
                    true => LBDL_A::BIT11,
                }
            }
            #[doc = "Checks if the value of the field is `BIT10`"]
            #[inline(always)]
            pub fn is_bit10(&self) -> bool {
                *self == LBDL_A::BIT10
            }
            #[doc = "Checks if the value of the field is `BIT11`"]
            #[inline(always)]
            pub fn is_bit11(&self) -> bool {
                *self == LBDL_A::BIT11
            }
        }
        #[doc = "Write proxy for field `LBDL`"]
        pub struct LBDL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "10-bit break detection"]
            #[inline(always)]
            pub fn bit10(self) -> &'a mut W {
                self.variant(LBDL_A::BIT10)
            }
            #[doc = "11-bit break detection"]
            #[inline(always)]
            pub fn bit11(self) -> &'a mut W {
                self.variant(LBDL_A::BIT11)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "7-bit Address Detection/4-bit Address Detection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDM7_A {
            #[doc = "0: 4-bit address detection"]
            BIT4 = 0,
            #[doc = "1: 7-bit address detection"]
            BIT7 = 1,
        }
        impl From<ADDM7_A> for bool {
            #[inline(always)]
            fn from(variant: ADDM7_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDM7`"]
        pub type ADDM7_R = crate::R<bool, ADDM7_A>;
        impl ADDM7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDM7_A {
                match self.bits {
                    false => ADDM7_A::BIT4,
                    true => ADDM7_A::BIT7,
                }
            }
            #[doc = "Checks if the value of the field is `BIT4`"]
            #[inline(always)]
            pub fn is_bit4(&self) -> bool {
                *self == ADDM7_A::BIT4
            }
            #[doc = "Checks if the value of the field is `BIT7`"]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == ADDM7_A::BIT7
            }
        }
        #[doc = "Write proxy for field `ADDM7`"]
        pub struct ADDM7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDM7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDM7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "4-bit address detection"]
            #[inline(always)]
            pub fn bit4(self) -> &'a mut W {
                self.variant(ADDM7_A::BIT4)
            }
            #[doc = "7-bit address detection"]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut W {
                self.variant(ADDM7_A::BIT7)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        #[doc = "Auto baud rate mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ABRMOD_A {
            #[doc = "0: Measurement of the start bit is used to detect the baud rate"]
            START = 0,
            #[doc = "1: Falling edge to falling edge measurement"]
            EDGE = 1,
            #[doc = "2: 0x7F frame detection"]
            FRAME7F = 2,
            #[doc = "3: 0x55 frame detection"]
            FRAME55 = 3,
        }
        impl From<ABRMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: ABRMOD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ABRMOD`"]
        pub type ABRMOD_R = crate::R<u8, ABRMOD_A>;
        impl ABRMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ABRMOD_A {
                match self.bits {
                    0 => ABRMOD_A::START,
                    1 => ABRMOD_A::EDGE,
                    2 => ABRMOD_A::FRAME7F,
                    3 => ABRMOD_A::FRAME55,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == ABRMOD_A::START
            }
            #[doc = "Checks if the value of the field is `EDGE`"]
            #[inline(always)]
            pub fn is_edge(&self) -> bool {
                *self == ABRMOD_A::EDGE
            }
            #[doc = "Checks if the value of the field is `FRAME7F`"]
            #[inline(always)]
            pub fn is_frame7f(&self) -> bool {
                *self == ABRMOD_A::FRAME7F
            }
            #[doc = "Checks if the value of the field is `FRAME55`"]
            #[inline(always)]
            pub fn is_frame55(&self) -> bool {
                *self == ABRMOD_A::FRAME55
            }
        }
        #[doc = "Write proxy for field `ABRMOD`"]
        pub struct ABRMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ABRMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ABRMOD_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Measurement of the start bit is used to detect the baud rate"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(ABRMOD_A::START)
            }
            #[doc = "Falling edge to falling edge measurement"]
            #[inline(always)]
            pub fn edge(self) -> &'a mut W {
                self.variant(ABRMOD_A::EDGE)
            }
            #[doc = "0x7F frame detection"]
            #[inline(always)]
            pub fn frame7f(self) -> &'a mut W {
                self.variant(ABRMOD_A::FRAME7F)
            }
            #[doc = "0x55 frame detection"]
            #[inline(always)]
            pub fn frame55(self) -> &'a mut W {
                self.variant(ABRMOD_A::FRAME55)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 21)) | (((value as u32) & 0x03) << 21);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 23 - Receiver timeout enable"]
            #[inline(always)]
            pub fn rtoen(&self) -> RTOEN_R {
                RTOEN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Auto baud rate enable"]
            #[inline(always)]
            pub fn abren(&self) -> ABREN_R {
                ABREN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Most significant bit first"]
            #[inline(always)]
            pub fn msbfirst(&self) -> MSBFIRST_R {
                MSBFIRST_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Binary data inversion"]
            #[inline(always)]
            pub fn datainv(&self) -> DATAINV_R {
                DATAINV_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - TX pin active level inversion"]
            #[inline(always)]
            pub fn txinv(&self) -> TXINV_R {
                TXINV_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - RX pin active level inversion"]
            #[inline(always)]
            pub fn rxinv(&self) -> RXINV_R {
                RXINV_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Swap TX/RX pins"]
            #[inline(always)]
            pub fn swap(&self) -> SWAP_R {
                SWAP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline(always)]
            pub fn lbcl(&self) -> LBCL_R {
                LBCL_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - LIN break detection length"]
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
            #[inline(always)]
            pub fn addm7(&self) -> ADDM7_R {
                ADDM7_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 24:31 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new(((self.bits >> 24) & 0xff) as u8)
            }
            #[doc = "Bits 21:22 - Auto baud rate mode"]
            #[inline(always)]
            pub fn abrmod(&self) -> ABRMOD_R {
                ABRMOD_R::new(((self.bits >> 21) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 23 - Receiver timeout enable"]
            #[inline(always)]
            pub fn rtoen(&mut self) -> RTOEN_W {
                RTOEN_W { w: self }
            }
            #[doc = "Bit 20 - Auto baud rate enable"]
            #[inline(always)]
            pub fn abren(&mut self) -> ABREN_W {
                ABREN_W { w: self }
            }
            #[doc = "Bit 19 - Most significant bit first"]
            #[inline(always)]
            pub fn msbfirst(&mut self) -> MSBFIRST_W {
                MSBFIRST_W { w: self }
            }
            #[doc = "Bit 18 - Binary data inversion"]
            #[inline(always)]
            pub fn datainv(&mut self) -> DATAINV_W {
                DATAINV_W { w: self }
            }
            #[doc = "Bit 17 - TX pin active level inversion"]
            #[inline(always)]
            pub fn txinv(&mut self) -> TXINV_W {
                TXINV_W { w: self }
            }
            #[doc = "Bit 16 - RX pin active level inversion"]
            #[inline(always)]
            pub fn rxinv(&mut self) -> RXINV_W {
                RXINV_W { w: self }
            }
            #[doc = "Bit 15 - Swap TX/RX pins"]
            #[inline(always)]
            pub fn swap(&mut self) -> SWAP_W {
                SWAP_W { w: self }
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline(always)]
            pub fn linen(&mut self) -> LINEN_W {
                LINEN_W { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline(always)]
            pub fn clken(&mut self) -> CLKEN_W {
                CLKEN_W { w: self }
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W {
                CPOL_W { w: self }
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W {
                CPHA_W { w: self }
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline(always)]
            pub fn lbcl(&mut self) -> LBCL_W {
                LBCL_W { w: self }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline(always)]
            pub fn lbdie(&mut self) -> LBDIE_W {
                LBDIE_W { w: self }
            }
            #[doc = "Bit 5 - LIN break detection length"]
            #[inline(always)]
            pub fn lbdl(&mut self) -> LBDL_W {
                LBDL_W { w: self }
            }
            #[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
            #[inline(always)]
            pub fn addm7(&mut self) -> ADDM7_W {
                ADDM7_W { w: self }
            }
            #[doc = "Bits 24:31 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
            #[doc = "Bits 21:22 - Auto baud rate mode"]
            #[inline(always)]
            pub fn abrmod(&mut self) -> ABRMOD_W {
                ABRMOD_W { w: self }
            }
        }
    }
    #[doc = "Control register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr3](cr3) module"]
    pub type CR3 = crate::Reg<u32, _CR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR3;
    #[doc = "`read()` method returns [cr3::R](cr3::R) reader structure"]
    impl crate::Readable for CR3 {}
    #[doc = "`write(|w| ..)` method takes [cr3::W](cr3::W) writer structure"]
    impl crate::Writable for CR3 {}
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = "Reader of register CR3"]
        pub type R = crate::R<u32, super::CR3>;
        #[doc = "Writer for register CR3"]
        pub type W = crate::W<u32, super::CR3>;
        #[doc = "Register CR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Wakeup from Stop mode interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUFIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An USART interrupt is generated whenever WUF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<WUFIE_A> for bool {
            #[inline(always)]
            fn from(variant: WUFIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUFIE`"]
        pub type WUFIE_R = crate::R<bool, WUFIE_A>;
        impl WUFIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUFIE_A {
                match self.bits {
                    false => WUFIE_A::DISABLED,
                    true => WUFIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WUFIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WUFIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WUFIE`"]
        pub struct WUFIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUFIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUFIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WUFIE_A::DISABLED)
            }
            #[doc = "An USART interrupt is generated whenever WUF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WUFIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Wakeup from Stop mode interrupt flag selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WUS_A {
            #[doc = "0: WUF active on address match"]
            ADDRESS = 0,
            #[doc = "2: WuF active on Start bit detection"]
            START = 2,
            #[doc = "3: WUF active on RXNE"]
            RXNE = 3,
        }
        impl From<WUS_A> for u8 {
            #[inline(always)]
            fn from(variant: WUS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WUS`"]
        pub type WUS_R = crate::R<u8, WUS_A>;
        impl WUS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, WUS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(WUS_A::ADDRESS),
                    2 => Val(WUS_A::START),
                    3 => Val(WUS_A::RXNE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ADDRESS`"]
            #[inline(always)]
            pub fn is_address(&self) -> bool {
                *self == WUS_A::ADDRESS
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == WUS_A::START
            }
            #[doc = "Checks if the value of the field is `RXNE`"]
            #[inline(always)]
            pub fn is_rxne(&self) -> bool {
                *self == WUS_A::RXNE
            }
        }
        #[doc = "Write proxy for field `WUS`"]
        pub struct WUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "WUF active on address match"]
            #[inline(always)]
            pub fn address(self) -> &'a mut W {
                self.variant(WUS_A::ADDRESS)
            }
            #[doc = "WuF active on Start bit detection"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(WUS_A::START)
            }
            #[doc = "WUF active on RXNE"]
            #[inline(always)]
            pub fn rxne(self) -> &'a mut W {
                self.variant(WUS_A::RXNE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `SCARCNT`"]
        pub type SCARCNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SCARCNT`"]
        pub struct SCARCNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCARCNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 17)) | (((value as u32) & 0x07) << 17);
                self.w
            }
        }
        #[doc = "Driver enable polarity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEP_A {
            #[doc = "0: DE signal is active high"]
            HIGH = 0,
            #[doc = "1: DE signal is active low"]
            LOW = 1,
        }
        impl From<DEP_A> for bool {
            #[inline(always)]
            fn from(variant: DEP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DEP`"]
        pub type DEP_R = crate::R<bool, DEP_A>;
        impl DEP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DEP_A {
                match self.bits {
                    false => DEP_A::HIGH,
                    true => DEP_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == DEP_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == DEP_A::LOW
            }
        }
        #[doc = "Write proxy for field `DEP`"]
        pub struct DEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DEP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DE signal is active high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(DEP_A::HIGH)
            }
            #[doc = "DE signal is active low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(DEP_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Driver enable mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEM_A {
            #[doc = "0: DE function is disabled"]
            DISABLED = 0,
            #[doc = "1: The DE signal is output on the RTS pin"]
            ENABLED = 1,
        }
        impl From<DEM_A> for bool {
            #[inline(always)]
            fn from(variant: DEM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DEM`"]
        pub type DEM_R = crate::R<bool, DEM_A>;
        impl DEM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DEM_A {
                match self.bits {
                    false => DEM_A::DISABLED,
                    true => DEM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DEM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DEM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DEM`"]
        pub struct DEM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DEM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DE function is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DEM_A::DISABLED)
            }
            #[doc = "The DE signal is output on the RTS pin"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DEM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "DMA Disable on Reception Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DDRE_A {
            #[doc = "0: DMA is not disabled in case of reception error"]
            NOTDISABLED = 0,
            #[doc = "1: DMA is disabled following a reception error"]
            DISABLED = 1,
        }
        impl From<DDRE_A> for bool {
            #[inline(always)]
            fn from(variant: DDRE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DDRE`"]
        pub type DDRE_R = crate::R<bool, DDRE_A>;
        impl DDRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DDRE_A {
                match self.bits {
                    false => DDRE_A::NOTDISABLED,
                    true => DDRE_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDISABLED`"]
            #[inline(always)]
            pub fn is_not_disabled(&self) -> bool {
                *self == DDRE_A::NOTDISABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DDRE_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `DDRE`"]
        pub struct DDRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DDRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DDRE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA is not disabled in case of reception error"]
            #[inline(always)]
            pub fn not_disabled(self) -> &'a mut W {
                self.variant(DDRE_A::NOTDISABLED)
            }
            #[doc = "DMA is disabled following a reception error"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DDRE_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Overrun Disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRDIS_A {
            #[doc = "0: Overrun Error Flag, ORE, is set when received data is not read before receiving new data"]
            ENABLED = 0,
            #[doc = "1: Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register"]
            DISABLED = 1,
        }
        impl From<OVRDIS_A> for bool {
            #[inline(always)]
            fn from(variant: OVRDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVRDIS`"]
        pub type OVRDIS_R = crate::R<bool, OVRDIS_A>;
        impl OVRDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVRDIS_A {
                match self.bits {
                    false => OVRDIS_A::ENABLED,
                    true => OVRDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OVRDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OVRDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `OVRDIS`"]
        pub struct OVRDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVRDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVRDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Overrun Error Flag, ORE, is set when received data is not read before receiving new data"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OVRDIS_A::ENABLED)
            }
            #[doc = "Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OVRDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "One sample bit method enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ONEBIT_A {
            #[doc = "0: Three sample bit method"]
            SAMPLE3 = 0,
            #[doc = "1: One sample bit method"]
            SAMPLE1 = 1,
        }
        impl From<ONEBIT_A> for bool {
            #[inline(always)]
            fn from(variant: ONEBIT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ONEBIT`"]
        pub type ONEBIT_R = crate::R<bool, ONEBIT_A>;
        impl ONEBIT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ONEBIT_A {
                match self.bits {
                    false => ONEBIT_A::SAMPLE3,
                    true => ONEBIT_A::SAMPLE1,
                }
            }
            #[doc = "Checks if the value of the field is `SAMPLE3`"]
            #[inline(always)]
            pub fn is_sample3(&self) -> bool {
                *self == ONEBIT_A::SAMPLE3
            }
            #[doc = "Checks if the value of the field is `SAMPLE1`"]
            #[inline(always)]
            pub fn is_sample1(&self) -> bool {
                *self == ONEBIT_A::SAMPLE1
            }
        }
        #[doc = "Write proxy for field `ONEBIT`"]
        pub struct ONEBIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ONEBIT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ONEBIT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Three sample bit method"]
            #[inline(always)]
            pub fn sample3(self) -> &'a mut W {
                self.variant(ONEBIT_A::SAMPLE3)
            }
            #[doc = "One sample bit method"]
            #[inline(always)]
            pub fn sample1(self) -> &'a mut W {
                self.variant(ONEBIT_A::SAMPLE1)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "CTS interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An interrupt is generated whenever CTSIF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<CTSIE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CTSIE`"]
        pub type CTSIE_R = crate::R<bool, CTSIE_A>;
        impl CTSIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTSIE_A {
                match self.bits {
                    false => CTSIE_A::DISABLED,
                    true => CTSIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CTSIE`"]
        pub struct CTSIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSIE_A::DISABLED)
            }
            #[doc = "An interrupt is generated whenever CTSIF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "CTS enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSE_A {
            #[doc = "0: CTS hardware flow control disabled"]
            DISABLED = 0,
            #[doc = "1: CTS mode enabled, data is only transmitted when the CTS input is asserted"]
            ENABLED = 1,
        }
        impl From<CTSE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CTSE`"]
        pub type CTSE_R = crate::R<bool, CTSE_A>;
        impl CTSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTSE_A {
                match self.bits {
                    false => CTSE_A::DISABLED,
                    true => CTSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CTSE`"]
        pub struct CTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CTS hardware flow control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSE_A::DISABLED)
            }
            #[doc = "CTS mode enabled, data is only transmitted when the CTS input is asserted"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "RTS enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTSE_A {
            #[doc = "0: RTS hardware flow control disabled"]
            DISABLED = 0,
            #[doc = "1: RTS output enabled, data is only requested when there is space in the receive buffer"]
            ENABLED = 1,
        }
        impl From<RTSE_A> for bool {
            #[inline(always)]
            fn from(variant: RTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTSE`"]
        pub type RTSE_R = crate::R<bool, RTSE_A>;
        impl RTSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTSE_A {
                match self.bits {
                    false => RTSE_A::DISABLED,
                    true => RTSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTSE`"]
        pub struct RTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTS hardware flow control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTSE_A::DISABLED)
            }
            #[doc = "RTS output enabled, data is only requested when there is space in the receive buffer"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "DMA enable transmitter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAT_A {
            #[doc = "0: DMA mode is disabled for transmission"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for transmission"]
            ENABLED = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAT`"]
        pub type DMAT_R = crate::R<bool, DMAT_A>;
        impl DMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::DISABLED,
                    true => DMAT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAT`"]
        pub struct DMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for transmission"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for transmission"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "DMA enable receiver\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR_A {
            #[doc = "0: DMA mode is disabled for reception"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for reception"]
            ENABLED = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAR`"]
        pub type DMAR_R = crate::R<bool, DMAR_A>;
        impl DMAR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::DISABLED,
                    true => DMAR_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAR_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAR_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAR`"]
        pub struct DMAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for reception"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for reception"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Smartcard mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCEN_A {
            #[doc = "0: Smartcard Mode disabled"]
            DISABLED = 0,
            #[doc = "1: Smartcard Mode enabled"]
            ENABLED = 1,
        }
        impl From<SCEN_A> for bool {
            #[inline(always)]
            fn from(variant: SCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SCEN`"]
        pub type SCEN_R = crate::R<bool, SCEN_A>;
        impl SCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SCEN_A {
                match self.bits {
                    false => SCEN_A::DISABLED,
                    true => SCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SCEN`"]
        pub struct SCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Smartcard Mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCEN_A::DISABLED)
            }
            #[doc = "Smartcard Mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Smartcard NACK enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACK_A {
            #[doc = "0: NACK transmission in case of parity error is disabled"]
            DISABLED = 0,
            #[doc = "1: NACK transmission during parity error is enabled"]
            ENABLED = 1,
        }
        impl From<NACK_A> for bool {
            #[inline(always)]
            fn from(variant: NACK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NACK`"]
        pub type NACK_R = crate::R<bool, NACK_A>;
        impl NACK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NACK_A {
                match self.bits {
                    false => NACK_A::DISABLED,
                    true => NACK_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NACK_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NACK_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `NACK`"]
        pub struct NACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NACK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NACK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NACK transmission in case of parity error is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NACK_A::DISABLED)
            }
            #[doc = "NACK transmission during parity error is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NACK_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Half-duplex selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HDSEL_A {
            #[doc = "0: Half duplex mode is not selected"]
            NOTSELECTED = 0,
            #[doc = "1: Half duplex mode is selected"]
            SELECTED = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HDSEL`"]
        pub type HDSEL_R = crate::R<bool, HDSEL_A>;
        impl HDSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::NOTSELECTED,
                    true => HDSEL_A::SELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSELECTED`"]
            #[inline(always)]
            pub fn is_not_selected(&self) -> bool {
                *self == HDSEL_A::NOTSELECTED
            }
            #[doc = "Checks if the value of the field is `SELECTED`"]
            #[inline(always)]
            pub fn is_selected(&self) -> bool {
                *self == HDSEL_A::SELECTED
            }
        }
        #[doc = "Write proxy for field `HDSEL`"]
        pub struct HDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HDSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HDSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Half duplex mode is not selected"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(HDSEL_A::NOTSELECTED)
            }
            #[doc = "Half duplex mode is selected"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(HDSEL_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Ir low-power\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRLP_A {
            #[doc = "0: Normal mode"]
            NORMAL = 0,
            #[doc = "1: Low-power mode"]
            LOWPOWER = 1,
        }
        impl From<IRLP_A> for bool {
            #[inline(always)]
            fn from(variant: IRLP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IRLP`"]
        pub type IRLP_R = crate::R<bool, IRLP_A>;
        impl IRLP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IRLP_A {
                match self.bits {
                    false => IRLP_A::NORMAL,
                    true => IRLP_A::LOWPOWER,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == IRLP_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `LOWPOWER`"]
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                *self == IRLP_A::LOWPOWER
            }
        }
        #[doc = "Write proxy for field `IRLP`"]
        pub struct IRLP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IRLP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRLP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Normal mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(IRLP_A::NORMAL)
            }
            #[doc = "Low-power mode"]
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(IRLP_A::LOWPOWER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Ir mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IREN_A {
            #[doc = "0: IrDA disabled"]
            DISABLED = 0,
            #[doc = "1: IrDA enabled"]
            ENABLED = 1,
        }
        impl From<IREN_A> for bool {
            #[inline(always)]
            fn from(variant: IREN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IREN`"]
        pub type IREN_R = crate::R<bool, IREN_A>;
        impl IREN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IREN_A {
                match self.bits {
                    false => IREN_A::DISABLED,
                    true => IREN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IREN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IREN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IREN`"]
        pub struct IREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "IrDA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IREN_A::DISABLED)
            }
            #[doc = "IrDA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IREN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EIE`"]
        pub type EIE_R = crate::R<bool, EIE_A>;
        impl EIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::DISABLED,
                    true => EIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EIE`"]
        pub struct EIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::DISABLED)
            }
            #[doc = "An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
            #[inline(always)]
            pub fn wufie(&self) -> WUFIE_R {
                WUFIE_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
            #[inline(always)]
            pub fn wus(&self) -> WUS_R {
                WUS_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bits 17:19 - Smartcard auto-retry count"]
            #[inline(always)]
            pub fn scarcnt(&self) -> SCARCNT_R {
                SCARCNT_R::new(((self.bits >> 17) & 0x07) as u8)
            }
            #[doc = "Bit 15 - Driver enable polarity selection"]
            #[inline(always)]
            pub fn dep(&self) -> DEP_R {
                DEP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Driver enable mode"]
            #[inline(always)]
            pub fn dem(&self) -> DEM_R {
                DEM_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - DMA Disable on Reception Error"]
            #[inline(always)]
            pub fn ddre(&self) -> DDRE_R {
                DDRE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Overrun Disable"]
            #[inline(always)]
            pub fn ovrdis(&self) -> OVRDIS_R {
                OVRDIS_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - One sample bit method enable"]
            #[inline(always)]
            pub fn onebit(&self) -> ONEBIT_R {
                ONEBIT_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline(always)]
            pub fn scen(&self) -> SCEN_R {
                SCEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Ir low-power"]
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Ir mode enable"]
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
            #[inline(always)]
            pub fn wufie(&mut self) -> WUFIE_W {
                WUFIE_W { w: self }
            }
            #[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
            #[inline(always)]
            pub fn wus(&mut self) -> WUS_W {
                WUS_W { w: self }
            }
            #[doc = "Bits 17:19 - Smartcard auto-retry count"]
            #[inline(always)]
            pub fn scarcnt(&mut self) -> SCARCNT_W {
                SCARCNT_W { w: self }
            }
            #[doc = "Bit 15 - Driver enable polarity selection"]
            #[inline(always)]
            pub fn dep(&mut self) -> DEP_W {
                DEP_W { w: self }
            }
            #[doc = "Bit 14 - Driver enable mode"]
            #[inline(always)]
            pub fn dem(&mut self) -> DEM_W {
                DEM_W { w: self }
            }
            #[doc = "Bit 13 - DMA Disable on Reception Error"]
            #[inline(always)]
            pub fn ddre(&mut self) -> DDRE_W {
                DDRE_W { w: self }
            }
            #[doc = "Bit 12 - Overrun Disable"]
            #[inline(always)]
            pub fn ovrdis(&mut self) -> OVRDIS_W {
                OVRDIS_W { w: self }
            }
            #[doc = "Bit 11 - One sample bit method enable"]
            #[inline(always)]
            pub fn onebit(&mut self) -> ONEBIT_W {
                ONEBIT_W { w: self }
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline(always)]
            pub fn ctsie(&mut self) -> CTSIE_W {
                CTSIE_W { w: self }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline(always)]
            pub fn ctse(&mut self) -> CTSE_W {
                CTSE_W { w: self }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline(always)]
            pub fn rtse(&mut self) -> RTSE_W {
                RTSE_W { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&mut self) -> DMAT_W {
                DMAT_W { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&mut self) -> DMAR_W {
                DMAR_W { w: self }
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline(always)]
            pub fn scen(&mut self) -> SCEN_W {
                SCEN_W { w: self }
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline(always)]
            pub fn nack(&mut self) -> NACK_W {
                NACK_W { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&mut self) -> HDSEL_W {
                HDSEL_W { w: self }
            }
            #[doc = "Bit 2 - Ir low-power"]
            #[inline(always)]
            pub fn irlp(&mut self) -> IRLP_W {
                IRLP_W { w: self }
            }
            #[doc = "Bit 1 - Ir mode enable"]
            #[inline(always)]
            pub fn iren(&mut self) -> IREN_W {
                IREN_W { w: self }
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&mut self) -> EIE_W {
                EIE_W { w: self }
            }
        }
    }
    #[doc = "Baud rate register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`read()` method returns [brr::R](brr::R) reader structure"]
    impl crate::Readable for BRR {}
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = "Reader of register BRR"]
        pub type R = crate::R<u32, super::BRR>;
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `BRR`"]
        pub type BRR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `BRR`"]
        pub struct BRR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BRR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - DIV_Mantissa"]
            #[inline(always)]
            pub fn brr(&self) -> BRR_R {
                BRR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - DIV_Mantissa"]
            #[inline(always)]
            pub fn brr(&mut self) -> BRR_W {
                BRR_W { w: self }
            }
        }
    }
    #[doc = "Guard time and prescaler register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtpr](gtpr) module"]
    pub type GTPR = crate::Reg<u32, _GTPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _GTPR;
    #[doc = "`read()` method returns [gtpr::R](gtpr::R) reader structure"]
    impl crate::Readable for GTPR {}
    #[doc = "`write(|w| ..)` method takes [gtpr::W](gtpr::W) writer structure"]
    impl crate::Writable for GTPR {}
    #[doc = "Guard time and prescaler register"]
    pub mod gtpr {
        #[doc = "Reader of register GTPR"]
        pub type R = crate::R<u32, super::GTPR>;
        #[doc = "Writer for register GTPR"]
        pub type W = crate::W<u32, super::GTPR>;
        #[doc = "Register GTPR `reset()`'s with value 0"]
        impl crate::ResetValue for super::GTPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `GT`"]
        pub type GT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `GT`"]
        pub struct GT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline(always)]
            pub fn gt(&self) -> GT_R {
                GT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline(always)]
            pub fn gt(&mut self) -> GT_W {
                GT_W { w: self }
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "Receiver timeout register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtor](rtor) module"]
    pub type RTOR = crate::Reg<u32, _RTOR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RTOR;
    #[doc = "`read()` method returns [rtor::R](rtor::R) reader structure"]
    impl crate::Readable for RTOR {}
    #[doc = "`write(|w| ..)` method takes [rtor::W](rtor::W) writer structure"]
    impl crate::Writable for RTOR {}
    #[doc = "Receiver timeout register"]
    pub mod rtor {
        #[doc = "Reader of register RTOR"]
        pub type R = crate::R<u32, super::RTOR>;
        #[doc = "Writer for register RTOR"]
        pub type W = crate::W<u32, super::RTOR>;
        #[doc = "Register RTOR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RTOR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `BLEN`"]
        pub type BLEN_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `BLEN`"]
        pub struct BLEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BLEN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `RTO`"]
        pub type RTO_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `RTO`"]
        pub struct RTO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTO_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | ((value as u32) & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 24:31 - Block Length"]
            #[inline(always)]
            pub fn blen(&self) -> BLEN_R {
                BLEN_R::new(((self.bits >> 24) & 0xff) as u8)
            }
            #[doc = "Bits 0:23 - Receiver timeout value"]
            #[inline(always)]
            pub fn rto(&self) -> RTO_R {
                RTO_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 24:31 - Block Length"]
            #[inline(always)]
            pub fn blen(&mut self) -> BLEN_W {
                BLEN_W { w: self }
            }
            #[doc = "Bits 0:23 - Receiver timeout value"]
            #[inline(always)]
            pub fn rto(&mut self) -> RTO_W {
                RTO_W { w: self }
            }
        }
    }
    #[doc = "Request register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rqr](rqr) module"]
    pub type RQR = crate::Reg<u32, _RQR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RQR;
    #[doc = "`write(|w| ..)` method takes [rqr::W](rqr::W) writer structure"]
    impl crate::Writable for RQR {}
    #[doc = "Request register"]
    pub mod rqr {
        #[doc = "Writer for register RQR"]
        pub type W = crate::W<u32, super::RQR>;
        #[doc = "Register RQR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RQR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Transmit data flush request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXFRQ_AW {
            #[doc = "1: Set the TXE flags. This allows to discard the transmit data"]
            DISCARD = 1,
        }
        impl From<TXFRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: TXFRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TXFRQ`"]
        pub struct TXFRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXFRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXFRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Set the TXE flags. This allows to discard the transmit data"]
            #[inline(always)]
            pub fn discard(self) -> &'a mut W {
                self.variant(TXFRQ_AW::DISCARD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Receive data flush request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXFRQ_AW {
            #[doc = "1: clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition"]
            DISCARD = 1,
        }
        impl From<RXFRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: RXFRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RXFRQ`"]
        pub struct RXFRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXFRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXFRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition"]
            #[inline(always)]
            pub fn discard(self) -> &'a mut W {
                self.variant(RXFRQ_AW::DISCARD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Mute mode request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MMRQ_AW {
            #[doc = "1: Puts the USART in mute mode and sets the RWU flag"]
            MUTE = 1,
        }
        impl From<MMRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: MMRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `MMRQ`"]
        pub struct MMRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Puts the USART in mute mode and sets the RWU flag"]
            #[inline(always)]
            pub fn mute(self) -> &'a mut W {
                self.variant(MMRQ_AW::MUTE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Send break request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBKRQ_AW {
            #[doc = "1: sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available"]
            BREAK = 1,
        }
        impl From<SBKRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: SBKRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `SBKRQ`"]
        pub struct SBKRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBKRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SBKRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available"]
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBKRQ_AW::BREAK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Auto baud rate request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ABRRQ_AW {
            #[doc = "1: resets the ABRF flag in the USART_ISR and request an automatic baud rate measurement on the next received data frame"]
            REQUEST = 1,
        }
        impl From<ABRRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: ABRRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ABRRQ`"]
        pub struct ABRRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ABRRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ABRRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "resets the ABRF flag in the USART_ISR and request an automatic baud rate measurement on the next received data frame"]
            #[inline(always)]
            pub fn request(self) -> &'a mut W {
                self.variant(ABRRQ_AW::REQUEST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 4 - Transmit data flush request"]
            #[inline(always)]
            pub fn txfrq(&mut self) -> TXFRQ_W {
                TXFRQ_W { w: self }
            }
            #[doc = "Bit 3 - Receive data flush request"]
            #[inline(always)]
            pub fn rxfrq(&mut self) -> RXFRQ_W {
                RXFRQ_W { w: self }
            }
            #[doc = "Bit 2 - Mute mode request"]
            #[inline(always)]
            pub fn mmrq(&mut self) -> MMRQ_W {
                MMRQ_W { w: self }
            }
            #[doc = "Bit 1 - Send break request"]
            #[inline(always)]
            pub fn sbkrq(&mut self) -> SBKRQ_W {
                SBKRQ_W { w: self }
            }
            #[doc = "Bit 0 - Auto baud rate request"]
            #[inline(always)]
            pub fn abrrq(&mut self) -> ABRRQ_W {
                ABRRQ_W { w: self }
            }
        }
    }
    #[doc = "Interrupt & status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "Interrupt & status register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Reader of field `REACK`"]
        pub type REACK_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TEACK`"]
        pub type TEACK_R = crate::R<bool, bool>;
        #[doc = "Reader of field `WUF`"]
        pub type WUF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RWU`"]
        pub type RWU_R = crate::R<bool, bool>;
        #[doc = "Reader of field `SBKF`"]
        pub type SBKF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `CMF`"]
        pub type CMF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `BUSY`"]
        pub type BUSY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ABRF`"]
        pub type ABRF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ABRE`"]
        pub type ABRE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `EOBF`"]
        pub type EOBF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RTOF`"]
        pub type RTOF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `CTS`"]
        pub type CTS_R = crate::R<bool, bool>;
        #[doc = "Reader of field `CTSIF`"]
        pub type CTSIF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `LBDF`"]
        pub type LBDF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TC`"]
        pub type TC_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `IDLE`"]
        pub type IDLE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ORE`"]
        pub type ORE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `NF`"]
        pub type NF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `FE`"]
        pub type FE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 22 - REACK"]
            #[inline(always)]
            pub fn reack(&self) -> REACK_R {
                REACK_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - TEACK"]
            #[inline(always)]
            pub fn teack(&self) -> TEACK_R {
                TEACK_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 20 - WUF"]
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - RWU"]
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - SBKF"]
            #[inline(always)]
            pub fn sbkf(&self) -> SBKF_R {
                SBKF_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - CMF"]
            #[inline(always)]
            pub fn cmf(&self) -> CMF_R {
                CMF_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - BUSY"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - ABRF"]
            #[inline(always)]
            pub fn abrf(&self) -> ABRF_R {
                ABRF_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - ABRE"]
            #[inline(always)]
            pub fn abre(&self) -> ABRE_R {
                ABRE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - EOBF"]
            #[inline(always)]
            pub fn eobf(&self) -> EOBF_R {
                EOBF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - RTOF"]
            #[inline(always)]
            pub fn rtof(&self) -> RTOF_R {
                RTOF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - CTS"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - CTSIF"]
            #[inline(always)]
            pub fn ctsif(&self) -> CTSIF_R {
                CTSIF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - LBDF"]
            #[inline(always)]
            pub fn lbdf(&self) -> LBDF_R {
                LBDF_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - TXE"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - TC"]
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RXNE"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE"]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - ORE"]
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - NF"]
            #[inline(always)]
            pub fn nf(&self) -> NF_R {
                NF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - FE"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - PE"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Interrupt flag clear register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
    pub type ICR = crate::Reg<u32, _ICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICR;
    #[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
    impl crate::Writable for ICR {}
    #[doc = "Interrupt flag clear register"]
    pub mod icr {
        #[doc = "Writer for register ICR"]
        pub type W = crate::W<u32, super::ICR>;
        #[doc = "Register ICR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Wakeup from Stop mode clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUCF_AW {
            #[doc = "1: Clears the WUF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<WUCF_AW> for bool {
            #[inline(always)]
            fn from(variant: WUCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `WUCF`"]
        pub struct WUCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the WUF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(WUCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Character match clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMCF_AW {
            #[doc = "1: Clears the CMF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CMCF_AW> for bool {
            #[inline(always)]
            fn from(variant: CMCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CMCF`"]
        pub struct CMCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the CMF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CMCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "End of block clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOBCF_AW {
            #[doc = "1: Clears the EOBF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<EOBCF_AW> for bool {
            #[inline(always)]
            fn from(variant: EOBCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EOBCF`"]
        pub struct EOBCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOBCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOBCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the EOBF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOBCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Receiver timeout clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTOCF_AW {
            #[doc = "1: Clears the RTOF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<RTOCF_AW> for bool {
            #[inline(always)]
            fn from(variant: RTOCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RTOCF`"]
        pub struct RTOCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTOCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTOCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the RTOF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RTOCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "CTS clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSCF_AW {
            #[doc = "1: Clears the CTSIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CTSCF_AW> for bool {
            #[inline(always)]
            fn from(variant: CTSCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTSCF`"]
        pub struct CTSCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the CTSIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTSCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "LIN break detection clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDCF_AW {
            #[doc = "1: Clears the LBDF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<LBDCF_AW> for bool {
            #[inline(always)]
            fn from(variant: LBDCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `LBDCF`"]
        pub struct LBDCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LBDCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the LBDF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LBDCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Transmission complete clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCCF_AW {
            #[doc = "1: Clears the TC flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<TCCF_AW> for bool {
            #[inline(always)]
            fn from(variant: TCCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TCCF`"]
        pub struct TCCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TC flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TCCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Idle line detected clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLECF_AW {
            #[doc = "1: Clears the IDLE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<IDLECF_AW> for bool {
            #[inline(always)]
            fn from(variant: IDLECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `IDLECF`"]
        pub struct IDLECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the IDLE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(IDLECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Overrun error clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ORECF_AW {
            #[doc = "1: Clears the ORE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<ORECF_AW> for bool {
            #[inline(always)]
            fn from(variant: ORECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ORECF`"]
        pub struct ORECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ORECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ORECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the ORE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ORECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Noise detected clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NCF_AW {
            #[doc = "1: Clears the NF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<NCF_AW> for bool {
            #[inline(always)]
            fn from(variant: NCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `NCF`"]
        pub struct NCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the NF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(NCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Framing error clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FECF_AW {
            #[doc = "1: Clears the FE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<FECF_AW> for bool {
            #[inline(always)]
            fn from(variant: FECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `FECF`"]
        pub struct FECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the FE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(FECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Parity error clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECF_AW {
            #[doc = "1: Clears the PE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<PECF_AW> for bool {
            #[inline(always)]
            fn from(variant: PECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `PECF`"]
        pub struct PECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the PE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 20 - Wakeup from Stop mode clear flag"]
            #[inline(always)]
            pub fn wucf(&mut self) -> WUCF_W {
                WUCF_W { w: self }
            }
            #[doc = "Bit 17 - Character match clear flag"]
            #[inline(always)]
            pub fn cmcf(&mut self) -> CMCF_W {
                CMCF_W { w: self }
            }
            #[doc = "Bit 12 - End of block clear flag"]
            #[inline(always)]
            pub fn eobcf(&mut self) -> EOBCF_W {
                EOBCF_W { w: self }
            }
            #[doc = "Bit 11 - Receiver timeout clear flag"]
            #[inline(always)]
            pub fn rtocf(&mut self) -> RTOCF_W {
                RTOCF_W { w: self }
            }
            #[doc = "Bit 9 - CTS clear flag"]
            #[inline(always)]
            pub fn ctscf(&mut self) -> CTSCF_W {
                CTSCF_W { w: self }
            }
            #[doc = "Bit 8 - LIN break detection clear flag"]
            #[inline(always)]
            pub fn lbdcf(&mut self) -> LBDCF_W {
                LBDCF_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete clear flag"]
            #[inline(always)]
            pub fn tccf(&mut self) -> TCCF_W {
                TCCF_W { w: self }
            }
            #[doc = "Bit 4 - Idle line detected clear flag"]
            #[inline(always)]
            pub fn idlecf(&mut self) -> IDLECF_W {
                IDLECF_W { w: self }
            }
            #[doc = "Bit 3 - Overrun error clear flag"]
            #[inline(always)]
            pub fn orecf(&mut self) -> ORECF_W {
                ORECF_W { w: self }
            }
            #[doc = "Bit 2 - Noise detected clear flag"]
            #[inline(always)]
            pub fn ncf(&mut self) -> NCF_W {
                NCF_W { w: self }
            }
            #[doc = "Bit 1 - Framing error clear flag"]
            #[inline(always)]
            pub fn fecf(&mut self) -> FECF_W {
                FECF_W { w: self }
            }
            #[doc = "Bit 0 - Parity error clear flag"]
            #[inline(always)]
            pub fn pecf(&mut self) -> PECF_W {
                PECF_W { w: self }
            }
        }
    }
    #[doc = "Receive data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rdr](rdr) module"]
    pub type RDR = crate::Reg<u32, _RDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RDR;
    #[doc = "`read()` method returns [rdr::R](rdr::R) reader structure"]
    impl crate::Readable for RDR {}
    #[doc = "Receive data register"]
    pub mod rdr {
        #[doc = "Reader of register RDR"]
        pub type R = crate::R<u32, super::RDR>;
        #[doc = "Reader of field `RDR`"]
        pub type RDR_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:8 - Receive data value"]
            #[inline(always)]
            pub fn rdr(&self) -> RDR_R {
                RDR_R::new((self.bits & 0x01ff) as u16)
            }
        }
    }
    #[doc = "Transmit data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tdr](tdr) module"]
    pub type TDR = crate::Reg<u32, _TDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TDR;
    #[doc = "`read()` method returns [tdr::R](tdr::R) reader structure"]
    impl crate::Readable for TDR {}
    #[doc = "`write(|w| ..)` method takes [tdr::W](tdr::W) writer structure"]
    impl crate::Writable for TDR {}
    #[doc = "Transmit data register"]
    pub mod tdr {
        #[doc = "Reader of register TDR"]
        pub type R = crate::R<u32, super::TDR>;
        #[doc = "Writer for register TDR"]
        pub type W = crate::W<u32, super::TDR>;
        #[doc = "Register TDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TDR`"]
        pub type TDR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `TDR`"]
        pub struct TDR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | ((value as u32) & 0x01ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:8 - Transmit data value"]
            #[inline(always)]
            pub fn tdr(&self) -> TDR_R {
                TDR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:8 - Transmit data value"]
            #[inline(always)]
            pub fn tdr(&mut self) -> TDR_W {
                TDR_W { w: self }
            }
        }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART2 {}
impl USART2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4000_4400 as *const _
    }
}
impl Deref for USART2 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART2::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART4 {}
impl USART4 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4000_4c00 as *const _
    }
}
impl Deref for USART4 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART4::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct USART5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART5 {}
impl USART5 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        0x4000_5000 as *const _
    }
}
impl Deref for USART5 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*USART5::ptr() }
    }
}
#[doc = "Independent watchdog"]
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IWDG {}
impl IWDG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iwdg::RegisterBlock {
        0x4000_3000 as *const _
    }
}
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*IWDG::ptr() }
    }
}
#[doc = "Independent watchdog"]
pub mod iwdg {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Key register"]
        pub kr: KR,
        #[doc = "0x04 - Prescaler register"]
        pub pr: PR,
        #[doc = "0x08 - Reload register"]
        pub rlr: RLR,
        #[doc = "0x0c - Status register"]
        pub sr: SR,
        #[doc = "0x10 - Window register"]
        pub winr: WINR,
    }
    #[doc = "Key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [kr](kr) module"]
    pub type KR = crate::Reg<u32, _KR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KR;
    #[doc = "`write(|w| ..)` method takes [kr::W](kr::W) writer structure"]
    impl crate::Writable for KR {}
    #[doc = "Key register"]
    pub mod kr {
        #[doc = "Writer for register KR"]
        pub type W = crate::W<u32, super::KR>;
        #[doc = "Register KR `reset()`'s with value 0"]
        impl crate::ResetValue for super::KR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Key value (write only, read 0x0000)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u16)]
        pub enum KEY_AW {
            #[doc = "21845: Enable access to PR, RLR and WINR registers (0x5555)"]
            ENABLE = 21845,
            #[doc = "43690: Reset the watchdog value (0xAAAA)"]
            RESET = 43690,
            #[doc = "52428: Start the watchdog (0xCCCC)"]
            START = 52428,
        }
        impl From<KEY_AW> for u16 {
            #[inline(always)]
            fn from(variant: KEY_AW) -> Self {
                variant as _
            }
        }
        #[doc = "Write proxy for field `KEY`"]
        pub struct KEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: KEY_AW) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Enable access to PR, RLR and WINR registers (0x5555)"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(KEY_AW::ENABLE)
            }
            #[doc = "Reset the watchdog value (0xAAAA)"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(KEY_AW::RESET)
            }
            #[doc = "Start the watchdog (0xCCCC)"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(KEY_AW::START)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Key value (write only, read 0x0000)"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W {
                KEY_W { w: self }
            }
        }
    }
    #[doc = "Prescaler register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pr](pr) module"]
    pub type PR = crate::Reg<u32, _PR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PR;
    #[doc = "`read()` method returns [pr::R](pr::R) reader structure"]
    impl crate::Readable for PR {}
    #[doc = "`write(|w| ..)` method takes [pr::W](pr::W) writer structure"]
    impl crate::Writable for PR {}
    #[doc = "Prescaler register"]
    pub mod pr {
        #[doc = "Reader of register PR"]
        pub type R = crate::R<u32, super::PR>;
        #[doc = "Writer for register PR"]
        pub type W = crate::W<u32, super::PR>;
        #[doc = "Register PR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Prescaler divider\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PR_A {
            #[doc = "0: Divider /4"]
            DIVIDEBY4 = 0,
            #[doc = "1: Divider /8"]
            DIVIDEBY8 = 1,
            #[doc = "2: Divider /16"]
            DIVIDEBY16 = 2,
            #[doc = "3: Divider /32"]
            DIVIDEBY32 = 3,
            #[doc = "4: Divider /64"]
            DIVIDEBY64 = 4,
            #[doc = "5: Divider /128"]
            DIVIDEBY128 = 5,
            #[doc = "6: Divider /256"]
            DIVIDEBY256 = 6,
            #[doc = "7: Divider /256"]
            DIVIDEBY256BIS = 7,
        }
        impl From<PR_A> for u8 {
            #[inline(always)]
            fn from(variant: PR_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PR`"]
        pub type PR_R = crate::R<u8, PR_A>;
        impl PR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PR_A {
                match self.bits {
                    0 => PR_A::DIVIDEBY4,
                    1 => PR_A::DIVIDEBY8,
                    2 => PR_A::DIVIDEBY16,
                    3 => PR_A::DIVIDEBY32,
                    4 => PR_A::DIVIDEBY64,
                    5 => PR_A::DIVIDEBY128,
                    6 => PR_A::DIVIDEBY256,
                    7 => PR_A::DIVIDEBY256BIS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY4`"]
            #[inline(always)]
            pub fn is_divide_by4(&self) -> bool {
                *self == PR_A::DIVIDEBY4
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY8`"]
            #[inline(always)]
            pub fn is_divide_by8(&self) -> bool {
                *self == PR_A::DIVIDEBY8
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY16`"]
            #[inline(always)]
            pub fn is_divide_by16(&self) -> bool {
                *self == PR_A::DIVIDEBY16
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY32`"]
            #[inline(always)]
            pub fn is_divide_by32(&self) -> bool {
                *self == PR_A::DIVIDEBY32
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY64`"]
            #[inline(always)]
            pub fn is_divide_by64(&self) -> bool {
                *self == PR_A::DIVIDEBY64
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY128`"]
            #[inline(always)]
            pub fn is_divide_by128(&self) -> bool {
                *self == PR_A::DIVIDEBY128
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY256`"]
            #[inline(always)]
            pub fn is_divide_by256(&self) -> bool {
                *self == PR_A::DIVIDEBY256
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY256BIS`"]
            #[inline(always)]
            pub fn is_divide_by256bis(&self) -> bool {
                *self == PR_A::DIVIDEBY256BIS
            }
        }
        #[doc = "Write proxy for field `PR`"]
        pub struct PR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PR_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Divider /4"]
            #[inline(always)]
            pub fn divide_by4(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY4)
            }
            #[doc = "Divider /8"]
            #[inline(always)]
            pub fn divide_by8(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY8)
            }
            #[doc = "Divider /16"]
            #[inline(always)]
            pub fn divide_by16(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY16)
            }
            #[doc = "Divider /32"]
            #[inline(always)]
            pub fn divide_by32(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY32)
            }
            #[doc = "Divider /64"]
            #[inline(always)]
            pub fn divide_by64(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY64)
            }
            #[doc = "Divider /128"]
            #[inline(always)]
            pub fn divide_by128(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY128)
            }
            #[doc = "Divider /256"]
            #[inline(always)]
            pub fn divide_by256(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY256)
            }
            #[doc = "Divider /256"]
            #[inline(always)]
            pub fn divide_by256bis(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY256BIS)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline(always)]
            pub fn pr(&self) -> PR_R {
                PR_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline(always)]
            pub fn pr(&mut self) -> PR_W {
                PR_W { w: self }
            }
        }
    }
    #[doc = "Reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rlr](rlr) module"]
    pub type RLR = crate::Reg<u32, _RLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RLR;
    #[doc = "`read()` method returns [rlr::R](rlr::R) reader structure"]
    impl crate::Readable for RLR {}
    #[doc = "`write(|w| ..)` method takes [rlr::W](rlr::W) writer structure"]
    impl crate::Writable for RLR {}
    #[doc = "Reload register"]
    pub mod rlr {
        #[doc = "Reader of register RLR"]
        pub type R = crate::R<u32, super::RLR>;
        #[doc = "Writer for register RLR"]
        pub type W = crate::W<u32, super::RLR>;
        #[doc = "Register RLR `reset()`'s with value 0x0fff"]
        impl crate::ResetValue for super::RLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0fff
            }
        }
        #[doc = "Reader of field `RL`"]
        pub type RL_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `RL`"]
        pub struct RL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline(always)]
            pub fn rl(&self) -> RL_R {
                RL_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline(always)]
            pub fn rl(&mut self) -> RL_W {
                RL_W { w: self }
            }
        }
    }
    #[doc = "Status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "Status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Reader of field `WVU`"]
        pub type WVU_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RVU`"]
        pub type RVU_R = crate::R<bool, bool>;
        #[doc = "Reader of field `PVU`"]
        pub type PVU_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 2 - Watchdog counter window value update"]
            #[inline(always)]
            pub fn wvu(&self) -> WVU_R {
                WVU_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Watchdog counter reload value update"]
            #[inline(always)]
            pub fn rvu(&self) -> RVU_R {
                RVU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Watchdog prescaler value update"]
            #[inline(always)]
            pub fn pvu(&self) -> PVU_R {
                PVU_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Window register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winr](winr) module"]
    pub type WINR = crate::Reg<u32, _WINR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _WINR;
    #[doc = "`read()` method returns [winr::R](winr::R) reader structure"]
    impl crate::Readable for WINR {}
    #[doc = "`write(|w| ..)` method takes [winr::W](winr::W) writer structure"]
    impl crate::Writable for WINR {}
    #[doc = "Window register"]
    pub mod winr {
        #[doc = "Reader of register WINR"]
        pub type R = crate::R<u32, super::WINR>;
        #[doc = "Writer for register WINR"]
        pub type W = crate::W<u32, super::WINR>;
        #[doc = "Register WINR `reset()`'s with value 0x0fff"]
        impl crate::ResetValue for super::WINR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0fff
            }
        }
        #[doc = "Reader of field `WIN`"]
        pub type WIN_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `WIN`"]
        pub struct WIN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WIN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Watchdog counter window value"]
            #[inline(always)]
            pub fn win(&self) -> WIN_R {
                WIN_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Watchdog counter window value"]
            #[inline(always)]
            pub fn win(&mut self) -> WIN_W {
                WIN_W { w: self }
            }
        }
    }
}
#[doc = "System window watchdog"]
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDG {}
impl WWDG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wwdg::RegisterBlock {
        0x4000_2c00 as *const _
    }
}
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*WWDG::ptr() }
    }
}
#[doc = "System window watchdog"]
pub mod wwdg {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register"]
        pub cr: CR,
        #[doc = "0x04 - Configuration register"]
        pub cfr: CFR,
        #[doc = "0x08 - Status register"]
        pub sr: SR,
    }
    #[doc = "Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0x7f"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x7f
            }
        }
        #[doc = "Activation bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDGA_A {
            #[doc = "0: Watchdog disabled"]
            DISABLED = 0,
            #[doc = "1: Watchdog enabled"]
            ENABLED = 1,
        }
        impl From<WDGA_A> for bool {
            #[inline(always)]
            fn from(variant: WDGA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WDGA`"]
        pub type WDGA_R = crate::R<bool, WDGA_A>;
        impl WDGA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WDGA_A {
                match self.bits {
                    false => WDGA_A::DISABLED,
                    true => WDGA_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WDGA_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WDGA_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WDGA`"]
        pub struct WDGA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDGA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDGA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Watchdog disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WDGA_A::DISABLED)
            }
            #[doc = "Watchdog enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WDGA_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `T`"]
        pub type T_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `T`"]
        pub struct T_W<'a> {
            w: &'a mut W,
        }
        impl<'a> T_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | ((value as u32) & 0x7f);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Activation bit"]
            #[inline(always)]
            pub fn wdga(&self) -> WDGA_R {
                WDGA_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
            #[inline(always)]
            pub fn t(&self) -> T_R {
                T_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 7 - Activation bit"]
            #[inline(always)]
            pub fn wdga(&mut self) -> WDGA_W {
                WDGA_W { w: self }
            }
            #[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
            #[inline(always)]
            pub fn t(&mut self) -> T_W {
                T_W { w: self }
            }
        }
    }
    #[doc = "Configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfr](cfr) module"]
    pub type CFR = crate::Reg<u32, _CFR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFR;
    #[doc = "`read()` method returns [cfr::R](cfr::R) reader structure"]
    impl crate::Readable for CFR {}
    #[doc = "`write(|w| ..)` method takes [cfr::W](cfr::W) writer structure"]
    impl crate::Writable for CFR {}
    #[doc = "Configuration register"]
    pub mod cfr {
        #[doc = "Reader of register CFR"]
        pub type R = crate::R<u32, super::CFR>;
        #[doc = "Writer for register CFR"]
        pub type W = crate::W<u32, super::CFR>;
        #[doc = "Register CFR `reset()`'s with value 0x7f"]
        impl crate::ResetValue for super::CFR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x7f
            }
        }
        #[doc = "Early wakeup interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWI_A {
            #[doc = "1: interrupt occurs whenever the counter reaches the value 0x40"]
            ENABLE = 1,
        }
        impl From<EWI_A> for bool {
            #[inline(always)]
            fn from(variant: EWI_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWI`"]
        pub type EWI_R = crate::R<bool, EWI_A>;
        impl EWI_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, EWI_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(EWI_A::ENABLE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == EWI_A::ENABLE
            }
        }
        #[doc = "Write proxy for field `EWI`"]
        pub struct EWI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWI_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWI_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "interrupt occurs whenever the counter reaches the value 0x40"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EWI_A::ENABLE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `W`"]
        pub type W_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `W`"]
        pub struct W_W<'a> {
            w: &'a mut W,
        }
        impl<'a> W_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | ((value as u32) & 0x7f);
                self.w
            }
        }
        #[doc = "Timer base\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WDGTB_A {
            #[doc = "0: Counter clock (PCLK1 div 4096) div 1"]
            DIV1 = 0,
            #[doc = "1: Counter clock (PCLK1 div 4096) div 2"]
            DIV2 = 1,
            #[doc = "2: Counter clock (PCLK1 div 4096) div 4"]
            DIV4 = 2,
            #[doc = "3: Counter clock (PCLK1 div 4096) div 8"]
            DIV8 = 3,
        }
        impl From<WDGTB_A> for u8 {
            #[inline(always)]
            fn from(variant: WDGTB_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WDGTB`"]
        pub type WDGTB_R = crate::R<u8, WDGTB_A>;
        impl WDGTB_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WDGTB_A {
                match self.bits {
                    0 => WDGTB_A::DIV1,
                    1 => WDGTB_A::DIV2,
                    2 => WDGTB_A::DIV4,
                    3 => WDGTB_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == WDGTB_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == WDGTB_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == WDGTB_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == WDGTB_A::DIV8
            }
        }
        #[doc = "Write proxy for field `WDGTB`"]
        pub struct WDGTB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDGTB_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDGTB_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV1)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV2)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV4)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 7)) | (((value as u32) & 0x03) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 9 - Early wakeup interrupt"]
            #[inline(always)]
            pub fn ewi(&self) -> EWI_R {
                EWI_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline(always)]
            pub fn w(&self) -> W_R {
                W_R::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bits 7:8 - Timer base"]
            #[inline(always)]
            pub fn wdgtb(&self) -> WDGTB_R {
                WDGTB_R::new(((self.bits >> 7) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 9 - Early wakeup interrupt"]
            #[inline(always)]
            pub fn ewi(&mut self) -> EWI_W {
                EWI_W { w: self }
            }
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline(always)]
            pub fn w(&mut self) -> W_W {
                W_W { w: self }
            }
            #[doc = "Bits 7:8 - Timer base"]
            #[inline(always)]
            pub fn wdgtb(&mut self) -> WDGTB_W {
                WDGTB_W { w: self }
            }
        }
    }
    #[doc = "Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Early wakeup interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIF_A {
            #[doc = "1: The EWI Interrupt Service Routine has been triggered"]
            PENDING = 1,
            #[doc = "0: The EWI Interrupt Service Routine has been serviced"]
            FINISHED = 0,
        }
        impl From<EWIF_A> for bool {
            #[inline(always)]
            fn from(variant: EWIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWIF`"]
        pub type EWIF_R = crate::R<bool, EWIF_A>;
        impl EWIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EWIF_A {
                match self.bits {
                    true => EWIF_A::PENDING,
                    false => EWIF_A::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                *self == EWIF_A::PENDING
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                *self == EWIF_A::FINISHED
            }
        }
        #[doc = "Early wakeup interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIF_AW {
            #[doc = "0: The EWI Interrupt Service Routine has been serviced"]
            FINISHED = 0,
        }
        impl From<EWIF_AW> for bool {
            #[inline(always)]
            fn from(variant: EWIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EWIF`"]
        pub struct EWIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The EWI Interrupt Service Routine has been serviced"]
            #[inline(always)]
            pub fn finished(self) -> &'a mut W {
                self.variant(EWIF_AW::FINISHED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Early wakeup interrupt flag"]
            #[inline(always)]
            pub fn ewif(&self) -> EWIF_R {
                EWIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Early wakeup interrupt flag"]
            #[inline(always)]
            pub fn ewif(&mut self) -> EWIF_W {
                EWIF_W { w: self }
            }
        }
    }
}
#[doc = "Firewall"]
pub struct FW {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FW {}
impl FW {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fw::RegisterBlock {
        0x4001_1c00 as *const _
    }
}
impl Deref for FW {
    type Target = fw::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*FW::ptr() }
    }
}
#[doc = "Firewall"]
pub mod fw {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Code segment start address"]
        pub cssa: CSSA,
        #[doc = "0x04 - Code segment length"]
        pub csl: CSL,
        #[doc = "0x08 - Non-volatile data segment start address"]
        pub nvdssa: NVDSSA,
        #[doc = "0x0c - Non-volatile data segment length"]
        pub nvdsl: NVDSL,
        #[doc = "0x10 - Volatile data segment start address"]
        pub vdssa: VDSSA,
        #[doc = "0x14 - Volatile data segment length"]
        pub vdsl: VDSL,
        _reserved6: [u8; 8usize],
        #[doc = "0x20 - Configuration register"]
        pub cr: CR,
    }
    #[doc = "Code segment start address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cssa](cssa) module"]
    pub type CSSA = crate::Reg<u32, _CSSA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSSA;
    #[doc = "`read()` method returns [cssa::R](cssa::R) reader structure"]
    impl crate::Readable for CSSA {}
    #[doc = "`write(|w| ..)` method takes [cssa::W](cssa::W) writer structure"]
    impl crate::Writable for CSSA {}
    #[doc = "Code segment start address"]
    pub mod cssa {
        #[doc = "Reader of register CSSA"]
        pub type R = crate::R<u32, super::CSSA>;
        #[doc = "Writer for register CSSA"]
        pub type W = crate::W<u32, super::CSSA>;
        #[doc = "Register CSSA `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSSA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 8)) | (((value as u32) & 0xffff) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:23 - code segment start address"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new(((self.bits >> 8) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 8:23 - code segment start address"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
        }
    }
    #[doc = "Code segment length\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csl](csl) module"]
    pub type CSL = crate::Reg<u32, _CSL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSL;
    #[doc = "`read()` method returns [csl::R](csl::R) reader structure"]
    impl crate::Readable for CSL {}
    #[doc = "`write(|w| ..)` method takes [csl::W](csl::W) writer structure"]
    impl crate::Writable for CSL {}
    #[doc = "Code segment length"]
    pub mod csl {
        #[doc = "Reader of register CSL"]
        pub type R = crate::R<u32, super::CSL>;
        #[doc = "Writer for register CSL"]
        pub type W = crate::W<u32, super::CSL>;
        #[doc = "Register CSL `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `LENG`"]
        pub type LENG_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `LENG`"]
        pub struct LENG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LENG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3fff << 8)) | (((value as u32) & 0x3fff) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:21 - code segment length"]
            #[inline(always)]
            pub fn leng(&self) -> LENG_R {
                LENG_R::new(((self.bits >> 8) & 0x3fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 8:21 - code segment length"]
            #[inline(always)]
            pub fn leng(&mut self) -> LENG_W {
                LENG_W { w: self }
            }
        }
    }
    #[doc = "Non-volatile data segment start address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nvdssa](nvdssa) module"]
    pub type NVDSSA = crate::Reg<u32, _NVDSSA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _NVDSSA;
    #[doc = "`read()` method returns [nvdssa::R](nvdssa::R) reader structure"]
    impl crate::Readable for NVDSSA {}
    #[doc = "`write(|w| ..)` method takes [nvdssa::W](nvdssa::W) writer structure"]
    impl crate::Writable for NVDSSA {}
    #[doc = "Non-volatile data segment start address"]
    pub mod nvdssa {
        #[doc = "Reader of register NVDSSA"]
        pub type R = crate::R<u32, super::NVDSSA>;
        #[doc = "Writer for register NVDSSA"]
        pub type W = crate::W<u32, super::NVDSSA>;
        #[doc = "Register NVDSSA `reset()`'s with value 0"]
        impl crate::ResetValue for super::NVDSSA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 8)) | (((value as u32) & 0xffff) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:23 - Non-volatile data segment start address"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new(((self.bits >> 8) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 8:23 - Non-volatile data segment start address"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
        }
    }
    #[doc = "Non-volatile data segment length\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nvdsl](nvdsl) module"]
    pub type NVDSL = crate::Reg<u32, _NVDSL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _NVDSL;
    #[doc = "`read()` method returns [nvdsl::R](nvdsl::R) reader structure"]
    impl crate::Readable for NVDSL {}
    #[doc = "`write(|w| ..)` method takes [nvdsl::W](nvdsl::W) writer structure"]
    impl crate::Writable for NVDSL {}
    #[doc = "Non-volatile data segment length"]
    pub mod nvdsl {
        #[doc = "Reader of register NVDSL"]
        pub type R = crate::R<u32, super::NVDSL>;
        #[doc = "Writer for register NVDSL"]
        pub type W = crate::W<u32, super::NVDSL>;
        #[doc = "Register NVDSL `reset()`'s with value 0"]
        impl crate::ResetValue for super::NVDSL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `LENG`"]
        pub type LENG_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `LENG`"]
        pub struct LENG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LENG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3fff << 8)) | (((value as u32) & 0x3fff) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:21 - Non-volatile data segment length"]
            #[inline(always)]
            pub fn leng(&self) -> LENG_R {
                LENG_R::new(((self.bits >> 8) & 0x3fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 8:21 - Non-volatile data segment length"]
            #[inline(always)]
            pub fn leng(&mut self) -> LENG_W {
                LENG_W { w: self }
            }
        }
    }
    #[doc = "Volatile data segment start address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vdssa](vdssa) module"]
    pub type VDSSA = crate::Reg<u32, _VDSSA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _VDSSA;
    #[doc = "`read()` method returns [vdssa::R](vdssa::R) reader structure"]
    impl crate::Readable for VDSSA {}
    #[doc = "`write(|w| ..)` method takes [vdssa::W](vdssa::W) writer structure"]
    impl crate::Writable for VDSSA {}
    #[doc = "Volatile data segment start address"]
    pub mod vdssa {
        #[doc = "Reader of register VDSSA"]
        pub type R = crate::R<u32, super::VDSSA>;
        #[doc = "Writer for register VDSSA"]
        pub type W = crate::W<u32, super::VDSSA>;
        #[doc = "Register VDSSA `reset()`'s with value 0"]
        impl crate::ResetValue for super::VDSSA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03ff << 6)) | (((value as u32) & 0x03ff) << 6);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 6:15 - Volatile data segment start address"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new(((self.bits >> 6) & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 6:15 - Volatile data segment start address"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
        }
    }
    #[doc = "Volatile data segment length\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vdsl](vdsl) module"]
    pub type VDSL = crate::Reg<u32, _VDSL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _VDSL;
    #[doc = "`read()` method returns [vdsl::R](vdsl::R) reader structure"]
    impl crate::Readable for VDSL {}
    #[doc = "`write(|w| ..)` method takes [vdsl::W](vdsl::W) writer structure"]
    impl crate::Writable for VDSL {}
    #[doc = "Volatile data segment length"]
    pub mod vdsl {
        #[doc = "Reader of register VDSL"]
        pub type R = crate::R<u32, super::VDSL>;
        #[doc = "Writer for register VDSL"]
        pub type W = crate::W<u32, super::VDSL>;
        #[doc = "Register VDSL `reset()`'s with value 0"]
        impl crate::ResetValue for super::VDSL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `LENG`"]
        pub type LENG_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `LENG`"]
        pub struct LENG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LENG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03ff << 6)) | (((value as u32) & 0x03ff) << 6);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 6:15 - Non-volatile data segment length"]
            #[inline(always)]
            pub fn leng(&self) -> LENG_R {
                LENG_R::new(((self.bits >> 6) & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 6:15 - Non-volatile data segment length"]
            #[inline(always)]
            pub fn leng(&mut self) -> LENG_W {
                LENG_W { w: self }
            }
        }
    }
    #[doc = "Configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Configuration register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Volatile data execution\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VDE_A {
            #[doc = "0: Volatile data segment cannot be executed if VDS = 0"]
            NOTEXECUTABLE = 0,
            #[doc = "1: Volatile data segment is declared executable whatever VDS bit value"]
            EXECUTABLE = 1,
        }
        impl From<VDE_A> for bool {
            #[inline(always)]
            fn from(variant: VDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VDE`"]
        pub type VDE_R = crate::R<bool, VDE_A>;
        impl VDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VDE_A {
                match self.bits {
                    false => VDE_A::NOTEXECUTABLE,
                    true => VDE_A::EXECUTABLE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEXECUTABLE`"]
            #[inline(always)]
            pub fn is_not_executable(&self) -> bool {
                *self == VDE_A::NOTEXECUTABLE
            }
            #[doc = "Checks if the value of the field is `EXECUTABLE`"]
            #[inline(always)]
            pub fn is_executable(&self) -> bool {
                *self == VDE_A::EXECUTABLE
            }
        }
        #[doc = "Volatile data execution\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VDE_AW {
            #[doc = "0: Resets volatile data execution bit"]
            RESET = 0,
        }
        impl From<VDE_AW> for bool {
            #[inline(always)]
            fn from(variant: VDE_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `VDE`"]
        pub struct VDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: VDE_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets volatile data execution bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(VDE_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Volatile data shared\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VDS_A {
            #[doc = "0: Volatile data segment is not shared and cannot be hit by a non protected executable code when the Firewall is closed"]
            NOTSHARED = 0,
            #[doc = "1: Volatile data segment is shared with non protected application code"]
            SHARED = 1,
        }
        impl From<VDS_A> for bool {
            #[inline(always)]
            fn from(variant: VDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VDS`"]
        pub type VDS_R = crate::R<bool, VDS_A>;
        impl VDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VDS_A {
                match self.bits {
                    false => VDS_A::NOTSHARED,
                    true => VDS_A::SHARED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSHARED`"]
            #[inline(always)]
            pub fn is_not_shared(&self) -> bool {
                *self == VDS_A::NOTSHARED
            }
            #[doc = "Checks if the value of the field is `SHARED`"]
            #[inline(always)]
            pub fn is_shared(&self) -> bool {
                *self == VDS_A::SHARED
            }
        }
        #[doc = "Volatile data shared\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VDS_AW {
            #[doc = "0: Resets volatile data shared bit"]
            RESET = 0,
        }
        impl From<VDS_AW> for bool {
            #[inline(always)]
            fn from(variant: VDS_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `VDS`"]
        pub struct VDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: VDS_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets volatile data shared bit"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(VDS_AW::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Firewall pre alarm\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FPA_A {
            #[doc = "0: Any code executed outside the protected segment when the Firewall is opened will generate a system reset"]
            PREARMRESET = 0,
            #[doc = "1: Any code executed outside the protected segment will close the Firewall"]
            PREARMSET = 1,
        }
        impl From<FPA_A> for bool {
            #[inline(always)]
            fn from(variant: FPA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FPA`"]
        pub type FPA_R = crate::R<bool, FPA_A>;
        impl FPA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FPA_A {
                match self.bits {
                    false => FPA_A::PREARMRESET,
                    true => FPA_A::PREARMSET,
                }
            }
            #[doc = "Checks if the value of the field is `PREARMRESET`"]
            #[inline(always)]
            pub fn is_pre_arm_reset(&self) -> bool {
                *self == FPA_A::PREARMRESET
            }
            #[doc = "Checks if the value of the field is `PREARMSET`"]
            #[inline(always)]
            pub fn is_pre_arm_set(&self) -> bool {
                *self == FPA_A::PREARMSET
            }
        }
        #[doc = "Write proxy for field `FPA`"]
        pub struct FPA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FPA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FPA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any code executed outside the protected segment when the Firewall is opened will generate a system reset"]
            #[inline(always)]
            pub fn pre_arm_reset(self) -> &'a mut W {
                self.variant(FPA_A::PREARMRESET)
            }
            #[doc = "Any code executed outside the protected segment will close the Firewall"]
            #[inline(always)]
            pub fn pre_arm_set(self) -> &'a mut W {
                self.variant(FPA_A::PREARMSET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 2 - Volatile data execution"]
            #[inline(always)]
            pub fn vde(&self) -> VDE_R {
                VDE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Volatile data shared"]
            #[inline(always)]
            pub fn vds(&self) -> VDS_R {
                VDS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Firewall pre alarm"]
            #[inline(always)]
            pub fn fpa(&self) -> FPA_R {
                FPA_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - Volatile data execution"]
            #[inline(always)]
            pub fn vde(&mut self) -> VDE_W {
                VDE_W { w: self }
            }
            #[doc = "Bit 1 - Volatile data shared"]
            #[inline(always)]
            pub fn vds(&mut self) -> VDS_W {
                VDS_W { w: self }
            }
            #[doc = "Bit 0 - Firewall pre alarm"]
            #[inline(always)]
            pub fn fpa(&mut self) -> FPA_W {
                FPA_W { w: self }
            }
        }
    }
}
#[doc = "Reset and clock control"]
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RCC {}
impl RCC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rcc::RegisterBlock {
        0x4002_1000 as *const _
    }
}
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*RCC::ptr() }
    }
}
#[doc = "Reset and clock control"]
pub mod rcc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Clock control register"]
        pub cr: CR,
        #[doc = "0x04 - Internal clock sources calibration register"]
        pub icscr: ICSCR,
        _reserved2: [u8; 4usize],
        #[doc = "0x0c - Clock configuration register"]
        pub cfgr: CFGR,
        #[doc = "0x10 - Clock interrupt enable register"]
        pub cier: CIER,
        #[doc = "0x14 - Clock interrupt flag register"]
        pub cifr: CIFR,
        #[doc = "0x18 - Clock interrupt clear register"]
        pub cicr: CICR,
        #[doc = "0x1c - GPIO reset register"]
        pub ioprstr: IOPRSTR,
        #[doc = "0x20 - AHB peripheral reset register"]
        pub ahbrstr: AHBRSTR,
        #[doc = "0x24 - APB2 peripheral reset register"]
        pub apb2rstr: APB2RSTR,
        #[doc = "0x28 - APB1 peripheral reset register"]
        pub apb1rstr: APB1RSTR,
        #[doc = "0x2c - GPIO clock enable register"]
        pub iopenr: IOPENR,
        #[doc = "0x30 - AHB peripheral clock enable register"]
        pub ahbenr: AHBENR,
        #[doc = "0x34 - APB2 peripheral clock enable register"]
        pub apb2enr: APB2ENR,
        #[doc = "0x38 - APB1 peripheral clock enable register"]
        pub apb1enr: APB1ENR,
        #[doc = "0x3c - GPIO clock enable in sleep mode register"]
        pub iopsmen: IOPSMEN,
        #[doc = "0x40 - AHB peripheral clock enable in sleep mode register"]
        pub ahbsmenr: AHBSMENR,
        #[doc = "0x44 - APB2 peripheral clock enable in sleep mode register"]
        pub apb2smenr: APB2SMENR,
        #[doc = "0x48 - APB1 peripheral clock enable in sleep mode register"]
        pub apb1smenr: APB1SMENR,
        #[doc = "0x4c - Clock configuration register"]
        pub ccipr: CCIPR,
        #[doc = "0x50 - Control and status register"]
        pub csr: CSR,
    }
    #[doc = "Clock control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Clock control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0x0300"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0300
            }
        }
        #[doc = "PLL clock ready flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLRDY_A {
            #[doc = "0: PLL unlocked"]
            UNLOCKED = 0,
            #[doc = "1: PLL locked"]
            LOCKED = 1,
        }
        impl From<PLLRDY_A> for bool {
            #[inline(always)]
            fn from(variant: PLLRDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PLLRDY`"]
        pub type PLLRDY_R = crate::R<bool, PLLRDY_A>;
        impl PLLRDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLLRDY_A {
                match self.bits {
                    false => PLLRDY_A::UNLOCKED,
                    true => PLLRDY_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == PLLRDY_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == PLLRDY_A::LOCKED
            }
        }
        #[doc = "PLL enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLON_A {
            #[doc = "0: Clock disabled"]
            DISABLED = 0,
            #[doc = "1: Clock enabled"]
            ENABLED = 1,
        }
        impl From<PLLON_A> for bool {
            #[inline(always)]
            fn from(variant: PLLON_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PLLON`"]
        pub type PLLON_R = crate::R<bool, PLLON_A>;
        impl PLLON_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLLON_A {
                match self.bits {
                    false => PLLON_A::DISABLED,
                    true => PLLON_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PLLON_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PLLON_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PLLON`"]
        pub struct PLLON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLON_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "TC/LCD prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum RTCPRE_A {
            #[doc = "0: HSE divided by 2"]
            DIV2 = 0,
            #[doc = "1: HSE divided by 4"]
            DIV4 = 1,
            #[doc = "2: HSE divided by 8"]
            DIV8 = 2,
            #[doc = "3: HSE divided by 16"]
            DIV16 = 3,
        }
        impl From<RTCPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: RTCPRE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `RTCPRE`"]
        pub type RTCPRE_R = crate::R<u8, RTCPRE_A>;
        impl RTCPRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTCPRE_A {
                match self.bits {
                    0 => RTCPRE_A::DIV2,
                    1 => RTCPRE_A::DIV4,
                    2 => RTCPRE_A::DIV8,
                    3 => RTCPRE_A::DIV16,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == RTCPRE_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == RTCPRE_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == RTCPRE_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == RTCPRE_A::DIV16
            }
        }
        #[doc = "Write proxy for field `RTCPRE`"]
        pub struct RTCPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCPRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTCPRE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "HSE divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(RTCPRE_A::DIV2)
            }
            #[doc = "HSE divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(RTCPRE_A::DIV4)
            }
            #[doc = "HSE divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(RTCPRE_A::DIV8)
            }
            #[doc = "HSE divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(RTCPRE_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Clock security system on HSE enable bit"]
        pub type CSSHSEON_A = PLLON_A;
        #[doc = "Reader of field `CSSHSEON`"]
        pub type CSSHSEON_R = crate::R<bool, PLLON_A>;
        #[doc = "Write proxy for field `CSSHSEON`"]
        pub struct CSSHSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSHSEON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CSSHSEON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLON_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "HSE clock bypass bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSEBYP_A {
            #[doc = "0: HSE oscillator not bypassed"]
            NOTBYPASSED = 0,
            #[doc = "1: HSE oscillator bypassed"]
            BYPASSED = 1,
        }
        impl From<HSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: HSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSEBYP`"]
        pub type HSEBYP_R = crate::R<bool, HSEBYP_A>;
        impl HSEBYP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSEBYP_A {
                match self.bits {
                    false => HSEBYP_A::NOTBYPASSED,
                    true => HSEBYP_A::BYPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBYPASSED`"]
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                *self == HSEBYP_A::NOTBYPASSED
            }
            #[doc = "Checks if the value of the field is `BYPASSED`"]
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                *self == HSEBYP_A::BYPASSED
            }
        }
        #[doc = "Write proxy for field `HSEBYP`"]
        pub struct HSEBYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSEBYP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSEBYP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSE oscillator not bypassed"]
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::NOTBYPASSED)
            }
            #[doc = "HSE oscillator bypassed"]
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::BYPASSED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "HSE clock ready flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSERDY_A {
            #[doc = "0: Oscillator is not stable"]
            NOTREADY = 0,
            #[doc = "1: Oscillator is stable"]
            READY = 1,
        }
        impl From<HSERDY_A> for bool {
            #[inline(always)]
            fn from(variant: HSERDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSERDY`"]
        pub type HSERDY_R = crate::R<bool, HSERDY_A>;
        impl HSERDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSERDY_A {
                match self.bits {
                    false => HSERDY_A::NOTREADY,
                    true => HSERDY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == HSERDY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == HSERDY_A::READY
            }
        }
        #[doc = "HSE clock enable bit"]
        pub type HSEON_A = PLLON_A;
        #[doc = "Reader of field `HSEON`"]
        pub type HSEON_R = crate::R<bool, PLLON_A>;
        #[doc = "Write proxy for field `HSEON`"]
        pub struct HSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSEON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSEON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLON_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "MSI clock ready flag"]
        pub type MSIRDY_A = HSERDY_A;
        #[doc = "Reader of field `MSIRDY`"]
        pub type MSIRDY_R = crate::R<bool, HSERDY_A>;
        #[doc = "MSI clock enable bit"]
        pub type MSION_A = PLLON_A;
        #[doc = "Reader of field `MSION`"]
        pub type MSION_R = crate::R<bool, PLLON_A>;
        #[doc = "Write proxy for field `MSION`"]
        pub struct MSION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSION_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSION_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLON_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "HSI16DIVF\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSI16DIVF_A {
            #[doc = "0: 16 MHz HSI clock not divided"]
            NOTDIVIDED = 0,
            #[doc = "1: 16 MHz HSI clock divided by 4"]
            DIV4 = 1,
        }
        impl From<HSI16DIVF_A> for bool {
            #[inline(always)]
            fn from(variant: HSI16DIVF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSI16DIVF`"]
        pub type HSI16DIVF_R = crate::R<bool, HSI16DIVF_A>;
        impl HSI16DIVF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSI16DIVF_A {
                match self.bits {
                    false => HSI16DIVF_A::NOTDIVIDED,
                    true => HSI16DIVF_A::DIV4,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDIVIDED`"]
            #[inline(always)]
            pub fn is_not_divided(&self) -> bool {
                *self == HSI16DIVF_A::NOTDIVIDED
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == HSI16DIVF_A::DIV4
            }
        }
        #[doc = "HSI16DIVEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSI16DIVEN_A {
            #[doc = "0: no 16 MHz HSI division requested"]
            NOTDIVIDED = 0,
            #[doc = "1: 16 MHz HSI division by 4 requested"]
            DIV4 = 1,
        }
        impl From<HSI16DIVEN_A> for bool {
            #[inline(always)]
            fn from(variant: HSI16DIVEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSI16DIVEN`"]
        pub type HSI16DIVEN_R = crate::R<bool, HSI16DIVEN_A>;
        impl HSI16DIVEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSI16DIVEN_A {
                match self.bits {
                    false => HSI16DIVEN_A::NOTDIVIDED,
                    true => HSI16DIVEN_A::DIV4,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDIVIDED`"]
            #[inline(always)]
            pub fn is_not_divided(&self) -> bool {
                *self == HSI16DIVEN_A::NOTDIVIDED
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == HSI16DIVEN_A::DIV4
            }
        }
        #[doc = "Write proxy for field `HSI16DIVEN`"]
        pub struct HSI16DIVEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSI16DIVEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSI16DIVEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "no 16 MHz HSI division requested"]
            #[inline(always)]
            pub fn not_divided(self) -> &'a mut W {
                self.variant(HSI16DIVEN_A::NOTDIVIDED)
            }
            #[doc = "16 MHz HSI division by 4 requested"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(HSI16DIVEN_A::DIV4)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Internal high-speed clock ready flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSI16RDYF_A {
            #[doc = "0: HSI 16 MHz oscillator not ready"]
            NOTREADY = 0,
            #[doc = "1: HSI 16 MHz oscillator ready"]
            READY = 1,
        }
        impl From<HSI16RDYF_A> for bool {
            #[inline(always)]
            fn from(variant: HSI16RDYF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSI16RDYF`"]
        pub type HSI16RDYF_R = crate::R<bool, HSI16RDYF_A>;
        impl HSI16RDYF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSI16RDYF_A {
                match self.bits {
                    false => HSI16RDYF_A::NOTREADY,
                    true => HSI16RDYF_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == HSI16RDYF_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == HSI16RDYF_A::READY
            }
        }
        #[doc = "Write proxy for field `HSI16RDYF`"]
        pub struct HSI16RDYF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSI16RDYF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSI16RDYF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSI 16 MHz oscillator not ready"]
            #[inline(always)]
            pub fn not_ready(self) -> &'a mut W {
                self.variant(HSI16RDYF_A::NOTREADY)
            }
            #[doc = "HSI 16 MHz oscillator ready"]
            #[inline(always)]
            pub fn ready(self) -> &'a mut W {
                self.variant(HSI16RDYF_A::READY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "High-speed internal clock enable bit for some IP kernels"]
        pub type HSI16KERON_A = PLLON_A;
        #[doc = "Reader of field `HSI16KERON`"]
        pub type HSI16KERON_R = crate::R<bool, PLLON_A>;
        #[doc = "16 MHz high-speed internal clock enable"]
        pub type HSI16ON_A = PLLON_A;
        #[doc = "Reader of field `HSI16ON`"]
        pub type HSI16ON_R = crate::R<bool, PLLON_A>;
        #[doc = "Write proxy for field `HSI16ON`"]
        pub struct HSI16ON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSI16ON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSI16ON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLON_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLON_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "16 MHz high-speed internal clock output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSI16OUTEN_A {
            #[doc = "0: HSI output clock disabled"]
            DISABLED = 0,
            #[doc = "1: HSI output clock enabled"]
            ENABLED = 1,
        }
        impl From<HSI16OUTEN_A> for bool {
            #[inline(always)]
            fn from(variant: HSI16OUTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HSI16OUTEN`"]
        pub type HSI16OUTEN_R = crate::R<bool, HSI16OUTEN_A>;
        impl HSI16OUTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HSI16OUTEN_A {
                match self.bits {
                    false => HSI16OUTEN_A::DISABLED,
                    true => HSI16OUTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == HSI16OUTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == HSI16OUTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `HSI16OUTEN`"]
        pub struct HSI16OUTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSI16OUTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HSI16OUTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSI output clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HSI16OUTEN_A::DISABLED)
            }
            #[doc = "HSI output clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HSI16OUTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 25 - PLL clock ready flag"]
            #[inline(always)]
            pub fn pllrdy(&self) -> PLLRDY_R {
                PLLRDY_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 24 - PLL enable bit"]
            #[inline(always)]
            pub fn pllon(&self) -> PLLON_R {
                PLLON_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - TC/LCD prescaler"]
            #[inline(always)]
            pub fn rtcpre(&self) -> RTCPRE_R {
                RTCPRE_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bit 19 - Clock security system on HSE enable bit"]
            #[inline(always)]
            pub fn csshseon(&self) -> CSSHSEON_R {
                CSSHSEON_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - HSE clock bypass bit"]
            #[inline(always)]
            pub fn hsebyp(&self) -> HSEBYP_R {
                HSEBYP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - HSE clock ready flag"]
            #[inline(always)]
            pub fn hserdy(&self) -> HSERDY_R {
                HSERDY_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - HSE clock enable bit"]
            #[inline(always)]
            pub fn hseon(&self) -> HSEON_R {
                HSEON_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 9 - MSI clock ready flag"]
            #[inline(always)]
            pub fn msirdy(&self) -> MSIRDY_R {
                MSIRDY_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - MSI clock enable bit"]
            #[inline(always)]
            pub fn msion(&self) -> MSION_R {
                MSION_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 4 - HSI16DIVF"]
            #[inline(always)]
            pub fn hsi16divf(&self) -> HSI16DIVF_R {
                HSI16DIVF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - HSI16DIVEN"]
            #[inline(always)]
            pub fn hsi16diven(&self) -> HSI16DIVEN_R {
                HSI16DIVEN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Internal high-speed clock ready flag"]
            #[inline(always)]
            pub fn hsi16rdyf(&self) -> HSI16RDYF_R {
                HSI16RDYF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - High-speed internal clock enable bit for some IP kernels"]
            #[inline(always)]
            pub fn hsi16keron(&self) -> HSI16KERON_R {
                HSI16KERON_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - 16 MHz high-speed internal clock enable"]
            #[inline(always)]
            pub fn hsi16on(&self) -> HSI16ON_R {
                HSI16ON_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 5 - 16 MHz high-speed internal clock output enable"]
            #[inline(always)]
            pub fn hsi16outen(&self) -> HSI16OUTEN_R {
                HSI16OUTEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 24 - PLL enable bit"]
            #[inline(always)]
            pub fn pllon(&mut self) -> PLLON_W {
                PLLON_W { w: self }
            }
            #[doc = "Bits 20:21 - TC/LCD prescaler"]
            #[inline(always)]
            pub fn rtcpre(&mut self) -> RTCPRE_W {
                RTCPRE_W { w: self }
            }
            #[doc = "Bit 19 - Clock security system on HSE enable bit"]
            #[inline(always)]
            pub fn csshseon(&mut self) -> CSSHSEON_W {
                CSSHSEON_W { w: self }
            }
            #[doc = "Bit 18 - HSE clock bypass bit"]
            #[inline(always)]
            pub fn hsebyp(&mut self) -> HSEBYP_W {
                HSEBYP_W { w: self }
            }
            #[doc = "Bit 16 - HSE clock enable bit"]
            #[inline(always)]
            pub fn hseon(&mut self) -> HSEON_W {
                HSEON_W { w: self }
            }
            #[doc = "Bit 8 - MSI clock enable bit"]
            #[inline(always)]
            pub fn msion(&mut self) -> MSION_W {
                MSION_W { w: self }
            }
            #[doc = "Bit 3 - HSI16DIVEN"]
            #[inline(always)]
            pub fn hsi16diven(&mut self) -> HSI16DIVEN_W {
                HSI16DIVEN_W { w: self }
            }
            #[doc = "Bit 2 - Internal high-speed clock ready flag"]
            #[inline(always)]
            pub fn hsi16rdyf(&mut self) -> HSI16RDYF_W {
                HSI16RDYF_W { w: self }
            }
            #[doc = "Bit 0 - 16 MHz high-speed internal clock enable"]
            #[inline(always)]
            pub fn hsi16on(&mut self) -> HSI16ON_W {
                HSI16ON_W { w: self }
            }
            #[doc = "Bit 5 - 16 MHz high-speed internal clock output enable"]
            #[inline(always)]
            pub fn hsi16outen(&mut self) -> HSI16OUTEN_W {
                HSI16OUTEN_W { w: self }
            }
        }
    }
    #[doc = "Internal clock sources calibration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icscr](icscr) module"]
    pub type ICSCR = crate::Reg<u32, _ICSCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICSCR;
    #[doc = "`read()` method returns [icscr::R](icscr::R) reader structure"]
    impl crate::Readable for ICSCR {}
    #[doc = "`write(|w| ..)` method takes [icscr::W](icscr::W) writer structure"]
    impl crate::Writable for ICSCR {}
    #[doc = "Internal clock sources calibration register"]
    pub mod icscr {
        #[doc = "Reader of register ICSCR"]
        pub type R = crate::R<u32, super::ICSCR>;
        #[doc = "Writer for register ICSCR"]
        pub type W = crate::W<u32, super::ICSCR>;
        #[doc = "Register ICSCR `reset()`'s with value 0xb000"]
        impl crate::ResetValue for super::ICSCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xb000
            }
        }
        #[doc = "Reader of field `MSITRIM`"]
        pub type MSITRIM_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `MSITRIM`"]
        pub struct MSITRIM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSITRIM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `MSICAL`"]
        pub type MSICAL_R = crate::R<u8, u8>;
        #[doc = "MSI clock ranges\n\nValue on reset: 5"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MSIRANGE_A {
            #[doc = "0: range 0 around 65.536 kHz"]
            RANGE0 = 0,
            #[doc = "1: range 1 around 131.072 kHz"]
            RANGE1 = 1,
            #[doc = "2: range 2 around 262.144 kHz"]
            RANGE2 = 2,
            #[doc = "3: range 3 around 524.288 kHz"]
            RANGE3 = 3,
            #[doc = "4: range 4 around 1.048 MHz"]
            RANGE4 = 4,
            #[doc = "5: range 5 around 2.097 MHz (reset value)"]
            RANGE5 = 5,
            #[doc = "6: range 6 around 4.194 MHz"]
            RANGE6 = 6,
            #[doc = "7: not allowed"]
            RANGE7 = 7,
        }
        impl From<MSIRANGE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIRANGE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MSIRANGE`"]
        pub type MSIRANGE_R = crate::R<u8, MSIRANGE_A>;
        impl MSIRANGE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSIRANGE_A {
                match self.bits {
                    0 => MSIRANGE_A::RANGE0,
                    1 => MSIRANGE_A::RANGE1,
                    2 => MSIRANGE_A::RANGE2,
                    3 => MSIRANGE_A::RANGE3,
                    4 => MSIRANGE_A::RANGE4,
                    5 => MSIRANGE_A::RANGE5,
                    6 => MSIRANGE_A::RANGE6,
                    7 => MSIRANGE_A::RANGE7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `RANGE0`"]
            #[inline(always)]
            pub fn is_range0(&self) -> bool {
                *self == MSIRANGE_A::RANGE0
            }
            #[doc = "Checks if the value of the field is `RANGE1`"]
            #[inline(always)]
            pub fn is_range1(&self) -> bool {
                *self == MSIRANGE_A::RANGE1
            }
            #[doc = "Checks if the value of the field is `RANGE2`"]
            #[inline(always)]
            pub fn is_range2(&self) -> bool {
                *self == MSIRANGE_A::RANGE2
            }
            #[doc = "Checks if the value of the field is `RANGE3`"]
            #[inline(always)]
            pub fn is_range3(&self) -> bool {
                *self == MSIRANGE_A::RANGE3
            }
            #[doc = "Checks if the value of the field is `RANGE4`"]
            #[inline(always)]
            pub fn is_range4(&self) -> bool {
                *self == MSIRANGE_A::RANGE4
            }
            #[doc = "Checks if the value of the field is `RANGE5`"]
            #[inline(always)]
            pub fn is_range5(&self) -> bool {
                *self == MSIRANGE_A::RANGE5
            }
            #[doc = "Checks if the value of the field is `RANGE6`"]
            #[inline(always)]
            pub fn is_range6(&self) -> bool {
                *self == MSIRANGE_A::RANGE6
            }
            #[doc = "Checks if the value of the field is `RANGE7`"]
            #[inline(always)]
            pub fn is_range7(&self) -> bool {
                *self == MSIRANGE_A::RANGE7
            }
        }
        #[doc = "Write proxy for field `MSIRANGE`"]
        pub struct MSIRANGE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSIRANGE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSIRANGE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "range 0 around 65.536 kHz"]
            #[inline(always)]
            pub fn range0(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE0)
            }
            #[doc = "range 1 around 131.072 kHz"]
            #[inline(always)]
            pub fn range1(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE1)
            }
            #[doc = "range 2 around 262.144 kHz"]
            #[inline(always)]
            pub fn range2(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE2)
            }
            #[doc = "range 3 around 524.288 kHz"]
            #[inline(always)]
            pub fn range3(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE3)
            }
            #[doc = "range 4 around 1.048 MHz"]
            #[inline(always)]
            pub fn range4(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE4)
            }
            #[doc = "range 5 around 2.097 MHz (reset value)"]
            #[inline(always)]
            pub fn range5(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE5)
            }
            #[doc = "range 6 around 4.194 MHz"]
            #[inline(always)]
            pub fn range6(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE6)
            }
            #[doc = "not allowed"]
            #[inline(always)]
            pub fn range7(self) -> &'a mut W {
                self.variant(MSIRANGE_A::RANGE7)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 13)) | (((value as u32) & 0x07) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `HSI16TRIM`"]
        pub type HSI16TRIM_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `HSI16TRIM`"]
        pub struct HSI16TRIM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSI16TRIM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `HSI16CAL`"]
        pub type HSI16CAL_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 24:31 - MSI clock trimming"]
            #[inline(always)]
            pub fn msitrim(&self) -> MSITRIM_R {
                MSITRIM_R::new(((self.bits >> 24) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - MSI clock calibration"]
            #[inline(always)]
            pub fn msical(&self) -> MSICAL_R {
                MSICAL_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 13:15 - MSI clock ranges"]
            #[inline(always)]
            pub fn msirange(&self) -> MSIRANGE_R {
                MSIRANGE_R::new(((self.bits >> 13) & 0x07) as u8)
            }
            #[doc = "Bits 8:12 - High speed internal clock trimming"]
            #[inline(always)]
            pub fn hsi16trim(&self) -> HSI16TRIM_R {
                HSI16TRIM_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 0:7 - nternal high speed clock calibration"]
            #[inline(always)]
            pub fn hsi16cal(&self) -> HSI16CAL_R {
                HSI16CAL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 24:31 - MSI clock trimming"]
            #[inline(always)]
            pub fn msitrim(&mut self) -> MSITRIM_W {
                MSITRIM_W { w: self }
            }
            #[doc = "Bits 13:15 - MSI clock ranges"]
            #[inline(always)]
            pub fn msirange(&mut self) -> MSIRANGE_W {
                MSIRANGE_W { w: self }
            }
            #[doc = "Bits 8:12 - High speed internal clock trimming"]
            #[inline(always)]
            pub fn hsi16trim(&mut self) -> HSI16TRIM_W {
                HSI16TRIM_W { w: self }
            }
        }
    }
    #[doc = "Clock configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr](cfgr) module"]
    pub type CFGR = crate::Reg<u32, _CFGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR;
    #[doc = "`read()` method returns [cfgr::R](cfgr::R) reader structure"]
    impl crate::Readable for CFGR {}
    #[doc = "`write(|w| ..)` method takes [cfgr::W](cfgr::W) writer structure"]
    impl crate::Writable for CFGR {}
    #[doc = "Clock configuration register"]
    pub mod cfgr {
        #[doc = "Reader of register CFGR"]
        pub type R = crate::R<u32, super::CFGR>;
        #[doc = "Writer for register CFGR"]
        pub type W = crate::W<u32, super::CFGR>;
        #[doc = "Register CFGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Microcontroller clock output prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MCOPRE_A {
            #[doc = "0: No division"]
            DIV1 = 0,
            #[doc = "1: Division by 2"]
            DIV2 = 1,
            #[doc = "2: Division by 4"]
            DIV4 = 2,
            #[doc = "3: Division by 8"]
            DIV8 = 3,
            #[doc = "4: Division by 16"]
            DIV16 = 4,
        }
        impl From<MCOPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: MCOPRE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MCOPRE`"]
        pub type MCOPRE_R = crate::R<u8, MCOPRE_A>;
        impl MCOPRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MCOPRE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MCOPRE_A::DIV1),
                    1 => Val(MCOPRE_A::DIV2),
                    2 => Val(MCOPRE_A::DIV4),
                    3 => Val(MCOPRE_A::DIV8),
                    4 => Val(MCOPRE_A::DIV16),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == MCOPRE_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == MCOPRE_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == MCOPRE_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == MCOPRE_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == MCOPRE_A::DIV16
            }
        }
        #[doc = "Write proxy for field `MCOPRE`"]
        pub struct MCOPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MCOPRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MCOPRE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "No division"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(MCOPRE_A::DIV1)
            }
            #[doc = "Division by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(MCOPRE_A::DIV2)
            }
            #[doc = "Division by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(MCOPRE_A::DIV4)
            }
            #[doc = "Division by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(MCOPRE_A::DIV8)
            }
            #[doc = "Division by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(MCOPRE_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 28)) | (((value as u32) & 0x07) << 28);
                self.w
            }
        }
        #[doc = "Microcontroller clock output selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MCOSEL_A {
            #[doc = "0: No clock"]
            NOCLOCK = 0,
            #[doc = "1: SYSCLK clock selected"]
            SYSCLK = 1,
            #[doc = "2: HSI oscillator clock selected"]
            HSI16 = 2,
            #[doc = "3: MSI oscillator clock selected"]
            MSI = 3,
            #[doc = "4: HSE oscillator clock selected"]
            HSE = 4,
            #[doc = "5: PLL clock selected"]
            PLL = 5,
            #[doc = "6: LSI oscillator clock selected"]
            LSI = 6,
            #[doc = "7: LSE oscillator clock selected"]
            LSE = 7,
        }
        impl From<MCOSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: MCOSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MCOSEL`"]
        pub type MCOSEL_R = crate::R<u8, MCOSEL_A>;
        impl MCOSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MCOSEL_A {
                match self.bits {
                    0 => MCOSEL_A::NOCLOCK,
                    1 => MCOSEL_A::SYSCLK,
                    2 => MCOSEL_A::HSI16,
                    3 => MCOSEL_A::MSI,
                    4 => MCOSEL_A::HSE,
                    5 => MCOSEL_A::PLL,
                    6 => MCOSEL_A::LSI,
                    7 => MCOSEL_A::LSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOCLOCK`"]
            #[inline(always)]
            pub fn is_no_clock(&self) -> bool {
                *self == MCOSEL_A::NOCLOCK
            }
            #[doc = "Checks if the value of the field is `SYSCLK`"]
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                *self == MCOSEL_A::SYSCLK
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == MCOSEL_A::HSI16
            }
            #[doc = "Checks if the value of the field is `MSI`"]
            #[inline(always)]
            pub fn is_msi(&self) -> bool {
                *self == MCOSEL_A::MSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == MCOSEL_A::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == MCOSEL_A::PLL
            }
            #[doc = "Checks if the value of the field is `LSI`"]
            #[inline(always)]
            pub fn is_lsi(&self) -> bool {
                *self == MCOSEL_A::LSI
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == MCOSEL_A::LSE
            }
        }
        #[doc = "Write proxy for field `MCOSEL`"]
        pub struct MCOSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MCOSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MCOSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No clock"]
            #[inline(always)]
            pub fn no_clock(self) -> &'a mut W {
                self.variant(MCOSEL_A::NOCLOCK)
            }
            #[doc = "SYSCLK clock selected"]
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut W {
                self.variant(MCOSEL_A::SYSCLK)
            }
            #[doc = "HSI oscillator clock selected"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(MCOSEL_A::HSI16)
            }
            #[doc = "MSI oscillator clock selected"]
            #[inline(always)]
            pub fn msi(self) -> &'a mut W {
                self.variant(MCOSEL_A::MSI)
            }
            #[doc = "HSE oscillator clock selected"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(MCOSEL_A::HSE)
            }
            #[doc = "PLL clock selected"]
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(MCOSEL_A::PLL)
            }
            #[doc = "LSI oscillator clock selected"]
            #[inline(always)]
            pub fn lsi(self) -> &'a mut W {
                self.variant(MCOSEL_A::LSI)
            }
            #[doc = "LSE oscillator clock selected"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(MCOSEL_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | (((value as u32) & 0x07) << 24);
                self.w
            }
        }
        #[doc = "PLL output division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PLLDIV_A {
            #[doc = "1: PLLVCO / 2"]
            DIV2 = 1,
            #[doc = "2: PLLVCO / 3"]
            DIV3 = 2,
            #[doc = "3: PLLVCO / 4"]
            DIV4 = 3,
        }
        impl From<PLLDIV_A> for u8 {
            #[inline(always)]
            fn from(variant: PLLDIV_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PLLDIV`"]
        pub type PLLDIV_R = crate::R<u8, PLLDIV_A>;
        impl PLLDIV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PLLDIV_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(PLLDIV_A::DIV2),
                    2 => Val(PLLDIV_A::DIV3),
                    3 => Val(PLLDIV_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PLLDIV_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV3`"]
            #[inline(always)]
            pub fn is_div3(&self) -> bool {
                *self == PLLDIV_A::DIV3
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PLLDIV_A::DIV4
            }
        }
        #[doc = "Write proxy for field `PLLDIV`"]
        pub struct PLLDIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLDIV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLDIV_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "PLLVCO / 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PLLDIV_A::DIV2)
            }
            #[doc = "PLLVCO / 3"]
            #[inline(always)]
            pub fn div3(self) -> &'a mut W {
                self.variant(PLLDIV_A::DIV3)
            }
            #[doc = "PLLVCO / 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PLLDIV_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        #[doc = "PLL multiplication factor\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PLLMUL_A {
            #[doc = "0: PLL clock entry x 3"]
            MUL3 = 0,
            #[doc = "1: PLL clock entry x 4"]
            MUL4 = 1,
            #[doc = "2: PLL clock entry x 6"]
            MUL6 = 2,
            #[doc = "3: PLL clock entry x 8"]
            MUL8 = 3,
            #[doc = "4: PLL clock entry x 12"]
            MUL12 = 4,
            #[doc = "5: PLL clock entry x 16"]
            MUL16 = 5,
            #[doc = "6: PLL clock entry x 24"]
            MUL24 = 6,
            #[doc = "7: PLL clock entry x 32"]
            MUL32 = 7,
            #[doc = "8: PLL clock entry x 48"]
            MUL48 = 8,
        }
        impl From<PLLMUL_A> for u8 {
            #[inline(always)]
            fn from(variant: PLLMUL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PLLMUL`"]
        pub type PLLMUL_R = crate::R<u8, PLLMUL_A>;
        impl PLLMUL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PLLMUL_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(PLLMUL_A::MUL3),
                    1 => Val(PLLMUL_A::MUL4),
                    2 => Val(PLLMUL_A::MUL6),
                    3 => Val(PLLMUL_A::MUL8),
                    4 => Val(PLLMUL_A::MUL12),
                    5 => Val(PLLMUL_A::MUL16),
                    6 => Val(PLLMUL_A::MUL24),
                    7 => Val(PLLMUL_A::MUL32),
                    8 => Val(PLLMUL_A::MUL48),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MUL3`"]
            #[inline(always)]
            pub fn is_mul3(&self) -> bool {
                *self == PLLMUL_A::MUL3
            }
            #[doc = "Checks if the value of the field is `MUL4`"]
            #[inline(always)]
            pub fn is_mul4(&self) -> bool {
                *self == PLLMUL_A::MUL4
            }
            #[doc = "Checks if the value of the field is `MUL6`"]
            #[inline(always)]
            pub fn is_mul6(&self) -> bool {
                *self == PLLMUL_A::MUL6
            }
            #[doc = "Checks if the value of the field is `MUL8`"]
            #[inline(always)]
            pub fn is_mul8(&self) -> bool {
                *self == PLLMUL_A::MUL8
            }
            #[doc = "Checks if the value of the field is `MUL12`"]
            #[inline(always)]
            pub fn is_mul12(&self) -> bool {
                *self == PLLMUL_A::MUL12
            }
            #[doc = "Checks if the value of the field is `MUL16`"]
            #[inline(always)]
            pub fn is_mul16(&self) -> bool {
                *self == PLLMUL_A::MUL16
            }
            #[doc = "Checks if the value of the field is `MUL24`"]
            #[inline(always)]
            pub fn is_mul24(&self) -> bool {
                *self == PLLMUL_A::MUL24
            }
            #[doc = "Checks if the value of the field is `MUL32`"]
            #[inline(always)]
            pub fn is_mul32(&self) -> bool {
                *self == PLLMUL_A::MUL32
            }
            #[doc = "Checks if the value of the field is `MUL48`"]
            #[inline(always)]
            pub fn is_mul48(&self) -> bool {
                *self == PLLMUL_A::MUL48
            }
        }
        #[doc = "Write proxy for field `PLLMUL`"]
        pub struct PLLMUL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLMUL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLMUL_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "PLL clock entry x 3"]
            #[inline(always)]
            pub fn mul3(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL3)
            }
            #[doc = "PLL clock entry x 4"]
            #[inline(always)]
            pub fn mul4(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL4)
            }
            #[doc = "PLL clock entry x 6"]
            #[inline(always)]
            pub fn mul6(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL6)
            }
            #[doc = "PLL clock entry x 8"]
            #[inline(always)]
            pub fn mul8(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL8)
            }
            #[doc = "PLL clock entry x 12"]
            #[inline(always)]
            pub fn mul12(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL12)
            }
            #[doc = "PLL clock entry x 16"]
            #[inline(always)]
            pub fn mul16(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL16)
            }
            #[doc = "PLL clock entry x 24"]
            #[inline(always)]
            pub fn mul24(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL24)
            }
            #[doc = "PLL clock entry x 32"]
            #[inline(always)]
            pub fn mul32(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL32)
            }
            #[doc = "PLL clock entry x 48"]
            #[inline(always)]
            pub fn mul48(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL48)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 18)) | (((value as u32) & 0x0f) << 18);
                self.w
            }
        }
        #[doc = "PLL entry clock source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLSRC_A {
            #[doc = "0: HSI selected as PLL input clock"]
            HSI16 = 0,
            #[doc = "1: HSE selected as PLL input clock"]
            HSE = 1,
        }
        impl From<PLLSRC_A> for bool {
            #[inline(always)]
            fn from(variant: PLLSRC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PLLSRC`"]
        pub type PLLSRC_R = crate::R<bool, PLLSRC_A>;
        impl PLLSRC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLLSRC_A {
                match self.bits {
                    false => PLLSRC_A::HSI16,
                    true => PLLSRC_A::HSE,
                }
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == PLLSRC_A::HSI16
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == PLLSRC_A::HSE
            }
        }
        #[doc = "Write proxy for field `PLLSRC`"]
        pub struct PLLSRC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLSRC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLLSRC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "HSI selected as PLL input clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(PLLSRC_A::HSI16)
            }
            #[doc = "HSE selected as PLL input clock"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(PLLSRC_A::HSE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Wake-up from stop clock selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPWUCK_A {
            #[doc = "0: Internal 64 KHz to 4 MHz (MSI) oscillator selected as wake-up from Stop clock"]
            MSI = 0,
            #[doc = "1: Internal 16 MHz (HSI) oscillator selected as wake-up from Stop clock (or HSI16/4 if HSI16DIVEN=1)"]
            HSI16 = 1,
        }
        impl From<STOPWUCK_A> for bool {
            #[inline(always)]
            fn from(variant: STOPWUCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STOPWUCK`"]
        pub type STOPWUCK_R = crate::R<bool, STOPWUCK_A>;
        impl STOPWUCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOPWUCK_A {
                match self.bits {
                    false => STOPWUCK_A::MSI,
                    true => STOPWUCK_A::HSI16,
                }
            }
            #[doc = "Checks if the value of the field is `MSI`"]
            #[inline(always)]
            pub fn is_msi(&self) -> bool {
                *self == STOPWUCK_A::MSI
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == STOPWUCK_A::HSI16
            }
        }
        #[doc = "Write proxy for field `STOPWUCK`"]
        pub struct STOPWUCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOPWUCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOPWUCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Internal 64 KHz to 4 MHz (MSI) oscillator selected as wake-up from Stop clock"]
            #[inline(always)]
            pub fn msi(self) -> &'a mut W {
                self.variant(STOPWUCK_A::MSI)
            }
            #[doc = "Internal 16 MHz (HSI) oscillator selected as wake-up from Stop clock (or HSI16/4 if HSI16DIVEN=1)"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(STOPWUCK_A::HSI16)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "APB high-speed prescaler (APB2)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PPRE2_A {
            #[doc = "0: HCLK not divided"]
            DIV1 = 0,
            #[doc = "4: HCLK divided by 2"]
            DIV2 = 4,
            #[doc = "5: HCLK divided by 4"]
            DIV4 = 5,
            #[doc = "6: HCLK divided by 8"]
            DIV8 = 6,
            #[doc = "7: HCLK divided by 16"]
            DIV16 = 7,
        }
        impl From<PPRE2_A> for u8 {
            #[inline(always)]
            fn from(variant: PPRE2_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PPRE2`"]
        pub type PPRE2_R = crate::R<u8, PPRE2_A>;
        impl PPRE2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PPRE2_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(PPRE2_A::DIV1),
                    4 => Val(PPRE2_A::DIV2),
                    5 => Val(PPRE2_A::DIV4),
                    6 => Val(PPRE2_A::DIV8),
                    7 => Val(PPRE2_A::DIV16),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PPRE2_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PPRE2_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PPRE2_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PPRE2_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PPRE2_A::DIV16
            }
        }
        #[doc = "Write proxy for field `PPRE2`"]
        pub struct PPRE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PPRE2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PPRE2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "HCLK not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV1)
            }
            #[doc = "HCLK divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV2)
            }
            #[doc = "HCLK divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV4)
            }
            #[doc = "HCLK divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV8)
            }
            #[doc = "HCLK divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 11)) | (((value as u32) & 0x07) << 11);
                self.w
            }
        }
        #[doc = "APB low-speed prescaler (APB1)"]
        pub type PPRE1_A = PPRE2_A;
        #[doc = "Reader of field `PPRE1`"]
        pub type PPRE1_R = crate::R<u8, PPRE2_A>;
        #[doc = "Write proxy for field `PPRE1`"]
        pub struct PPRE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PPRE1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PPRE1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "HCLK not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV1)
            }
            #[doc = "HCLK divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV2)
            }
            #[doc = "HCLK divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV4)
            }
            #[doc = "HCLK divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV8)
            }
            #[doc = "HCLK divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 8)) | (((value as u32) & 0x07) << 8);
                self.w
            }
        }
        #[doc = "AHB prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum HPRE_A {
            #[doc = "0: system clock not divided"]
            DIV1 = 0,
            #[doc = "8: system clock divided by 2"]
            DIV2 = 8,
            #[doc = "9: system clock divided by 4"]
            DIV4 = 9,
            #[doc = "10: system clock divided by 8"]
            DIV8 = 10,
            #[doc = "11: system clock divided by 16"]
            DIV16 = 11,
            #[doc = "12: system clock divided by 64"]
            DIV64 = 12,
            #[doc = "13: system clock divided by 128"]
            DIV128 = 13,
            #[doc = "14: system clock divided by 256"]
            DIV256 = 14,
            #[doc = "15: system clock divided by 512"]
            DIV512 = 15,
        }
        impl From<HPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: HPRE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `HPRE`"]
        pub type HPRE_R = crate::R<u8, HPRE_A>;
        impl HPRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, HPRE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(HPRE_A::DIV1),
                    8 => Val(HPRE_A::DIV2),
                    9 => Val(HPRE_A::DIV4),
                    10 => Val(HPRE_A::DIV8),
                    11 => Val(HPRE_A::DIV16),
                    12 => Val(HPRE_A::DIV64),
                    13 => Val(HPRE_A::DIV128),
                    14 => Val(HPRE_A::DIV256),
                    15 => Val(HPRE_A::DIV512),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == HPRE_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == HPRE_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == HPRE_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == HPRE_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == HPRE_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == HPRE_A::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == HPRE_A::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == HPRE_A::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                *self == HPRE_A::DIV512
            }
        }
        #[doc = "Write proxy for field `HPRE`"]
        pub struct HPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HPRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HPRE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "system clock not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(HPRE_A::DIV1)
            }
            #[doc = "system clock divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(HPRE_A::DIV2)
            }
            #[doc = "system clock divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(HPRE_A::DIV4)
            }
            #[doc = "system clock divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(HPRE_A::DIV8)
            }
            #[doc = "system clock divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(HPRE_A::DIV16)
            }
            #[doc = "system clock divided by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(HPRE_A::DIV64)
            }
            #[doc = "system clock divided by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(HPRE_A::DIV128)
            }
            #[doc = "system clock divided by 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(HPRE_A::DIV256)
            }
            #[doc = "system clock divided by 512"]
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(HPRE_A::DIV512)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "System clock switch status\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SWS_A {
            #[doc = "0: MSI oscillator used as system clock"]
            MSI = 0,
            #[doc = "1: HSI oscillator used as system clock"]
            HSI16 = 1,
            #[doc = "2: HSE oscillator used as system clock"]
            HSE = 2,
            #[doc = "3: PLL used as system clock"]
            PLL = 3,
        }
        impl From<SWS_A> for u8 {
            #[inline(always)]
            fn from(variant: SWS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SWS`"]
        pub type SWS_R = crate::R<u8, SWS_A>;
        impl SWS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SWS_A {
                match self.bits {
                    0 => SWS_A::MSI,
                    1 => SWS_A::HSI16,
                    2 => SWS_A::HSE,
                    3 => SWS_A::PLL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MSI`"]
            #[inline(always)]
            pub fn is_msi(&self) -> bool {
                *self == SWS_A::MSI
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == SWS_A::HSI16
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == SWS_A::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == SWS_A::PLL
            }
        }
        #[doc = "System clock switch\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SW_A {
            #[doc = "0: MSI oscillator used as system clock"]
            MSI = 0,
            #[doc = "1: HSI oscillator used as system clock"]
            HSI16 = 1,
            #[doc = "2: HSE oscillator used as system clock"]
            HSE = 2,
            #[doc = "3: PLL used as system clock"]
            PLL = 3,
        }
        impl From<SW_A> for u8 {
            #[inline(always)]
            fn from(variant: SW_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SW`"]
        pub type SW_R = crate::R<u8, SW_A>;
        impl SW_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SW_A {
                match self.bits {
                    0 => SW_A::MSI,
                    1 => SW_A::HSI16,
                    2 => SW_A::HSE,
                    3 => SW_A::PLL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MSI`"]
            #[inline(always)]
            pub fn is_msi(&self) -> bool {
                *self == SW_A::MSI
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == SW_A::HSI16
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == SW_A::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == SW_A::PLL
            }
        }
        #[doc = "Write proxy for field `SW`"]
        pub struct SW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SW_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SW_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "MSI oscillator used as system clock"]
            #[inline(always)]
            pub fn msi(self) -> &'a mut W {
                self.variant(SW_A::MSI)
            }
            #[doc = "HSI oscillator used as system clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(SW_A::HSI16)
            }
            #[doc = "HSE oscillator used as system clock"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(SW_A::HSE)
            }
            #[doc = "PLL used as system clock"]
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(SW_A::PLL)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 28:30 - Microcontroller clock output prescaler"]
            #[inline(always)]
            pub fn mcopre(&self) -> MCOPRE_R {
                MCOPRE_R::new(((self.bits >> 28) & 0x07) as u8)
            }
            #[doc = "Bits 24:26 - Microcontroller clock output selection"]
            #[inline(always)]
            pub fn mcosel(&self) -> MCOSEL_R {
                MCOSEL_R::new(((self.bits >> 24) & 0x07) as u8)
            }
            #[doc = "Bits 22:23 - PLL output division"]
            #[inline(always)]
            pub fn plldiv(&self) -> PLLDIV_R {
                PLLDIV_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            #[doc = "Bits 18:21 - PLL multiplication factor"]
            #[inline(always)]
            pub fn pllmul(&self) -> PLLMUL_R {
                PLLMUL_R::new(((self.bits >> 18) & 0x0f) as u8)
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline(always)]
            pub fn pllsrc(&self) -> PLLSRC_R {
                PLLSRC_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Wake-up from stop clock selection"]
            #[inline(always)]
            pub fn stopwuck(&self) -> STOPWUCK_R {
                STOPWUCK_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 11:13 - APB high-speed prescaler (APB2)"]
            #[inline(always)]
            pub fn ppre2(&self) -> PPRE2_R {
                PPRE2_R::new(((self.bits >> 11) & 0x07) as u8)
            }
            #[doc = "Bits 8:10 - APB low-speed prescaler (APB1)"]
            #[inline(always)]
            pub fn ppre1(&self) -> PPRE1_R {
                PPRE1_R::new(((self.bits >> 8) & 0x07) as u8)
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline(always)]
            pub fn hpre(&self) -> HPRE_R {
                HPRE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - System clock switch status"]
            #[inline(always)]
            pub fn sws(&self) -> SWS_R {
                SWS_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - System clock switch"]
            #[inline(always)]
            pub fn sw(&self) -> SW_R {
                SW_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 28:30 - Microcontroller clock output prescaler"]
            #[inline(always)]
            pub fn mcopre(&mut self) -> MCOPRE_W {
                MCOPRE_W { w: self }
            }
            #[doc = "Bits 24:26 - Microcontroller clock output selection"]
            #[inline(always)]
            pub fn mcosel(&mut self) -> MCOSEL_W {
                MCOSEL_W { w: self }
            }
            #[doc = "Bits 22:23 - PLL output division"]
            #[inline(always)]
            pub fn plldiv(&mut self) -> PLLDIV_W {
                PLLDIV_W { w: self }
            }
            #[doc = "Bits 18:21 - PLL multiplication factor"]
            #[inline(always)]
            pub fn pllmul(&mut self) -> PLLMUL_W {
                PLLMUL_W { w: self }
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline(always)]
            pub fn pllsrc(&mut self) -> PLLSRC_W {
                PLLSRC_W { w: self }
            }
            #[doc = "Bit 15 - Wake-up from stop clock selection"]
            #[inline(always)]
            pub fn stopwuck(&mut self) -> STOPWUCK_W {
                STOPWUCK_W { w: self }
            }
            #[doc = "Bits 11:13 - APB high-speed prescaler (APB2)"]
            #[inline(always)]
            pub fn ppre2(&mut self) -> PPRE2_W {
                PPRE2_W { w: self }
            }
            #[doc = "Bits 8:10 - APB low-speed prescaler (APB1)"]
            #[inline(always)]
            pub fn ppre1(&mut self) -> PPRE1_W {
                PPRE1_W { w: self }
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline(always)]
            pub fn hpre(&mut self) -> HPRE_W {
                HPRE_W { w: self }
            }
            #[doc = "Bits 0:1 - System clock switch"]
            #[inline(always)]
            pub fn sw(&mut self) -> SW_W {
                SW_W { w: self }
            }
        }
    }
    #[doc = "Clock interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cier](cier) module"]
    pub type CIER = crate::Reg<u32, _CIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CIER;
    #[doc = "`read()` method returns [cier::R](cier::R) reader structure"]
    impl crate::Readable for CIER {}
    #[doc = "Clock interrupt enable register"]
    pub mod cier {
        #[doc = "Reader of register CIER"]
        pub type R = crate::R<u32, super::CIER>;
        #[doc = "LSE CSS interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSLSE_A {
            #[doc = "0: LSE CSS interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: LSE CSS interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CSSLSE_A> for bool {
            #[inline(always)]
            fn from(variant: CSSLSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSLSE`"]
        pub type CSSLSE_R = crate::R<bool, CSSLSE_A>;
        impl CSSLSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSLSE_A {
                match self.bits {
                    false => CSSLSE_A::DISABLED,
                    true => CSSLSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CSSLSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CSSLSE_A::ENABLED
            }
        }
        #[doc = "MSI ready interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSIRDYIE_A {
            #[doc = "0: Ready interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Ready interrupt enabled"]
            ENABLED = 1,
        }
        impl From<MSIRDYIE_A> for bool {
            #[inline(always)]
            fn from(variant: MSIRDYIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSIRDYIE`"]
        pub type MSIRDYIE_R = crate::R<bool, MSIRDYIE_A>;
        impl MSIRDYIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSIRDYIE_A {
                match self.bits {
                    false => MSIRDYIE_A::DISABLED,
                    true => MSIRDYIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MSIRDYIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MSIRDYIE_A::ENABLED
            }
        }
        #[doc = "PLL ready interrupt flag"]
        pub type PLLRDYIE_A = MSIRDYIE_A;
        #[doc = "Reader of field `PLLRDYIE`"]
        pub type PLLRDYIE_R = crate::R<bool, MSIRDYIE_A>;
        #[doc = "HSE ready interrupt flag"]
        pub type HSERDYIE_A = MSIRDYIE_A;
        #[doc = "Reader of field `HSERDYIE`"]
        pub type HSERDYIE_R = crate::R<bool, MSIRDYIE_A>;
        #[doc = "HSI16 ready interrupt flag"]
        pub type HSI16RDYIE_A = MSIRDYIE_A;
        #[doc = "Reader of field `HSI16RDYIE`"]
        pub type HSI16RDYIE_R = crate::R<bool, MSIRDYIE_A>;
        #[doc = "LSE ready interrupt flag"]
        pub type LSERDYIE_A = MSIRDYIE_A;
        #[doc = "Reader of field `LSERDYIE`"]
        pub type LSERDYIE_R = crate::R<bool, MSIRDYIE_A>;
        #[doc = "LSI ready interrupt flag"]
        pub type LSIRDYIE_A = MSIRDYIE_A;
        #[doc = "Reader of field `LSIRDYIE`"]
        pub type LSIRDYIE_R = crate::R<bool, MSIRDYIE_A>;
        impl R {
            #[doc = "Bit 7 - LSE CSS interrupt flag"]
            #[inline(always)]
            pub fn csslse(&self) -> CSSLSE_R {
                CSSLSE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - MSI ready interrupt flag"]
            #[inline(always)]
            pub fn msirdyie(&self) -> MSIRDYIE_R {
                MSIRDYIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - PLL ready interrupt flag"]
            #[inline(always)]
            pub fn pllrdyie(&self) -> PLLRDYIE_R {
                PLLRDYIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - HSE ready interrupt flag"]
            #[inline(always)]
            pub fn hserdyie(&self) -> HSERDYIE_R {
                HSERDYIE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - HSI16 ready interrupt flag"]
            #[inline(always)]
            pub fn hsi16rdyie(&self) -> HSI16RDYIE_R {
                HSI16RDYIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - LSE ready interrupt flag"]
            #[inline(always)]
            pub fn lserdyie(&self) -> LSERDYIE_R {
                LSERDYIE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - LSI ready interrupt flag"]
            #[inline(always)]
            pub fn lsirdyie(&self) -> LSIRDYIE_R {
                LSIRDYIE_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clock interrupt flag register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cifr](cifr) module"]
    pub type CIFR = crate::Reg<u32, _CIFR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CIFR;
    #[doc = "`read()` method returns [cifr::R](cifr::R) reader structure"]
    impl crate::Readable for CIFR {}
    #[doc = "Clock interrupt flag register"]
    pub mod cifr {
        #[doc = "Reader of register CIFR"]
        pub type R = crate::R<u32, super::CIFR>;
        #[doc = "Clock Security System Interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSHSEF_A {
            #[doc = "0: No clock security interrupt caused by HSE clock failure"]
            NOCLOCK = 0,
            #[doc = "1: Clock security interrupt caused by HSE clock failure"]
            CLOCK = 1,
        }
        impl From<CSSHSEF_A> for bool {
            #[inline(always)]
            fn from(variant: CSSHSEF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSHSEF`"]
        pub type CSSHSEF_R = crate::R<bool, CSSHSEF_A>;
        impl CSSHSEF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSHSEF_A {
                match self.bits {
                    false => CSSHSEF_A::NOCLOCK,
                    true => CSSHSEF_A::CLOCK,
                }
            }
            #[doc = "Checks if the value of the field is `NOCLOCK`"]
            #[inline(always)]
            pub fn is_no_clock(&self) -> bool {
                *self == CSSHSEF_A::NOCLOCK
            }
            #[doc = "Checks if the value of the field is `CLOCK`"]
            #[inline(always)]
            pub fn is_clock(&self) -> bool {
                *self == CSSHSEF_A::CLOCK
            }
        }
        #[doc = "LSE Clock Security System Interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSLSEF_A {
            #[doc = "0: No failure detected on LSE clock failure"]
            NOFAILURE = 0,
            #[doc = "1: Failure detected on LSE clock failure"]
            FAILURE = 1,
        }
        impl From<CSSLSEF_A> for bool {
            #[inline(always)]
            fn from(variant: CSSLSEF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSLSEF`"]
        pub type CSSLSEF_R = crate::R<bool, CSSLSEF_A>;
        impl CSSLSEF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSLSEF_A {
                match self.bits {
                    false => CSSLSEF_A::NOFAILURE,
                    true => CSSLSEF_A::FAILURE,
                }
            }
            #[doc = "Checks if the value of the field is `NOFAILURE`"]
            #[inline(always)]
            pub fn is_no_failure(&self) -> bool {
                *self == CSSLSEF_A::NOFAILURE
            }
            #[doc = "Checks if the value of the field is `FAILURE`"]
            #[inline(always)]
            pub fn is_failure(&self) -> bool {
                *self == CSSLSEF_A::FAILURE
            }
        }
        #[doc = "MSI ready interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSIRDYF_A {
            #[doc = "0: No clock ready interrupt"]
            NOTINTERRUPTED = 0,
            #[doc = "1: Clock ready interrupt"]
            INTERRUPTED = 1,
        }
        impl From<MSIRDYF_A> for bool {
            #[inline(always)]
            fn from(variant: MSIRDYF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSIRDYF`"]
        pub type MSIRDYF_R = crate::R<bool, MSIRDYF_A>;
        impl MSIRDYF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSIRDYF_A {
                match self.bits {
                    false => MSIRDYF_A::NOTINTERRUPTED,
                    true => MSIRDYF_A::INTERRUPTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINTERRUPTED`"]
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == MSIRDYF_A::NOTINTERRUPTED
            }
            #[doc = "Checks if the value of the field is `INTERRUPTED`"]
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == MSIRDYF_A::INTERRUPTED
            }
        }
        #[doc = "PLL ready interrupt flag"]
        pub type PLLRDYF_A = MSIRDYF_A;
        #[doc = "Reader of field `PLLRDYF`"]
        pub type PLLRDYF_R = crate::R<bool, MSIRDYF_A>;
        #[doc = "HSE ready interrupt flag"]
        pub type HSERDYF_A = MSIRDYF_A;
        #[doc = "Reader of field `HSERDYF`"]
        pub type HSERDYF_R = crate::R<bool, MSIRDYF_A>;
        #[doc = "HSI16 ready interrupt flag"]
        pub type HSI16RDYF_A = MSIRDYF_A;
        #[doc = "Reader of field `HSI16RDYF`"]
        pub type HSI16RDYF_R = crate::R<bool, MSIRDYF_A>;
        #[doc = "LSE ready interrupt flag"]
        pub type LSERDYF_A = MSIRDYF_A;
        #[doc = "Reader of field `LSERDYF`"]
        pub type LSERDYF_R = crate::R<bool, MSIRDYF_A>;
        #[doc = "LSI ready interrupt flag"]
        pub type LSIRDYF_A = MSIRDYF_A;
        #[doc = "Reader of field `LSIRDYF`"]
        pub type LSIRDYF_R = crate::R<bool, MSIRDYF_A>;
        impl R {
            #[doc = "Bit 8 - Clock Security System Interrupt flag"]
            #[inline(always)]
            pub fn csshsef(&self) -> CSSHSEF_R {
                CSSHSEF_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - LSE Clock Security System Interrupt flag"]
            #[inline(always)]
            pub fn csslsef(&self) -> CSSLSEF_R {
                CSSLSEF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - MSI ready interrupt flag"]
            #[inline(always)]
            pub fn msirdyf(&self) -> MSIRDYF_R {
                MSIRDYF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - PLL ready interrupt flag"]
            #[inline(always)]
            pub fn pllrdyf(&self) -> PLLRDYF_R {
                PLLRDYF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - HSE ready interrupt flag"]
            #[inline(always)]
            pub fn hserdyf(&self) -> HSERDYF_R {
                HSERDYF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - HSI16 ready interrupt flag"]
            #[inline(always)]
            pub fn hsi16rdyf(&self) -> HSI16RDYF_R {
                HSI16RDYF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - LSE ready interrupt flag"]
            #[inline(always)]
            pub fn lserdyf(&self) -> LSERDYF_R {
                LSERDYF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - LSI ready interrupt flag"]
            #[inline(always)]
            pub fn lsirdyf(&self) -> LSIRDYF_R {
                LSIRDYF_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clock interrupt clear register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cicr](cicr) module"]
    pub type CICR = crate::Reg<u32, _CICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CICR;
    #[doc = "`read()` method returns [cicr::R](cicr::R) reader structure"]
    impl crate::Readable for CICR {}
    #[doc = "Clock interrupt clear register"]
    pub mod cicr {
        #[doc = "Reader of register CICR"]
        pub type R = crate::R<u32, super::CICR>;
        #[doc = "Clock Security System Interrupt clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSHSEC_A {
            #[doc = "1: Clear interrupt flag"]
            CLEAR = 1,
        }
        impl From<CSSHSEC_A> for bool {
            #[inline(always)]
            fn from(variant: CSSHSEC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSHSEC`"]
        pub type CSSHSEC_R = crate::R<bool, CSSHSEC_A>;
        impl CSSHSEC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CSSHSEC_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CSSHSEC_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CSSHSEC_A::CLEAR
            }
        }
        #[doc = "LSE Clock Security System Interrupt clear"]
        pub type CSSLSEC_A = CSSHSEC_A;
        #[doc = "Reader of field `CSSLSEC`"]
        pub type CSSLSEC_R = crate::R<bool, CSSHSEC_A>;
        #[doc = "MSI ready Interrupt clear"]
        pub type MSIRDYC_A = CSSHSEC_A;
        #[doc = "Reader of field `MSIRDYC`"]
        pub type MSIRDYC_R = crate::R<bool, CSSHSEC_A>;
        #[doc = "PLL ready Interrupt clear"]
        pub type PLLRDYC_A = CSSHSEC_A;
        #[doc = "Reader of field `PLLRDYC`"]
        pub type PLLRDYC_R = crate::R<bool, CSSHSEC_A>;
        #[doc = "HSE ready Interrupt clear"]
        pub type HSERDYC_A = CSSHSEC_A;
        #[doc = "Reader of field `HSERDYC`"]
        pub type HSERDYC_R = crate::R<bool, CSSHSEC_A>;
        #[doc = "HSI16 ready Interrupt clear"]
        pub type HSI16RDYC_A = CSSHSEC_A;
        #[doc = "Reader of field `HSI16RDYC`"]
        pub type HSI16RDYC_R = crate::R<bool, CSSHSEC_A>;
        #[doc = "LSE ready Interrupt clear"]
        pub type LSERDYC_A = CSSHSEC_A;
        #[doc = "Reader of field `LSERDYC`"]
        pub type LSERDYC_R = crate::R<bool, CSSHSEC_A>;
        #[doc = "LSI ready Interrupt clear"]
        pub type LSIRDYC_A = CSSHSEC_A;
        #[doc = "Reader of field `LSIRDYC`"]
        pub type LSIRDYC_R = crate::R<bool, CSSHSEC_A>;
        impl R {
            #[doc = "Bit 8 - Clock Security System Interrupt clear"]
            #[inline(always)]
            pub fn csshsec(&self) -> CSSHSEC_R {
                CSSHSEC_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - LSE Clock Security System Interrupt clear"]
            #[inline(always)]
            pub fn csslsec(&self) -> CSSLSEC_R {
                CSSLSEC_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - MSI ready Interrupt clear"]
            #[inline(always)]
            pub fn msirdyc(&self) -> MSIRDYC_R {
                MSIRDYC_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - PLL ready Interrupt clear"]
            #[inline(always)]
            pub fn pllrdyc(&self) -> PLLRDYC_R {
                PLLRDYC_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - HSE ready Interrupt clear"]
            #[inline(always)]
            pub fn hserdyc(&self) -> HSERDYC_R {
                HSERDYC_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - HSI16 ready Interrupt clear"]
            #[inline(always)]
            pub fn hsi16rdyc(&self) -> HSI16RDYC_R {
                HSI16RDYC_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - LSE ready Interrupt clear"]
            #[inline(always)]
            pub fn lserdyc(&self) -> LSERDYC_R {
                LSERDYC_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - LSI ready Interrupt clear"]
            #[inline(always)]
            pub fn lsirdyc(&self) -> LSIRDYC_R {
                LSIRDYC_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "GPIO reset register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ioprstr](ioprstr) module"]
    pub type IOPRSTR = crate::Reg<u32, _IOPRSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IOPRSTR;
    #[doc = "`read()` method returns [ioprstr::R](ioprstr::R) reader structure"]
    impl crate::Readable for IOPRSTR {}
    #[doc = "`write(|w| ..)` method takes [ioprstr::W](ioprstr::W) writer structure"]
    impl crate::Writable for IOPRSTR {}
    #[doc = "GPIO reset register"]
    pub mod ioprstr {
        #[doc = "Reader of register IOPRSTR"]
        pub type R = crate::R<u32, super::IOPRSTR>;
        #[doc = "Writer for register IOPRSTR"]
        pub type W = crate::W<u32, super::IOPRSTR>;
        #[doc = "Register IOPRSTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IOPRSTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "I/O port H reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOPHRST_A {
            #[doc = "1: Reset I/O port"]
            RESET = 1,
        }
        impl From<IOPHRST_A> for bool {
            #[inline(always)]
            fn from(variant: IOPHRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IOPHRST`"]
        pub type IOPHRST_R = crate::R<bool, IOPHRST_A>;
        impl IOPHRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, IOPHRST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(IOPHRST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == IOPHRST_A::RESET
            }
        }
        #[doc = "Write proxy for field `IOPHRST`"]
        pub struct IOPHRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPHRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPHRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset I/O port"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPHRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "I/O port D reset"]
        pub type IOPDRST_A = IOPHRST_A;
        #[doc = "Reader of field `IOPDRST`"]
        pub type IOPDRST_R = crate::R<bool, IOPHRST_A>;
        #[doc = "Write proxy for field `IOPDRST`"]
        pub struct IOPDRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPDRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset I/O port"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPHRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "I/O port A reset"]
        pub type IOPCRST_A = IOPHRST_A;
        #[doc = "Reader of field `IOPCRST`"]
        pub type IOPCRST_R = crate::R<bool, IOPHRST_A>;
        #[doc = "Write proxy for field `IOPCRST`"]
        pub struct IOPCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPCRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset I/O port"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPHRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "I/O port B reset"]
        pub type IOPBRST_A = IOPHRST_A;
        #[doc = "Reader of field `IOPBRST`"]
        pub type IOPBRST_R = crate::R<bool, IOPHRST_A>;
        #[doc = "Write proxy for field `IOPBRST`"]
        pub struct IOPBRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPBRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset I/O port"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPHRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "I/O port A reset"]
        pub type IOPARST_A = IOPHRST_A;
        #[doc = "Reader of field `IOPARST`"]
        pub type IOPARST_R = crate::R<bool, IOPHRST_A>;
        #[doc = "Write proxy for field `IOPARST`"]
        pub struct IOPARST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPARST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPARST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset I/O port"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPHRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "I/O port E reset"]
        pub type IOPERST_A = IOPHRST_A;
        #[doc = "Reader of field `IOPERST`"]
        pub type IOPERST_R = crate::R<bool, IOPHRST_A>;
        #[doc = "Write proxy for field `IOPERST`"]
        pub struct IOPERST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPERST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPERST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset I/O port"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPHRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - I/O port H reset"]
            #[inline(always)]
            pub fn iophrst(&self) -> IOPHRST_R {
                IOPHRST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - I/O port D reset"]
            #[inline(always)]
            pub fn iopdrst(&self) -> IOPDRST_R {
                IOPDRST_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - I/O port A reset"]
            #[inline(always)]
            pub fn iopcrst(&self) -> IOPCRST_R {
                IOPCRST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - I/O port B reset"]
            #[inline(always)]
            pub fn iopbrst(&self) -> IOPBRST_R {
                IOPBRST_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - I/O port A reset"]
            #[inline(always)]
            pub fn ioparst(&self) -> IOPARST_R {
                IOPARST_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 4 - I/O port E reset"]
            #[inline(always)]
            pub fn ioperst(&self) -> IOPERST_R {
                IOPERST_R::new(((self.bits >> 4) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - I/O port H reset"]
            #[inline(always)]
            pub fn iophrst(&mut self) -> IOPHRST_W {
                IOPHRST_W { w: self }
            }
            #[doc = "Bit 3 - I/O port D reset"]
            #[inline(always)]
            pub fn iopdrst(&mut self) -> IOPDRST_W {
                IOPDRST_W { w: self }
            }
            #[doc = "Bit 2 - I/O port A reset"]
            #[inline(always)]
            pub fn iopcrst(&mut self) -> IOPCRST_W {
                IOPCRST_W { w: self }
            }
            #[doc = "Bit 1 - I/O port B reset"]
            #[inline(always)]
            pub fn iopbrst(&mut self) -> IOPBRST_W {
                IOPBRST_W { w: self }
            }
            #[doc = "Bit 0 - I/O port A reset"]
            #[inline(always)]
            pub fn ioparst(&mut self) -> IOPARST_W {
                IOPARST_W { w: self }
            }
            #[doc = "Bit 4 - I/O port E reset"]
            #[inline(always)]
            pub fn ioperst(&mut self) -> IOPERST_W {
                IOPERST_W { w: self }
            }
        }
    }
    #[doc = "AHB peripheral reset register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ahbrstr](ahbrstr) module"]
    pub type AHBRSTR = crate::Reg<u32, _AHBRSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AHBRSTR;
    #[doc = "`read()` method returns [ahbrstr::R](ahbrstr::R) reader structure"]
    impl crate::Readable for AHBRSTR {}
    #[doc = "`write(|w| ..)` method takes [ahbrstr::W](ahbrstr::W) writer structure"]
    impl crate::Writable for AHBRSTR {}
    #[doc = "AHB peripheral reset register"]
    pub mod ahbrstr {
        #[doc = "Reader of register AHBRSTR"]
        pub type R = crate::R<u32, super::AHBRSTR>;
        #[doc = "Writer for register AHBRSTR"]
        pub type W = crate::W<u32, super::AHBRSTR>;
        #[doc = "Register AHBRSTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::AHBRSTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Crypto module reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRYPRST_A {
            #[doc = "1: Reset the module"]
            RESET = 1,
        }
        impl From<CRYPRST_A> for bool {
            #[inline(always)]
            fn from(variant: CRYPRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRYPRST`"]
        pub type CRYPRST_R = crate::R<bool, CRYPRST_A>;
        impl CRYPRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CRYPRST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CRYPRST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == CRYPRST_A::RESET
            }
        }
        #[doc = "Write proxy for field `CRYPRST`"]
        pub struct CRYPRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRYPRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRYPRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CRYPRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Test integration module reset"]
        pub type CRCRST_A = CRYPRST_A;
        #[doc = "Reader of field `CRCRST`"]
        pub type CRCRST_R = crate::R<bool, CRYPRST_A>;
        #[doc = "Write proxy for field `CRCRST`"]
        pub struct CRCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CRYPRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Memory interface reset"]
        pub type MIFRST_A = CRYPRST_A;
        #[doc = "Reader of field `MIFRST`"]
        pub type MIFRST_R = crate::R<bool, CRYPRST_A>;
        #[doc = "Write proxy for field `MIFRST`"]
        pub struct MIFRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MIFRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MIFRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CRYPRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "DMA reset"]
        pub type DMARST_A = CRYPRST_A;
        #[doc = "Reader of field `DMARST`"]
        pub type DMARST_R = crate::R<bool, CRYPRST_A>;
        #[doc = "Write proxy for field `DMARST`"]
        pub struct DMARST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMARST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMARST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CRYPRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 24 - Crypto module reset"]
            #[inline(always)]
            pub fn cryprst(&self) -> CRYPRST_R {
                CRYPRST_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Test integration module reset"]
            #[inline(always)]
            pub fn crcrst(&self) -> CRCRST_R {
                CRCRST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Memory interface reset"]
            #[inline(always)]
            pub fn mifrst(&self) -> MIFRST_R {
                MIFRST_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 0 - DMA reset"]
            #[inline(always)]
            pub fn dmarst(&self) -> DMARST_R {
                DMARST_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 24 - Crypto module reset"]
            #[inline(always)]
            pub fn cryprst(&mut self) -> CRYPRST_W {
                CRYPRST_W { w: self }
            }
            #[doc = "Bit 12 - Test integration module reset"]
            #[inline(always)]
            pub fn crcrst(&mut self) -> CRCRST_W {
                CRCRST_W { w: self }
            }
            #[doc = "Bit 8 - Memory interface reset"]
            #[inline(always)]
            pub fn mifrst(&mut self) -> MIFRST_W {
                MIFRST_W { w: self }
            }
            #[doc = "Bit 0 - DMA reset"]
            #[inline(always)]
            pub fn dmarst(&mut self) -> DMARST_W {
                DMARST_W { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral reset register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb2rstr](apb2rstr) module"]
    pub type APB2RSTR = crate::Reg<u32, _APB2RSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB2RSTR;
    #[doc = "`read()` method returns [apb2rstr::R](apb2rstr::R) reader structure"]
    impl crate::Readable for APB2RSTR {}
    #[doc = "`write(|w| ..)` method takes [apb2rstr::W](apb2rstr::W) writer structure"]
    impl crate::Writable for APB2RSTR {}
    #[doc = "APB2 peripheral reset register"]
    pub mod apb2rstr {
        #[doc = "Reader of register APB2RSTR"]
        pub type R = crate::R<u32, super::APB2RSTR>;
        #[doc = "Writer for register APB2RSTR"]
        pub type W = crate::W<u32, super::APB2RSTR>;
        #[doc = "Register APB2RSTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB2RSTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DBG reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBGRST_A {
            #[doc = "1: Reset the module"]
            RESET = 1,
        }
        impl From<DBGRST_A> for bool {
            #[inline(always)]
            fn from(variant: DBGRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBGRST`"]
        pub type DBGRST_R = crate::R<bool, DBGRST_A>;
        impl DBGRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, DBGRST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(DBGRST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == DBGRST_A::RESET
            }
        }
        #[doc = "Write proxy for field `DBGRST`"]
        pub struct DBGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBGRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBGRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "USART1 reset"]
        pub type USART1RST_A = DBGRST_A;
        #[doc = "Reader of field `USART1RST`"]
        pub type USART1RST_R = crate::R<bool, DBGRST_A>;
        #[doc = "Write proxy for field `USART1RST`"]
        pub struct USART1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "SPI 1 reset"]
        pub type SPI1RST_A = DBGRST_A;
        #[doc = "Reader of field `SPI1RST`"]
        pub type SPI1RST_R = crate::R<bool, DBGRST_A>;
        #[doc = "Write proxy for field `SPI1RST`"]
        pub struct SPI1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "ADC interface reset"]
        pub type ADCRST_A = DBGRST_A;
        #[doc = "Reader of field `ADCRST`"]
        pub type ADCRST_R = crate::R<bool, DBGRST_A>;
        #[doc = "Write proxy for field `ADCRST`"]
        pub struct ADCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADCRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADCRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "TIM22 timer reset"]
        pub type TIM22RST_A = DBGRST_A;
        #[doc = "Reader of field `TIM22RST`"]
        pub type TIM22RST_R = crate::R<bool, DBGRST_A>;
        #[doc = "Write proxy for field `TIM22RST`"]
        pub struct TIM22RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM22RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM22RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "TIM21 timer reset"]
        pub type TIM21RST_A = DBGRST_A;
        #[doc = "Reader of field `TIM21RST`"]
        pub type TIM21RST_R = crate::R<bool, DBGRST_A>;
        #[doc = "Write proxy for field `TIM21RST`"]
        pub struct TIM21RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM21RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM21RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "System configuration controller reset"]
        pub type SYSCFGRST_A = DBGRST_A;
        #[doc = "Reader of field `SYSCFGRST`"]
        pub type SYSCFGRST_R = crate::R<bool, DBGRST_A>;
        #[doc = "Write proxy for field `SYSCFGRST`"]
        pub struct SYSCFGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SYSCFGRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSCFGRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DBGRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 22 - DBG reset"]
            #[inline(always)]
            pub fn dbgrst(&self) -> DBGRST_R {
                DBGRST_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline(always)]
            pub fn usart1rst(&self) -> USART1RST_R {
                USART1RST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline(always)]
            pub fn spi1rst(&self) -> SPI1RST_R {
                SPI1RST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 9 - ADC interface reset"]
            #[inline(always)]
            pub fn adcrst(&self) -> ADCRST_R {
                ADCRST_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 5 - TIM22 timer reset"]
            #[inline(always)]
            pub fn tim22rst(&self) -> TIM22RST_R {
                TIM22RST_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 2 - TIM21 timer reset"]
            #[inline(always)]
            pub fn tim21rst(&self) -> TIM21RST_R {
                TIM21RST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - System configuration controller reset"]
            #[inline(always)]
            pub fn syscfgrst(&self) -> SYSCFGRST_R {
                SYSCFGRST_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 22 - DBG reset"]
            #[inline(always)]
            pub fn dbgrst(&mut self) -> DBGRST_W {
                DBGRST_W { w: self }
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline(always)]
            pub fn usart1rst(&mut self) -> USART1RST_W {
                USART1RST_W { w: self }
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline(always)]
            pub fn spi1rst(&mut self) -> SPI1RST_W {
                SPI1RST_W { w: self }
            }
            #[doc = "Bit 9 - ADC interface reset"]
            #[inline(always)]
            pub fn adcrst(&mut self) -> ADCRST_W {
                ADCRST_W { w: self }
            }
            #[doc = "Bit 5 - TIM22 timer reset"]
            #[inline(always)]
            pub fn tim22rst(&mut self) -> TIM22RST_W {
                TIM22RST_W { w: self }
            }
            #[doc = "Bit 2 - TIM21 timer reset"]
            #[inline(always)]
            pub fn tim21rst(&mut self) -> TIM21RST_W {
                TIM21RST_W { w: self }
            }
            #[doc = "Bit 0 - System configuration controller reset"]
            #[inline(always)]
            pub fn syscfgrst(&mut self) -> SYSCFGRST_W {
                SYSCFGRST_W { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral reset register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb1rstr](apb1rstr) module"]
    pub type APB1RSTR = crate::Reg<u32, _APB1RSTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB1RSTR;
    #[doc = "`read()` method returns [apb1rstr::R](apb1rstr::R) reader structure"]
    impl crate::Readable for APB1RSTR {}
    #[doc = "`write(|w| ..)` method takes [apb1rstr::W](apb1rstr::W) writer structure"]
    impl crate::Writable for APB1RSTR {}
    #[doc = "APB1 peripheral reset register"]
    pub mod apb1rstr {
        #[doc = "Reader of register APB1RSTR"]
        pub type R = crate::R<u32, super::APB1RSTR>;
        #[doc = "Writer for register APB1RSTR"]
        pub type W = crate::W<u32, super::APB1RSTR>;
        #[doc = "Register APB1RSTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB1RSTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Low power timer reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPTIM1RST_A {
            #[doc = "1: Reset the module"]
            RESET = 1,
        }
        impl From<LPTIM1RST_A> for bool {
            #[inline(always)]
            fn from(variant: LPTIM1RST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPTIM1RST`"]
        pub type LPTIM1RST_R = crate::R<bool, LPTIM1RST_A>;
        impl LPTIM1RST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, LPTIM1RST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(LPTIM1RST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == LPTIM1RST_A::RESET
            }
        }
        #[doc = "Write proxy for field `LPTIM1RST`"]
        pub struct LPTIM1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPTIM1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPTIM1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Power interface reset"]
        pub type PWRRST_A = LPTIM1RST_A;
        #[doc = "Reader of field `PWRRST`"]
        pub type PWRRST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `PWRRST`"]
        pub struct PWRRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PWRRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "I2C2 reset"]
        pub type I2C2RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `I2C2RST`"]
        pub type I2C2RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `I2C2RST`"]
        pub struct I2C2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "I2C1 reset"]
        pub type I2C1RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `I2C1RST`"]
        pub type I2C1RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `I2C1RST`"]
        pub struct I2C1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "LPUART1 reset"]
        pub type LPUART1RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `LPUART1RST`"]
        pub type LPUART1RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `LPUART1RST`"]
        pub struct LPUART1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPUART1RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPUART1RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "USART2 reset"]
        pub type USART2RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `USART2RST`"]
        pub type USART2RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `USART2RST`"]
        pub struct USART2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "SPI2 reset"]
        pub type SPI2RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `SPI2RST`"]
        pub type SPI2RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `SPI2RST`"]
        pub struct SPI2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Window watchdog reset"]
        pub type WWDGRST_A = LPTIM1RST_A;
        #[doc = "Reader of field `WWDGRST`"]
        pub type WWDGRST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `WWDGRST`"]
        pub struct WWDGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Timer 6 reset"]
        pub type TIM6RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `TIM6RST`"]
        pub type TIM6RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `TIM6RST`"]
        pub struct TIM6RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM6RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Timer 2 reset"]
        pub type TIM2RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `TIM2RST`"]
        pub type TIM2RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `TIM2RST`"]
        pub struct TIM2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM2RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Timer 3 reset"]
        pub type TIM3RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `TIM3RST`"]
        pub type TIM3RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `TIM3RST`"]
        pub struct TIM3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM3RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Timer 7 reset"]
        pub type TIM7RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `TIM7RST`"]
        pub type TIM7RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `TIM7RST`"]
        pub struct TIM7RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM7RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "USART4 reset"]
        pub type USART4RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `USART4RST`"]
        pub type USART4RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `USART4RST`"]
        pub struct USART4RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART4RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART4RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "USART5 reset"]
        pub type USART5RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `USART5RST`"]
        pub type USART5RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `USART5RST`"]
        pub struct USART5RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART5RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART5RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "CRC reset"]
        pub type CRCRST_A = LPTIM1RST_A;
        #[doc = "Reader of field `CRCRST`"]
        pub type CRCRST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `CRCRST`"]
        pub struct CRCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "I2C3 reset"]
        pub type I2C3RST_A = LPTIM1RST_A;
        #[doc = "Reader of field `I2C3RST`"]
        pub type I2C3RST_R = crate::R<bool, LPTIM1RST_A>;
        #[doc = "Write proxy for field `I2C3RST`"]
        pub struct I2C3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C3RST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C3RST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reset the module"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPTIM1RST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 31 - Low power timer reset"]
            #[inline(always)]
            pub fn lptim1rst(&self) -> LPTIM1RST_R {
                LPTIM1RST_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline(always)]
            pub fn pwrrst(&self) -> PWRRST_R {
                PWRRST_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline(always)]
            pub fn i2c2rst(&self) -> I2C2RST_R {
                I2C2RST_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline(always)]
            pub fn i2c1rst(&self) -> I2C1RST_R {
                I2C1RST_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 18 - LPUART1 reset"]
            #[inline(always)]
            pub fn lpuart1rst(&self) -> LPUART1RST_R {
                LPUART1RST_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - USART2 reset"]
            #[inline(always)]
            pub fn usart2rst(&self) -> USART2RST_R {
                USART2RST_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline(always)]
            pub fn spi2rst(&self) -> SPI2RST_R {
                SPI2RST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline(always)]
            pub fn wwdgrst(&self) -> WWDGRST_R {
                WWDGRST_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline(always)]
            pub fn tim6rst(&self) -> TIM6RST_R {
                TIM6RST_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline(always)]
            pub fn tim2rst(&self) -> TIM2RST_R {
                TIM2RST_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline(always)]
            pub fn tim3rst(&self) -> TIM3RST_R {
                TIM3RST_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Timer 7 reset"]
            #[inline(always)]
            pub fn tim7rst(&self) -> TIM7RST_R {
                TIM7RST_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 19 - USART4 reset"]
            #[inline(always)]
            pub fn usart4rst(&self) -> USART4RST_R {
                USART4RST_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - USART5 reset"]
            #[inline(always)]
            pub fn usart5rst(&self) -> USART5RST_R {
                USART5RST_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 27 - CRC reset"]
            #[inline(always)]
            pub fn crcrst(&self) -> CRCRST_R {
                CRCRST_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 30 - I2C3 reset"]
            #[inline(always)]
            pub fn i2c3rst(&self) -> I2C3RST_R {
                I2C3RST_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 31 - Low power timer reset"]
            #[inline(always)]
            pub fn lptim1rst(&mut self) -> LPTIM1RST_W {
                LPTIM1RST_W { w: self }
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline(always)]
            pub fn pwrrst(&mut self) -> PWRRST_W {
                PWRRST_W { w: self }
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline(always)]
            pub fn i2c2rst(&mut self) -> I2C2RST_W {
                I2C2RST_W { w: self }
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline(always)]
            pub fn i2c1rst(&mut self) -> I2C1RST_W {
                I2C1RST_W { w: self }
            }
            #[doc = "Bit 18 - LPUART1 reset"]
            #[inline(always)]
            pub fn lpuart1rst(&mut self) -> LPUART1RST_W {
                LPUART1RST_W { w: self }
            }
            #[doc = "Bit 17 - USART2 reset"]
            #[inline(always)]
            pub fn usart2rst(&mut self) -> USART2RST_W {
                USART2RST_W { w: self }
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline(always)]
            pub fn spi2rst(&mut self) -> SPI2RST_W {
                SPI2RST_W { w: self }
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline(always)]
            pub fn wwdgrst(&mut self) -> WWDGRST_W {
                WWDGRST_W { w: self }
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline(always)]
            pub fn tim6rst(&mut self) -> TIM6RST_W {
                TIM6RST_W { w: self }
            }
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline(always)]
            pub fn tim2rst(&mut self) -> TIM2RST_W {
                TIM2RST_W { w: self }
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline(always)]
            pub fn tim3rst(&mut self) -> TIM3RST_W {
                TIM3RST_W { w: self }
            }
            #[doc = "Bit 5 - Timer 7 reset"]
            #[inline(always)]
            pub fn tim7rst(&mut self) -> TIM7RST_W {
                TIM7RST_W { w: self }
            }
            #[doc = "Bit 19 - USART4 reset"]
            #[inline(always)]
            pub fn usart4rst(&mut self) -> USART4RST_W {
                USART4RST_W { w: self }
            }
            #[doc = "Bit 20 - USART5 reset"]
            #[inline(always)]
            pub fn usart5rst(&mut self) -> USART5RST_W {
                USART5RST_W { w: self }
            }
            #[doc = "Bit 27 - CRC reset"]
            #[inline(always)]
            pub fn crcrst(&mut self) -> CRCRST_W {
                CRCRST_W { w: self }
            }
            #[doc = "Bit 30 - I2C3 reset"]
            #[inline(always)]
            pub fn i2c3rst(&mut self) -> I2C3RST_W {
                I2C3RST_W { w: self }
            }
        }
    }
    #[doc = "GPIO clock enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iopenr](iopenr) module"]
    pub type IOPENR = crate::Reg<u32, _IOPENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IOPENR;
    #[doc = "`read()` method returns [iopenr::R](iopenr::R) reader structure"]
    impl crate::Readable for IOPENR {}
    #[doc = "`write(|w| ..)` method takes [iopenr::W](iopenr::W) writer structure"]
    impl crate::Writable for IOPENR {}
    #[doc = "GPIO clock enable register"]
    pub mod iopenr {
        #[doc = "Reader of register IOPENR"]
        pub type R = crate::R<u32, super::IOPENR>;
        #[doc = "Writer for register IOPENR"]
        pub type W = crate::W<u32, super::IOPENR>;
        #[doc = "Register IOPENR `reset()`'s with value 0"]
        impl crate::ResetValue for super::IOPENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "I/O port H clock enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOPHEN_A {
            #[doc = "0: Port clock disabled"]
            DISABLED = 0,
            #[doc = "1: Port clock enabled"]
            ENABLED = 1,
        }
        impl From<IOPHEN_A> for bool {
            #[inline(always)]
            fn from(variant: IOPHEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IOPHEN`"]
        pub type IOPHEN_R = crate::R<bool, IOPHEN_A>;
        impl IOPHEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IOPHEN_A {
                match self.bits {
                    false => IOPHEN_A::DISABLED,
                    true => IOPHEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IOPHEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IOPHEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IOPHEN`"]
        pub struct IOPHEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPHEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPHEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::DISABLED)
            }
            #[doc = "Port clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "I/O port D clock enable bit"]
        pub type IOPDEN_A = IOPHEN_A;
        #[doc = "Reader of field `IOPDEN`"]
        pub type IOPDEN_R = crate::R<bool, IOPHEN_A>;
        #[doc = "Write proxy for field `IOPDEN`"]
        pub struct IOPDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::DISABLED)
            }
            #[doc = "Port clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "IO port A clock enable bit"]
        pub type IOPCEN_A = IOPHEN_A;
        #[doc = "Reader of field `IOPCEN`"]
        pub type IOPCEN_R = crate::R<bool, IOPHEN_A>;
        #[doc = "Write proxy for field `IOPCEN`"]
        pub struct IOPCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::DISABLED)
            }
            #[doc = "Port clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "IO port B clock enable bit"]
        pub type IOPBEN_A = IOPHEN_A;
        #[doc = "Reader of field `IOPBEN`"]
        pub type IOPBEN_R = crate::R<bool, IOPHEN_A>;
        #[doc = "Write proxy for field `IOPBEN`"]
        pub struct IOPBEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPBEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::DISABLED)
            }
            #[doc = "Port clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "IO port A clock enable bit"]
        pub type IOPAEN_A = IOPHEN_A;
        #[doc = "Reader of field `IOPAEN`"]
        pub type IOPAEN_R = crate::R<bool, IOPHEN_A>;
        #[doc = "Write proxy for field `IOPAEN`"]
        pub struct IOPAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::DISABLED)
            }
            #[doc = "Port clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "IO port E clock enable bit"]
        pub type IOPEEN_A = IOPHEN_A;
        #[doc = "Reader of field `IOPEEN`"]
        pub type IOPEEN_R = crate::R<bool, IOPHEN_A>;
        #[doc = "Write proxy for field `IOPEEN`"]
        pub struct IOPEEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPEEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPEEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::DISABLED)
            }
            #[doc = "Port clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - I/O port H clock enable bit"]
            #[inline(always)]
            pub fn iophen(&self) -> IOPHEN_R {
                IOPHEN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - I/O port D clock enable bit"]
            #[inline(always)]
            pub fn iopden(&self) -> IOPDEN_R {
                IOPDEN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - IO port A clock enable bit"]
            #[inline(always)]
            pub fn iopcen(&self) -> IOPCEN_R {
                IOPCEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - IO port B clock enable bit"]
            #[inline(always)]
            pub fn iopben(&self) -> IOPBEN_R {
                IOPBEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - IO port A clock enable bit"]
            #[inline(always)]
            pub fn iopaen(&self) -> IOPAEN_R {
                IOPAEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 4 - IO port E clock enable bit"]
            #[inline(always)]
            pub fn iopeen(&self) -> IOPEEN_R {
                IOPEEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - I/O port H clock enable bit"]
            #[inline(always)]
            pub fn iophen(&mut self) -> IOPHEN_W {
                IOPHEN_W { w: self }
            }
            #[doc = "Bit 3 - I/O port D clock enable bit"]
            #[inline(always)]
            pub fn iopden(&mut self) -> IOPDEN_W {
                IOPDEN_W { w: self }
            }
            #[doc = "Bit 2 - IO port A clock enable bit"]
            #[inline(always)]
            pub fn iopcen(&mut self) -> IOPCEN_W {
                IOPCEN_W { w: self }
            }
            #[doc = "Bit 1 - IO port B clock enable bit"]
            #[inline(always)]
            pub fn iopben(&mut self) -> IOPBEN_W {
                IOPBEN_W { w: self }
            }
            #[doc = "Bit 0 - IO port A clock enable bit"]
            #[inline(always)]
            pub fn iopaen(&mut self) -> IOPAEN_W {
                IOPAEN_W { w: self }
            }
            #[doc = "Bit 4 - IO port E clock enable bit"]
            #[inline(always)]
            pub fn iopeen(&mut self) -> IOPEEN_W {
                IOPEEN_W { w: self }
            }
        }
    }
    #[doc = "AHB peripheral clock enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ahbenr](ahbenr) module"]
    pub type AHBENR = crate::Reg<u32, _AHBENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AHBENR;
    #[doc = "`read()` method returns [ahbenr::R](ahbenr::R) reader structure"]
    impl crate::Readable for AHBENR {}
    #[doc = "`write(|w| ..)` method takes [ahbenr::W](ahbenr::W) writer structure"]
    impl crate::Writable for AHBENR {}
    #[doc = "AHB peripheral clock enable register"]
    pub mod ahbenr {
        #[doc = "Reader of register AHBENR"]
        pub type R = crate::R<u32, super::AHBENR>;
        #[doc = "Writer for register AHBENR"]
        pub type W = crate::W<u32, super::AHBENR>;
        #[doc = "Register AHBENR `reset()`'s with value 0x0100"]
        impl crate::ResetValue for super::AHBENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0100
            }
        }
        #[doc = "Crypto clock enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRYPEN_A {
            #[doc = "0: Clock disabled"]
            DISABLED = 0,
            #[doc = "1: Clock enabled"]
            ENABLED = 1,
        }
        impl From<CRYPEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRYPEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRYPEN`"]
        pub type CRYPEN_R = crate::R<bool, CRYPEN_A>;
        impl CRYPEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRYPEN_A {
                match self.bits {
                    false => CRYPEN_A::DISABLED,
                    true => CRYPEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CRYPEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CRYPEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CRYPEN`"]
        pub struct CRYPEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRYPEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRYPEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "CRC clock enable bit"]
        pub type CRCEN_A = CRYPEN_A;
        #[doc = "Reader of field `CRCEN`"]
        pub type CRCEN_R = crate::R<bool, CRYPEN_A>;
        #[doc = "Write proxy for field `CRCEN`"]
        pub struct CRCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "NVM interface clock enable bit"]
        pub type MIFEN_A = CRYPEN_A;
        #[doc = "Reader of field `MIFEN`"]
        pub type MIFEN_R = crate::R<bool, CRYPEN_A>;
        #[doc = "Write proxy for field `MIFEN`"]
        pub struct MIFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MIFEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MIFEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "DMA clock enable bit"]
        pub type DMAEN_A = CRYPEN_A;
        #[doc = "Reader of field `DMAEN`"]
        pub type DMAEN_R = crate::R<bool, CRYPEN_A>;
        #[doc = "Write proxy for field `DMAEN`"]
        pub struct DMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRYPEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 24 - Crypto clock enable bit"]
            #[inline(always)]
            pub fn crypen(&self) -> CRYPEN_R {
                CRYPEN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 12 - CRC clock enable bit"]
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 8 - NVM interface clock enable bit"]
            #[inline(always)]
            pub fn mifen(&self) -> MIFEN_R {
                MIFEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 0 - DMA clock enable bit"]
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 24 - Crypto clock enable bit"]
            #[inline(always)]
            pub fn crypen(&mut self) -> CRYPEN_W {
                CRYPEN_W { w: self }
            }
            #[doc = "Bit 12 - CRC clock enable bit"]
            #[inline(always)]
            pub fn crcen(&mut self) -> CRCEN_W {
                CRCEN_W { w: self }
            }
            #[doc = "Bit 8 - NVM interface clock enable bit"]
            #[inline(always)]
            pub fn mifen(&mut self) -> MIFEN_W {
                MIFEN_W { w: self }
            }
            #[doc = "Bit 0 - DMA clock enable bit"]
            #[inline(always)]
            pub fn dmaen(&mut self) -> DMAEN_W {
                DMAEN_W { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral clock enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb2enr](apb2enr) module"]
    pub type APB2ENR = crate::Reg<u32, _APB2ENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB2ENR;
    #[doc = "`read()` method returns [apb2enr::R](apb2enr::R) reader structure"]
    impl crate::Readable for APB2ENR {}
    #[doc = "`write(|w| ..)` method takes [apb2enr::W](apb2enr::W) writer structure"]
    impl crate::Writable for APB2ENR {}
    #[doc = "APB2 peripheral clock enable register"]
    pub mod apb2enr {
        #[doc = "Reader of register APB2ENR"]
        pub type R = crate::R<u32, super::APB2ENR>;
        #[doc = "Writer for register APB2ENR"]
        pub type W = crate::W<u32, super::APB2ENR>;
        #[doc = "Register APB2ENR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB2ENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "DBG clock enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBGEN_A {
            #[doc = "0: Clock disabled"]
            DISABLED = 0,
            #[doc = "1: Clock enabled"]
            ENABLED = 1,
        }
        impl From<DBGEN_A> for bool {
            #[inline(always)]
            fn from(variant: DBGEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBGEN`"]
        pub type DBGEN_R = crate::R<bool, DBGEN_A>;
        impl DBGEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBGEN_A {
                match self.bits {
                    false => DBGEN_A::DISABLED,
                    true => DBGEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DBGEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DBGEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DBGEN`"]
        pub struct DBGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBGEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "USART1 clock enable bit"]
        pub type USART1EN_A = DBGEN_A;
        #[doc = "Reader of field `USART1EN`"]
        pub type USART1EN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `USART1EN`"]
        pub struct USART1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "SPI1 clock enable bit"]
        pub type SPI1EN_A = DBGEN_A;
        #[doc = "Reader of field `SPI1EN`"]
        pub type SPI1EN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `SPI1EN`"]
        pub struct SPI1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "ADC clock enable bit"]
        pub type ADCEN_A = DBGEN_A;
        #[doc = "Reader of field `ADCEN`"]
        pub type ADCEN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `ADCEN`"]
        pub struct ADCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Firewall clock enable bit"]
        pub type FWEN_A = DBGEN_A;
        #[doc = "Reader of field `FWEN`"]
        pub type FWEN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `FWEN`"]
        pub struct FWEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FWEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FWEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "TIM22 timer clock enable bit"]
        pub type TIM22EN_A = DBGEN_A;
        #[doc = "Reader of field `TIM22EN`"]
        pub type TIM22EN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `TIM22EN`"]
        pub struct TIM22EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM22EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM22EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "TIM21 timer clock enable bit"]
        pub type TIM21EN_A = DBGEN_A;
        #[doc = "Reader of field `TIM21EN`"]
        pub type TIM21EN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `TIM21EN`"]
        pub struct TIM21EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM21EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM21EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "System configuration controller clock enable bit"]
        pub type SYSCFGEN_A = DBGEN_A;
        #[doc = "Reader of field `SYSCFGEN`"]
        pub type SYSCFGEN_R = crate::R<bool, DBGEN_A>;
        #[doc = "Write proxy for field `SYSCFGEN`"]
        pub struct SYSCFGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SYSCFGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSCFGEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 22 - DBG clock enable bit"]
            #[inline(always)]
            pub fn dbgen(&self) -> DBGEN_R {
                DBGEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 14 - USART1 clock enable bit"]
            #[inline(always)]
            pub fn usart1en(&self) -> USART1EN_R {
                USART1EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - SPI1 clock enable bit"]
            #[inline(always)]
            pub fn spi1en(&self) -> SPI1EN_R {
                SPI1EN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 9 - ADC clock enable bit"]
            #[inline(always)]
            pub fn adcen(&self) -> ADCEN_R {
                ADCEN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Firewall clock enable bit"]
            #[inline(always)]
            pub fn fwen(&self) -> FWEN_R {
                FWEN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - TIM22 timer clock enable bit"]
            #[inline(always)]
            pub fn tim22en(&self) -> TIM22EN_R {
                TIM22EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 2 - TIM21 timer clock enable bit"]
            #[inline(always)]
            pub fn tim21en(&self) -> TIM21EN_R {
                TIM21EN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - System configuration controller clock enable bit"]
            #[inline(always)]
            pub fn syscfgen(&self) -> SYSCFGEN_R {
                SYSCFGEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 22 - DBG clock enable bit"]
            #[inline(always)]
            pub fn dbgen(&mut self) -> DBGEN_W {
                DBGEN_W { w: self }
            }
            #[doc = "Bit 14 - USART1 clock enable bit"]
            #[inline(always)]
            pub fn usart1en(&mut self) -> USART1EN_W {
                USART1EN_W { w: self }
            }
            #[doc = "Bit 12 - SPI1 clock enable bit"]
            #[inline(always)]
            pub fn spi1en(&mut self) -> SPI1EN_W {
                SPI1EN_W { w: self }
            }
            #[doc = "Bit 9 - ADC clock enable bit"]
            #[inline(always)]
            pub fn adcen(&mut self) -> ADCEN_W {
                ADCEN_W { w: self }
            }
            #[doc = "Bit 7 - Firewall clock enable bit"]
            #[inline(always)]
            pub fn fwen(&mut self) -> FWEN_W {
                FWEN_W { w: self }
            }
            #[doc = "Bit 5 - TIM22 timer clock enable bit"]
            #[inline(always)]
            pub fn tim22en(&mut self) -> TIM22EN_W {
                TIM22EN_W { w: self }
            }
            #[doc = "Bit 2 - TIM21 timer clock enable bit"]
            #[inline(always)]
            pub fn tim21en(&mut self) -> TIM21EN_W {
                TIM21EN_W { w: self }
            }
            #[doc = "Bit 0 - System configuration controller clock enable bit"]
            #[inline(always)]
            pub fn syscfgen(&mut self) -> SYSCFGEN_W {
                SYSCFGEN_W { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral clock enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb1enr](apb1enr) module"]
    pub type APB1ENR = crate::Reg<u32, _APB1ENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB1ENR;
    #[doc = "`read()` method returns [apb1enr::R](apb1enr::R) reader structure"]
    impl crate::Readable for APB1ENR {}
    #[doc = "`write(|w| ..)` method takes [apb1enr::W](apb1enr::W) writer structure"]
    impl crate::Writable for APB1ENR {}
    #[doc = "APB1 peripheral clock enable register"]
    pub mod apb1enr {
        #[doc = "Reader of register APB1ENR"]
        pub type R = crate::R<u32, super::APB1ENR>;
        #[doc = "Writer for register APB1ENR"]
        pub type W = crate::W<u32, super::APB1ENR>;
        #[doc = "Register APB1ENR `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB1ENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Low power timer clock enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPTIM1EN_A {
            #[doc = "0: Clock disabled"]
            DISABLED = 0,
            #[doc = "1: Clock enabled"]
            ENABLED = 1,
        }
        impl From<LPTIM1EN_A> for bool {
            #[inline(always)]
            fn from(variant: LPTIM1EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPTIM1EN`"]
        pub type LPTIM1EN_R = crate::R<bool, LPTIM1EN_A>;
        impl LPTIM1EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPTIM1EN_A {
                match self.bits {
                    false => LPTIM1EN_A::DISABLED,
                    true => LPTIM1EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LPTIM1EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LPTIM1EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LPTIM1EN`"]
        pub struct LPTIM1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPTIM1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPTIM1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Power interface clock enable bit"]
        pub type PWREN_A = LPTIM1EN_A;
        #[doc = "Reader of field `PWREN`"]
        pub type PWREN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `PWREN`"]
        pub struct PWREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWREN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PWREN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "I2C2 clock enable bit"]
        pub type I2C2EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `I2C2EN`"]
        pub type I2C2EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `I2C2EN`"]
        pub struct I2C2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "I2C1 clock enable bit"]
        pub type I2C1EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `I2C1EN`"]
        pub type I2C1EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `I2C1EN`"]
        pub struct I2C1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "LPUART1 clock enable bit"]
        pub type LPUART1EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `LPUART1EN`"]
        pub type LPUART1EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `LPUART1EN`"]
        pub struct LPUART1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPUART1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPUART1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "UART2 clock enable bit"]
        pub type USART2EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `USART2EN`"]
        pub type USART2EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `USART2EN`"]
        pub struct USART2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "SPI2 clock enable bit"]
        pub type SPI2EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `SPI2EN`"]
        pub type SPI2EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `SPI2EN`"]
        pub struct SPI2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Window watchdog clock enable bit"]
        pub type WWDGEN_A = LPTIM1EN_A;
        #[doc = "Reader of field `WWDGEN`"]
        pub type WWDGEN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `WWDGEN`"]
        pub struct WWDGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Timer 6 clock enable bit"]
        pub type TIM6EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `TIM6EN`"]
        pub type TIM6EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `TIM6EN`"]
        pub struct TIM6EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM6EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Timer2 clock enable bit"]
        pub type TIM2EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `TIM2EN`"]
        pub type TIM2EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `TIM2EN`"]
        pub struct TIM2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Timer 3 clock enbale bit"]
        pub type TIM3EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `TIM3EN`"]
        pub type TIM3EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `TIM3EN`"]
        pub struct TIM3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM3EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Timer 7 clock enable bit"]
        pub type TIM7EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `TIM7EN`"]
        pub type TIM7EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `TIM7EN`"]
        pub struct TIM7EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM7EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "USART4 clock enable bit"]
        pub type USART4EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `USART4EN`"]
        pub type USART4EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `USART4EN`"]
        pub struct USART4EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART4EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART4EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "USART5 clock enable bit"]
        pub type USART5EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `USART5EN`"]
        pub type USART5EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `USART5EN`"]
        pub struct USART5EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART5EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART5EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "I2C3 clock enable bit"]
        pub type I2C3EN_A = LPTIM1EN_A;
        #[doc = "Reader of field `I2C3EN`"]
        pub type I2C3EN_R = crate::R<bool, LPTIM1EN_A>;
        #[doc = "Write proxy for field `I2C3EN`"]
        pub struct I2C3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C3EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C3EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 31 - Low power timer clock enable bit"]
            #[inline(always)]
            pub fn lptim1en(&self) -> LPTIM1EN_R {
                LPTIM1EN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Power interface clock enable bit"]
            #[inline(always)]
            pub fn pwren(&self) -> PWREN_R {
                PWREN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 22 - I2C2 clock enable bit"]
            #[inline(always)]
            pub fn i2c2en(&self) -> I2C2EN_R {
                I2C2EN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - I2C1 clock enable bit"]
            #[inline(always)]
            pub fn i2c1en(&self) -> I2C1EN_R {
                I2C1EN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 18 - LPUART1 clock enable bit"]
            #[inline(always)]
            pub fn lpuart1en(&self) -> LPUART1EN_R {
                LPUART1EN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - UART2 clock enable bit"]
            #[inline(always)]
            pub fn usart2en(&self) -> USART2EN_R {
                USART2EN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 14 - SPI2 clock enable bit"]
            #[inline(always)]
            pub fn spi2en(&self) -> SPI2EN_R {
                SPI2EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Window watchdog clock enable bit"]
            #[inline(always)]
            pub fn wwdgen(&self) -> WWDGEN_R {
                WWDGEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Timer 6 clock enable bit"]
            #[inline(always)]
            pub fn tim6en(&self) -> TIM6EN_R {
                TIM6EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Timer2 clock enable bit"]
            #[inline(always)]
            pub fn tim2en(&self) -> TIM2EN_R {
                TIM2EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Timer 3 clock enbale bit"]
            #[inline(always)]
            pub fn tim3en(&self) -> TIM3EN_R {
                TIM3EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Timer 7 clock enable bit"]
            #[inline(always)]
            pub fn tim7en(&self) -> TIM7EN_R {
                TIM7EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 19 - USART4 clock enable bit"]
            #[inline(always)]
            pub fn usart4en(&self) -> USART4EN_R {
                USART4EN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - USART5 clock enable bit"]
            #[inline(always)]
            pub fn usart5en(&self) -> USART5EN_R {
                USART5EN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 30 - I2C3 clock enable bit"]
            #[inline(always)]
            pub fn i2c3en(&self) -> I2C3EN_R {
                I2C3EN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 31 - Low power timer clock enable bit"]
            #[inline(always)]
            pub fn lptim1en(&mut self) -> LPTIM1EN_W {
                LPTIM1EN_W { w: self }
            }
            #[doc = "Bit 28 - Power interface clock enable bit"]
            #[inline(always)]
            pub fn pwren(&mut self) -> PWREN_W {
                PWREN_W { w: self }
            }
            #[doc = "Bit 22 - I2C2 clock enable bit"]
            #[inline(always)]
            pub fn i2c2en(&mut self) -> I2C2EN_W {
                I2C2EN_W { w: self }
            }
            #[doc = "Bit 21 - I2C1 clock enable bit"]
            #[inline(always)]
            pub fn i2c1en(&mut self) -> I2C1EN_W {
                I2C1EN_W { w: self }
            }
            #[doc = "Bit 18 - LPUART1 clock enable bit"]
            #[inline(always)]
            pub fn lpuart1en(&mut self) -> LPUART1EN_W {
                LPUART1EN_W { w: self }
            }
            #[doc = "Bit 17 - UART2 clock enable bit"]
            #[inline(always)]
            pub fn usart2en(&mut self) -> USART2EN_W {
                USART2EN_W { w: self }
            }
            #[doc = "Bit 14 - SPI2 clock enable bit"]
            #[inline(always)]
            pub fn spi2en(&mut self) -> SPI2EN_W {
                SPI2EN_W { w: self }
            }
            #[doc = "Bit 11 - Window watchdog clock enable bit"]
            #[inline(always)]
            pub fn wwdgen(&mut self) -> WWDGEN_W {
                WWDGEN_W { w: self }
            }
            #[doc = "Bit 4 - Timer 6 clock enable bit"]
            #[inline(always)]
            pub fn tim6en(&mut self) -> TIM6EN_W {
                TIM6EN_W { w: self }
            }
            #[doc = "Bit 0 - Timer2 clock enable bit"]
            #[inline(always)]
            pub fn tim2en(&mut self) -> TIM2EN_W {
                TIM2EN_W { w: self }
            }
            #[doc = "Bit 1 - Timer 3 clock enbale bit"]
            #[inline(always)]
            pub fn tim3en(&mut self) -> TIM3EN_W {
                TIM3EN_W { w: self }
            }
            #[doc = "Bit 5 - Timer 7 clock enable bit"]
            #[inline(always)]
            pub fn tim7en(&mut self) -> TIM7EN_W {
                TIM7EN_W { w: self }
            }
            #[doc = "Bit 19 - USART4 clock enable bit"]
            #[inline(always)]
            pub fn usart4en(&mut self) -> USART4EN_W {
                USART4EN_W { w: self }
            }
            #[doc = "Bit 20 - USART5 clock enable bit"]
            #[inline(always)]
            pub fn usart5en(&mut self) -> USART5EN_W {
                USART5EN_W { w: self }
            }
            #[doc = "Bit 30 - I2C3 clock enable bit"]
            #[inline(always)]
            pub fn i2c3en(&mut self) -> I2C3EN_W {
                I2C3EN_W { w: self }
            }
        }
    }
    #[doc = "GPIO clock enable in sleep mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iopsmen](iopsmen) module"]
    pub type IOPSMEN = crate::Reg<u32, _IOPSMEN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IOPSMEN;
    #[doc = "`read()` method returns [iopsmen::R](iopsmen::R) reader structure"]
    impl crate::Readable for IOPSMEN {}
    #[doc = "`write(|w| ..)` method takes [iopsmen::W](iopsmen::W) writer structure"]
    impl crate::Writable for IOPSMEN {}
    #[doc = "GPIO clock enable in sleep mode register"]
    pub mod iopsmen {
        #[doc = "Reader of register IOPSMEN"]
        pub type R = crate::R<u32, super::IOPSMEN>;
        #[doc = "Writer for register IOPSMEN"]
        pub type W = crate::W<u32, super::IOPSMEN>;
        #[doc = "Register IOPSMEN `reset()`'s with value 0x8f"]
        impl crate::ResetValue for super::IOPSMEN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x8f
            }
        }
        #[doc = "Port H clock enable during Sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOPHSMEN_A {
            #[doc = "0: Port x clock is disabled in Sleep mode"]
            DISABLED = 0,
            #[doc = "1: Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            ENABLED = 1,
        }
        impl From<IOPHSMEN_A> for bool {
            #[inline(always)]
            fn from(variant: IOPHSMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IOPHSMEN`"]
        pub type IOPHSMEN_R = crate::R<bool, IOPHSMEN_A>;
        impl IOPHSMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IOPHSMEN_A {
                match self.bits {
                    false => IOPHSMEN_A::DISABLED,
                    true => IOPHSMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IOPHSMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IOPHSMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IOPHSMEN`"]
        pub struct IOPHSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPHSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPHSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port x clock is disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::DISABLED)
            }
            #[doc = "Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Port D clock enable during Sleep mode bit"]
        pub type IOPDSMEN_A = IOPHSMEN_A;
        #[doc = "Reader of field `IOPDSMEN`"]
        pub type IOPDSMEN_R = crate::R<bool, IOPHSMEN_A>;
        #[doc = "Write proxy for field `IOPDSMEN`"]
        pub struct IOPDSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPDSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port x clock is disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::DISABLED)
            }
            #[doc = "Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Port C clock enable during Sleep mode bit"]
        pub type IOPCSMEN_A = IOPHSMEN_A;
        #[doc = "Reader of field `IOPCSMEN`"]
        pub type IOPCSMEN_R = crate::R<bool, IOPHSMEN_A>;
        #[doc = "Write proxy for field `IOPCSMEN`"]
        pub struct IOPCSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPCSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port x clock is disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::DISABLED)
            }
            #[doc = "Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Port B clock enable during Sleep mode bit"]
        pub type IOPBSMEN_A = IOPHSMEN_A;
        #[doc = "Reader of field `IOPBSMEN`"]
        pub type IOPBSMEN_R = crate::R<bool, IOPHSMEN_A>;
        #[doc = "Write proxy for field `IOPBSMEN`"]
        pub struct IOPBSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPBSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port x clock is disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::DISABLED)
            }
            #[doc = "Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Port A clock enable during Sleep mode bit"]
        pub type IOPASMEN_A = IOPHSMEN_A;
        #[doc = "Reader of field `IOPASMEN`"]
        pub type IOPASMEN_R = crate::R<bool, IOPHSMEN_A>;
        #[doc = "Write proxy for field `IOPASMEN`"]
        pub struct IOPASMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPASMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPASMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port x clock is disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::DISABLED)
            }
            #[doc = "Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Port E clock enable during Sleep mode bit"]
        pub type IOPESMEN_A = IOPHSMEN_A;
        #[doc = "Reader of field `IOPESMEN`"]
        pub type IOPESMEN_R = crate::R<bool, IOPHSMEN_A>;
        #[doc = "Write proxy for field `IOPESMEN`"]
        pub struct IOPESMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPESMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOPESMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Port x clock is disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::DISABLED)
            }
            #[doc = "Port x clock is enabled in Sleep mode (if enabled by IOPHEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPHSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Port H clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iophsmen(&self) -> IOPHSMEN_R {
                IOPHSMEN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Port D clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopdsmen(&self) -> IOPDSMEN_R {
                IOPDSMEN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Port C clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopcsmen(&self) -> IOPCSMEN_R {
                IOPCSMEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Port B clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopbsmen(&self) -> IOPBSMEN_R {
                IOPBSMEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Port A clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopasmen(&self) -> IOPASMEN_R {
                IOPASMEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 4 - Port E clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopesmen(&self) -> IOPESMEN_R {
                IOPESMEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Port H clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iophsmen(&mut self) -> IOPHSMEN_W {
                IOPHSMEN_W { w: self }
            }
            #[doc = "Bit 3 - Port D clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopdsmen(&mut self) -> IOPDSMEN_W {
                IOPDSMEN_W { w: self }
            }
            #[doc = "Bit 2 - Port C clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopcsmen(&mut self) -> IOPCSMEN_W {
                IOPCSMEN_W { w: self }
            }
            #[doc = "Bit 1 - Port B clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopbsmen(&mut self) -> IOPBSMEN_W {
                IOPBSMEN_W { w: self }
            }
            #[doc = "Bit 0 - Port A clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopasmen(&mut self) -> IOPASMEN_W {
                IOPASMEN_W { w: self }
            }
            #[doc = "Bit 4 - Port E clock enable during Sleep mode bit"]
            #[inline(always)]
            pub fn iopesmen(&mut self) -> IOPESMEN_W {
                IOPESMEN_W { w: self }
            }
        }
    }
    #[doc = "AHB peripheral clock enable in sleep mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ahbsmenr](ahbsmenr) module"]
    pub type AHBSMENR = crate::Reg<u32, _AHBSMENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AHBSMENR;
    #[doc = "`read()` method returns [ahbsmenr::R](ahbsmenr::R) reader structure"]
    impl crate::Readable for AHBSMENR {}
    #[doc = "`write(|w| ..)` method takes [ahbsmenr::W](ahbsmenr::W) writer structure"]
    impl crate::Writable for AHBSMENR {}
    #[doc = "AHB peripheral clock enable in sleep mode register"]
    pub mod ahbsmenr {
        #[doc = "Reader of register AHBSMENR"]
        pub type R = crate::R<u32, super::AHBSMENR>;
        #[doc = "Writer for register AHBSMENR"]
        pub type W = crate::W<u32, super::AHBSMENR>;
        #[doc = "Register AHBSMENR `reset()`'s with value 0x0111_1301"]
        impl crate::ResetValue for super::AHBSMENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0111_1301
            }
        }
        #[doc = "Crypto clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRYPSMEN_A {
            #[doc = "0: Crypto clock disabled in Sleep mode"]
            DISABLED = 0,
            #[doc = "1: Crypto clock enabled in Sleep mode"]
            ENABLED = 1,
        }
        impl From<CRYPSMEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRYPSMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRYPSMEN`"]
        pub type CRYPSMEN_R = crate::R<bool, CRYPSMEN_A>;
        impl CRYPSMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRYPSMEN_A {
                match self.bits {
                    false => CRYPSMEN_A::DISABLED,
                    true => CRYPSMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CRYPSMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CRYPSMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CRYPSMEN`"]
        pub struct CRYPSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRYPSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRYPSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Crypto clock disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRYPSMEN_A::DISABLED)
            }
            #[doc = "Crypto clock enabled in Sleep mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRYPSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "CRC clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCSMEN_A {
            #[doc = "0: Test integration module clock disabled in Sleep mode"]
            DISABLED = 0,
            #[doc = "1: Test integration module clock enabled in Sleep mode (if enabled by CRCEN)"]
            ENABLED = 1,
        }
        impl From<CRCSMEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRCSMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCSMEN`"]
        pub type CRCSMEN_R = crate::R<bool, CRCSMEN_A>;
        impl CRCSMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCSMEN_A {
                match self.bits {
                    false => CRCSMEN_A::DISABLED,
                    true => CRCSMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CRCSMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CRCSMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CRCSMEN`"]
        pub struct CRCSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Test integration module clock disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRCSMEN_A::DISABLED)
            }
            #[doc = "Test integration module clock enabled in Sleep mode (if enabled by CRCEN)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRCSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "SRAM interface clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRAMSMEN_A {
            #[doc = "0: NVM interface clock disabled in Sleep mode"]
            DISABLED = 0,
            #[doc = "1: NVM interface clock enabled in Sleep mode"]
            ENABLED = 1,
        }
        impl From<SRAMSMEN_A> for bool {
            #[inline(always)]
            fn from(variant: SRAMSMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SRAMSMEN`"]
        pub type SRAMSMEN_R = crate::R<bool, SRAMSMEN_A>;
        impl SRAMSMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SRAMSMEN_A {
                match self.bits {
                    false => SRAMSMEN_A::DISABLED,
                    true => SRAMSMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SRAMSMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SRAMSMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SRAMSMEN`"]
        pub struct SRAMSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAMSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRAMSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NVM interface clock disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SRAMSMEN_A::DISABLED)
            }
            #[doc = "NVM interface clock enabled in Sleep mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SRAMSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "NVM interface clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MIFSMEN_A {
            #[doc = "0: NVM interface clock disabled in Sleep mode"]
            DISABLED = 0,
            #[doc = "1: NVM interface clock enabled in Sleep mode"]
            ENABLED = 1,
        }
        impl From<MIFSMEN_A> for bool {
            #[inline(always)]
            fn from(variant: MIFSMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MIFSMEN`"]
        pub type MIFSMEN_R = crate::R<bool, MIFSMEN_A>;
        impl MIFSMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MIFSMEN_A {
                match self.bits {
                    false => MIFSMEN_A::DISABLED,
                    true => MIFSMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MIFSMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MIFSMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MIFSMEN`"]
        pub struct MIFSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MIFSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MIFSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NVM interface clock disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MIFSMEN_A::DISABLED)
            }
            #[doc = "NVM interface clock enabled in Sleep mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MIFSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "DMA clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMASMEN_A {
            #[doc = "0: DMA clock disabled in Sleep mode"]
            DISABLED = 0,
            #[doc = "1: DMA clock enabled in Sleep mode"]
            ENABLED = 1,
        }
        impl From<DMASMEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMASMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMASMEN`"]
        pub type DMASMEN_R = crate::R<bool, DMASMEN_A>;
        impl DMASMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMASMEN_A {
                match self.bits {
                    false => DMASMEN_A::DISABLED,
                    true => DMASMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMASMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMASMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMASMEN`"]
        pub struct DMASMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMASMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMASMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA clock disabled in Sleep mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMASMEN_A::DISABLED)
            }
            #[doc = "DMA clock enabled in Sleep mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMASMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 24 - Crypto clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn crypsmen(&self) -> CRYPSMEN_R {
                CRYPSMEN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 12 - CRC clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn crcsmen(&self) -> CRCSMEN_R {
                CRCSMEN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 9 - SRAM interface clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn sramsmen(&self) -> SRAMSMEN_R {
                SRAMSMEN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - NVM interface clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn mifsmen(&self) -> MIFSMEN_R {
                MIFSMEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 0 - DMA clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn dmasmen(&self) -> DMASMEN_R {
                DMASMEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 24 - Crypto clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn crypsmen(&mut self) -> CRYPSMEN_W {
                CRYPSMEN_W { w: self }
            }
            #[doc = "Bit 12 - CRC clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn crcsmen(&mut self) -> CRCSMEN_W {
                CRCSMEN_W { w: self }
            }
            #[doc = "Bit 9 - SRAM interface clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn sramsmen(&mut self) -> SRAMSMEN_W {
                SRAMSMEN_W { w: self }
            }
            #[doc = "Bit 8 - NVM interface clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn mifsmen(&mut self) -> MIFSMEN_W {
                MIFSMEN_W { w: self }
            }
            #[doc = "Bit 0 - DMA clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn dmasmen(&mut self) -> DMASMEN_W {
                DMASMEN_W { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral clock enable in sleep mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb2smenr](apb2smenr) module"]
    pub type APB2SMENR = crate::Reg<u32, _APB2SMENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB2SMENR;
    #[doc = "`read()` method returns [apb2smenr::R](apb2smenr::R) reader structure"]
    impl crate::Readable for APB2SMENR {}
    #[doc = "`write(|w| ..)` method takes [apb2smenr::W](apb2smenr::W) writer structure"]
    impl crate::Writable for APB2SMENR {}
    #[doc = "APB2 peripheral clock enable in sleep mode register"]
    pub mod apb2smenr {
        #[doc = "Reader of register APB2SMENR"]
        pub type R = crate::R<u32, super::APB2SMENR>;
        #[doc = "Writer for register APB2SMENR"]
        pub type W = crate::W<u32, super::APB2SMENR>;
        #[doc = "Register APB2SMENR `reset()`'s with value 0x0040_5225"]
        impl crate::ResetValue for super::APB2SMENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0040_5225
            }
        }
        #[doc = "DBG clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBGSMEN_A {
            #[doc = "0: Clock disabled"]
            DISABLED = 0,
            #[doc = "1: Clock enabled"]
            ENABLED = 1,
        }
        impl From<DBGSMEN_A> for bool {
            #[inline(always)]
            fn from(variant: DBGSMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBGSMEN`"]
        pub type DBGSMEN_R = crate::R<bool, DBGSMEN_A>;
        impl DBGSMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBGSMEN_A {
                match self.bits {
                    false => DBGSMEN_A::DISABLED,
                    true => DBGSMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DBGSMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DBGSMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DBGSMEN`"]
        pub struct DBGSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBGSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBGSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "USART1 clock enable during sleep mode bit"]
        pub type USART1SMEN_A = DBGSMEN_A;
        #[doc = "Reader of field `USART1SMEN`"]
        pub type USART1SMEN_R = crate::R<bool, DBGSMEN_A>;
        #[doc = "Write proxy for field `USART1SMEN`"]
        pub struct USART1SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART1SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "SPI1 clock enable during sleep mode bit"]
        pub type SPI1SMEN_A = DBGSMEN_A;
        #[doc = "Reader of field `SPI1SMEN`"]
        pub type SPI1SMEN_R = crate::R<bool, DBGSMEN_A>;
        #[doc = "Write proxy for field `SPI1SMEN`"]
        pub struct SPI1SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "ADC clock enable during sleep mode bit"]
        pub type ADCSMEN_A = DBGSMEN_A;
        #[doc = "Reader of field `ADCSMEN`"]
        pub type ADCSMEN_R = crate::R<bool, DBGSMEN_A>;
        #[doc = "Write proxy for field `ADCSMEN`"]
        pub struct ADCSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADCSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADCSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "TIM22 timer clock enable during sleep mode bit"]
        pub type TIM22SMEN_A = DBGSMEN_A;
        #[doc = "Reader of field `TIM22SMEN`"]
        pub type TIM22SMEN_R = crate::R<bool, DBGSMEN_A>;
        #[doc = "Write proxy for field `TIM22SMEN`"]
        pub struct TIM22SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM22SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM22SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "TIM21 timer clock enable during sleep mode bit"]
        pub type TIM21SMEN_A = DBGSMEN_A;
        #[doc = "Reader of field `TIM21SMEN`"]
        pub type TIM21SMEN_R = crate::R<bool, DBGSMEN_A>;
        #[doc = "Write proxy for field `TIM21SMEN`"]
        pub struct TIM21SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM21SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM21SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "System configuration controller clock enable during sleep mode bit"]
        pub type SYSCFGSMEN_A = DBGSMEN_A;
        #[doc = "Reader of field `SYSCFGSMEN`"]
        pub type SYSCFGSMEN_R = crate::R<bool, DBGSMEN_A>;
        #[doc = "Write proxy for field `SYSCFGSMEN`"]
        pub struct SYSCFGSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SYSCFGSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSCFGSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBGSMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 22 - DBG clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn dbgsmen(&self) -> DBGSMEN_R {
                DBGSMEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 14 - USART1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn usart1smen(&self) -> USART1SMEN_R {
                USART1SMEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - SPI1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn spi1smen(&self) -> SPI1SMEN_R {
                SPI1SMEN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 9 - ADC clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn adcsmen(&self) -> ADCSMEN_R {
                ADCSMEN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 5 - TIM22 timer clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim22smen(&self) -> TIM22SMEN_R {
                TIM22SMEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 2 - TIM21 timer clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim21smen(&self) -> TIM21SMEN_R {
                TIM21SMEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - System configuration controller clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn syscfgsmen(&self) -> SYSCFGSMEN_R {
                SYSCFGSMEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 22 - DBG clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn dbgsmen(&mut self) -> DBGSMEN_W {
                DBGSMEN_W { w: self }
            }
            #[doc = "Bit 14 - USART1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn usart1smen(&mut self) -> USART1SMEN_W {
                USART1SMEN_W { w: self }
            }
            #[doc = "Bit 12 - SPI1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn spi1smen(&mut self) -> SPI1SMEN_W {
                SPI1SMEN_W { w: self }
            }
            #[doc = "Bit 9 - ADC clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn adcsmen(&mut self) -> ADCSMEN_W {
                ADCSMEN_W { w: self }
            }
            #[doc = "Bit 5 - TIM22 timer clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim22smen(&mut self) -> TIM22SMEN_W {
                TIM22SMEN_W { w: self }
            }
            #[doc = "Bit 2 - TIM21 timer clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim21smen(&mut self) -> TIM21SMEN_W {
                TIM21SMEN_W { w: self }
            }
            #[doc = "Bit 0 - System configuration controller clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn syscfgsmen(&mut self) -> SYSCFGSMEN_W {
                SYSCFGSMEN_W { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral clock enable in sleep mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb1smenr](apb1smenr) module"]
    pub type APB1SMENR = crate::Reg<u32, _APB1SMENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB1SMENR;
    #[doc = "`read()` method returns [apb1smenr::R](apb1smenr::R) reader structure"]
    impl crate::Readable for APB1SMENR {}
    #[doc = "`write(|w| ..)` method takes [apb1smenr::W](apb1smenr::W) writer structure"]
    impl crate::Writable for APB1SMENR {}
    #[doc = "APB1 peripheral clock enable in sleep mode register"]
    pub mod apb1smenr {
        #[doc = "Reader of register APB1SMENR"]
        pub type R = crate::R<u32, super::APB1SMENR>;
        #[doc = "Writer for register APB1SMENR"]
        pub type W = crate::W<u32, super::APB1SMENR>;
        #[doc = "Register APB1SMENR `reset()`'s with value 0xb8e6_4a11"]
        impl crate::ResetValue for super::APB1SMENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xb8e6_4a11
            }
        }
        #[doc = "Low power timer clock enable during sleep mode bit\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPTIM1SMEN_A {
            #[doc = "0: Clock disabled"]
            DISABLED = 0,
            #[doc = "1: Clock enabled"]
            ENABLED = 1,
        }
        impl From<LPTIM1SMEN_A> for bool {
            #[inline(always)]
            fn from(variant: LPTIM1SMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPTIM1SMEN`"]
        pub type LPTIM1SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        impl LPTIM1SMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPTIM1SMEN_A {
                match self.bits {
                    false => LPTIM1SMEN_A::DISABLED,
                    true => LPTIM1SMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LPTIM1SMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LPTIM1SMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LPTIM1SMEN`"]
        pub struct LPTIM1SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPTIM1SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPTIM1SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Power interface clock enable during sleep mode bit"]
        pub type PWRSMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `PWRSMEN`"]
        pub type PWRSMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `PWRSMEN`"]
        pub struct PWRSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PWRSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Clock recovery system clock enable during sleep mode bit"]
        pub type CRSSMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `CRSSMEN`"]
        pub type CRSSMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `CRSSMEN`"]
        pub struct CRSSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRSSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRSSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "I2C2 clock enable during sleep mode bit"]
        pub type I2C2SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `I2C2SMEN`"]
        pub type I2C2SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `I2C2SMEN`"]
        pub struct I2C2SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C2SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "I2C1 clock enable during sleep mode bit"]
        pub type I2C1SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `I2C1SMEN`"]
        pub type I2C1SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `I2C1SMEN`"]
        pub struct I2C1SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "LPUART1 clock enable during sleep mode bit"]
        pub type LPUART1SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `LPUART1SMEN`"]
        pub type LPUART1SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `LPUART1SMEN`"]
        pub struct LPUART1SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPUART1SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPUART1SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "UART2 clock enable during sleep mode bit"]
        pub type USART2SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `USART2SMEN`"]
        pub type USART2SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `USART2SMEN`"]
        pub struct USART2SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART2SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "SPI2 clock enable during sleep mode bit"]
        pub type SPI2SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `SPI2SMEN`"]
        pub type SPI2SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `SPI2SMEN`"]
        pub struct SPI2SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI2SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Window watchdog clock enable during sleep mode bit"]
        pub type WWDGSMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `WWDGSMEN`"]
        pub type WWDGSMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `WWDGSMEN`"]
        pub struct WWDGSMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGSMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGSMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Timer 6 clock enable during sleep mode bit"]
        pub type TIM6SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `TIM6SMEN`"]
        pub type TIM6SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `TIM6SMEN`"]
        pub struct TIM6SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM6SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Timer2 clock enable during sleep mode bit"]
        pub type TIM2SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `TIM2SMEN`"]
        pub type TIM2SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `TIM2SMEN`"]
        pub struct TIM2SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM2SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Timer 3 clock enable during sleep mode bit"]
        pub type TIM3SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `TIM3SMEN`"]
        pub type TIM3SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `TIM3SMEN`"]
        pub struct TIM3SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM3SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Timer 7 clock enable during sleep mode bit"]
        pub type TIM7SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `TIM7SMEN`"]
        pub type TIM7SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `TIM7SMEN`"]
        pub struct TIM7SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIM7SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "USART4 clock enabe during sleep mode bit"]
        pub type USART4SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `USART4SMEN`"]
        pub type USART4SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `USART4SMEN`"]
        pub struct USART4SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART4SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART4SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "USART5 clock enable during sleep mode bit"]
        pub type USART5SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `USART5SMEN`"]
        pub type USART5SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `USART5SMEN`"]
        pub struct USART5SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART5SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART5SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "I2C3 clock enable during sleep mode bit"]
        pub type I2C3SMEN_A = LPTIM1SMEN_A;
        #[doc = "Reader of field `I2C3SMEN`"]
        pub type I2C3SMEN_R = crate::R<bool, LPTIM1SMEN_A>;
        #[doc = "Write proxy for field `I2C3SMEN`"]
        pub struct I2C3SMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C3SMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C3SMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::DISABLED)
            }
            #[doc = "Clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPTIM1SMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 31 - Low power timer clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn lptim1smen(&self) -> LPTIM1SMEN_R {
                LPTIM1SMEN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Power interface clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn pwrsmen(&self) -> PWRSMEN_R {
                PWRSMEN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 27 - Clock recovery system clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn crssmen(&self) -> CRSSMEN_R {
                CRSSMEN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 22 - I2C2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn i2c2smen(&self) -> I2C2SMEN_R {
                I2C2SMEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - I2C1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn i2c1smen(&self) -> I2C1SMEN_R {
                I2C1SMEN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 18 - LPUART1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn lpuart1smen(&self) -> LPUART1SMEN_R {
                LPUART1SMEN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - UART2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn usart2smen(&self) -> USART2SMEN_R {
                USART2SMEN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 14 - SPI2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn spi2smen(&self) -> SPI2SMEN_R {
                SPI2SMEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Window watchdog clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn wwdgsmen(&self) -> WWDGSMEN_R {
                WWDGSMEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Timer 6 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim6smen(&self) -> TIM6SMEN_R {
                TIM6SMEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Timer2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim2smen(&self) -> TIM2SMEN_R {
                TIM2SMEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Timer 3 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim3smen(&self) -> TIM3SMEN_R {
                TIM3SMEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Timer 7 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim7smen(&self) -> TIM7SMEN_R {
                TIM7SMEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 19 - USART4 clock enabe during sleep mode bit"]
            #[inline(always)]
            pub fn usart4smen(&self) -> USART4SMEN_R {
                USART4SMEN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - USART5 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn usart5smen(&self) -> USART5SMEN_R {
                USART5SMEN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 30 - I2C3 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn i2c3smen(&self) -> I2C3SMEN_R {
                I2C3SMEN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 31 - Low power timer clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn lptim1smen(&mut self) -> LPTIM1SMEN_W {
                LPTIM1SMEN_W { w: self }
            }
            #[doc = "Bit 28 - Power interface clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn pwrsmen(&mut self) -> PWRSMEN_W {
                PWRSMEN_W { w: self }
            }
            #[doc = "Bit 27 - Clock recovery system clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn crssmen(&mut self) -> CRSSMEN_W {
                CRSSMEN_W { w: self }
            }
            #[doc = "Bit 22 - I2C2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn i2c2smen(&mut self) -> I2C2SMEN_W {
                I2C2SMEN_W { w: self }
            }
            #[doc = "Bit 21 - I2C1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn i2c1smen(&mut self) -> I2C1SMEN_W {
                I2C1SMEN_W { w: self }
            }
            #[doc = "Bit 18 - LPUART1 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn lpuart1smen(&mut self) -> LPUART1SMEN_W {
                LPUART1SMEN_W { w: self }
            }
            #[doc = "Bit 17 - UART2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn usart2smen(&mut self) -> USART2SMEN_W {
                USART2SMEN_W { w: self }
            }
            #[doc = "Bit 14 - SPI2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn spi2smen(&mut self) -> SPI2SMEN_W {
                SPI2SMEN_W { w: self }
            }
            #[doc = "Bit 11 - Window watchdog clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn wwdgsmen(&mut self) -> WWDGSMEN_W {
                WWDGSMEN_W { w: self }
            }
            #[doc = "Bit 4 - Timer 6 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim6smen(&mut self) -> TIM6SMEN_W {
                TIM6SMEN_W { w: self }
            }
            #[doc = "Bit 0 - Timer2 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim2smen(&mut self) -> TIM2SMEN_W {
                TIM2SMEN_W { w: self }
            }
            #[doc = "Bit 1 - Timer 3 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim3smen(&mut self) -> TIM3SMEN_W {
                TIM3SMEN_W { w: self }
            }
            #[doc = "Bit 5 - Timer 7 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn tim7smen(&mut self) -> TIM7SMEN_W {
                TIM7SMEN_W { w: self }
            }
            #[doc = "Bit 19 - USART4 clock enabe during sleep mode bit"]
            #[inline(always)]
            pub fn usart4smen(&mut self) -> USART4SMEN_W {
                USART4SMEN_W { w: self }
            }
            #[doc = "Bit 20 - USART5 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn usart5smen(&mut self) -> USART5SMEN_W {
                USART5SMEN_W { w: self }
            }
            #[doc = "Bit 30 - I2C3 clock enable during sleep mode bit"]
            #[inline(always)]
            pub fn i2c3smen(&mut self) -> I2C3SMEN_W {
                I2C3SMEN_W { w: self }
            }
        }
    }
    #[doc = "Clock configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccipr](ccipr) module"]
    pub type CCIPR = crate::Reg<u32, _CCIPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCIPR;
    #[doc = "`read()` method returns [ccipr::R](ccipr::R) reader structure"]
    impl crate::Readable for CCIPR {}
    #[doc = "`write(|w| ..)` method takes [ccipr::W](ccipr::W) writer structure"]
    impl crate::Writable for CCIPR {}
    #[doc = "Clock configuration register"]
    pub mod ccipr {
        #[doc = "Reader of register CCIPR"]
        pub type R = crate::R<u32, super::CCIPR>;
        #[doc = "Writer for register CCIPR"]
        pub type W = crate::W<u32, super::CCIPR>;
        #[doc = "Register CCIPR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCIPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Low Power Timer clock source selection bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum LPTIM1SEL_A {
            #[doc = "0: APB clock selected as Timer clock"]
            APB = 0,
            #[doc = "1: LSI clock selected as Timer clock"]
            LSI = 1,
            #[doc = "2: HSI16 clock selected as Timer clock"]
            HSI16 = 2,
            #[doc = "3: LSE clock selected as Timer clock"]
            LSE = 3,
        }
        impl From<LPTIM1SEL_A> for u8 {
            #[inline(always)]
            fn from(variant: LPTIM1SEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `LPTIM1SEL`"]
        pub type LPTIM1SEL_R = crate::R<u8, LPTIM1SEL_A>;
        impl LPTIM1SEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPTIM1SEL_A {
                match self.bits {
                    0 => LPTIM1SEL_A::APB,
                    1 => LPTIM1SEL_A::LSI,
                    2 => LPTIM1SEL_A::HSI16,
                    3 => LPTIM1SEL_A::LSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `APB`"]
            #[inline(always)]
            pub fn is_apb(&self) -> bool {
                *self == LPTIM1SEL_A::APB
            }
            #[doc = "Checks if the value of the field is `LSI`"]
            #[inline(always)]
            pub fn is_lsi(&self) -> bool {
                *self == LPTIM1SEL_A::LSI
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == LPTIM1SEL_A::HSI16
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == LPTIM1SEL_A::LSE
            }
        }
        #[doc = "Write proxy for field `LPTIM1SEL`"]
        pub struct LPTIM1SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPTIM1SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPTIM1SEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "APB clock selected as Timer clock"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(LPTIM1SEL_A::APB)
            }
            #[doc = "LSI clock selected as Timer clock"]
            #[inline(always)]
            pub fn lsi(self) -> &'a mut W {
                self.variant(LPTIM1SEL_A::LSI)
            }
            #[doc = "HSI16 clock selected as Timer clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(LPTIM1SEL_A::HSI16)
            }
            #[doc = "LSE clock selected as Timer clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(LPTIM1SEL_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | (((value as u32) & 0x03) << 18);
                self.w
            }
        }
        #[doc = "I2C3 clock source selection bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum I2C3SEL_A {
            #[doc = "0: APB clock selected as peripheral clock"]
            APB = 0,
            #[doc = "1: System clock selected as peripheral clock"]
            SYSTEM = 1,
            #[doc = "2: HSI16 clock selected as peripheral clock"]
            HSI16 = 2,
        }
        impl From<I2C3SEL_A> for u8 {
            #[inline(always)]
            fn from(variant: I2C3SEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `I2C3SEL`"]
        pub type I2C3SEL_R = crate::R<u8, I2C3SEL_A>;
        impl I2C3SEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, I2C3SEL_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(I2C3SEL_A::APB),
                    1 => Val(I2C3SEL_A::SYSTEM),
                    2 => Val(I2C3SEL_A::HSI16),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `APB`"]
            #[inline(always)]
            pub fn is_apb(&self) -> bool {
                *self == I2C3SEL_A::APB
            }
            #[doc = "Checks if the value of the field is `SYSTEM`"]
            #[inline(always)]
            pub fn is_system(&self) -> bool {
                *self == I2C3SEL_A::SYSTEM
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == I2C3SEL_A::HSI16
            }
        }
        #[doc = "Write proxy for field `I2C3SEL`"]
        pub struct I2C3SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C3SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C3SEL_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "APB clock selected as peripheral clock"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(I2C3SEL_A::APB)
            }
            #[doc = "System clock selected as peripheral clock"]
            #[inline(always)]
            pub fn system(self) -> &'a mut W {
                self.variant(I2C3SEL_A::SYSTEM)
            }
            #[doc = "HSI16 clock selected as peripheral clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(I2C3SEL_A::HSI16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "I2C1 clock source selection bits"]
        pub type I2C1SEL_A = I2C3SEL_A;
        #[doc = "Reader of field `I2C1SEL`"]
        pub type I2C1SEL_R = crate::R<u8, I2C3SEL_A>;
        #[doc = "Write proxy for field `I2C1SEL`"]
        pub struct I2C1SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1SEL_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "APB clock selected as peripheral clock"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(I2C3SEL_A::APB)
            }
            #[doc = "System clock selected as peripheral clock"]
            #[inline(always)]
            pub fn system(self) -> &'a mut W {
                self.variant(I2C3SEL_A::SYSTEM)
            }
            #[doc = "HSI16 clock selected as peripheral clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(I2C3SEL_A::HSI16)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "LPUART1 clock source selection bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum LPUART1SEL_A {
            #[doc = "0: APB clock selected as peripheral clock"]
            APB = 0,
            #[doc = "1: System clock selected as peripheral clock"]
            SYSTEM = 1,
            #[doc = "2: HSI16 clock selected as peripheral clock"]
            HSI16 = 2,
            #[doc = "3: LSE clock selected as peripheral clock"]
            LSE = 3,
        }
        impl From<LPUART1SEL_A> for u8 {
            #[inline(always)]
            fn from(variant: LPUART1SEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `LPUART1SEL`"]
        pub type LPUART1SEL_R = crate::R<u8, LPUART1SEL_A>;
        impl LPUART1SEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPUART1SEL_A {
                match self.bits {
                    0 => LPUART1SEL_A::APB,
                    1 => LPUART1SEL_A::SYSTEM,
                    2 => LPUART1SEL_A::HSI16,
                    3 => LPUART1SEL_A::LSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `APB`"]
            #[inline(always)]
            pub fn is_apb(&self) -> bool {
                *self == LPUART1SEL_A::APB
            }
            #[doc = "Checks if the value of the field is `SYSTEM`"]
            #[inline(always)]
            pub fn is_system(&self) -> bool {
                *self == LPUART1SEL_A::SYSTEM
            }
            #[doc = "Checks if the value of the field is `HSI16`"]
            #[inline(always)]
            pub fn is_hsi16(&self) -> bool {
                *self == LPUART1SEL_A::HSI16
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == LPUART1SEL_A::LSE
            }
        }
        #[doc = "Write proxy for field `LPUART1SEL`"]
        pub struct LPUART1SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPUART1SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPUART1SEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "APB clock selected as peripheral clock"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::APB)
            }
            #[doc = "System clock selected as peripheral clock"]
            #[inline(always)]
            pub fn system(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::SYSTEM)
            }
            #[doc = "HSI16 clock selected as peripheral clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::HSI16)
            }
            #[doc = "LSE clock selected as peripheral clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "USART2 clock source selection bits"]
        pub type USART2SEL_A = LPUART1SEL_A;
        #[doc = "Reader of field `USART2SEL`"]
        pub type USART2SEL_R = crate::R<u8, LPUART1SEL_A>;
        #[doc = "Write proxy for field `USART2SEL`"]
        pub struct USART2SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART2SEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "APB clock selected as peripheral clock"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::APB)
            }
            #[doc = "System clock selected as peripheral clock"]
            #[inline(always)]
            pub fn system(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::SYSTEM)
            }
            #[doc = "HSI16 clock selected as peripheral clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::HSI16)
            }
            #[doc = "LSE clock selected as peripheral clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "USART1 clock source selection bits"]
        pub type USART1SEL_A = LPUART1SEL_A;
        #[doc = "Reader of field `USART1SEL`"]
        pub type USART1SEL_R = crate::R<u8, LPUART1SEL_A>;
        #[doc = "Write proxy for field `USART1SEL`"]
        pub struct USART1SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART1SEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "APB clock selected as peripheral clock"]
            #[inline(always)]
            pub fn apb(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::APB)
            }
            #[doc = "System clock selected as peripheral clock"]
            #[inline(always)]
            pub fn system(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::SYSTEM)
            }
            #[doc = "HSI16 clock selected as peripheral clock"]
            #[inline(always)]
            pub fn hsi16(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::HSI16)
            }
            #[doc = "LSE clock selected as peripheral clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(LPUART1SEL_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 18:19 - Low Power Timer clock source selection bits"]
            #[inline(always)]
            pub fn lptim1sel(&self) -> LPTIM1SEL_R {
                LPTIM1SEL_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            #[doc = "Bits 16:17 - I2C3 clock source selection bits"]
            #[inline(always)]
            pub fn i2c3sel(&self) -> I2C3SEL_R {
                I2C3SEL_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bits 12:13 - I2C1 clock source selection bits"]
            #[inline(always)]
            pub fn i2c1sel(&self) -> I2C1SEL_R {
                I2C1SEL_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - LPUART1 clock source selection bits"]
            #[inline(always)]
            pub fn lpuart1sel(&self) -> LPUART1SEL_R {
                LPUART1SEL_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - USART2 clock source selection bits"]
            #[inline(always)]
            pub fn usart2sel(&self) -> USART2SEL_R {
                USART2SEL_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - USART1 clock source selection bits"]
            #[inline(always)]
            pub fn usart1sel(&self) -> USART1SEL_R {
                USART1SEL_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 18:19 - Low Power Timer clock source selection bits"]
            #[inline(always)]
            pub fn lptim1sel(&mut self) -> LPTIM1SEL_W {
                LPTIM1SEL_W { w: self }
            }
            #[doc = "Bits 16:17 - I2C3 clock source selection bits"]
            #[inline(always)]
            pub fn i2c3sel(&mut self) -> I2C3SEL_W {
                I2C3SEL_W { w: self }
            }
            #[doc = "Bits 12:13 - I2C1 clock source selection bits"]
            #[inline(always)]
            pub fn i2c1sel(&mut self) -> I2C1SEL_W {
                I2C1SEL_W { w: self }
            }
            #[doc = "Bits 10:11 - LPUART1 clock source selection bits"]
            #[inline(always)]
            pub fn lpuart1sel(&mut self) -> LPUART1SEL_W {
                LPUART1SEL_W { w: self }
            }
            #[doc = "Bits 2:3 - USART2 clock source selection bits"]
            #[inline(always)]
            pub fn usart2sel(&mut self) -> USART2SEL_W {
                USART2SEL_W { w: self }
            }
            #[doc = "Bits 0:1 - USART1 clock source selection bits"]
            #[inline(always)]
            pub fn usart1sel(&mut self) -> USART1SEL_W {
                USART1SEL_W { w: self }
            }
        }
    }
    #[doc = "Control and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
    pub type CSR = crate::Reg<u32, _CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSR;
    #[doc = "`read()` method returns [csr::R](csr::R) reader structure"]
    impl crate::Readable for CSR {}
    #[doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
    impl crate::Writable for CSR {}
    #[doc = "Control and status register"]
    pub mod csr {
        #[doc = "Reader of register CSR"]
        pub type R = crate::R<u32, super::CSR>;
        #[doc = "Writer for register CSR"]
        pub type W = crate::W<u32, super::CSR>;
        #[doc = "Register CSR `reset()`'s with value 0x0c00_0000"]
        impl crate::ResetValue for super::CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0c00_0000
            }
        }
        #[doc = "Low-power reset flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPWRRSTF_A {
            #[doc = "0: No reset has occured"]
            NORESET = 0,
            #[doc = "1: A reset has occured"]
            RESET = 1,
        }
        impl From<LPWRRSTF_A> for bool {
            #[inline(always)]
            fn from(variant: LPWRRSTF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPWRRSTF`"]
        pub type LPWRRSTF_R = crate::R<bool, LPWRRSTF_A>;
        impl LPWRRSTF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPWRRSTF_A {
                match self.bits {
                    false => LPWRRSTF_A::NORESET,
                    true => LPWRRSTF_A::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORESET`"]
            #[inline(always)]
            pub fn is_no_reset(&self) -> bool {
                *self == LPWRRSTF_A::NORESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == LPWRRSTF_A::RESET
            }
        }
        #[doc = "Write proxy for field `LPWRRSTF`"]
        pub struct LPWRRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPWRRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPWRRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "Window watchdog reset flag"]
        pub type WWDGRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `WWDGRSTF`"]
        pub type WWDGRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `WWDGRSTF`"]
        pub struct WWDGRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDGRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Independent watchdog reset flag"]
        pub type IWDGRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `IWDGRSTF`"]
        pub type IWDGRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `IWDGRSTF`"]
        pub struct IWDGRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IWDGRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IWDGRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Software reset flag"]
        pub type SFTRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `SFTRSTF`"]
        pub type SFTRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `SFTRSTF`"]
        pub struct SFTRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SFTRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SFTRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "POR/PDR reset flag"]
        pub type PORRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `PORRSTF`"]
        pub type PORRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `PORRSTF`"]
        pub struct PORRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PORRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PORRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "PIN reset flag"]
        pub type PINRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `PINRSTF`"]
        pub type PINRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `PINRSTF`"]
        pub struct PINRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PINRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "OBLRSTF"]
        pub type OBLRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `OBLRSTF`"]
        pub type OBLRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `OBLRSTF`"]
        pub struct OBLRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OBLRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OBLRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Firewall reset flag"]
        pub type FWRSTF_A = LPWRRSTF_A;
        #[doc = "Reader of field `FWRSTF`"]
        pub type FWRSTF_R = crate::R<bool, LPWRRSTF_A>;
        #[doc = "Write proxy for field `FWRSTF`"]
        pub struct FWRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FWRSTF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FWRSTF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No reset has occured"]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "RTC software reset bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTCRST_A {
            #[doc = "1: Resets the RTC peripheral"]
            RESET = 1,
        }
        impl From<RTCRST_A> for bool {
            #[inline(always)]
            fn from(variant: RTCRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTCRST`"]
        pub type RTCRST_R = crate::R<bool, RTCRST_A>;
        impl RTCRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, RTCRST_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(RTCRST_A::RESET),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == RTCRST_A::RESET
            }
        }
        #[doc = "Write proxy for field `RTCRST`"]
        pub struct RTCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTCRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Resets the RTC peripheral"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RTCRST_A::RESET)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "RTC clock enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTCEN_A {
            #[doc = "0: RTC clock disabled"]
            DISABLED = 0,
            #[doc = "1: RTC clock enabled"]
            ENABLED = 1,
        }
        impl From<RTCEN_A> for bool {
            #[inline(always)]
            fn from(variant: RTCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTCEN`"]
        pub type RTCEN_R = crate::R<bool, RTCEN_A>;
        impl RTCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTCEN_A {
                match self.bits {
                    false => RTCEN_A::DISABLED,
                    true => RTCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTCEN`"]
        pub struct RTCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTC clock disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTCEN_A::DISABLED)
            }
            #[doc = "RTC clock enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "RTC and LCD clock source selection bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum RTCSEL_A {
            #[doc = "0: No clock"]
            NOCLOCK = 0,
            #[doc = "1: LSE oscillator clock used as RTC clock"]
            LSE = 1,
            #[doc = "2: LSI oscillator clock used as RTC clock"]
            LSI = 2,
            #[doc = "3: HSE oscillator clock divided by a programmable prescaler (selection through the RTCPRE\\[1:0\\]
bits in the RCC clock control register (RCC_CR)) used as the RTC clock"]
            HSE = 3,
        }
        impl From<RTCSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: RTCSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `RTCSEL`"]
        pub type RTCSEL_R = crate::R<u8, RTCSEL_A>;
        impl RTCSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTCSEL_A {
                match self.bits {
                    0 => RTCSEL_A::NOCLOCK,
                    1 => RTCSEL_A::LSE,
                    2 => RTCSEL_A::LSI,
                    3 => RTCSEL_A::HSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOCLOCK`"]
            #[inline(always)]
            pub fn is_no_clock(&self) -> bool {
                *self == RTCSEL_A::NOCLOCK
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == RTCSEL_A::LSE
            }
            #[doc = "Checks if the value of the field is `LSI`"]
            #[inline(always)]
            pub fn is_lsi(&self) -> bool {
                *self == RTCSEL_A::LSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == RTCSEL_A::HSE
            }
        }
        #[doc = "Write proxy for field `RTCSEL`"]
        pub struct RTCSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTCSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No clock"]
            #[inline(always)]
            pub fn no_clock(self) -> &'a mut W {
                self.variant(RTCSEL_A::NOCLOCK)
            }
            #[doc = "LSE oscillator clock used as RTC clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(RTCSEL_A::LSE)
            }
            #[doc = "LSI oscillator clock used as RTC clock"]
            #[inline(always)]
            pub fn lsi(self) -> &'a mut W {
                self.variant(RTCSEL_A::LSI)
            }
            #[doc = "HSE oscillator clock divided by a programmable prescaler (selection through the RTCPRE\\[1:0\\]
bits in the RCC clock control register (RCC_CR)) used as the RTC clock"]
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(RTCSEL_A::HSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "CSS on LSE failure detection flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSLSED_A {
            #[doc = "0: No failure detected on LSE (32 kHz oscillator)"]
            NOFAILURE = 0,
            #[doc = "1: Failure detected on LSE (32 kHz oscillator)"]
            FAILURE = 1,
        }
        impl From<CSSLSED_A> for bool {
            #[inline(always)]
            fn from(variant: CSSLSED_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSLSED`"]
        pub type CSSLSED_R = crate::R<bool, CSSLSED_A>;
        impl CSSLSED_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSLSED_A {
                match self.bits {
                    false => CSSLSED_A::NOFAILURE,
                    true => CSSLSED_A::FAILURE,
                }
            }
            #[doc = "Checks if the value of the field is `NOFAILURE`"]
            #[inline(always)]
            pub fn is_no_failure(&self) -> bool {
                *self == CSSLSED_A::NOFAILURE
            }
            #[doc = "Checks if the value of the field is `FAILURE`"]
            #[inline(always)]
            pub fn is_failure(&self) -> bool {
                *self == CSSLSED_A::FAILURE
            }
        }
        #[doc = "Write proxy for field `CSSLSED`"]
        pub struct CSSLSED_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSLSED_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CSSLSED_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No failure detected on LSE (32 kHz oscillator)"]
            #[inline(always)]
            pub fn no_failure(self) -> &'a mut W {
                self.variant(CSSLSED_A::NOFAILURE)
            }
            #[doc = "Failure detected on LSE (32 kHz oscillator)"]
            #[inline(always)]
            pub fn failure(self) -> &'a mut W {
                self.variant(CSSLSED_A::FAILURE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "CSSLSEON\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSLSEON_A {
            #[doc = "0: Oscillator OFF"]
            OFF = 0,
            #[doc = "1: Oscillator ON"]
            ON = 1,
        }
        impl From<CSSLSEON_A> for bool {
            #[inline(always)]
            fn from(variant: CSSLSEON_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSSLSEON`"]
        pub type CSSLSEON_R = crate::R<bool, CSSLSEON_A>;
        impl CSSLSEON_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CSSLSEON_A {
                match self.bits {
                    false => CSSLSEON_A::OFF,
                    true => CSSLSEON_A::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == CSSLSEON_A::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == CSSLSEON_A::ON
            }
        }
        #[doc = "Write proxy for field `CSSLSEON`"]
        pub struct CSSLSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSLSEON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CSSLSEON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Oscillator OFF"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(CSSLSEON_A::OFF)
            }
            #[doc = "Oscillator ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(CSSLSEON_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "LSEDRV\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum LSEDRV_A {
            #[doc = "0: Lowest drive"]
            LOW = 0,
            #[doc = "1: Medium low drive"]
            MEDIUMLOW = 1,
            #[doc = "2: Medium high drive"]
            MEDIUMHIGH = 2,
            #[doc = "3: Highest drive"]
            HIGH = 3,
        }
        impl From<LSEDRV_A> for u8 {
            #[inline(always)]
            fn from(variant: LSEDRV_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `LSEDRV`"]
        pub type LSEDRV_R = crate::R<u8, LSEDRV_A>;
        impl LSEDRV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSEDRV_A {
                match self.bits {
                    0 => LSEDRV_A::LOW,
                    1 => LSEDRV_A::MEDIUMLOW,
                    2 => LSEDRV_A::MEDIUMHIGH,
                    3 => LSEDRV_A::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == LSEDRV_A::LOW
            }
            #[doc = "Checks if the value of the field is `MEDIUMLOW`"]
            #[inline(always)]
            pub fn is_medium_low(&self) -> bool {
                *self == LSEDRV_A::MEDIUMLOW
            }
            #[doc = "Checks if the value of the field is `MEDIUMHIGH`"]
            #[inline(always)]
            pub fn is_medium_high(&self) -> bool {
                *self == LSEDRV_A::MEDIUMHIGH
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == LSEDRV_A::HIGH
            }
        }
        #[doc = "Write proxy for field `LSEDRV`"]
        pub struct LSEDRV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEDRV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSEDRV_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Lowest drive"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(LSEDRV_A::LOW)
            }
            #[doc = "Medium low drive"]
            #[inline(always)]
            pub fn medium_low(self) -> &'a mut W {
                self.variant(LSEDRV_A::MEDIUMLOW)
            }
            #[doc = "Medium high drive"]
            #[inline(always)]
            pub fn medium_high(self) -> &'a mut W {
                self.variant(LSEDRV_A::MEDIUMHIGH)
            }
            #[doc = "Highest drive"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(LSEDRV_A::HIGH)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 11)) | (((value as u32) & 0x03) << 11);
                self.w
            }
        }
        #[doc = "External low-speed oscillator bypass bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEBYP_A {
            #[doc = "0: LSE oscillator not bypassed"]
            NOTBYPASSED = 0,
            #[doc = "1: LSE oscillator bypassed"]
            BYPASSED = 1,
        }
        impl From<LSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: LSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSEBYP`"]
        pub type LSEBYP_R = crate::R<bool, LSEBYP_A>;
        impl LSEBYP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSEBYP_A {
                match self.bits {
                    false => LSEBYP_A::NOTBYPASSED,
                    true => LSEBYP_A::BYPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBYPASSED`"]
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                *self == LSEBYP_A::NOTBYPASSED
            }
            #[doc = "Checks if the value of the field is `BYPASSED`"]
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                *self == LSEBYP_A::BYPASSED
            }
        }
        #[doc = "Write proxy for field `LSEBYP`"]
        pub struct LSEBYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEBYP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSEBYP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LSE oscillator not bypassed"]
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::NOTBYPASSED)
            }
            #[doc = "LSE oscillator bypassed"]
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::BYPASSED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "External low-speed oscillator ready bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSERDY_A {
            #[doc = "0: Oscillator not ready"]
            NOTREADY = 0,
            #[doc = "1: Oscillator ready"]
            READY = 1,
        }
        impl From<LSERDY_A> for bool {
            #[inline(always)]
            fn from(variant: LSERDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSERDY`"]
        pub type LSERDY_R = crate::R<bool, LSERDY_A>;
        impl LSERDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSERDY_A {
                match self.bits {
                    false => LSERDY_A::NOTREADY,
                    true => LSERDY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == LSERDY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == LSERDY_A::READY
            }
        }
        #[doc = "External low-speed oscillator enable bit"]
        pub type LSEON_A = CSSLSEON_A;
        #[doc = "Reader of field `LSEON`"]
        pub type LSEON_R = crate::R<bool, CSSLSEON_A>;
        #[doc = "Write proxy for field `LSEON`"]
        pub struct LSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEON_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSEON_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Oscillator OFF"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(CSSLSEON_A::OFF)
            }
            #[doc = "Oscillator ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(CSSLSEON_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Internal low-speed oscillator ready bit"]
        pub type LSIRDY_A = LSERDY_A;
        #[doc = "Reader of field `LSIRDY`"]
        pub type LSIRDY_R = crate::R<bool, LSERDY_A>;
        #[doc = "Internal low-speed oscillator enable"]
        pub type LSION_A = CSSLSEON_A;
        #[doc = "Reader of field `LSION`"]
        pub type LSION_R = crate::R<bool, CSSLSEON_A>;
        #[doc = "Write proxy for field `LSION`"]
        pub struct LSION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSION_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSION_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Oscillator OFF"]
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(CSSLSEON_A::OFF)
            }
            #[doc = "Oscillator ON"]
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(CSSLSEON_A::ON)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Remove reset flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMVF_A {
            #[doc = "1: Clears the reset flag"]
            CLEAR = 1,
        }
        impl From<RMVF_A> for bool {
            #[inline(always)]
            fn from(variant: RMVF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RMVF`"]
        pub type RMVF_R = crate::R<bool, RMVF_A>;
        impl RMVF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, RMVF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(RMVF_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == RMVF_A::CLEAR
            }
        }
        #[doc = "Write proxy for field `RMVF`"]
        pub struct RMVF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RMVF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RMVF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the reset flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RMVF_A::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline(always)]
            pub fn lpwrrstf(&self) -> LPWRRSTF_R {
                LPWRRSTF_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline(always)]
            pub fn wwdgrstf(&self) -> WWDGRSTF_R {
                WWDGRSTF_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline(always)]
            pub fn iwdgrstf(&self) -> IWDGRSTF_R {
                IWDGRSTF_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline(always)]
            pub fn sftrstf(&self) -> SFTRSTF_R {
                SFTRSTF_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline(always)]
            pub fn porrstf(&self) -> PORRSTF_R {
                PORRSTF_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline(always)]
            pub fn pinrstf(&self) -> PINRSTF_R {
                PINRSTF_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 25 - OBLRSTF"]
            #[inline(always)]
            pub fn oblrstf(&self) -> OBLRSTF_R {
                OBLRSTF_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Firewall reset flag"]
            #[inline(always)]
            pub fn fwrstf(&self) -> FWRSTF_R {
                FWRSTF_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 19 - RTC software reset bit"]
            #[inline(always)]
            pub fn rtcrst(&self) -> RTCRST_R {
                RTCRST_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - RTC clock enable bit"]
            #[inline(always)]
            pub fn rtcen(&self) -> RTCEN_R {
                RTCEN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bits 16:17 - RTC and LCD clock source selection bits"]
            #[inline(always)]
            pub fn rtcsel(&self) -> RTCSEL_R {
                RTCSEL_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bit 14 - CSS on LSE failure detection flag"]
            #[inline(always)]
            pub fn csslsed(&self) -> CSSLSED_R {
                CSSLSED_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - CSSLSEON"]
            #[inline(always)]
            pub fn csslseon(&self) -> CSSLSEON_R {
                CSSLSEON_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bits 11:12 - LSEDRV"]
            #[inline(always)]
            pub fn lsedrv(&self) -> LSEDRV_R {
                LSEDRV_R::new(((self.bits >> 11) & 0x03) as u8)
            }
            #[doc = "Bit 10 - External low-speed oscillator bypass bit"]
            #[inline(always)]
            pub fn lsebyp(&self) -> LSEBYP_R {
                LSEBYP_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - External low-speed oscillator ready bit"]
            #[inline(always)]
            pub fn lserdy(&self) -> LSERDY_R {
                LSERDY_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - External low-speed oscillator enable bit"]
            #[inline(always)]
            pub fn lseon(&self) -> LSEON_R {
                LSEON_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Internal low-speed oscillator ready bit"]
            #[inline(always)]
            pub fn lsirdy(&self) -> LSIRDY_R {
                LSIRDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Internal low-speed oscillator enable"]
            #[inline(always)]
            pub fn lsion(&self) -> LSION_R {
                LSION_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 23 - Remove reset flag"]
            #[inline(always)]
            pub fn rmvf(&self) -> RMVF_R {
                RMVF_R::new(((self.bits >> 23) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline(always)]
            pub fn lpwrrstf(&mut self) -> LPWRRSTF_W {
                LPWRRSTF_W { w: self }
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline(always)]
            pub fn wwdgrstf(&mut self) -> WWDGRSTF_W {
                WWDGRSTF_W { w: self }
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline(always)]
            pub fn iwdgrstf(&mut self) -> IWDGRSTF_W {
                IWDGRSTF_W { w: self }
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline(always)]
            pub fn sftrstf(&mut self) -> SFTRSTF_W {
                SFTRSTF_W { w: self }
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline(always)]
            pub fn porrstf(&mut self) -> PORRSTF_W {
                PORRSTF_W { w: self }
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline(always)]
            pub fn pinrstf(&mut self) -> PINRSTF_W {
                PINRSTF_W { w: self }
            }
            #[doc = "Bit 25 - OBLRSTF"]
            #[inline(always)]
            pub fn oblrstf(&mut self) -> OBLRSTF_W {
                OBLRSTF_W { w: self }
            }
            #[doc = "Bit 24 - Firewall reset flag"]
            #[inline(always)]
            pub fn fwrstf(&mut self) -> FWRSTF_W {
                FWRSTF_W { w: self }
            }
            #[doc = "Bit 19 - RTC software reset bit"]
            #[inline(always)]
            pub fn rtcrst(&mut self) -> RTCRST_W {
                RTCRST_W { w: self }
            }
            #[doc = "Bit 18 - RTC clock enable bit"]
            #[inline(always)]
            pub fn rtcen(&mut self) -> RTCEN_W {
                RTCEN_W { w: self }
            }
            #[doc = "Bits 16:17 - RTC and LCD clock source selection bits"]
            #[inline(always)]
            pub fn rtcsel(&mut self) -> RTCSEL_W {
                RTCSEL_W { w: self }
            }
            #[doc = "Bit 14 - CSS on LSE failure detection flag"]
            #[inline(always)]
            pub fn csslsed(&mut self) -> CSSLSED_W {
                CSSLSED_W { w: self }
            }
            #[doc = "Bit 13 - CSSLSEON"]
            #[inline(always)]
            pub fn csslseon(&mut self) -> CSSLSEON_W {
                CSSLSEON_W { w: self }
            }
            #[doc = "Bits 11:12 - LSEDRV"]
            #[inline(always)]
            pub fn lsedrv(&mut self) -> LSEDRV_W {
                LSEDRV_W { w: self }
            }
            #[doc = "Bit 10 - External low-speed oscillator bypass bit"]
            #[inline(always)]
            pub fn lsebyp(&mut self) -> LSEBYP_W {
                LSEBYP_W { w: self }
            }
            #[doc = "Bit 8 - External low-speed oscillator enable bit"]
            #[inline(always)]
            pub fn lseon(&mut self) -> LSEON_W {
                LSEON_W { w: self }
            }
            #[doc = "Bit 0 - Internal low-speed oscillator enable"]
            #[inline(always)]
            pub fn lsion(&mut self) -> LSION_W {
                LSION_W { w: self }
            }
            #[doc = "Bit 23 - Remove reset flag"]
            #[inline(always)]
            pub fn rmvf(&mut self) -> RMVF_W {
                RMVF_W { w: self }
            }
        }
    }
}
#[doc = "System configuration controller and COMP register"]
pub struct SYSCFG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCFG {}
impl SYSCFG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const syscfg::RegisterBlock {
        0x4001_0000 as *const _
    }
}
impl Deref for SYSCFG {
    type Target = syscfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SYSCFG::ptr() }
    }
}
#[doc = "System configuration controller and COMP register"]
pub mod syscfg {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SYSCFG configuration register 1"]
        pub cfgr1: CFGR1,
        #[doc = "0x04 - SYSCFG configuration register 2"]
        pub cfgr2: CFGR2,
        #[doc = "0x08 - external interrupt configuration register 1"]
        pub exticr1: EXTICR1,
        #[doc = "0x0c - external interrupt configuration register 2"]
        pub exticr2: EXTICR2,
        #[doc = "0x10 - external interrupt configuration register 3"]
        pub exticr3: EXTICR3,
        #[doc = "0x14 - external interrupt configuration register 4"]
        pub exticr4: EXTICR4,
        #[doc = "0x18 - Comparator 1 control and status register"]
        pub comp1_csr: COMP1_CSR,
        #[doc = "0x1c - Comparator 2 control and status register"]
        pub comp2_csr: COMP2_CSR,
        #[doc = "0x20 - SYSCFG configuration register 3"]
        pub cfgr3: CFGR3,
    }
    #[doc = "SYSCFG configuration register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr1](cfgr1) module"]
    pub type CFGR1 = crate::Reg<u32, _CFGR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR1;
    #[doc = "`read()` method returns [cfgr1::R](cfgr1::R) reader structure"]
    impl crate::Readable for CFGR1 {}
    #[doc = "`write(|w| ..)` method takes [cfgr1::W](cfgr1::W) writer structure"]
    impl crate::Writable for CFGR1 {}
    #[doc = "SYSCFG configuration register 1"]
    pub mod cfgr1 {
        #[doc = "Reader of register CFGR1"]
        pub type R = crate::R<u32, super::CFGR1>;
        #[doc = "Writer for register CFGR1"]
        pub type W = crate::W<u32, super::CFGR1>;
        #[doc = "Register CFGR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Boot mode selected by the boot pins status bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum BOOT_MODE_A {
            #[doc = "0: Main Flash memory boot mode"]
            MAINFLASH = 0,
            #[doc = "1: System Flash memory boot mode"]
            SYSTEMFLASH = 1,
            #[doc = "3: Embedded SRAM boot mode"]
            SRAM = 3,
        }
        impl From<BOOT_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: BOOT_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `BOOT_MODE`"]
        pub type BOOT_MODE_R = crate::R<u8, BOOT_MODE_A>;
        impl BOOT_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, BOOT_MODE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(BOOT_MODE_A::MAINFLASH),
                    1 => Val(BOOT_MODE_A::SYSTEMFLASH),
                    3 => Val(BOOT_MODE_A::SRAM),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MAINFLASH`"]
            #[inline(always)]
            pub fn is_main_flash(&self) -> bool {
                *self == BOOT_MODE_A::MAINFLASH
            }
            #[doc = "Checks if the value of the field is `SYSTEMFLASH`"]
            #[inline(always)]
            pub fn is_system_flash(&self) -> bool {
                *self == BOOT_MODE_A::SYSTEMFLASH
            }
            #[doc = "Checks if the value of the field is `SRAM`"]
            #[inline(always)]
            pub fn is_sram(&self) -> bool {
                *self == BOOT_MODE_A::SRAM
            }
        }
        #[doc = "Memory mapping selection bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MEM_MODE_A {
            #[doc = "0: Main Flash memory mapped at 0x0000_0000"]
            MAINFLASH = 0,
            #[doc = "1: System Flash memory mapped at 0x0000_0000"]
            SYSTEMFLASH = 1,
            #[doc = "3: Embedded SRAM mapped at 0x0000_0000"]
            SRAM = 3,
        }
        impl From<MEM_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: MEM_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MEM_MODE`"]
        pub type MEM_MODE_R = crate::R<u8, MEM_MODE_A>;
        impl MEM_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MEM_MODE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MEM_MODE_A::MAINFLASH),
                    1 => Val(MEM_MODE_A::SYSTEMFLASH),
                    3 => Val(MEM_MODE_A::SRAM),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MAINFLASH`"]
            #[inline(always)]
            pub fn is_main_flash(&self) -> bool {
                *self == MEM_MODE_A::MAINFLASH
            }
            #[doc = "Checks if the value of the field is `SYSTEMFLASH`"]
            #[inline(always)]
            pub fn is_system_flash(&self) -> bool {
                *self == MEM_MODE_A::SYSTEMFLASH
            }
            #[doc = "Checks if the value of the field is `SRAM`"]
            #[inline(always)]
            pub fn is_sram(&self) -> bool {
                *self == MEM_MODE_A::SRAM
            }
        }
        #[doc = "Write proxy for field `MEM_MODE`"]
        pub struct MEM_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MEM_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MEM_MODE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Main Flash memory mapped at 0x0000_0000"]
            #[inline(always)]
            pub fn main_flash(self) -> &'a mut W {
                self.variant(MEM_MODE_A::MAINFLASH)
            }
            #[doc = "System Flash memory mapped at 0x0000_0000"]
            #[inline(always)]
            pub fn system_flash(self) -> &'a mut W {
                self.variant(MEM_MODE_A::SYSTEMFLASH)
            }
            #[doc = "Embedded SRAM mapped at 0x0000_0000"]
            #[inline(always)]
            pub fn sram(self) -> &'a mut W {
                self.variant(MEM_MODE_A::SRAM)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "User bank swapping\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UFB_A {
            #[doc = "0: Flash Program memory Bank 1 is mapped at 0x0800 0000 (and aliased at 0x0000 0000 if MEM_MODE=00) and Data EEPROM Bank 1 at 0x0808 0000 (aliased at 0x0008 0000 if MEM_MODE=00)"]
            BANK1 = 0,
            #[doc = "1: Flash Program memory Bank 2 is mapped at 0x0800 0000 (and aliased at 0x0000 0000 if MEM_MODE=00) and Data EEPROM Bank 2 at 0x0808 0000 (and aliased at 0x0008 0000 if MEM_MODE=00)"]
            BANK2 = 1,
        }
        impl From<UFB_A> for bool {
            #[inline(always)]
            fn from(variant: UFB_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UFB`"]
        pub type UFB_R = crate::R<bool, UFB_A>;
        impl UFB_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UFB_A {
                match self.bits {
                    false => UFB_A::BANK1,
                    true => UFB_A::BANK2,
                }
            }
            #[doc = "Checks if the value of the field is `BANK1`"]
            #[inline(always)]
            pub fn is_bank1(&self) -> bool {
                *self == UFB_A::BANK1
            }
            #[doc = "Checks if the value of the field is `BANK2`"]
            #[inline(always)]
            pub fn is_bank2(&self) -> bool {
                *self == UFB_A::BANK2
            }
        }
        #[doc = "Write proxy for field `UFB`"]
        pub struct UFB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UFB_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UFB_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Flash Program memory Bank 1 is mapped at 0x0800 0000 (and aliased at 0x0000 0000 if MEM_MODE=00) and Data EEPROM Bank 1 at 0x0808 0000 (aliased at 0x0008 0000 if MEM_MODE=00)"]
            #[inline(always)]
            pub fn bank1(self) -> &'a mut W {
                self.variant(UFB_A::BANK1)
            }
            #[doc = "Flash Program memory Bank 2 is mapped at 0x0800 0000 (and aliased at 0x0000 0000 if MEM_MODE=00) and Data EEPROM Bank 2 at 0x0808 0000 (and aliased at 0x0008 0000 if MEM_MODE=00)"]
            #[inline(always)]
            pub fn bank2(self) -> &'a mut W {
                self.variant(UFB_A::BANK2)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Boot mode selected by the boot pins status bits"]
            #[inline(always)]
            pub fn boot_mode(&self) -> BOOT_MODE_R {
                BOOT_MODE_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Memory mapping selection bits"]
            #[inline(always)]
            pub fn mem_mode(&self) -> MEM_MODE_R {
                MEM_MODE_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bit 3 - User bank swapping"]
            #[inline(always)]
            pub fn ufb(&self) -> UFB_R {
                UFB_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Memory mapping selection bits"]
            #[inline(always)]
            pub fn mem_mode(&mut self) -> MEM_MODE_W {
                MEM_MODE_W { w: self }
            }
            #[doc = "Bit 3 - User bank swapping"]
            #[inline(always)]
            pub fn ufb(&mut self) -> UFB_W {
                UFB_W { w: self }
            }
        }
    }
    #[doc = "SYSCFG configuration register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr2](cfgr2) module"]
    pub type CFGR2 = crate::Reg<u32, _CFGR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR2;
    #[doc = "`read()` method returns [cfgr2::R](cfgr2::R) reader structure"]
    impl crate::Readable for CFGR2 {}
    #[doc = "`write(|w| ..)` method takes [cfgr2::W](cfgr2::W) writer structure"]
    impl crate::Writable for CFGR2 {}
    #[doc = "SYSCFG configuration register 2"]
    pub mod cfgr2 {
        #[doc = "Reader of register CFGR2"]
        pub type R = crate::R<u32, super::CFGR2>;
        #[doc = "Writer for register CFGR2"]
        pub type W = crate::W<u32, super::CFGR2>;
        #[doc = "Register CFGR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "I2C2 Fm+ drive capability enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C2_FMP_A {
            #[doc = "0: FM+ mode is controlled by I2C_Pxx_FMP bits only"]
            STANDARD = 0,
            #[doc = "1: FM+ mode is enabled on all I2C2 pins selected through selection bits in GPIOx_AFR registers"]
            FMP = 1,
        }
        impl From<I2C2_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C2_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C2_FMP`"]
        pub type I2C2_FMP_R = crate::R<bool, I2C2_FMP_A>;
        impl I2C2_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C2_FMP_A {
                match self.bits {
                    false => I2C2_FMP_A::STANDARD,
                    true => I2C2_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C2_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C2_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C2_FMP`"]
        pub struct I2C2_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C2_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "FM+ mode is controlled by I2C_Pxx_FMP bits only"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C2_FMP_A::STANDARD)
            }
            #[doc = "FM+ mode is enabled on all I2C2 pins selected through selection bits in GPIOx_AFR registers"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C2_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "I2C1 Fm+ drive capability enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C1_FMP_A {
            #[doc = "0: FM+ mode is controlled by I2C_Pxx_FMP bits only"]
            STANDARD = 0,
            #[doc = "1: FM+ mode is enabled on all I2C1 pins selected through selection bits in GPIOx_AFR registers"]
            FMP = 1,
        }
        impl From<I2C1_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C1_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C1_FMP`"]
        pub type I2C1_FMP_R = crate::R<bool, I2C1_FMP_A>;
        impl I2C1_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C1_FMP_A {
                match self.bits {
                    false => I2C1_FMP_A::STANDARD,
                    true => I2C1_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C1_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C1_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C1_FMP`"]
        pub struct I2C1_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C1_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "FM+ mode is controlled by I2C_Pxx_FMP bits only"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C1_FMP_A::STANDARD)
            }
            #[doc = "FM+ mode is enabled on all I2C1 pins selected through selection bits in GPIOx_AFR registers"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C1_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Fm+ drive capability on PB9 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C_PB9_FMP_A {
            #[doc = "0: PB9 pin operate in standard mode"]
            STANDARD = 0,
            #[doc = "1: I2C FM+ mode enabled on PB9 and the Speed control is bypassed"]
            FMP = 1,
        }
        impl From<I2C_PB9_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C_PB9_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C_PB9_FMP`"]
        pub type I2C_PB9_FMP_R = crate::R<bool, I2C_PB9_FMP_A>;
        impl I2C_PB9_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C_PB9_FMP_A {
                match self.bits {
                    false => I2C_PB9_FMP_A::STANDARD,
                    true => I2C_PB9_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C_PB9_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C_PB9_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C_PB9_FMP`"]
        pub struct I2C_PB9_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C_PB9_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C_PB9_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PB9 pin operate in standard mode"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C_PB9_FMP_A::STANDARD)
            }
            #[doc = "I2C FM+ mode enabled on PB9 and the Speed control is bypassed"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C_PB9_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Fm+ drive capability on PB8 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C_PB8_FMP_A {
            #[doc = "0: PB8 pin operate in standard mode"]
            STANDARD = 0,
            #[doc = "1: I2C FM+ mode enabled on PB8 and the Speed control is bypassed"]
            FMP = 1,
        }
        impl From<I2C_PB8_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C_PB8_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C_PB8_FMP`"]
        pub type I2C_PB8_FMP_R = crate::R<bool, I2C_PB8_FMP_A>;
        impl I2C_PB8_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C_PB8_FMP_A {
                match self.bits {
                    false => I2C_PB8_FMP_A::STANDARD,
                    true => I2C_PB8_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C_PB8_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C_PB8_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C_PB8_FMP`"]
        pub struct I2C_PB8_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C_PB8_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C_PB8_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PB8 pin operate in standard mode"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C_PB8_FMP_A::STANDARD)
            }
            #[doc = "I2C FM+ mode enabled on PB8 and the Speed control is bypassed"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C_PB8_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Fm+ drive capability on PB7 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C_PB7_FMP_A {
            #[doc = "0: PB7 pin operate in standard mode"]
            STANDARD = 0,
            #[doc = "1: I2C FM+ mode enabled on PB7 and the Speed control is bypassed"]
            FMP = 1,
        }
        impl From<I2C_PB7_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C_PB7_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C_PB7_FMP`"]
        pub type I2C_PB7_FMP_R = crate::R<bool, I2C_PB7_FMP_A>;
        impl I2C_PB7_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C_PB7_FMP_A {
                match self.bits {
                    false => I2C_PB7_FMP_A::STANDARD,
                    true => I2C_PB7_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C_PB7_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C_PB7_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C_PB7_FMP`"]
        pub struct I2C_PB7_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C_PB7_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C_PB7_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PB7 pin operate in standard mode"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C_PB7_FMP_A::STANDARD)
            }
            #[doc = "I2C FM+ mode enabled on PB7 and the Speed control is bypassed"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C_PB7_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Fm+ drive capability on PB6 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C_PB6_FMP_A {
            #[doc = "0: PB6 pin operate in standard mode"]
            STANDARD = 0,
            #[doc = "1: I2C FM+ mode enabled on PB6 and the Speed control is bypassed"]
            FMP = 1,
        }
        impl From<I2C_PB6_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C_PB6_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C_PB6_FMP`"]
        pub type I2C_PB6_FMP_R = crate::R<bool, I2C_PB6_FMP_A>;
        impl I2C_PB6_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C_PB6_FMP_A {
                match self.bits {
                    false => I2C_PB6_FMP_A::STANDARD,
                    true => I2C_PB6_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C_PB6_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C_PB6_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C_PB6_FMP`"]
        pub struct I2C_PB6_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C_PB6_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C_PB6_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PB6 pin operate in standard mode"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C_PB6_FMP_A::STANDARD)
            }
            #[doc = "I2C FM+ mode enabled on PB6 and the Speed control is bypassed"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C_PB6_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "I2C3 Fm+ drive capability enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C3_FMP_A {
            #[doc = "0: FM+ mode is controlled by I2C_Pxx_FMP bits only"]
            STANDARD = 0,
            #[doc = "1: FM+ mode is enabled on all I2C3 pins selected through selection bits in GPIOx_AFR registers"]
            FMP = 1,
        }
        impl From<I2C3_FMP_A> for bool {
            #[inline(always)]
            fn from(variant: I2C3_FMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `I2C3_FMP`"]
        pub type I2C3_FMP_R = crate::R<bool, I2C3_FMP_A>;
        impl I2C3_FMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> I2C3_FMP_A {
                match self.bits {
                    false => I2C3_FMP_A::STANDARD,
                    true => I2C3_FMP_A::FMP,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == I2C3_FMP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FMP`"]
            #[inline(always)]
            pub fn is_fmp(&self) -> bool {
                *self == I2C3_FMP_A::FMP
            }
        }
        #[doc = "Write proxy for field `I2C3_FMP`"]
        pub struct I2C3_FMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C3_FMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C3_FMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "FM+ mode is controlled by I2C_Pxx_FMP bits only"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(I2C3_FMP_A::STANDARD)
            }
            #[doc = "FM+ mode is enabled on all I2C3 pins selected through selection bits in GPIOx_AFR registers"]
            #[inline(always)]
            pub fn fmp(self) -> &'a mut W {
                self.variant(I2C3_FMP_A::FMP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Firewall disable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FWDIS_A {
            #[doc = "0: Firewall access enabled"]
            ENABLED = 0,
            #[doc = "1: Firewall access disabled"]
            DISABLED = 1,
        }
        impl From<FWDIS_A> for bool {
            #[inline(always)]
            fn from(variant: FWDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FWDIS`"]
        pub type FWDIS_R = crate::R<bool, FWDIS_A>;
        impl FWDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FWDIS_A {
                match self.bits {
                    false => FWDIS_A::ENABLED,
                    true => FWDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == FWDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == FWDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `FWDIS`"]
        pub struct FWDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FWDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FWDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Firewall access enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FWDIS_A::ENABLED)
            }
            #[doc = "Firewall access disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FWDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 13 - I2C2 Fm+ drive capability enable bit"]
            #[inline(always)]
            pub fn i2c2_fmp(&self) -> I2C2_FMP_R {
                I2C2_FMP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - I2C1 Fm+ drive capability enable bit"]
            #[inline(always)]
            pub fn i2c1_fmp(&self) -> I2C1_FMP_R {
                I2C1_FMP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Fm+ drive capability on PB9 enable bit"]
            #[inline(always)]
            pub fn i2c_pb9_fmp(&self) -> I2C_PB9_FMP_R {
                I2C_PB9_FMP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Fm+ drive capability on PB8 enable bit"]
            #[inline(always)]
            pub fn i2c_pb8_fmp(&self) -> I2C_PB8_FMP_R {
                I2C_PB8_FMP_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Fm+ drive capability on PB7 enable bit"]
            #[inline(always)]
            pub fn i2c_pb7_fmp(&self) -> I2C_PB7_FMP_R {
                I2C_PB7_FMP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Fm+ drive capability on PB6 enable bit"]
            #[inline(always)]
            pub fn i2c_pb6_fmp(&self) -> I2C_PB6_FMP_R {
                I2C_PB6_FMP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 14 - I2C3 Fm+ drive capability enable bit"]
            #[inline(always)]
            pub fn i2c3_fmp(&self) -> I2C3_FMP_R {
                I2C3_FMP_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Firewall disable bit"]
            #[inline(always)]
            pub fn fwdis(&self) -> FWDIS_R {
                FWDIS_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 13 - I2C2 Fm+ drive capability enable bit"]
            #[inline(always)]
            pub fn i2c2_fmp(&mut self) -> I2C2_FMP_W {
                I2C2_FMP_W { w: self }
            }
            #[doc = "Bit 12 - I2C1 Fm+ drive capability enable bit"]
            #[inline(always)]
            pub fn i2c1_fmp(&mut self) -> I2C1_FMP_W {
                I2C1_FMP_W { w: self }
            }
            #[doc = "Bit 11 - Fm+ drive capability on PB9 enable bit"]
            #[inline(always)]
            pub fn i2c_pb9_fmp(&mut self) -> I2C_PB9_FMP_W {
                I2C_PB9_FMP_W { w: self }
            }
            #[doc = "Bit 10 - Fm+ drive capability on PB8 enable bit"]
            #[inline(always)]
            pub fn i2c_pb8_fmp(&mut self) -> I2C_PB8_FMP_W {
                I2C_PB8_FMP_W { w: self }
            }
            #[doc = "Bit 9 - Fm+ drive capability on PB7 enable bit"]
            #[inline(always)]
            pub fn i2c_pb7_fmp(&mut self) -> I2C_PB7_FMP_W {
                I2C_PB7_FMP_W { w: self }
            }
            #[doc = "Bit 8 - Fm+ drive capability on PB6 enable bit"]
            #[inline(always)]
            pub fn i2c_pb6_fmp(&mut self) -> I2C_PB6_FMP_W {
                I2C_PB6_FMP_W { w: self }
            }
            #[doc = "Bit 14 - I2C3 Fm+ drive capability enable bit"]
            #[inline(always)]
            pub fn i2c3_fmp(&mut self) -> I2C3_FMP_W {
                I2C3_FMP_W { w: self }
            }
            #[doc = "Bit 0 - Firewall disable bit"]
            #[inline(always)]
            pub fn fwdis(&mut self) -> FWDIS_W {
                FWDIS_W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr1](exticr1) module"]
    pub type EXTICR1 = crate::Reg<u32, _EXTICR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR1;
    #[doc = "`read()` method returns [exticr1::R](exticr1::R) reader structure"]
    impl crate::Readable for EXTICR1 {}
    #[doc = "`write(|w| ..)` method takes [exticr1::W](exticr1::W) writer structure"]
    impl crate::Writable for EXTICR1 {}
    #[doc = "external interrupt configuration register 1"]
    pub mod exticr1 {
        #[doc = "Reader of register EXTICR1"]
        pub type R = crate::R<u32, super::EXTICR1>;
        #[doc = "Writer for register EXTICR1"]
        pub type W = crate::W<u32, super::EXTICR1>;
        #[doc = "Register EXTICR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "EXTI x configuration (x = 0 to 3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI3_A {
            #[doc = "0: Select PA3 as the source input for the EXTI3 external interrupt"]
            PA3 = 0,
            #[doc = "1: Select PB3 as the source input for the EXTI3 external interrupt"]
            PB3 = 1,
            #[doc = "2: Select PC3 as the source input for the EXTI3 external interrupt"]
            PC3 = 2,
            #[doc = "3: Select PD3 as the source input for the EXTI3 external interrupt"]
            PD3 = 3,
            #[doc = "4: Select PE3 as the source input for the EXTI3 external interrupt"]
            PE3 = 4,
            #[doc = "5: Select PH3 as the source input for the EXTI3 external interrupt"]
            PH3 = 5,
        }
        impl From<EXTI3_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI3_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI3`"]
        pub type EXTI3_R = crate::R<u8, EXTI3_A>;
        impl EXTI3_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI3_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI3_A::PA3),
                    1 => Val(EXTI3_A::PB3),
                    2 => Val(EXTI3_A::PC3),
                    3 => Val(EXTI3_A::PD3),
                    4 => Val(EXTI3_A::PE3),
                    5 => Val(EXTI3_A::PH3),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA3`"]
            #[inline(always)]
            pub fn is_pa3(&self) -> bool {
                *self == EXTI3_A::PA3
            }
            #[doc = "Checks if the value of the field is `PB3`"]
            #[inline(always)]
            pub fn is_pb3(&self) -> bool {
                *self == EXTI3_A::PB3
            }
            #[doc = "Checks if the value of the field is `PC3`"]
            #[inline(always)]
            pub fn is_pc3(&self) -> bool {
                *self == EXTI3_A::PC3
            }
            #[doc = "Checks if the value of the field is `PD3`"]
            #[inline(always)]
            pub fn is_pd3(&self) -> bool {
                *self == EXTI3_A::PD3
            }
            #[doc = "Checks if the value of the field is `PE3`"]
            #[inline(always)]
            pub fn is_pe3(&self) -> bool {
                *self == EXTI3_A::PE3
            }
            #[doc = "Checks if the value of the field is `PH3`"]
            #[inline(always)]
            pub fn is_ph3(&self) -> bool {
                *self == EXTI3_A::PH3
            }
        }
        #[doc = "Write proxy for field `EXTI3`"]
        pub struct EXTI3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI3_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA3 as the source input for the EXTI3 external interrupt"]
            #[inline(always)]
            pub fn pa3(self) -> &'a mut W {
                self.variant(EXTI3_A::PA3)
            }
            #[doc = "Select PB3 as the source input for the EXTI3 external interrupt"]
            #[inline(always)]
            pub fn pb3(self) -> &'a mut W {
                self.variant(EXTI3_A::PB3)
            }
            #[doc = "Select PC3 as the source input for the EXTI3 external interrupt"]
            #[inline(always)]
            pub fn pc3(self) -> &'a mut W {
                self.variant(EXTI3_A::PC3)
            }
            #[doc = "Select PD3 as the source input for the EXTI3 external interrupt"]
            #[inline(always)]
            pub fn pd3(self) -> &'a mut W {
                self.variant(EXTI3_A::PD3)
            }
            #[doc = "Select PE3 as the source input for the EXTI3 external interrupt"]
            #[inline(always)]
            pub fn pe3(self) -> &'a mut W {
                self.variant(EXTI3_A::PE3)
            }
            #[doc = "Select PH3 as the source input for the EXTI3 external interrupt"]
            #[inline(always)]
            pub fn ph3(self) -> &'a mut W {
                self.variant(EXTI3_A::PH3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 0 to 3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI2_A {
            #[doc = "0: Select PA2 as the source input for the EXTI2 external interrupt"]
            PA2 = 0,
            #[doc = "1: Select PB2 as the source input for the EXTI2 external interrupt"]
            PB2 = 1,
            #[doc = "2: Select PC2 as the source input for the EXTI2 external interrupt"]
            PC2 = 2,
            #[doc = "3: Select PD2 as the source input for the EXTI2 external interrupt"]
            PD2 = 3,
            #[doc = "4: Select PE2 as the source input for the EXTI2 external interrupt"]
            PE2 = 4,
            #[doc = "5: Select PH2 as the source input for the EXTI2 external interrupt"]
            PH2 = 5,
        }
        impl From<EXTI2_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI2_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI2`"]
        pub type EXTI2_R = crate::R<u8, EXTI2_A>;
        impl EXTI2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI2_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI2_A::PA2),
                    1 => Val(EXTI2_A::PB2),
                    2 => Val(EXTI2_A::PC2),
                    3 => Val(EXTI2_A::PD2),
                    4 => Val(EXTI2_A::PE2),
                    5 => Val(EXTI2_A::PH2),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA2`"]
            #[inline(always)]
            pub fn is_pa2(&self) -> bool {
                *self == EXTI2_A::PA2
            }
            #[doc = "Checks if the value of the field is `PB2`"]
            #[inline(always)]
            pub fn is_pb2(&self) -> bool {
                *self == EXTI2_A::PB2
            }
            #[doc = "Checks if the value of the field is `PC2`"]
            #[inline(always)]
            pub fn is_pc2(&self) -> bool {
                *self == EXTI2_A::PC2
            }
            #[doc = "Checks if the value of the field is `PD2`"]
            #[inline(always)]
            pub fn is_pd2(&self) -> bool {
                *self == EXTI2_A::PD2
            }
            #[doc = "Checks if the value of the field is `PE2`"]
            #[inline(always)]
            pub fn is_pe2(&self) -> bool {
                *self == EXTI2_A::PE2
            }
            #[doc = "Checks if the value of the field is `PH2`"]
            #[inline(always)]
            pub fn is_ph2(&self) -> bool {
                *self == EXTI2_A::PH2
            }
        }
        #[doc = "Write proxy for field `EXTI2`"]
        pub struct EXTI2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA2 as the source input for the EXTI2 external interrupt"]
            #[inline(always)]
            pub fn pa2(self) -> &'a mut W {
                self.variant(EXTI2_A::PA2)
            }
            #[doc = "Select PB2 as the source input for the EXTI2 external interrupt"]
            #[inline(always)]
            pub fn pb2(self) -> &'a mut W {
                self.variant(EXTI2_A::PB2)
            }
            #[doc = "Select PC2 as the source input for the EXTI2 external interrupt"]
            #[inline(always)]
            pub fn pc2(self) -> &'a mut W {
                self.variant(EXTI2_A::PC2)
            }
            #[doc = "Select PD2 as the source input for the EXTI2 external interrupt"]
            #[inline(always)]
            pub fn pd2(self) -> &'a mut W {
                self.variant(EXTI2_A::PD2)
            }
            #[doc = "Select PE2 as the source input for the EXTI2 external interrupt"]
            #[inline(always)]
            pub fn pe2(self) -> &'a mut W {
                self.variant(EXTI2_A::PE2)
            }
            #[doc = "Select PH2 as the source input for the EXTI2 external interrupt"]
            #[inline(always)]
            pub fn ph2(self) -> &'a mut W {
                self.variant(EXTI2_A::PH2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 0 to 3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI1_A {
            #[doc = "0: Select PA1 as the source input for the EXTI1 external interrupt"]
            PA1 = 0,
            #[doc = "1: Select PB1 as the source input for the EXTI1 external interrupt"]
            PB1 = 1,
            #[doc = "2: Select PC1 as the source input for the EXTI1 external interrupt"]
            PC1 = 2,
            #[doc = "3: Select PD1 as the source input for the EXTI1 external interrupt"]
            PD1 = 3,
            #[doc = "4: Select PE1 as the source input for the EXTI1 external interrupt"]
            PE1 = 4,
            #[doc = "5: Select PH1 as the source input for the EXTI1 external interrupt"]
            PH1 = 5,
        }
        impl From<EXTI1_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI1_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI1`"]
        pub type EXTI1_R = crate::R<u8, EXTI1_A>;
        impl EXTI1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI1_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI1_A::PA1),
                    1 => Val(EXTI1_A::PB1),
                    2 => Val(EXTI1_A::PC1),
                    3 => Val(EXTI1_A::PD1),
                    4 => Val(EXTI1_A::PE1),
                    5 => Val(EXTI1_A::PH1),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA1`"]
            #[inline(always)]
            pub fn is_pa1(&self) -> bool {
                *self == EXTI1_A::PA1
            }
            #[doc = "Checks if the value of the field is `PB1`"]
            #[inline(always)]
            pub fn is_pb1(&self) -> bool {
                *self == EXTI1_A::PB1
            }
            #[doc = "Checks if the value of the field is `PC1`"]
            #[inline(always)]
            pub fn is_pc1(&self) -> bool {
                *self == EXTI1_A::PC1
            }
            #[doc = "Checks if the value of the field is `PD1`"]
            #[inline(always)]
            pub fn is_pd1(&self) -> bool {
                *self == EXTI1_A::PD1
            }
            #[doc = "Checks if the value of the field is `PE1`"]
            #[inline(always)]
            pub fn is_pe1(&self) -> bool {
                *self == EXTI1_A::PE1
            }
            #[doc = "Checks if the value of the field is `PH1`"]
            #[inline(always)]
            pub fn is_ph1(&self) -> bool {
                *self == EXTI1_A::PH1
            }
        }
        #[doc = "Write proxy for field `EXTI1`"]
        pub struct EXTI1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA1 as the source input for the EXTI1 external interrupt"]
            #[inline(always)]
            pub fn pa1(self) -> &'a mut W {
                self.variant(EXTI1_A::PA1)
            }
            #[doc = "Select PB1 as the source input for the EXTI1 external interrupt"]
            #[inline(always)]
            pub fn pb1(self) -> &'a mut W {
                self.variant(EXTI1_A::PB1)
            }
            #[doc = "Select PC1 as the source input for the EXTI1 external interrupt"]
            #[inline(always)]
            pub fn pc1(self) -> &'a mut W {
                self.variant(EXTI1_A::PC1)
            }
            #[doc = "Select PD1 as the source input for the EXTI1 external interrupt"]
            #[inline(always)]
            pub fn pd1(self) -> &'a mut W {
                self.variant(EXTI1_A::PD1)
            }
            #[doc = "Select PE1 as the source input for the EXTI1 external interrupt"]
            #[inline(always)]
            pub fn pe1(self) -> &'a mut W {
                self.variant(EXTI1_A::PE1)
            }
            #[doc = "Select PH1 as the source input for the EXTI1 external interrupt"]
            #[inline(always)]
            pub fn ph1(self) -> &'a mut W {
                self.variant(EXTI1_A::PH1)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 0 to 3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI0_A {
            #[doc = "0: Select PA0 as the source input for the EXTI0 external interrupt"]
            PA0 = 0,
            #[doc = "1: Select PB0 as the source input for the EXTI0 external interrupt"]
            PB0 = 1,
            #[doc = "2: Select PC0 as the source input for the EXTI0 external interrupt"]
            PC0 = 2,
            #[doc = "3: Select PD0 as the source input for the EXTI0 external interrupt"]
            PD0 = 3,
            #[doc = "4: Select PE0 as the source input for the EXTI0 external interrupt"]
            PE0 = 4,
            #[doc = "5: Select PH0 as the source input for the EXTI0 external interrupt"]
            PH0 = 5,
        }
        impl From<EXTI0_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI0_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI0`"]
        pub type EXTI0_R = crate::R<u8, EXTI0_A>;
        impl EXTI0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI0_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI0_A::PA0),
                    1 => Val(EXTI0_A::PB0),
                    2 => Val(EXTI0_A::PC0),
                    3 => Val(EXTI0_A::PD0),
                    4 => Val(EXTI0_A::PE0),
                    5 => Val(EXTI0_A::PH0),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA0`"]
            #[inline(always)]
            pub fn is_pa0(&self) -> bool {
                *self == EXTI0_A::PA0
            }
            #[doc = "Checks if the value of the field is `PB0`"]
            #[inline(always)]
            pub fn is_pb0(&self) -> bool {
                *self == EXTI0_A::PB0
            }
            #[doc = "Checks if the value of the field is `PC0`"]
            #[inline(always)]
            pub fn is_pc0(&self) -> bool {
                *self == EXTI0_A::PC0
            }
            #[doc = "Checks if the value of the field is `PD0`"]
            #[inline(always)]
            pub fn is_pd0(&self) -> bool {
                *self == EXTI0_A::PD0
            }
            #[doc = "Checks if the value of the field is `PE0`"]
            #[inline(always)]
            pub fn is_pe0(&self) -> bool {
                *self == EXTI0_A::PE0
            }
            #[doc = "Checks if the value of the field is `PH0`"]
            #[inline(always)]
            pub fn is_ph0(&self) -> bool {
                *self == EXTI0_A::PH0
            }
        }
        #[doc = "Write proxy for field `EXTI0`"]
        pub struct EXTI0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI0_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA0 as the source input for the EXTI0 external interrupt"]
            #[inline(always)]
            pub fn pa0(self) -> &'a mut W {
                self.variant(EXTI0_A::PA0)
            }
            #[doc = "Select PB0 as the source input for the EXTI0 external interrupt"]
            #[inline(always)]
            pub fn pb0(self) -> &'a mut W {
                self.variant(EXTI0_A::PB0)
            }
            #[doc = "Select PC0 as the source input for the EXTI0 external interrupt"]
            #[inline(always)]
            pub fn pc0(self) -> &'a mut W {
                self.variant(EXTI0_A::PC0)
            }
            #[doc = "Select PD0 as the source input for the EXTI0 external interrupt"]
            #[inline(always)]
            pub fn pd0(self) -> &'a mut W {
                self.variant(EXTI0_A::PD0)
            }
            #[doc = "Select PE0 as the source input for the EXTI0 external interrupt"]
            #[inline(always)]
            pub fn pe0(self) -> &'a mut W {
                self.variant(EXTI0_A::PE0)
            }
            #[doc = "Select PH0 as the source input for the EXTI0 external interrupt"]
            #[inline(always)]
            pub fn ph0(self) -> &'a mut W {
                self.variant(EXTI0_A::PH0)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti3(&self) -> EXTI3_R {
                EXTI3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti2(&self) -> EXTI2_R {
                EXTI2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti1(&self) -> EXTI1_R {
                EXTI1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti0(&self) -> EXTI0_R {
                EXTI0_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti3(&mut self) -> EXTI3_W {
                EXTI3_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti2(&mut self) -> EXTI2_W {
                EXTI2_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti1(&mut self) -> EXTI1_W {
                EXTI1_W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI x configuration (x = 0 to 3)"]
            #[inline(always)]
            pub fn exti0(&mut self) -> EXTI0_W {
                EXTI0_W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr2](exticr2) module"]
    pub type EXTICR2 = crate::Reg<u32, _EXTICR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR2;
    #[doc = "`read()` method returns [exticr2::R](exticr2::R) reader structure"]
    impl crate::Readable for EXTICR2 {}
    #[doc = "`write(|w| ..)` method takes [exticr2::W](exticr2::W) writer structure"]
    impl crate::Writable for EXTICR2 {}
    #[doc = "external interrupt configuration register 2"]
    pub mod exticr2 {
        #[doc = "Reader of register EXTICR2"]
        pub type R = crate::R<u32, super::EXTICR2>;
        #[doc = "Writer for register EXTICR2"]
        pub type W = crate::W<u32, super::EXTICR2>;
        #[doc = "Register EXTICR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "EXTI x configuration (x = 4 to 7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI7_A {
            #[doc = "0: Select PA7 as the source input for the EXTI7 external interrupt"]
            PA7 = 0,
            #[doc = "1: Select PB7 as the source input for the EXTI7 external interrupt"]
            PB7 = 1,
            #[doc = "2: Select PC7 as the source input for the EXTI7 external interrupt"]
            PC7 = 2,
            #[doc = "3: Select PD7 as the source input for the EXTI7 external interrupt"]
            PD7 = 3,
            #[doc = "4: Select PE7 as the source input for the EXTI7 external interrupt"]
            PE7 = 4,
        }
        impl From<EXTI7_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI7_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI7`"]
        pub type EXTI7_R = crate::R<u8, EXTI7_A>;
        impl EXTI7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI7_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI7_A::PA7),
                    1 => Val(EXTI7_A::PB7),
                    2 => Val(EXTI7_A::PC7),
                    3 => Val(EXTI7_A::PD7),
                    4 => Val(EXTI7_A::PE7),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA7`"]
            #[inline(always)]
            pub fn is_pa7(&self) -> bool {
                *self == EXTI7_A::PA7
            }
            #[doc = "Checks if the value of the field is `PB7`"]
            #[inline(always)]
            pub fn is_pb7(&self) -> bool {
                *self == EXTI7_A::PB7
            }
            #[doc = "Checks if the value of the field is `PC7`"]
            #[inline(always)]
            pub fn is_pc7(&self) -> bool {
                *self == EXTI7_A::PC7
            }
            #[doc = "Checks if the value of the field is `PD7`"]
            #[inline(always)]
            pub fn is_pd7(&self) -> bool {
                *self == EXTI7_A::PD7
            }
            #[doc = "Checks if the value of the field is `PE7`"]
            #[inline(always)]
            pub fn is_pe7(&self) -> bool {
                *self == EXTI7_A::PE7
            }
        }
        #[doc = "Write proxy for field `EXTI7`"]
        pub struct EXTI7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI7_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA7 as the source input for the EXTI7 external interrupt"]
            #[inline(always)]
            pub fn pa7(self) -> &'a mut W {
                self.variant(EXTI7_A::PA7)
            }
            #[doc = "Select PB7 as the source input for the EXTI7 external interrupt"]
            #[inline(always)]
            pub fn pb7(self) -> &'a mut W {
                self.variant(EXTI7_A::PB7)
            }
            #[doc = "Select PC7 as the source input for the EXTI7 external interrupt"]
            #[inline(always)]
            pub fn pc7(self) -> &'a mut W {
                self.variant(EXTI7_A::PC7)
            }
            #[doc = "Select PD7 as the source input for the EXTI7 external interrupt"]
            #[inline(always)]
            pub fn pd7(self) -> &'a mut W {
                self.variant(EXTI7_A::PD7)
            }
            #[doc = "Select PE7 as the source input for the EXTI7 external interrupt"]
            #[inline(always)]
            pub fn pe7(self) -> &'a mut W {
                self.variant(EXTI7_A::PE7)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 4 to 7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI6_A {
            #[doc = "0: Select PA6 as the source input for the EXTI6 external interrupt"]
            PA6 = 0,
            #[doc = "1: Select PB6 as the source input for the EXTI6 external interrupt"]
            PB6 = 1,
            #[doc = "2: Select PC6 as the source input for the EXTI6 external interrupt"]
            PC6 = 2,
            #[doc = "3: Select PD6 as the source input for the EXTI6 external interrupt"]
            PD6 = 3,
            #[doc = "4: Select PE6 as the source input for the EXTI6 external interrupt"]
            PE6 = 4,
        }
        impl From<EXTI6_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI6_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI6`"]
        pub type EXTI6_R = crate::R<u8, EXTI6_A>;
        impl EXTI6_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI6_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI6_A::PA6),
                    1 => Val(EXTI6_A::PB6),
                    2 => Val(EXTI6_A::PC6),
                    3 => Val(EXTI6_A::PD6),
                    4 => Val(EXTI6_A::PE6),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA6`"]
            #[inline(always)]
            pub fn is_pa6(&self) -> bool {
                *self == EXTI6_A::PA6
            }
            #[doc = "Checks if the value of the field is `PB6`"]
            #[inline(always)]
            pub fn is_pb6(&self) -> bool {
                *self == EXTI6_A::PB6
            }
            #[doc = "Checks if the value of the field is `PC6`"]
            #[inline(always)]
            pub fn is_pc6(&self) -> bool {
                *self == EXTI6_A::PC6
            }
            #[doc = "Checks if the value of the field is `PD6`"]
            #[inline(always)]
            pub fn is_pd6(&self) -> bool {
                *self == EXTI6_A::PD6
            }
            #[doc = "Checks if the value of the field is `PE6`"]
            #[inline(always)]
            pub fn is_pe6(&self) -> bool {
                *self == EXTI6_A::PE6
            }
        }
        #[doc = "Write proxy for field `EXTI6`"]
        pub struct EXTI6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI6_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA6 as the source input for the EXTI6 external interrupt"]
            #[inline(always)]
            pub fn pa6(self) -> &'a mut W {
                self.variant(EXTI6_A::PA6)
            }
            #[doc = "Select PB6 as the source input for the EXTI6 external interrupt"]
            #[inline(always)]
            pub fn pb6(self) -> &'a mut W {
                self.variant(EXTI6_A::PB6)
            }
            #[doc = "Select PC6 as the source input for the EXTI6 external interrupt"]
            #[inline(always)]
            pub fn pc6(self) -> &'a mut W {
                self.variant(EXTI6_A::PC6)
            }
            #[doc = "Select PD6 as the source input for the EXTI6 external interrupt"]
            #[inline(always)]
            pub fn pd6(self) -> &'a mut W {
                self.variant(EXTI6_A::PD6)
            }
            #[doc = "Select PE6 as the source input for the EXTI6 external interrupt"]
            #[inline(always)]
            pub fn pe6(self) -> &'a mut W {
                self.variant(EXTI6_A::PE6)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 4 to 7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI5_A {
            #[doc = "0: Select PA5 as the source input for the EXTI5 external interrupt"]
            PA5 = 0,
            #[doc = "1: Select PB5 as the source input for the EXTI5 external interrupt"]
            PB5 = 1,
            #[doc = "2: Select PC5 as the source input for the EXTI5 external interrupt"]
            PC5 = 2,
            #[doc = "3: Select PD5 as the source input for the EXTI5 external interrupt"]
            PD5 = 3,
            #[doc = "4: Select PE5 as the source input for the EXTI5 external interrupt"]
            PE5 = 4,
        }
        impl From<EXTI5_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI5_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI5`"]
        pub type EXTI5_R = crate::R<u8, EXTI5_A>;
        impl EXTI5_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI5_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI5_A::PA5),
                    1 => Val(EXTI5_A::PB5),
                    2 => Val(EXTI5_A::PC5),
                    3 => Val(EXTI5_A::PD5),
                    4 => Val(EXTI5_A::PE5),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA5`"]
            #[inline(always)]
            pub fn is_pa5(&self) -> bool {
                *self == EXTI5_A::PA5
            }
            #[doc = "Checks if the value of the field is `PB5`"]
            #[inline(always)]
            pub fn is_pb5(&self) -> bool {
                *self == EXTI5_A::PB5
            }
            #[doc = "Checks if the value of the field is `PC5`"]
            #[inline(always)]
            pub fn is_pc5(&self) -> bool {
                *self == EXTI5_A::PC5
            }
            #[doc = "Checks if the value of the field is `PD5`"]
            #[inline(always)]
            pub fn is_pd5(&self) -> bool {
                *self == EXTI5_A::PD5
            }
            #[doc = "Checks if the value of the field is `PE5`"]
            #[inline(always)]
            pub fn is_pe5(&self) -> bool {
                *self == EXTI5_A::PE5
            }
        }
        #[doc = "Write proxy for field `EXTI5`"]
        pub struct EXTI5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI5_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA5 as the source input for the EXTI5 external interrupt"]
            #[inline(always)]
            pub fn pa5(self) -> &'a mut W {
                self.variant(EXTI5_A::PA5)
            }
            #[doc = "Select PB5 as the source input for the EXTI5 external interrupt"]
            #[inline(always)]
            pub fn pb5(self) -> &'a mut W {
                self.variant(EXTI5_A::PB5)
            }
            #[doc = "Select PC5 as the source input for the EXTI5 external interrupt"]
            #[inline(always)]
            pub fn pc5(self) -> &'a mut W {
                self.variant(EXTI5_A::PC5)
            }
            #[doc = "Select PD5 as the source input for the EXTI5 external interrupt"]
            #[inline(always)]
            pub fn pd5(self) -> &'a mut W {
                self.variant(EXTI5_A::PD5)
            }
            #[doc = "Select PE5 as the source input for the EXTI5 external interrupt"]
            #[inline(always)]
            pub fn pe5(self) -> &'a mut W {
                self.variant(EXTI5_A::PE5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 4 to 7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI4_A {
            #[doc = "0: Select PA4 as the source input for the EXTI4 external interrupt"]
            PA4 = 0,
            #[doc = "1: Select PB4 as the source input for the EXTI4 external interrupt"]
            PB4 = 1,
            #[doc = "2: Select PC4 as the source input for the EXTI4 external interrupt"]
            PC4 = 2,
            #[doc = "3: Select PD4 as the source input for the EXTI4 external interrupt"]
            PD4 = 3,
            #[doc = "4: Select PE4 as the source input for the EXTI4 external interrupt"]
            PE4 = 4,
        }
        impl From<EXTI4_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI4_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI4`"]
        pub type EXTI4_R = crate::R<u8, EXTI4_A>;
        impl EXTI4_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI4_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI4_A::PA4),
                    1 => Val(EXTI4_A::PB4),
                    2 => Val(EXTI4_A::PC4),
                    3 => Val(EXTI4_A::PD4),
                    4 => Val(EXTI4_A::PE4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA4`"]
            #[inline(always)]
            pub fn is_pa4(&self) -> bool {
                *self == EXTI4_A::PA4
            }
            #[doc = "Checks if the value of the field is `PB4`"]
            #[inline(always)]
            pub fn is_pb4(&self) -> bool {
                *self == EXTI4_A::PB4
            }
            #[doc = "Checks if the value of the field is `PC4`"]
            #[inline(always)]
            pub fn is_pc4(&self) -> bool {
                *self == EXTI4_A::PC4
            }
            #[doc = "Checks if the value of the field is `PD4`"]
            #[inline(always)]
            pub fn is_pd4(&self) -> bool {
                *self == EXTI4_A::PD4
            }
            #[doc = "Checks if the value of the field is `PE4`"]
            #[inline(always)]
            pub fn is_pe4(&self) -> bool {
                *self == EXTI4_A::PE4
            }
        }
        #[doc = "Write proxy for field `EXTI4`"]
        pub struct EXTI4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI4_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA4 as the source input for the EXTI4 external interrupt"]
            #[inline(always)]
            pub fn pa4(self) -> &'a mut W {
                self.variant(EXTI4_A::PA4)
            }
            #[doc = "Select PB4 as the source input for the EXTI4 external interrupt"]
            #[inline(always)]
            pub fn pb4(self) -> &'a mut W {
                self.variant(EXTI4_A::PB4)
            }
            #[doc = "Select PC4 as the source input for the EXTI4 external interrupt"]
            #[inline(always)]
            pub fn pc4(self) -> &'a mut W {
                self.variant(EXTI4_A::PC4)
            }
            #[doc = "Select PD4 as the source input for the EXTI4 external interrupt"]
            #[inline(always)]
            pub fn pd4(self) -> &'a mut W {
                self.variant(EXTI4_A::PD4)
            }
            #[doc = "Select PE4 as the source input for the EXTI4 external interrupt"]
            #[inline(always)]
            pub fn pe4(self) -> &'a mut W {
                self.variant(EXTI4_A::PE4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti7(&self) -> EXTI7_R {
                EXTI7_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti6(&self) -> EXTI6_R {
                EXTI6_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti5(&self) -> EXTI5_R {
                EXTI5_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti4(&self) -> EXTI4_R {
                EXTI4_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti7(&mut self) -> EXTI7_W {
                EXTI7_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti6(&mut self) -> EXTI6_W {
                EXTI6_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti5(&mut self) -> EXTI5_W {
                EXTI5_W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI x configuration (x = 4 to 7)"]
            #[inline(always)]
            pub fn exti4(&mut self) -> EXTI4_W {
                EXTI4_W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr3](exticr3) module"]
    pub type EXTICR3 = crate::Reg<u32, _EXTICR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR3;
    #[doc = "`read()` method returns [exticr3::R](exticr3::R) reader structure"]
    impl crate::Readable for EXTICR3 {}
    #[doc = "`write(|w| ..)` method takes [exticr3::W](exticr3::W) writer structure"]
    impl crate::Writable for EXTICR3 {}
    #[doc = "external interrupt configuration register 3"]
    pub mod exticr3 {
        #[doc = "Reader of register EXTICR3"]
        pub type R = crate::R<u32, super::EXTICR3>;
        #[doc = "Writer for register EXTICR3"]
        pub type W = crate::W<u32, super::EXTICR3>;
        #[doc = "Register EXTICR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "EXTI x configuration (x = 8 to 11)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI11_A {
            #[doc = "0: Select PA11 as the source input for the EXTI11 external interrupt"]
            PA11 = 0,
            #[doc = "1: Select PB11 as the source input for the EXTI11 external interrupt"]
            PB11 = 1,
            #[doc = "2: Select PC11 as the source input for the EXTI11 external interrupt"]
            PC11 = 2,
            #[doc = "3: Select PD11 as the source input for the EXTI11 external interrupt"]
            PD11 = 3,
            #[doc = "4: Select PE11 as the source input for the EXTI11 external interrupt"]
            PE11 = 4,
            #[doc = "5: Select PH11 as the source input for the EXTI11 external interrupt"]
            PH11 = 5,
        }
        impl From<EXTI11_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI11_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI11`"]
        pub type EXTI11_R = crate::R<u8, EXTI11_A>;
        impl EXTI11_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI11_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI11_A::PA11),
                    1 => Val(EXTI11_A::PB11),
                    2 => Val(EXTI11_A::PC11),
                    3 => Val(EXTI11_A::PD11),
                    4 => Val(EXTI11_A::PE11),
                    5 => Val(EXTI11_A::PH11),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA11`"]
            #[inline(always)]
            pub fn is_pa11(&self) -> bool {
                *self == EXTI11_A::PA11
            }
            #[doc = "Checks if the value of the field is `PB11`"]
            #[inline(always)]
            pub fn is_pb11(&self) -> bool {
                *self == EXTI11_A::PB11
            }
            #[doc = "Checks if the value of the field is `PC11`"]
            #[inline(always)]
            pub fn is_pc11(&self) -> bool {
                *self == EXTI11_A::PC11
            }
            #[doc = "Checks if the value of the field is `PD11`"]
            #[inline(always)]
            pub fn is_pd11(&self) -> bool {
                *self == EXTI11_A::PD11
            }
            #[doc = "Checks if the value of the field is `PE11`"]
            #[inline(always)]
            pub fn is_pe11(&self) -> bool {
                *self == EXTI11_A::PE11
            }
            #[doc = "Checks if the value of the field is `PH11`"]
            #[inline(always)]
            pub fn is_ph11(&self) -> bool {
                *self == EXTI11_A::PH11
            }
        }
        #[doc = "Write proxy for field `EXTI11`"]
        pub struct EXTI11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI11_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA11 as the source input for the EXTI11 external interrupt"]
            #[inline(always)]
            pub fn pa11(self) -> &'a mut W {
                self.variant(EXTI11_A::PA11)
            }
            #[doc = "Select PB11 as the source input for the EXTI11 external interrupt"]
            #[inline(always)]
            pub fn pb11(self) -> &'a mut W {
                self.variant(EXTI11_A::PB11)
            }
            #[doc = "Select PC11 as the source input for the EXTI11 external interrupt"]
            #[inline(always)]
            pub fn pc11(self) -> &'a mut W {
                self.variant(EXTI11_A::PC11)
            }
            #[doc = "Select PD11 as the source input for the EXTI11 external interrupt"]
            #[inline(always)]
            pub fn pd11(self) -> &'a mut W {
                self.variant(EXTI11_A::PD11)
            }
            #[doc = "Select PE11 as the source input for the EXTI11 external interrupt"]
            #[inline(always)]
            pub fn pe11(self) -> &'a mut W {
                self.variant(EXTI11_A::PE11)
            }
            #[doc = "Select PH11 as the source input for the EXTI11 external interrupt"]
            #[inline(always)]
            pub fn ph11(self) -> &'a mut W {
                self.variant(EXTI11_A::PH11)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "EXTI10\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI10_A {
            #[doc = "0: Select PA10 as the source input for the EXTI10 external interrupt"]
            PA10 = 0,
            #[doc = "1: Select PB10 as the source input for the EXTI10 external interrupt"]
            PB10 = 1,
            #[doc = "2: Select PC10 as the source input for the EXTI10 external interrupt"]
            PC10 = 2,
            #[doc = "3: Select PD10 as the source input for the EXTI10 external interrupt"]
            PD10 = 3,
            #[doc = "4: Select PE10 as the source input for the EXTI10 external interrupt"]
            PE10 = 4,
            #[doc = "5: Select PH10 as the source input for the EXTI10 external interrupt"]
            PH10 = 5,
        }
        impl From<EXTI10_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI10_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI10`"]
        pub type EXTI10_R = crate::R<u8, EXTI10_A>;
        impl EXTI10_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI10_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI10_A::PA10),
                    1 => Val(EXTI10_A::PB10),
                    2 => Val(EXTI10_A::PC10),
                    3 => Val(EXTI10_A::PD10),
                    4 => Val(EXTI10_A::PE10),
                    5 => Val(EXTI10_A::PH10),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA10`"]
            #[inline(always)]
            pub fn is_pa10(&self) -> bool {
                *self == EXTI10_A::PA10
            }
            #[doc = "Checks if the value of the field is `PB10`"]
            #[inline(always)]
            pub fn is_pb10(&self) -> bool {
                *self == EXTI10_A::PB10
            }
            #[doc = "Checks if the value of the field is `PC10`"]
            #[inline(always)]
            pub fn is_pc10(&self) -> bool {
                *self == EXTI10_A::PC10
            }
            #[doc = "Checks if the value of the field is `PD10`"]
            #[inline(always)]
            pub fn is_pd10(&self) -> bool {
                *self == EXTI10_A::PD10
            }
            #[doc = "Checks if the value of the field is `PE10`"]
            #[inline(always)]
            pub fn is_pe10(&self) -> bool {
                *self == EXTI10_A::PE10
            }
            #[doc = "Checks if the value of the field is `PH10`"]
            #[inline(always)]
            pub fn is_ph10(&self) -> bool {
                *self == EXTI10_A::PH10
            }
        }
        #[doc = "Write proxy for field `EXTI10`"]
        pub struct EXTI10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI10_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA10 as the source input for the EXTI10 external interrupt"]
            #[inline(always)]
            pub fn pa10(self) -> &'a mut W {
                self.variant(EXTI10_A::PA10)
            }
            #[doc = "Select PB10 as the source input for the EXTI10 external interrupt"]
            #[inline(always)]
            pub fn pb10(self) -> &'a mut W {
                self.variant(EXTI10_A::PB10)
            }
            #[doc = "Select PC10 as the source input for the EXTI10 external interrupt"]
            #[inline(always)]
            pub fn pc10(self) -> &'a mut W {
                self.variant(EXTI10_A::PC10)
            }
            #[doc = "Select PD10 as the source input for the EXTI10 external interrupt"]
            #[inline(always)]
            pub fn pd10(self) -> &'a mut W {
                self.variant(EXTI10_A::PD10)
            }
            #[doc = "Select PE10 as the source input for the EXTI10 external interrupt"]
            #[inline(always)]
            pub fn pe10(self) -> &'a mut W {
                self.variant(EXTI10_A::PE10)
            }
            #[doc = "Select PH10 as the source input for the EXTI10 external interrupt"]
            #[inline(always)]
            pub fn ph10(self) -> &'a mut W {
                self.variant(EXTI10_A::PH10)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 8 to 11)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI9_A {
            #[doc = "0: Select PA9 as the source input for the EXTI9 external interrupt"]
            PA9 = 0,
            #[doc = "1: Select PB9 as the source input for the EXTI9 external interrupt"]
            PB9 = 1,
            #[doc = "2: Select PC9 as the source input for the EXTI9 external interrupt"]
            PC9 = 2,
            #[doc = "3: Select PD9 as the source input for the EXTI9 external interrupt"]
            PD9 = 3,
            #[doc = "4: Select PE9 as the source input for the EXTI9 external interrupt"]
            PE9 = 4,
            #[doc = "5: Select PH9 as the source input for the EXTI9 external interrupt"]
            PH9 = 5,
        }
        impl From<EXTI9_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI9_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI9`"]
        pub type EXTI9_R = crate::R<u8, EXTI9_A>;
        impl EXTI9_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI9_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI9_A::PA9),
                    1 => Val(EXTI9_A::PB9),
                    2 => Val(EXTI9_A::PC9),
                    3 => Val(EXTI9_A::PD9),
                    4 => Val(EXTI9_A::PE9),
                    5 => Val(EXTI9_A::PH9),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA9`"]
            #[inline(always)]
            pub fn is_pa9(&self) -> bool {
                *self == EXTI9_A::PA9
            }
            #[doc = "Checks if the value of the field is `PB9`"]
            #[inline(always)]
            pub fn is_pb9(&self) -> bool {
                *self == EXTI9_A::PB9
            }
            #[doc = "Checks if the value of the field is `PC9`"]
            #[inline(always)]
            pub fn is_pc9(&self) -> bool {
                *self == EXTI9_A::PC9
            }
            #[doc = "Checks if the value of the field is `PD9`"]
            #[inline(always)]
            pub fn is_pd9(&self) -> bool {
                *self == EXTI9_A::PD9
            }
            #[doc = "Checks if the value of the field is `PE9`"]
            #[inline(always)]
            pub fn is_pe9(&self) -> bool {
                *self == EXTI9_A::PE9
            }
            #[doc = "Checks if the value of the field is `PH9`"]
            #[inline(always)]
            pub fn is_ph9(&self) -> bool {
                *self == EXTI9_A::PH9
            }
        }
        #[doc = "Write proxy for field `EXTI9`"]
        pub struct EXTI9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI9_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA9 as the source input for the EXTI9 external interrupt"]
            #[inline(always)]
            pub fn pa9(self) -> &'a mut W {
                self.variant(EXTI9_A::PA9)
            }
            #[doc = "Select PB9 as the source input for the EXTI9 external interrupt"]
            #[inline(always)]
            pub fn pb9(self) -> &'a mut W {
                self.variant(EXTI9_A::PB9)
            }
            #[doc = "Select PC9 as the source input for the EXTI9 external interrupt"]
            #[inline(always)]
            pub fn pc9(self) -> &'a mut W {
                self.variant(EXTI9_A::PC9)
            }
            #[doc = "Select PD9 as the source input for the EXTI9 external interrupt"]
            #[inline(always)]
            pub fn pd9(self) -> &'a mut W {
                self.variant(EXTI9_A::PD9)
            }
            #[doc = "Select PE9 as the source input for the EXTI9 external interrupt"]
            #[inline(always)]
            pub fn pe9(self) -> &'a mut W {
                self.variant(EXTI9_A::PE9)
            }
            #[doc = "Select PH9 as the source input for the EXTI9 external interrupt"]
            #[inline(always)]
            pub fn ph9(self) -> &'a mut W {
                self.variant(EXTI9_A::PH9)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "EXTI x configuration (x = 8 to 11)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI8_A {
            #[doc = "0: Select PA8 as the source input for the EXTI8 external interrupt"]
            PA8 = 0,
            #[doc = "1: Select PB8 as the source input for the EXTI8 external interrupt"]
            PB8 = 1,
            #[doc = "2: Select PC8 as the source input for the EXTI8 external interrupt"]
            PC8 = 2,
            #[doc = "3: Select PD8 as the source input for the EXTI8 external interrupt"]
            PD8 = 3,
            #[doc = "4: Select PE8 as the source input for the EXTI8 external interrupt"]
            PE8 = 4,
            #[doc = "5: Select PH8 as the source input for the EXTI8 external interrupt"]
            PH8 = 5,
        }
        impl From<EXTI8_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI8_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI8`"]
        pub type EXTI8_R = crate::R<u8, EXTI8_A>;
        impl EXTI8_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI8_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI8_A::PA8),
                    1 => Val(EXTI8_A::PB8),
                    2 => Val(EXTI8_A::PC8),
                    3 => Val(EXTI8_A::PD8),
                    4 => Val(EXTI8_A::PE8),
                    5 => Val(EXTI8_A::PH8),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA8`"]
            #[inline(always)]
            pub fn is_pa8(&self) -> bool {
                *self == EXTI8_A::PA8
            }
            #[doc = "Checks if the value of the field is `PB8`"]
            #[inline(always)]
            pub fn is_pb8(&self) -> bool {
                *self == EXTI8_A::PB8
            }
            #[doc = "Checks if the value of the field is `PC8`"]
            #[inline(always)]
            pub fn is_pc8(&self) -> bool {
                *self == EXTI8_A::PC8
            }
            #[doc = "Checks if the value of the field is `PD8`"]
            #[inline(always)]
            pub fn is_pd8(&self) -> bool {
                *self == EXTI8_A::PD8
            }
            #[doc = "Checks if the value of the field is `PE8`"]
            #[inline(always)]
            pub fn is_pe8(&self) -> bool {
                *self == EXTI8_A::PE8
            }
            #[doc = "Checks if the value of the field is `PH8`"]
            #[inline(always)]
            pub fn is_ph8(&self) -> bool {
                *self == EXTI8_A::PH8
            }
        }
        #[doc = "Write proxy for field `EXTI8`"]
        pub struct EXTI8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI8_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA8 as the source input for the EXTI8 external interrupt"]
            #[inline(always)]
            pub fn pa8(self) -> &'a mut W {
                self.variant(EXTI8_A::PA8)
            }
            #[doc = "Select PB8 as the source input for the EXTI8 external interrupt"]
            #[inline(always)]
            pub fn pb8(self) -> &'a mut W {
                self.variant(EXTI8_A::PB8)
            }
            #[doc = "Select PC8 as the source input for the EXTI8 external interrupt"]
            #[inline(always)]
            pub fn pc8(self) -> &'a mut W {
                self.variant(EXTI8_A::PC8)
            }
            #[doc = "Select PD8 as the source input for the EXTI8 external interrupt"]
            #[inline(always)]
            pub fn pd8(self) -> &'a mut W {
                self.variant(EXTI8_A::PD8)
            }
            #[doc = "Select PE8 as the source input for the EXTI8 external interrupt"]
            #[inline(always)]
            pub fn pe8(self) -> &'a mut W {
                self.variant(EXTI8_A::PE8)
            }
            #[doc = "Select PH8 as the source input for the EXTI8 external interrupt"]
            #[inline(always)]
            pub fn ph8(self) -> &'a mut W {
                self.variant(EXTI8_A::PH8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 8 to 11)"]
            #[inline(always)]
            pub fn exti11(&self) -> EXTI11_R {
                EXTI11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI10"]
            #[inline(always)]
            pub fn exti10(&self) -> EXTI10_R {
                EXTI10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI x configuration (x = 8 to 11)"]
            #[inline(always)]
            pub fn exti9(&self) -> EXTI9_R {
                EXTI9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - EXTI x configuration (x = 8 to 11)"]
            #[inline(always)]
            pub fn exti8(&self) -> EXTI8_R {
                EXTI8_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 8 to 11)"]
            #[inline(always)]
            pub fn exti11(&mut self) -> EXTI11_W {
                EXTI11_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI10"]
            #[inline(always)]
            pub fn exti10(&mut self) -> EXTI10_W {
                EXTI10_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI x configuration (x = 8 to 11)"]
            #[inline(always)]
            pub fn exti9(&mut self) -> EXTI9_W {
                EXTI9_W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI x configuration (x = 8 to 11)"]
            #[inline(always)]
            pub fn exti8(&mut self) -> EXTI8_W {
                EXTI8_W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [exticr4](exticr4) module"]
    pub type EXTICR4 = crate::Reg<u32, _EXTICR4>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTICR4;
    #[doc = "`read()` method returns [exticr4::R](exticr4::R) reader structure"]
    impl crate::Readable for EXTICR4 {}
    #[doc = "`write(|w| ..)` method takes [exticr4::W](exticr4::W) writer structure"]
    impl crate::Writable for EXTICR4 {}
    #[doc = "external interrupt configuration register 4"]
    pub mod exticr4 {
        #[doc = "Reader of register EXTICR4"]
        pub type R = crate::R<u32, super::EXTICR4>;
        #[doc = "Writer for register EXTICR4"]
        pub type W = crate::W<u32, super::EXTICR4>;
        #[doc = "Register EXTICR4 `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTICR4 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "EXTI x configuration (x = 12 to 15)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI15_A {
            #[doc = "0: Select PA15 as the source input for the EXTI15 external interrupt"]
            PA15 = 0,
            #[doc = "1: Select PB15 as the source input for the EXTI15 external interrupt"]
            PB15 = 1,
            #[doc = "2: Select PC15 as the source input for the EXTI15 external interrupt"]
            PC15 = 2,
            #[doc = "3: Select PD15 as the source input for the EXTI15 external interrupt"]
            PD15 = 3,
            #[doc = "4: Select PE15 as the source input for the EXTI15 external interrupt"]
            PE15 = 4,
        }
        impl From<EXTI15_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI15_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI15`"]
        pub type EXTI15_R = crate::R<u8, EXTI15_A>;
        impl EXTI15_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI15_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI15_A::PA15),
                    1 => Val(EXTI15_A::PB15),
                    2 => Val(EXTI15_A::PC15),
                    3 => Val(EXTI15_A::PD15),
                    4 => Val(EXTI15_A::PE15),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA15`"]
            #[inline(always)]
            pub fn is_pa15(&self) -> bool {
                *self == EXTI15_A::PA15
            }
            #[doc = "Checks if the value of the field is `PB15`"]
            #[inline(always)]
            pub fn is_pb15(&self) -> bool {
                *self == EXTI15_A::PB15
            }
            #[doc = "Checks if the value of the field is `PC15`"]
            #[inline(always)]
            pub fn is_pc15(&self) -> bool {
                *self == EXTI15_A::PC15
            }
            #[doc = "Checks if the value of the field is `PD15`"]
            #[inline(always)]
            pub fn is_pd15(&self) -> bool {
                *self == EXTI15_A::PD15
            }
            #[doc = "Checks if the value of the field is `PE15`"]
            #[inline(always)]
            pub fn is_pe15(&self) -> bool {
                *self == EXTI15_A::PE15
            }
        }
        #[doc = "Write proxy for field `EXTI15`"]
        pub struct EXTI15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI15_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA15 as the source input for the EXTI15 external interrupt"]
            #[inline(always)]
            pub fn pa15(self) -> &'a mut W {
                self.variant(EXTI15_A::PA15)
            }
            #[doc = "Select PB15 as the source input for the EXTI15 external interrupt"]
            #[inline(always)]
            pub fn pb15(self) -> &'a mut W {
                self.variant(EXTI15_A::PB15)
            }
            #[doc = "Select PC15 as the source input for the EXTI15 external interrupt"]
            #[inline(always)]
            pub fn pc15(self) -> &'a mut W {
                self.variant(EXTI15_A::PC15)
            }
            #[doc = "Select PD15 as the source input for the EXTI15 external interrupt"]
            #[inline(always)]
            pub fn pd15(self) -> &'a mut W {
                self.variant(EXTI15_A::PD15)
            }
            #[doc = "Select PE15 as the source input for the EXTI15 external interrupt"]
            #[inline(always)]
            pub fn pe15(self) -> &'a mut W {
                self.variant(EXTI15_A::PE15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "EXTI14\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI14_A {
            #[doc = "0: Select PA14 as the source input for the EXTI14 external interrupt"]
            PA14 = 0,
            #[doc = "1: Select PB14 as the source input for the EXTI14 external interrupt"]
            PB14 = 1,
            #[doc = "2: Select PC14 as the source input for the EXTI14 external interrupt"]
            PC14 = 2,
            #[doc = "3: Select PD14 as the source input for the EXTI14 external interrupt"]
            PD14 = 3,
            #[doc = "4: Select PE14 as the source input for the EXTI14 external interrupt"]
            PE14 = 4,
        }
        impl From<EXTI14_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI14_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI14`"]
        pub type EXTI14_R = crate::R<u8, EXTI14_A>;
        impl EXTI14_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI14_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI14_A::PA14),
                    1 => Val(EXTI14_A::PB14),
                    2 => Val(EXTI14_A::PC14),
                    3 => Val(EXTI14_A::PD14),
                    4 => Val(EXTI14_A::PE14),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA14`"]
            #[inline(always)]
            pub fn is_pa14(&self) -> bool {
                *self == EXTI14_A::PA14
            }
            #[doc = "Checks if the value of the field is `PB14`"]
            #[inline(always)]
            pub fn is_pb14(&self) -> bool {
                *self == EXTI14_A::PB14
            }
            #[doc = "Checks if the value of the field is `PC14`"]
            #[inline(always)]
            pub fn is_pc14(&self) -> bool {
                *self == EXTI14_A::PC14
            }
            #[doc = "Checks if the value of the field is `PD14`"]
            #[inline(always)]
            pub fn is_pd14(&self) -> bool {
                *self == EXTI14_A::PD14
            }
            #[doc = "Checks if the value of the field is `PE14`"]
            #[inline(always)]
            pub fn is_pe14(&self) -> bool {
                *self == EXTI14_A::PE14
            }
        }
        #[doc = "Write proxy for field `EXTI14`"]
        pub struct EXTI14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI14_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA14 as the source input for the EXTI14 external interrupt"]
            #[inline(always)]
            pub fn pa14(self) -> &'a mut W {
                self.variant(EXTI14_A::PA14)
            }
            #[doc = "Select PB14 as the source input for the EXTI14 external interrupt"]
            #[inline(always)]
            pub fn pb14(self) -> &'a mut W {
                self.variant(EXTI14_A::PB14)
            }
            #[doc = "Select PC14 as the source input for the EXTI14 external interrupt"]
            #[inline(always)]
            pub fn pc14(self) -> &'a mut W {
                self.variant(EXTI14_A::PC14)
            }
            #[doc = "Select PD14 as the source input for the EXTI14 external interrupt"]
            #[inline(always)]
            pub fn pd14(self) -> &'a mut W {
                self.variant(EXTI14_A::PD14)
            }
            #[doc = "Select PE14 as the source input for the EXTI14 external interrupt"]
            #[inline(always)]
            pub fn pe14(self) -> &'a mut W {
                self.variant(EXTI14_A::PE14)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "EXTI13\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI13_A {
            #[doc = "0: Select PA13 as the source input for the EXTI13 external interrupt"]
            PA13 = 0,
            #[doc = "1: Select PB13 as the source input for the EXTI13 external interrupt"]
            PB13 = 1,
            #[doc = "2: Select PC13 as the source input for the EXTI13 external interrupt"]
            PC13 = 2,
            #[doc = "3: Select PD13 as the source input for the EXTI13 external interrupt"]
            PD13 = 3,
            #[doc = "4: Select PE13 as the source input for the EXTI13 external interrupt"]
            PE13 = 4,
        }
        impl From<EXTI13_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI13_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI13`"]
        pub type EXTI13_R = crate::R<u8, EXTI13_A>;
        impl EXTI13_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI13_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI13_A::PA13),
                    1 => Val(EXTI13_A::PB13),
                    2 => Val(EXTI13_A::PC13),
                    3 => Val(EXTI13_A::PD13),
                    4 => Val(EXTI13_A::PE13),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA13`"]
            #[inline(always)]
            pub fn is_pa13(&self) -> bool {
                *self == EXTI13_A::PA13
            }
            #[doc = "Checks if the value of the field is `PB13`"]
            #[inline(always)]
            pub fn is_pb13(&self) -> bool {
                *self == EXTI13_A::PB13
            }
            #[doc = "Checks if the value of the field is `PC13`"]
            #[inline(always)]
            pub fn is_pc13(&self) -> bool {
                *self == EXTI13_A::PC13
            }
            #[doc = "Checks if the value of the field is `PD13`"]
            #[inline(always)]
            pub fn is_pd13(&self) -> bool {
                *self == EXTI13_A::PD13
            }
            #[doc = "Checks if the value of the field is `PE13`"]
            #[inline(always)]
            pub fn is_pe13(&self) -> bool {
                *self == EXTI13_A::PE13
            }
        }
        #[doc = "Write proxy for field `EXTI13`"]
        pub struct EXTI13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI13_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA13 as the source input for the EXTI13 external interrupt"]
            #[inline(always)]
            pub fn pa13(self) -> &'a mut W {
                self.variant(EXTI13_A::PA13)
            }
            #[doc = "Select PB13 as the source input for the EXTI13 external interrupt"]
            #[inline(always)]
            pub fn pb13(self) -> &'a mut W {
                self.variant(EXTI13_A::PB13)
            }
            #[doc = "Select PC13 as the source input for the EXTI13 external interrupt"]
            #[inline(always)]
            pub fn pc13(self) -> &'a mut W {
                self.variant(EXTI13_A::PC13)
            }
            #[doc = "Select PD13 as the source input for the EXTI13 external interrupt"]
            #[inline(always)]
            pub fn pd13(self) -> &'a mut W {
                self.variant(EXTI13_A::PD13)
            }
            #[doc = "Select PE13 as the source input for the EXTI13 external interrupt"]
            #[inline(always)]
            pub fn pe13(self) -> &'a mut W {
                self.variant(EXTI13_A::PE13)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "EXTI12\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTI12_A {
            #[doc = "0: Select PA12 as the source input for the EXTI12 external interrupt"]
            PA12 = 0,
            #[doc = "1: Select PB12 as the source input for the EXTI12 external interrupt"]
            PB12 = 1,
            #[doc = "2: Select PC12 as the source input for the EXTI12 external interrupt"]
            PC12 = 2,
            #[doc = "3: Select PD12 as the source input for the EXTI12 external interrupt"]
            PD12 = 3,
            #[doc = "4: Select PE12 as the source input for the EXTI12 external interrupt"]
            PE12 = 4,
        }
        impl From<EXTI12_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTI12_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTI12`"]
        pub type EXTI12_R = crate::R<u8, EXTI12_A>;
        impl EXTI12_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, EXTI12_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(EXTI12_A::PA12),
                    1 => Val(EXTI12_A::PB12),
                    2 => Val(EXTI12_A::PC12),
                    3 => Val(EXTI12_A::PD12),
                    4 => Val(EXTI12_A::PE12),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA12`"]
            #[inline(always)]
            pub fn is_pa12(&self) -> bool {
                *self == EXTI12_A::PA12
            }
            #[doc = "Checks if the value of the field is `PB12`"]
            #[inline(always)]
            pub fn is_pb12(&self) -> bool {
                *self == EXTI12_A::PB12
            }
            #[doc = "Checks if the value of the field is `PC12`"]
            #[inline(always)]
            pub fn is_pc12(&self) -> bool {
                *self == EXTI12_A::PC12
            }
            #[doc = "Checks if the value of the field is `PD12`"]
            #[inline(always)]
            pub fn is_pd12(&self) -> bool {
                *self == EXTI12_A::PD12
            }
            #[doc = "Checks if the value of the field is `PE12`"]
            #[inline(always)]
            pub fn is_pe12(&self) -> bool {
                *self == EXTI12_A::PE12
            }
        }
        #[doc = "Write proxy for field `EXTI12`"]
        pub struct EXTI12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTI12_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Select PA12 as the source input for the EXTI12 external interrupt"]
            #[inline(always)]
            pub fn pa12(self) -> &'a mut W {
                self.variant(EXTI12_A::PA12)
            }
            #[doc = "Select PB12 as the source input for the EXTI12 external interrupt"]
            #[inline(always)]
            pub fn pb12(self) -> &'a mut W {
                self.variant(EXTI12_A::PB12)
            }
            #[doc = "Select PC12 as the source input for the EXTI12 external interrupt"]
            #[inline(always)]
            pub fn pc12(self) -> &'a mut W {
                self.variant(EXTI12_A::PC12)
            }
            #[doc = "Select PD12 as the source input for the EXTI12 external interrupt"]
            #[inline(always)]
            pub fn pd12(self) -> &'a mut W {
                self.variant(EXTI12_A::PD12)
            }
            #[doc = "Select PE12 as the source input for the EXTI12 external interrupt"]
            #[inline(always)]
            pub fn pe12(self) -> &'a mut W {
                self.variant(EXTI12_A::PE12)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 12 to 15)"]
            #[inline(always)]
            pub fn exti15(&self) -> EXTI15_R {
                EXTI15_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - EXTI14"]
            #[inline(always)]
            pub fn exti14(&self) -> EXTI14_R {
                EXTI14_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - EXTI13"]
            #[inline(always)]
            pub fn exti13(&self) -> EXTI13_R {
                EXTI13_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 0:3 - EXTI12"]
            #[inline(always)]
            pub fn exti12(&self) -> EXTI12_R {
                EXTI12_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - EXTI x configuration (x = 12 to 15)"]
            #[inline(always)]
            pub fn exti15(&mut self) -> EXTI15_W {
                EXTI15_W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI14"]
            #[inline(always)]
            pub fn exti14(&mut self) -> EXTI14_W {
                EXTI14_W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI13"]
            #[inline(always)]
            pub fn exti13(&mut self) -> EXTI13_W {
                EXTI13_W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI12"]
            #[inline(always)]
            pub fn exti12(&mut self) -> EXTI12_W {
                EXTI12_W { w: self }
            }
        }
    }
    #[doc = "SYSCFG configuration register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr3](cfgr3) module"]
    pub type CFGR3 = crate::Reg<u32, _CFGR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR3;
    #[doc = "`read()` method returns [cfgr3::R](cfgr3::R) reader structure"]
    impl crate::Readable for CFGR3 {}
    #[doc = "`write(|w| ..)` method takes [cfgr3::W](cfgr3::W) writer structure"]
    impl crate::Writable for CFGR3 {}
    #[doc = "SYSCFG configuration register 3"]
    pub mod cfgr3 {
        #[doc = "Reader of register CFGR3"]
        pub type R = crate::R<u32, super::CFGR3>;
        #[doc = "Writer for register CFGR3"]
        pub type W = crate::W<u32, super::CFGR3>;
        #[doc = "Register CFGR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "VREFINT ready flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VREFINT_RDYF_A {
            #[doc = "0: VREFINT OFF"]
            NOTREADY = 0,
            #[doc = "1: VREFINT ready"]
            READY = 1,
        }
        impl From<VREFINT_RDYF_A> for bool {
            #[inline(always)]
            fn from(variant: VREFINT_RDYF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VREFINT_RDYF`"]
        pub type VREFINT_RDYF_R = crate::R<bool, VREFINT_RDYF_A>;
        impl VREFINT_RDYF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VREFINT_RDYF_A {
                match self.bits {
                    false => VREFINT_RDYF_A::NOTREADY,
                    true => VREFINT_RDYF_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == VREFINT_RDYF_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == VREFINT_RDYF_A::READY
            }
        }
        #[doc = "Sensor reference for ADC enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENBUF_SENSOR_ADC_A {
            #[doc = "0: Disables the buffer used to generate VREFINT reference for the temperature sensor"]
            DISABLED = 0,
            #[doc = "1: Enables the buffer used to generate VREFINT reference for the temperature sensor"]
            ENABLED = 1,
        }
        impl From<ENBUF_SENSOR_ADC_A> for bool {
            #[inline(always)]
            fn from(variant: ENBUF_SENSOR_ADC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENBUF_SENSOR_ADC`"]
        pub type ENBUF_SENSOR_ADC_R = crate::R<bool, ENBUF_SENSOR_ADC_A>;
        impl ENBUF_SENSOR_ADC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENBUF_SENSOR_ADC_A {
                match self.bits {
                    false => ENBUF_SENSOR_ADC_A::DISABLED,
                    true => ENBUF_SENSOR_ADC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENBUF_SENSOR_ADC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENBUF_SENSOR_ADC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENBUF_SENSOR_ADC`"]
        pub struct ENBUF_SENSOR_ADC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENBUF_SENSOR_ADC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENBUF_SENSOR_ADC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disables the buffer used to generate VREFINT reference for the temperature sensor"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENBUF_SENSOR_ADC_A::DISABLED)
            }
            #[doc = "Enables the buffer used to generate VREFINT reference for the temperature sensor"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENBUF_SENSOR_ADC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "BGAP_ADC connection bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SEL_VREF_OUT_A {
            #[doc = "0: no pad connected"]
            NOCONNECTION = 0,
            #[doc = "1: PB0 connected"]
            PB0 = 1,
            #[doc = "2: PB1 connected"]
            PB1 = 2,
            #[doc = "3: PB0 and PB1 connected"]
            BOTH = 3,
        }
        impl From<SEL_VREF_OUT_A> for u8 {
            #[inline(always)]
            fn from(variant: SEL_VREF_OUT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SEL_VREF_OUT`"]
        pub type SEL_VREF_OUT_R = crate::R<u8, SEL_VREF_OUT_A>;
        impl SEL_VREF_OUT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SEL_VREF_OUT_A {
                match self.bits {
                    0 => SEL_VREF_OUT_A::NOCONNECTION,
                    1 => SEL_VREF_OUT_A::PB0,
                    2 => SEL_VREF_OUT_A::PB1,
                    3 => SEL_VREF_OUT_A::BOTH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOCONNECTION`"]
            #[inline(always)]
            pub fn is_no_connection(&self) -> bool {
                *self == SEL_VREF_OUT_A::NOCONNECTION
            }
            #[doc = "Checks if the value of the field is `PB0`"]
            #[inline(always)]
            pub fn is_pb0(&self) -> bool {
                *self == SEL_VREF_OUT_A::PB0
            }
            #[doc = "Checks if the value of the field is `PB1`"]
            #[inline(always)]
            pub fn is_pb1(&self) -> bool {
                *self == SEL_VREF_OUT_A::PB1
            }
            #[doc = "Checks if the value of the field is `BOTH`"]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == SEL_VREF_OUT_A::BOTH
            }
        }
        #[doc = "Write proxy for field `SEL_VREF_OUT`"]
        pub struct SEL_VREF_OUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SEL_VREF_OUT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SEL_VREF_OUT_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "no pad connected"]
            #[inline(always)]
            pub fn no_connection(self) -> &'a mut W {
                self.variant(SEL_VREF_OUT_A::NOCONNECTION)
            }
            #[doc = "PB0 connected"]
            #[inline(always)]
            pub fn pb0(self) -> &'a mut W {
                self.variant(SEL_VREF_OUT_A::PB0)
            }
            #[doc = "PB1 connected"]
            #[inline(always)]
            pub fn pb1(self) -> &'a mut W {
                self.variant(SEL_VREF_OUT_A::PB1)
            }
            #[doc = "PB0 and PB1 connected"]
            #[inline(always)]
            pub fn both(self) -> &'a mut W {
                self.variant(SEL_VREF_OUT_A::BOTH)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "SYSCFG_CFGR3 lock bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REF_LOCK_A {
            #[doc = "0: SYSCFG_CFGR3\\[31:0\\]
bits are read/write"]
            READWRITE = 0,
            #[doc = "1: SYSCFG_CFGR3\\[31:0\\]
bits are read-only"]
            READONLY = 1,
        }
        impl From<REF_LOCK_A> for bool {
            #[inline(always)]
            fn from(variant: REF_LOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `REF_LOCK`"]
        pub type REF_LOCK_R = crate::R<bool, REF_LOCK_A>;
        impl REF_LOCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> REF_LOCK_A {
                match self.bits {
                    false => REF_LOCK_A::READWRITE,
                    true => REF_LOCK_A::READONLY,
                }
            }
            #[doc = "Checks if the value of the field is `READWRITE`"]
            #[inline(always)]
            pub fn is_read_write(&self) -> bool {
                *self == REF_LOCK_A::READWRITE
            }
            #[doc = "Checks if the value of the field is `READONLY`"]
            #[inline(always)]
            pub fn is_read_only(&self) -> bool {
                *self == REF_LOCK_A::READONLY
            }
        }
        #[doc = "Write proxy for field `REF_LOCK`"]
        pub struct REF_LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REF_LOCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: REF_LOCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "SYSCFG_CFGR3\\[31:0\\]
bits are read/write"]
            #[inline(always)]
            pub fn read_write(self) -> &'a mut W {
                self.variant(REF_LOCK_A::READWRITE)
            }
            #[doc = "SYSCFG_CFGR3\\[31:0\\]
bits are read-only"]
            #[inline(always)]
            pub fn read_only(self) -> &'a mut W {
                self.variant(REF_LOCK_A::READONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        #[doc = "VREFINT reference for COMP2 scaler enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENBUF_VREFINT_COMP2_A {
            #[doc = "0: Disables the buffer used to generate VREFINT references for COMP2"]
            DISABLED = 0,
            #[doc = "1: Enables the buffer used to generate VREFINT references for COMP2"]
            ENABLED = 1,
        }
        impl From<ENBUF_VREFINT_COMP2_A> for bool {
            #[inline(always)]
            fn from(variant: ENBUF_VREFINT_COMP2_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENBUF_VREFINT_COMP2`"]
        pub type ENBUF_VREFINT_COMP2_R = crate::R<bool, ENBUF_VREFINT_COMP2_A>;
        impl ENBUF_VREFINT_COMP2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENBUF_VREFINT_COMP2_A {
                match self.bits {
                    false => ENBUF_VREFINT_COMP2_A::DISABLED,
                    true => ENBUF_VREFINT_COMP2_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENBUF_VREFINT_COMP2_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENBUF_VREFINT_COMP2_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENBUF_VREFINT_COMP2`"]
        pub struct ENBUF_VREFINT_COMP2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENBUF_VREFINT_COMP2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENBUF_VREFINT_COMP2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disables the buffer used to generate VREFINT references for COMP2"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENBUF_VREFINT_COMP2_A::DISABLED)
            }
            #[doc = "Enables the buffer used to generate VREFINT references for COMP2"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENBUF_VREFINT_COMP2_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "VREFINT reference for ADC enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENBUF_VREFINT_ADC_A {
            #[doc = "0: Disables the buffer used to generate VREFINT reference for the ADC"]
            DISABLED = 0,
            #[doc = "1: Enables the buffer used to generate VREFINT reference for the ADC"]
            ENABLED = 1,
        }
        impl From<ENBUF_VREFINT_ADC_A> for bool {
            #[inline(always)]
            fn from(variant: ENBUF_VREFINT_ADC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENBUF_VREFINT_ADC`"]
        pub type ENBUF_VREFINT_ADC_R = crate::R<bool, ENBUF_VREFINT_ADC_A>;
        impl ENBUF_VREFINT_ADC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENBUF_VREFINT_ADC_A {
                match self.bits {
                    false => ENBUF_VREFINT_ADC_A::DISABLED,
                    true => ENBUF_VREFINT_ADC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENBUF_VREFINT_ADC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENBUF_VREFINT_ADC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ENBUF_VREFINT_ADC`"]
        pub struct ENBUF_VREFINT_ADC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENBUF_VREFINT_ADC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENBUF_VREFINT_ADC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disables the buffer used to generate VREFINT reference for the ADC"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENBUF_VREFINT_ADC_A::DISABLED)
            }
            #[doc = "Enables the buffer used to generate VREFINT reference for the ADC"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENBUF_VREFINT_ADC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "VREFINT enable and scaler control for COMP2 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN_VREFINT_A {
            #[doc = "0: VREFINT voltage disabled in low-power mode (if ULP=1) and scaler for COMP2 disabled"]
            DISABLED = 0,
            #[doc = "1: VREFINT voltage enabled in low-power mode and scaler for COMP2 enabled"]
            ENABLED = 1,
        }
        impl From<EN_VREFINT_A> for bool {
            #[inline(always)]
            fn from(variant: EN_VREFINT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EN_VREFINT`"]
        pub type EN_VREFINT_R = crate::R<bool, EN_VREFINT_A>;
        impl EN_VREFINT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EN_VREFINT_A {
                match self.bits {
                    false => EN_VREFINT_A::DISABLED,
                    true => EN_VREFINT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_VREFINT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_VREFINT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EN_VREFINT`"]
        pub struct EN_VREFINT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN_VREFINT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EN_VREFINT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "VREFINT voltage disabled in low-power mode (if ULP=1) and scaler for COMP2 disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_VREFINT_A::DISABLED)
            }
            #[doc = "VREFINT voltage enabled in low-power mode and scaler for COMP2 enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_VREFINT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 30 - VREFINT ready flag"]
            #[inline(always)]
            pub fn vrefint_rdyf(&self) -> VREFINT_RDYF_R {
                VREFINT_RDYF_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Sensor reference for ADC enable bit"]
            #[inline(always)]
            pub fn enbuf_sensor_adc(&self) -> ENBUF_SENSOR_ADC_R {
                ENBUF_SENSOR_ADC_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bits 4:5 - BGAP_ADC connection bit"]
            #[inline(always)]
            pub fn sel_vref_out(&self) -> SEL_VREF_OUT_R {
                SEL_VREF_OUT_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bit 31 - SYSCFG_CFGR3 lock bit"]
            #[inline(always)]
            pub fn ref_lock(&self) -> REF_LOCK_R {
                REF_LOCK_R::new(((self.bits >> 31) & 0x01) != 0)
            }
            #[doc = "Bit 12 - VREFINT reference for COMP2 scaler enable bit"]
            #[inline(always)]
            pub fn enbuf_vrefint_comp2(&self) -> ENBUF_VREFINT_COMP2_R {
                ENBUF_VREFINT_COMP2_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 8 - VREFINT reference for ADC enable bit"]
            #[inline(always)]
            pub fn enbuf_vrefint_adc(&self) -> ENBUF_VREFINT_ADC_R {
                ENBUF_VREFINT_ADC_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 0 - VREFINT enable and scaler control for COMP2 enable bit"]
            #[inline(always)]
            pub fn en_vrefint(&self) -> EN_VREFINT_R {
                EN_VREFINT_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 9 - Sensor reference for ADC enable bit"]
            #[inline(always)]
            pub fn enbuf_sensor_adc(&mut self) -> ENBUF_SENSOR_ADC_W {
                ENBUF_SENSOR_ADC_W { w: self }
            }
            #[doc = "Bits 4:5 - BGAP_ADC connection bit"]
            #[inline(always)]
            pub fn sel_vref_out(&mut self) -> SEL_VREF_OUT_W {
                SEL_VREF_OUT_W { w: self }
            }
            #[doc = "Bit 31 - SYSCFG_CFGR3 lock bit"]
            #[inline(always)]
            pub fn ref_lock(&mut self) -> REF_LOCK_W {
                REF_LOCK_W { w: self }
            }
            #[doc = "Bit 12 - VREFINT reference for COMP2 scaler enable bit"]
            #[inline(always)]
            pub fn enbuf_vrefint_comp2(&mut self) -> ENBUF_VREFINT_COMP2_W {
                ENBUF_VREFINT_COMP2_W { w: self }
            }
            #[doc = "Bit 8 - VREFINT reference for ADC enable bit"]
            #[inline(always)]
            pub fn enbuf_vrefint_adc(&mut self) -> ENBUF_VREFINT_ADC_W {
                ENBUF_VREFINT_ADC_W { w: self }
            }
            #[doc = "Bit 0 - VREFINT enable and scaler control for COMP2 enable bit"]
            #[inline(always)]
            pub fn en_vrefint(&mut self) -> EN_VREFINT_W {
                EN_VREFINT_W { w: self }
            }
        }
    }
    #[doc = "Comparator 1 control and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp1_csr](comp1_csr) module"]
    pub type COMP1_CSR = crate::Reg<u32, _COMP1_CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP1_CSR;
    #[doc = "`read()` method returns [comp1_csr::R](comp1_csr::R) reader structure"]
    impl crate::Readable for COMP1_CSR {}
    #[doc = "`write(|w| ..)` method takes [comp1_csr::W](comp1_csr::W) writer structure"]
    impl crate::Writable for COMP1_CSR {}
    #[doc = "Comparator 1 control and status register"]
    pub mod comp1_csr {
        #[doc = "Reader of register COMP1_CSR"]
        pub type R = crate::R<u32, super::COMP1_CSR>;
        #[doc = "Writer for register COMP1_CSR"]
        pub type W = crate::W<u32, super::COMP1_CSR>;
        #[doc = "Register COMP1_CSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP1_CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Comparator 1 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP1EN_A {
            #[doc = "0: Comparator 1 switched OFF"]
            DISABLED = 0,
            #[doc = "1: Comparator 1 switched ON"]
            ENABLED = 1,
        }
        impl From<COMP1EN_A> for bool {
            #[inline(always)]
            fn from(variant: COMP1EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP1EN`"]
        pub type COMP1EN_R = crate::R<bool, COMP1EN_A>;
        impl COMP1EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1EN_A {
                match self.bits {
                    false => COMP1EN_A::DISABLED,
                    true => COMP1EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == COMP1EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == COMP1EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `COMP1EN`"]
        pub struct COMP1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 1 switched OFF"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMP1EN_A::DISABLED)
            }
            #[doc = "Comparator 1 switched ON"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMP1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Comparator 1 Input Minus connection configuration bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum COMP1INNSEL_A {
            #[doc = "0: VREFINT"]
            VREFINT = 0,
            #[doc = "1: PA0"]
            PA0 = 1,
            #[doc = "2: PA4"]
            PA4 = 2,
            #[doc = "3: PA5"]
            PA5 = 3,
        }
        impl From<COMP1INNSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: COMP1INNSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `COMP1INNSEL`"]
        pub type COMP1INNSEL_R = crate::R<u8, COMP1INNSEL_A>;
        impl COMP1INNSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1INNSEL_A {
                match self.bits {
                    0 => COMP1INNSEL_A::VREFINT,
                    1 => COMP1INNSEL_A::PA0,
                    2 => COMP1INNSEL_A::PA4,
                    3 => COMP1INNSEL_A::PA5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VREFINT`"]
            #[inline(always)]
            pub fn is_vrefint(&self) -> bool {
                *self == COMP1INNSEL_A::VREFINT
            }
            #[doc = "Checks if the value of the field is `PA0`"]
            #[inline(always)]
            pub fn is_pa0(&self) -> bool {
                *self == COMP1INNSEL_A::PA0
            }
            #[doc = "Checks if the value of the field is `PA4`"]
            #[inline(always)]
            pub fn is_pa4(&self) -> bool {
                *self == COMP1INNSEL_A::PA4
            }
            #[doc = "Checks if the value of the field is `PA5`"]
            #[inline(always)]
            pub fn is_pa5(&self) -> bool {
                *self == COMP1INNSEL_A::PA5
            }
        }
        #[doc = "Write proxy for field `COMP1INNSEL`"]
        pub struct COMP1INNSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1INNSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1INNSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "VREFINT"]
            #[inline(always)]
            pub fn vrefint(self) -> &'a mut W {
                self.variant(COMP1INNSEL_A::VREFINT)
            }
            #[doc = "PA0"]
            #[inline(always)]
            pub fn pa0(self) -> &'a mut W {
                self.variant(COMP1INNSEL_A::PA0)
            }
            #[doc = "PA4"]
            #[inline(always)]
            pub fn pa4(self) -> &'a mut W {
                self.variant(COMP1INNSEL_A::PA4)
            }
            #[doc = "PA5"]
            #[inline(always)]
            pub fn pa5(self) -> &'a mut W {
                self.variant(COMP1INNSEL_A::PA5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Comparator 1 window mode selection bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP1WM_A {
            #[doc = "0: Plus input of comparator 1 connected to PA1"]
            PA1 = 0,
            #[doc = "1: Plus input of comparator 1 shorted with Plus input of comparator 2 (see COMP1_CSR)"]
            COMP2PLUS = 1,
        }
        impl From<COMP1WM_A> for bool {
            #[inline(always)]
            fn from(variant: COMP1WM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP1WM`"]
        pub type COMP1WM_R = crate::R<bool, COMP1WM_A>;
        impl COMP1WM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1WM_A {
                match self.bits {
                    false => COMP1WM_A::PA1,
                    true => COMP1WM_A::COMP2PLUS,
                }
            }
            #[doc = "Checks if the value of the field is `PA1`"]
            #[inline(always)]
            pub fn is_pa1(&self) -> bool {
                *self == COMP1WM_A::PA1
            }
            #[doc = "Checks if the value of the field is `COMP2PLUS`"]
            #[inline(always)]
            pub fn is_comp2plus(&self) -> bool {
                *self == COMP1WM_A::COMP2PLUS
            }
        }
        #[doc = "Write proxy for field `COMP1WM`"]
        pub struct COMP1WM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1WM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1WM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Plus input of comparator 1 connected to PA1"]
            #[inline(always)]
            pub fn pa1(self) -> &'a mut W {
                self.variant(COMP1WM_A::PA1)
            }
            #[doc = "Plus input of comparator 1 shorted with Plus input of comparator 2 (see COMP1_CSR)"]
            #[inline(always)]
            pub fn comp2plus(self) -> &'a mut W {
                self.variant(COMP1WM_A::COMP2PLUS)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Comparator 1 LPTIM input propagation bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP1LPTIMIN1_A {
            #[doc = "0: Comparator 1 output gated"]
            GATED = 0,
            #[doc = "1: Comparator 1 output sent to LPTIM input 1"]
            NOTGATED = 1,
        }
        impl From<COMP1LPTIMIN1_A> for bool {
            #[inline(always)]
            fn from(variant: COMP1LPTIMIN1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP1LPTIMIN1`"]
        pub type COMP1LPTIMIN1_R = crate::R<bool, COMP1LPTIMIN1_A>;
        impl COMP1LPTIMIN1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1LPTIMIN1_A {
                match self.bits {
                    false => COMP1LPTIMIN1_A::GATED,
                    true => COMP1LPTIMIN1_A::NOTGATED,
                }
            }
            #[doc = "Checks if the value of the field is `GATED`"]
            #[inline(always)]
            pub fn is_gated(&self) -> bool {
                *self == COMP1LPTIMIN1_A::GATED
            }
            #[doc = "Checks if the value of the field is `NOTGATED`"]
            #[inline(always)]
            pub fn is_not_gated(&self) -> bool {
                *self == COMP1LPTIMIN1_A::NOTGATED
            }
        }
        #[doc = "Write proxy for field `COMP1LPTIMIN1`"]
        pub struct COMP1LPTIMIN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1LPTIMIN1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1LPTIMIN1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 1 output gated"]
            #[inline(always)]
            pub fn gated(self) -> &'a mut W {
                self.variant(COMP1LPTIMIN1_A::GATED)
            }
            #[doc = "Comparator 1 output sent to LPTIM input 1"]
            #[inline(always)]
            pub fn not_gated(self) -> &'a mut W {
                self.variant(COMP1LPTIMIN1_A::NOTGATED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Comparator 1 polarity selection bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP1POLARITY_A {
            #[doc = "0: Comparator 1 output value not inverted"]
            NOTINVERTED = 0,
            #[doc = "1: Comparator 1 output value inverted"]
            INVERTED = 1,
        }
        impl From<COMP1POLARITY_A> for bool {
            #[inline(always)]
            fn from(variant: COMP1POLARITY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP1POLARITY`"]
        pub type COMP1POLARITY_R = crate::R<bool, COMP1POLARITY_A>;
        impl COMP1POLARITY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1POLARITY_A {
                match self.bits {
                    false => COMP1POLARITY_A::NOTINVERTED,
                    true => COMP1POLARITY_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINVERTED`"]
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                *self == COMP1POLARITY_A::NOTINVERTED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == COMP1POLARITY_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `COMP1POLARITY`"]
        pub struct COMP1POLARITY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1POLARITY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1POLARITY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 1 output value not inverted"]
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(COMP1POLARITY_A::NOTINVERTED)
            }
            #[doc = "Comparator 1 output value inverted"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(COMP1POLARITY_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Comparator 1 output status bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP1VALUE_A {
            #[doc = "0: Comparator values are not equal"]
            NOTEQUAL = 0,
            #[doc = "1: Comparator values are equal"]
            EQUAL = 1,
        }
        impl From<COMP1VALUE_A> for bool {
            #[inline(always)]
            fn from(variant: COMP1VALUE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP1VALUE`"]
        pub type COMP1VALUE_R = crate::R<bool, COMP1VALUE_A>;
        impl COMP1VALUE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1VALUE_A {
                match self.bits {
                    false => COMP1VALUE_A::NOTEQUAL,
                    true => COMP1VALUE_A::EQUAL,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEQUAL`"]
            #[inline(always)]
            pub fn is_not_equal(&self) -> bool {
                *self == COMP1VALUE_A::NOTEQUAL
            }
            #[doc = "Checks if the value of the field is `EQUAL`"]
            #[inline(always)]
            pub fn is_equal(&self) -> bool {
                *self == COMP1VALUE_A::EQUAL
            }
        }
        #[doc = "Write proxy for field `COMP1VALUE`"]
        pub struct COMP1VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1VALUE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1VALUE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator values are not equal"]
            #[inline(always)]
            pub fn not_equal(self) -> &'a mut W {
                self.variant(COMP1VALUE_A::NOTEQUAL)
            }
            #[doc = "Comparator values are equal"]
            #[inline(always)]
            pub fn equal(self) -> &'a mut W {
                self.variant(COMP1VALUE_A::EQUAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "COMP1_CSR register lock bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP1LOCK_A {
            #[doc = "0: COMP1_CSR\\[31:0\\]
for comparator 1 are read/write"]
            READWRITE = 0,
            #[doc = "1: COMP1_CSR\\[31:0\\]
for comparator 1 are read-only"]
            READONLY = 1,
        }
        impl From<COMP1LOCK_A> for bool {
            #[inline(always)]
            fn from(variant: COMP1LOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP1LOCK`"]
        pub type COMP1LOCK_R = crate::R<bool, COMP1LOCK_A>;
        impl COMP1LOCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP1LOCK_A {
                match self.bits {
                    false => COMP1LOCK_A::READWRITE,
                    true => COMP1LOCK_A::READONLY,
                }
            }
            #[doc = "Checks if the value of the field is `READWRITE`"]
            #[inline(always)]
            pub fn is_read_write(&self) -> bool {
                *self == COMP1LOCK_A::READWRITE
            }
            #[doc = "Checks if the value of the field is `READONLY`"]
            #[inline(always)]
            pub fn is_read_only(&self) -> bool {
                *self == COMP1LOCK_A::READONLY
            }
        }
        #[doc = "Write proxy for field `COMP1LOCK`"]
        pub struct COMP1LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP1LOCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP1LOCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "COMP1_CSR\\[31:0\\]
for comparator 1 are read/write"]
            #[inline(always)]
            pub fn read_write(self) -> &'a mut W {
                self.variant(COMP1LOCK_A::READWRITE)
            }
            #[doc = "COMP1_CSR\\[31:0\\]
for comparator 1 are read-only"]
            #[inline(always)]
            pub fn read_only(self) -> &'a mut W {
                self.variant(COMP1LOCK_A::READONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Comparator 1 enable bit"]
            #[inline(always)]
            pub fn comp1en(&self) -> COMP1EN_R {
                COMP1EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 4:5 - Comparator 1 Input Minus connection configuration bit"]
            #[inline(always)]
            pub fn comp1innsel(&self) -> COMP1INNSEL_R {
                COMP1INNSEL_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bit 8 - Comparator 1 window mode selection bit"]
            #[inline(always)]
            pub fn comp1wm(&self) -> COMP1WM_R {
                COMP1WM_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Comparator 1 LPTIM input propagation bit"]
            #[inline(always)]
            pub fn comp1lptimin1(&self) -> COMP1LPTIMIN1_R {
                COMP1LPTIMIN1_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Comparator 1 polarity selection bit"]
            #[inline(always)]
            pub fn comp1polarity(&self) -> COMP1POLARITY_R {
                COMP1POLARITY_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 30 - Comparator 1 output status bit"]
            #[inline(always)]
            pub fn comp1value(&self) -> COMP1VALUE_R {
                COMP1VALUE_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31 - COMP1_CSR register lock bit"]
            #[inline(always)]
            pub fn comp1lock(&self) -> COMP1LOCK_R {
                COMP1LOCK_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Comparator 1 enable bit"]
            #[inline(always)]
            pub fn comp1en(&mut self) -> COMP1EN_W {
                COMP1EN_W { w: self }
            }
            #[doc = "Bits 4:5 - Comparator 1 Input Minus connection configuration bit"]
            #[inline(always)]
            pub fn comp1innsel(&mut self) -> COMP1INNSEL_W {
                COMP1INNSEL_W { w: self }
            }
            #[doc = "Bit 8 - Comparator 1 window mode selection bit"]
            #[inline(always)]
            pub fn comp1wm(&mut self) -> COMP1WM_W {
                COMP1WM_W { w: self }
            }
            #[doc = "Bit 12 - Comparator 1 LPTIM input propagation bit"]
            #[inline(always)]
            pub fn comp1lptimin1(&mut self) -> COMP1LPTIMIN1_W {
                COMP1LPTIMIN1_W { w: self }
            }
            #[doc = "Bit 15 - Comparator 1 polarity selection bit"]
            #[inline(always)]
            pub fn comp1polarity(&mut self) -> COMP1POLARITY_W {
                COMP1POLARITY_W { w: self }
            }
            #[doc = "Bit 30 - Comparator 1 output status bit"]
            #[inline(always)]
            pub fn comp1value(&mut self) -> COMP1VALUE_W {
                COMP1VALUE_W { w: self }
            }
            #[doc = "Bit 31 - COMP1_CSR register lock bit"]
            #[inline(always)]
            pub fn comp1lock(&mut self) -> COMP1LOCK_W {
                COMP1LOCK_W { w: self }
            }
        }
    }
    #[doc = "Comparator 2 control and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp2_csr](comp2_csr) module"]
    pub type COMP2_CSR = crate::Reg<u32, _COMP2_CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP2_CSR;
    #[doc = "`read()` method returns [comp2_csr::R](comp2_csr::R) reader structure"]
    impl crate::Readable for COMP2_CSR {}
    #[doc = "`write(|w| ..)` method takes [comp2_csr::W](comp2_csr::W) writer structure"]
    impl crate::Writable for COMP2_CSR {}
    #[doc = "Comparator 2 control and status register"]
    pub mod comp2_csr {
        #[doc = "Reader of register COMP2_CSR"]
        pub type R = crate::R<u32, super::COMP2_CSR>;
        #[doc = "Writer for register COMP2_CSR"]
        pub type W = crate::W<u32, super::COMP2_CSR>;
        #[doc = "Register COMP2_CSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP2_CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Comparator 2 enable bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2EN_A {
            #[doc = "0: Comparator 2 switched OFF"]
            DISABLED = 0,
            #[doc = "1: Comparator 2 switched ON"]
            ENABLED = 1,
        }
        impl From<COMP2EN_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2EN`"]
        pub type COMP2EN_R = crate::R<bool, COMP2EN_A>;
        impl COMP2EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2EN_A {
                match self.bits {
                    false => COMP2EN_A::DISABLED,
                    true => COMP2EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == COMP2EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == COMP2EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `COMP2EN`"]
        pub struct COMP2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 2 switched OFF"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMP2EN_A::DISABLED)
            }
            #[doc = "Comparator 2 switched ON"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMP2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Comparator 2 power mode selection bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2SPEED_A {
            #[doc = "0: Slow speed"]
            SLOW = 0,
            #[doc = "1: Fast speed"]
            FAST = 1,
        }
        impl From<COMP2SPEED_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2SPEED_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2SPEED`"]
        pub type COMP2SPEED_R = crate::R<bool, COMP2SPEED_A>;
        impl COMP2SPEED_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2SPEED_A {
                match self.bits {
                    false => COMP2SPEED_A::SLOW,
                    true => COMP2SPEED_A::FAST,
                }
            }
            #[doc = "Checks if the value of the field is `SLOW`"]
            #[inline(always)]
            pub fn is_slow(&self) -> bool {
                *self == COMP2SPEED_A::SLOW
            }
            #[doc = "Checks if the value of the field is `FAST`"]
            #[inline(always)]
            pub fn is_fast(&self) -> bool {
                *self == COMP2SPEED_A::FAST
            }
        }
        #[doc = "Write proxy for field `COMP2SPEED`"]
        pub struct COMP2SPEED_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2SPEED_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2SPEED_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Slow speed"]
            #[inline(always)]
            pub fn slow(self) -> &'a mut W {
                self.variant(COMP2SPEED_A::SLOW)
            }
            #[doc = "Fast speed"]
            #[inline(always)]
            pub fn fast(self) -> &'a mut W {
                self.variant(COMP2SPEED_A::FAST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Comparator 2 Input Minus connection configuration bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum COMP2INNSEL_A {
            #[doc = "0: VREFINT"]
            VREFINT = 0,
            #[doc = "1: PA2"]
            PA2 = 1,
            #[doc = "2: PA4"]
            PA4 = 2,
            #[doc = "3: PA5"]
            PA5 = 3,
            #[doc = "4: 1/4 VREFINT"]
            VREFINT_DIV4 = 4,
            #[doc = "5: 1/2 VREFINT"]
            VREFINT_DIV2 = 5,
            #[doc = "6: 3/4 VREFINT"]
            VREFINT_DIV3_4 = 6,
            #[doc = "7: PB3"]
            PB3 = 7,
        }
        impl From<COMP2INNSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: COMP2INNSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `COMP2INNSEL`"]
        pub type COMP2INNSEL_R = crate::R<u8, COMP2INNSEL_A>;
        impl COMP2INNSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2INNSEL_A {
                match self.bits {
                    0 => COMP2INNSEL_A::VREFINT,
                    1 => COMP2INNSEL_A::PA2,
                    2 => COMP2INNSEL_A::PA4,
                    3 => COMP2INNSEL_A::PA5,
                    4 => COMP2INNSEL_A::VREFINT_DIV4,
                    5 => COMP2INNSEL_A::VREFINT_DIV2,
                    6 => COMP2INNSEL_A::VREFINT_DIV3_4,
                    7 => COMP2INNSEL_A::PB3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VREFINT`"]
            #[inline(always)]
            pub fn is_vrefint(&self) -> bool {
                *self == COMP2INNSEL_A::VREFINT
            }
            #[doc = "Checks if the value of the field is `PA2`"]
            #[inline(always)]
            pub fn is_pa2(&self) -> bool {
                *self == COMP2INNSEL_A::PA2
            }
            #[doc = "Checks if the value of the field is `PA4`"]
            #[inline(always)]
            pub fn is_pa4(&self) -> bool {
                *self == COMP2INNSEL_A::PA4
            }
            #[doc = "Checks if the value of the field is `PA5`"]
            #[inline(always)]
            pub fn is_pa5(&self) -> bool {
                *self == COMP2INNSEL_A::PA5
            }
            #[doc = "Checks if the value of the field is `VREFINT_DIV4`"]
            #[inline(always)]
            pub fn is_vrefint_div4(&self) -> bool {
                *self == COMP2INNSEL_A::VREFINT_DIV4
            }
            #[doc = "Checks if the value of the field is `VREFINT_DIV2`"]
            #[inline(always)]
            pub fn is_vrefint_div2(&self) -> bool {
                *self == COMP2INNSEL_A::VREFINT_DIV2
            }
            #[doc = "Checks if the value of the field is `VREFINT_DIV3_4`"]
            #[inline(always)]
            pub fn is_vrefint_div3_4(&self) -> bool {
                *self == COMP2INNSEL_A::VREFINT_DIV3_4
            }
            #[doc = "Checks if the value of the field is `PB3`"]
            #[inline(always)]
            pub fn is_pb3(&self) -> bool {
                *self == COMP2INNSEL_A::PB3
            }
        }
        #[doc = "Write proxy for field `COMP2INNSEL`"]
        pub struct COMP2INNSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2INNSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2INNSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "VREFINT"]
            #[inline(always)]
            pub fn vrefint(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::VREFINT)
            }
            #[doc = "PA2"]
            #[inline(always)]
            pub fn pa2(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::PA2)
            }
            #[doc = "PA4"]
            #[inline(always)]
            pub fn pa4(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::PA4)
            }
            #[doc = "PA5"]
            #[inline(always)]
            pub fn pa5(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::PA5)
            }
            #[doc = "1/4 VREFINT"]
            #[inline(always)]
            pub fn vrefint_div4(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::VREFINT_DIV4)
            }
            #[doc = "1/2 VREFINT"]
            #[inline(always)]
            pub fn vrefint_div2(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::VREFINT_DIV2)
            }
            #[doc = "3/4 VREFINT"]
            #[inline(always)]
            pub fn vrefint_div3_4(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::VREFINT_DIV3_4)
            }
            #[doc = "PB3"]
            #[inline(always)]
            pub fn pb3(self) -> &'a mut W {
                self.variant(COMP2INNSEL_A::PB3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Comparator 2 Input Plus connection configuration bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum COMP2INPSEL_A {
            #[doc = "0: PA3"]
            PA3 = 0,
            #[doc = "1: PB4"]
            PB4 = 1,
            #[doc = "2: PB5"]
            PB5 = 2,
            #[doc = "3: PB6"]
            PB6 = 3,
            #[doc = "4: PB7"]
            PB7 = 4,
            #[doc = "5: PA7"]
            PA7 = 5,
        }
        impl From<COMP2INPSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: COMP2INPSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `COMP2INPSEL`"]
        pub type COMP2INPSEL_R = crate::R<u8, COMP2INPSEL_A>;
        impl COMP2INPSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, COMP2INPSEL_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(COMP2INPSEL_A::PA3),
                    1 => Val(COMP2INPSEL_A::PB4),
                    2 => Val(COMP2INPSEL_A::PB5),
                    3 => Val(COMP2INPSEL_A::PB6),
                    4 => Val(COMP2INPSEL_A::PB7),
                    5 => Val(COMP2INPSEL_A::PA7),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PA3`"]
            #[inline(always)]
            pub fn is_pa3(&self) -> bool {
                *self == COMP2INPSEL_A::PA3
            }
            #[doc = "Checks if the value of the field is `PB4`"]
            #[inline(always)]
            pub fn is_pb4(&self) -> bool {
                *self == COMP2INPSEL_A::PB4
            }
            #[doc = "Checks if the value of the field is `PB5`"]
            #[inline(always)]
            pub fn is_pb5(&self) -> bool {
                *self == COMP2INPSEL_A::PB5
            }
            #[doc = "Checks if the value of the field is `PB6`"]
            #[inline(always)]
            pub fn is_pb6(&self) -> bool {
                *self == COMP2INPSEL_A::PB6
            }
            #[doc = "Checks if the value of the field is `PB7`"]
            #[inline(always)]
            pub fn is_pb7(&self) -> bool {
                *self == COMP2INPSEL_A::PB7
            }
            #[doc = "Checks if the value of the field is `PA7`"]
            #[inline(always)]
            pub fn is_pa7(&self) -> bool {
                *self == COMP2INPSEL_A::PA7
            }
        }
        #[doc = "Write proxy for field `COMP2INPSEL`"]
        pub struct COMP2INPSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2INPSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2INPSEL_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "PA3"]
            #[inline(always)]
            pub fn pa3(self) -> &'a mut W {
                self.variant(COMP2INPSEL_A::PA3)
            }
            #[doc = "PB4"]
            #[inline(always)]
            pub fn pb4(self) -> &'a mut W {
                self.variant(COMP2INPSEL_A::PB4)
            }
            #[doc = "PB5"]
            #[inline(always)]
            pub fn pb5(self) -> &'a mut W {
                self.variant(COMP2INPSEL_A::PB5)
            }
            #[doc = "PB6"]
            #[inline(always)]
            pub fn pb6(self) -> &'a mut W {
                self.variant(COMP2INPSEL_A::PB6)
            }
            #[doc = "PB7"]
            #[inline(always)]
            pub fn pb7(self) -> &'a mut W {
                self.variant(COMP2INPSEL_A::PB7)
            }
            #[doc = "PA7"]
            #[inline(always)]
            pub fn pa7(self) -> &'a mut W {
                self.variant(COMP2INPSEL_A::PA7)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 8)) | (((value as u32) & 0x07) << 8);
                self.w
            }
        }
        #[doc = "Comparator 2 LPTIM input 2 propagation bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2LPTIMIN2_A {
            #[doc = "0: Comparator 2 output gated"]
            GATED = 0,
            #[doc = "1: Comparator 2 output sent to LPTIM input 2"]
            NOTGATED = 1,
        }
        impl From<COMP2LPTIMIN2_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2LPTIMIN2_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2LPTIMIN2`"]
        pub type COMP2LPTIMIN2_R = crate::R<bool, COMP2LPTIMIN2_A>;
        impl COMP2LPTIMIN2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2LPTIMIN2_A {
                match self.bits {
                    false => COMP2LPTIMIN2_A::GATED,
                    true => COMP2LPTIMIN2_A::NOTGATED,
                }
            }
            #[doc = "Checks if the value of the field is `GATED`"]
            #[inline(always)]
            pub fn is_gated(&self) -> bool {
                *self == COMP2LPTIMIN2_A::GATED
            }
            #[doc = "Checks if the value of the field is `NOTGATED`"]
            #[inline(always)]
            pub fn is_not_gated(&self) -> bool {
                *self == COMP2LPTIMIN2_A::NOTGATED
            }
        }
        #[doc = "Write proxy for field `COMP2LPTIMIN2`"]
        pub struct COMP2LPTIMIN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2LPTIMIN2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2LPTIMIN2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 2 output gated"]
            #[inline(always)]
            pub fn gated(self) -> &'a mut W {
                self.variant(COMP2LPTIMIN2_A::GATED)
            }
            #[doc = "Comparator 2 output sent to LPTIM input 2"]
            #[inline(always)]
            pub fn not_gated(self) -> &'a mut W {
                self.variant(COMP2LPTIMIN2_A::NOTGATED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Comparator 2 LPTIM input 1 propagation bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2LPTIMIN1_A {
            #[doc = "0: Comparator 2 output gated"]
            GATED = 0,
            #[doc = "1: Comparator 2 output sent to LPTIM input 1"]
            NOTGATED = 1,
        }
        impl From<COMP2LPTIMIN1_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2LPTIMIN1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2LPTIMIN1`"]
        pub type COMP2LPTIMIN1_R = crate::R<bool, COMP2LPTIMIN1_A>;
        impl COMP2LPTIMIN1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2LPTIMIN1_A {
                match self.bits {
                    false => COMP2LPTIMIN1_A::GATED,
                    true => COMP2LPTIMIN1_A::NOTGATED,
                }
            }
            #[doc = "Checks if the value of the field is `GATED`"]
            #[inline(always)]
            pub fn is_gated(&self) -> bool {
                *self == COMP2LPTIMIN1_A::GATED
            }
            #[doc = "Checks if the value of the field is `NOTGATED`"]
            #[inline(always)]
            pub fn is_not_gated(&self) -> bool {
                *self == COMP2LPTIMIN1_A::NOTGATED
            }
        }
        #[doc = "Write proxy for field `COMP2LPTIMIN1`"]
        pub struct COMP2LPTIMIN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2LPTIMIN1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2LPTIMIN1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 2 output gated"]
            #[inline(always)]
            pub fn gated(self) -> &'a mut W {
                self.variant(COMP2LPTIMIN1_A::GATED)
            }
            #[doc = "Comparator 2 output sent to LPTIM input 1"]
            #[inline(always)]
            pub fn not_gated(self) -> &'a mut W {
                self.variant(COMP2LPTIMIN1_A::NOTGATED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Comparator 2 polarity selection bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2POLARITY_A {
            #[doc = "0: Comparator 2 output value not inverted"]
            NOTINVERTED = 0,
            #[doc = "1: Comparator 2 output value inverted"]
            INVERTED = 1,
        }
        impl From<COMP2POLARITY_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2POLARITY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2POLARITY`"]
        pub type COMP2POLARITY_R = crate::R<bool, COMP2POLARITY_A>;
        impl COMP2POLARITY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2POLARITY_A {
                match self.bits {
                    false => COMP2POLARITY_A::NOTINVERTED,
                    true => COMP2POLARITY_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINVERTED`"]
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                *self == COMP2POLARITY_A::NOTINVERTED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == COMP2POLARITY_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `COMP2POLARITY`"]
        pub struct COMP2POLARITY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2POLARITY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2POLARITY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator 2 output value not inverted"]
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(COMP2POLARITY_A::NOTINVERTED)
            }
            #[doc = "Comparator 2 output value inverted"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(COMP2POLARITY_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Comparator 2 output status bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2VALUE_A {
            #[doc = "0: Comparator values are not equal"]
            NOTEQUAL = 0,
            #[doc = "1: Comparator values are equal"]
            EQUAL = 1,
        }
        impl From<COMP2VALUE_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2VALUE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2VALUE`"]
        pub type COMP2VALUE_R = crate::R<bool, COMP2VALUE_A>;
        impl COMP2VALUE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2VALUE_A {
                match self.bits {
                    false => COMP2VALUE_A::NOTEQUAL,
                    true => COMP2VALUE_A::EQUAL,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEQUAL`"]
            #[inline(always)]
            pub fn is_not_equal(&self) -> bool {
                *self == COMP2VALUE_A::NOTEQUAL
            }
            #[doc = "Checks if the value of the field is `EQUAL`"]
            #[inline(always)]
            pub fn is_equal(&self) -> bool {
                *self == COMP2VALUE_A::EQUAL
            }
        }
        #[doc = "Write proxy for field `COMP2VALUE`"]
        pub struct COMP2VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2VALUE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2VALUE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Comparator values are not equal"]
            #[inline(always)]
            pub fn not_equal(self) -> &'a mut W {
                self.variant(COMP2VALUE_A::NOTEQUAL)
            }
            #[doc = "Comparator values are equal"]
            #[inline(always)]
            pub fn equal(self) -> &'a mut W {
                self.variant(COMP2VALUE_A::EQUAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "COMP2_CSR register lock bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP2LOCK_A {
            #[doc = "0: COMP2_CSR\\[31:0\\]
for comparator 2 are read/write"]
            READWRITE = 0,
            #[doc = "1: COMP2_CSR\\[31:0\\]
for comparator 2 are read-only"]
            READONLY = 1,
        }
        impl From<COMP2LOCK_A> for bool {
            #[inline(always)]
            fn from(variant: COMP2LOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `COMP2LOCK`"]
        pub type COMP2LOCK_R = crate::R<bool, COMP2LOCK_A>;
        impl COMP2LOCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> COMP2LOCK_A {
                match self.bits {
                    false => COMP2LOCK_A::READWRITE,
                    true => COMP2LOCK_A::READONLY,
                }
            }
            #[doc = "Checks if the value of the field is `READWRITE`"]
            #[inline(always)]
            pub fn is_read_write(&self) -> bool {
                *self == COMP2LOCK_A::READWRITE
            }
            #[doc = "Checks if the value of the field is `READONLY`"]
            #[inline(always)]
            pub fn is_read_only(&self) -> bool {
                *self == COMP2LOCK_A::READONLY
            }
        }
        #[doc = "Write proxy for field `COMP2LOCK`"]
        pub struct COMP2LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMP2LOCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP2LOCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "COMP2_CSR\\[31:0\\]
for comparator 2 are read/write"]
            #[inline(always)]
            pub fn read_write(self) -> &'a mut W {
                self.variant(COMP2LOCK_A::READWRITE)
            }
            #[doc = "COMP2_CSR\\[31:0\\]
for comparator 2 are read-only"]
            #[inline(always)]
            pub fn read_only(self) -> &'a mut W {
                self.variant(COMP2LOCK_A::READONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Comparator 2 enable bit"]
            #[inline(always)]
            pub fn comp2en(&self) -> COMP2EN_R {
                COMP2EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 3 - Comparator 2 power mode selection bit"]
            #[inline(always)]
            pub fn comp2speed(&self) -> COMP2SPEED_R {
                COMP2SPEED_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Comparator 2 Input Minus connection configuration bit"]
            #[inline(always)]
            pub fn comp2innsel(&self) -> COMP2INNSEL_R {
                COMP2INNSEL_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 8:10 - Comparator 2 Input Plus connection configuration bit"]
            #[inline(always)]
            pub fn comp2inpsel(&self) -> COMP2INPSEL_R {
                COMP2INPSEL_R::new(((self.bits >> 8) & 0x07) as u8)
            }
            #[doc = "Bit 12 - Comparator 2 LPTIM input 2 propagation bit"]
            #[inline(always)]
            pub fn comp2lptimin2(&self) -> COMP2LPTIMIN2_R {
                COMP2LPTIMIN2_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Comparator 2 LPTIM input 1 propagation bit"]
            #[inline(always)]
            pub fn comp2lptimin1(&self) -> COMP2LPTIMIN1_R {
                COMP2LPTIMIN1_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Comparator 2 polarity selection bit"]
            #[inline(always)]
            pub fn comp2polarity(&self) -> COMP2POLARITY_R {
                COMP2POLARITY_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 30 - Comparator 2 output status bit"]
            #[inline(always)]
            pub fn comp2value(&self) -> COMP2VALUE_R {
                COMP2VALUE_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31 - COMP2_CSR register lock bit"]
            #[inline(always)]
            pub fn comp2lock(&self) -> COMP2LOCK_R {
                COMP2LOCK_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Comparator 2 enable bit"]
            #[inline(always)]
            pub fn comp2en(&mut self) -> COMP2EN_W {
                COMP2EN_W { w: self }
            }
            #[doc = "Bit 3 - Comparator 2 power mode selection bit"]
            #[inline(always)]
            pub fn comp2speed(&mut self) -> COMP2SPEED_W {
                COMP2SPEED_W { w: self }
            }
            #[doc = "Bits 4:6 - Comparator 2 Input Minus connection configuration bit"]
            #[inline(always)]
            pub fn comp2innsel(&mut self) -> COMP2INNSEL_W {
                COMP2INNSEL_W { w: self }
            }
            #[doc = "Bits 8:10 - Comparator 2 Input Plus connection configuration bit"]
            #[inline(always)]
            pub fn comp2inpsel(&mut self) -> COMP2INPSEL_W {
                COMP2INPSEL_W { w: self }
            }
            #[doc = "Bit 12 - Comparator 2 LPTIM input 2 propagation bit"]
            #[inline(always)]
            pub fn comp2lptimin2(&mut self) -> COMP2LPTIMIN2_W {
                COMP2LPTIMIN2_W { w: self }
            }
            #[doc = "Bit 13 - Comparator 2 LPTIM input 1 propagation bit"]
            #[inline(always)]
            pub fn comp2lptimin1(&mut self) -> COMP2LPTIMIN1_W {
                COMP2LPTIMIN1_W { w: self }
            }
            #[doc = "Bit 15 - Comparator 2 polarity selection bit"]
            #[inline(always)]
            pub fn comp2polarity(&mut self) -> COMP2POLARITY_W {
                COMP2POLARITY_W { w: self }
            }
            #[doc = "Bit 30 - Comparator 2 output status bit"]
            #[inline(always)]
            pub fn comp2value(&mut self) -> COMP2VALUE_W {
                COMP2VALUE_W { w: self }
            }
            #[doc = "Bit 31 - COMP2_CSR register lock bit"]
            #[inline(always)]
            pub fn comp2lock(&mut self) -> COMP2LOCK_W {
                COMP2LOCK_W { w: self }
            }
        }
    }
}
#[doc = "Serial peripheral interface"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        0x4001_3000 as *const _
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "Serial peripheral interface"]
pub mod spi1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - status register"]
        pub sr: SR,
        #[doc = "0x0c - data register"]
        pub dr: DR,
        #[doc = "0x10 - CRC polynomial register"]
        pub crcpr: CRCPR,
        #[doc = "0x14 - RX CRC register"]
        pub rxcrcr: RXCRCR,
        #[doc = "0x18 - TX CRC register"]
        pub txcrcr: TXCRCR,
        #[doc = "0x1c - I2S configuration register"]
        pub i2scfgr: I2SCFGR,
        #[doc = "0x20 - I2S prescaler register"]
        pub i2spr: I2SPR,
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Bidirectional data mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIMODE_A {
            #[doc = "0: 2-line unidirectional data mode selected"]
            UNIDIRECTIONAL = 0,
            #[doc = "1: 1-line bidirectional data mode selected"]
            BIDIRECTIONAL = 1,
        }
        impl From<BIDIMODE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BIDIMODE`"]
        pub type BIDIMODE_R = crate::R<bool, BIDIMODE_A>;
        impl BIDIMODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BIDIMODE_A {
                match self.bits {
                    false => BIDIMODE_A::UNIDIRECTIONAL,
                    true => BIDIMODE_A::BIDIRECTIONAL,
                }
            }
            #[doc = "Checks if the value of the field is `UNIDIRECTIONAL`"]
            #[inline(always)]
            pub fn is_unidirectional(&self) -> bool {
                *self == BIDIMODE_A::UNIDIRECTIONAL
            }
            #[doc = "Checks if the value of the field is `BIDIRECTIONAL`"]
            #[inline(always)]
            pub fn is_bidirectional(&self) -> bool {
                *self == BIDIMODE_A::BIDIRECTIONAL
            }
        }
        #[doc = "Write proxy for field `BIDIMODE`"]
        pub struct BIDIMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIDIMODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIDIMODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "2-line unidirectional data mode selected"]
            #[inline(always)]
            pub fn unidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::UNIDIRECTIONAL)
            }
            #[doc = "1-line bidirectional data mode selected"]
            #[inline(always)]
            pub fn bidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::BIDIRECTIONAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output enable in bidirectional mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIOE_A {
            #[doc = "0: Output disabled (receive-only mode)"]
            OUTPUTDISABLED = 0,
            #[doc = "1: Output enabled (transmit-only mode)"]
            OUTPUTENABLED = 1,
        }
        impl From<BIDIOE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIOE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BIDIOE`"]
        pub type BIDIOE_R = crate::R<bool, BIDIOE_A>;
        impl BIDIOE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BIDIOE_A {
                match self.bits {
                    false => BIDIOE_A::OUTPUTDISABLED,
                    true => BIDIOE_A::OUTPUTENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUTDISABLED`"]
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                *self == BIDIOE_A::OUTPUTDISABLED
            }
            #[doc = "Checks if the value of the field is `OUTPUTENABLED`"]
            #[inline(always)]
            pub fn is_output_enabled(&self) -> bool {
                *self == BIDIOE_A::OUTPUTENABLED
            }
        }
        #[doc = "Write proxy for field `BIDIOE`"]
        pub struct BIDIOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIDIOE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIDIOE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Output disabled (receive-only mode)"]
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OUTPUTDISABLED)
            }
            #[doc = "Output enabled (transmit-only mode)"]
            #[inline(always)]
            pub fn output_enabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OUTPUTENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Hardware CRC calculation enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCEN_A {
            #[doc = "0: CRC calculation disabled"]
            DISABLED = 0,
            #[doc = "1: CRC calculation enabled"]
            ENABLED = 1,
        }
        impl From<CRCEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCEN`"]
        pub type CRCEN_R = crate::R<bool, CRCEN_A>;
        impl CRCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCEN_A {
                match self.bits {
                    false => CRCEN_A::DISABLED,
                    true => CRCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CRCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CRCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CRCEN`"]
        pub struct CRCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CRC calculation disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRCEN_A::DISABLED)
            }
            #[doc = "CRC calculation enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "CRC transfer next\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCNEXT_A {
            #[doc = "0: Next transmit value is from Tx buffer"]
            TXBUFFER = 0,
            #[doc = "1: Next transmit value is from Tx CRC register"]
            CRC = 1,
        }
        impl From<CRCNEXT_A> for bool {
            #[inline(always)]
            fn from(variant: CRCNEXT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCNEXT`"]
        pub type CRCNEXT_R = crate::R<bool, CRCNEXT_A>;
        impl CRCNEXT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCNEXT_A {
                match self.bits {
                    false => CRCNEXT_A::TXBUFFER,
                    true => CRCNEXT_A::CRC,
                }
            }
            #[doc = "Checks if the value of the field is `TXBUFFER`"]
            #[inline(always)]
            pub fn is_tx_buffer(&self) -> bool {
                *self == CRCNEXT_A::TXBUFFER
            }
            #[doc = "Checks if the value of the field is `CRC`"]
            #[inline(always)]
            pub fn is_crc(&self) -> bool {
                *self == CRCNEXT_A::CRC
            }
        }
        #[doc = "Write proxy for field `CRCNEXT`"]
        pub struct CRCNEXT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCNEXT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCNEXT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Next transmit value is from Tx buffer"]
            #[inline(always)]
            pub fn tx_buffer(self) -> &'a mut W {
                self.variant(CRCNEXT_A::TXBUFFER)
            }
            #[doc = "Next transmit value is from Tx CRC register"]
            #[inline(always)]
            pub fn crc(self) -> &'a mut W {
                self.variant(CRCNEXT_A::CRC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Data frame format\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DFF_A {
            #[doc = "0: 8-bit data frame format is selected for transmission/reception"]
            EIGHTBIT = 0,
            #[doc = "1: 16-bit data frame format is selected for transmission/reception"]
            SIXTEENBIT = 1,
        }
        impl From<DFF_A> for bool {
            #[inline(always)]
            fn from(variant: DFF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DFF`"]
        pub type DFF_R = crate::R<bool, DFF_A>;
        impl DFF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DFF_A {
                match self.bits {
                    false => DFF_A::EIGHTBIT,
                    true => DFF_A::SIXTEENBIT,
                }
            }
            #[doc = "Checks if the value of the field is `EIGHTBIT`"]
            #[inline(always)]
            pub fn is_eight_bit(&self) -> bool {
                *self == DFF_A::EIGHTBIT
            }
            #[doc = "Checks if the value of the field is `SIXTEENBIT`"]
            #[inline(always)]
            pub fn is_sixteen_bit(&self) -> bool {
                *self == DFF_A::SIXTEENBIT
            }
        }
        #[doc = "Write proxy for field `DFF`"]
        pub struct DFF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DFF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "8-bit data frame format is selected for transmission/reception"]
            #[inline(always)]
            pub fn eight_bit(self) -> &'a mut W {
                self.variant(DFF_A::EIGHTBIT)
            }
            #[doc = "16-bit data frame format is selected for transmission/reception"]
            #[inline(always)]
            pub fn sixteen_bit(self) -> &'a mut W {
                self.variant(DFF_A::SIXTEENBIT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Receive only\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXONLY_A {
            #[doc = "0: Full duplex (Transmit and receive)"]
            FULLDUPLEX = 0,
            #[doc = "1: Output disabled (Receive-only mode)"]
            OUTPUTDISABLED = 1,
        }
        impl From<RXONLY_A> for bool {
            #[inline(always)]
            fn from(variant: RXONLY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXONLY`"]
        pub type RXONLY_R = crate::R<bool, RXONLY_A>;
        impl RXONLY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXONLY_A {
                match self.bits {
                    false => RXONLY_A::FULLDUPLEX,
                    true => RXONLY_A::OUTPUTDISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `FULLDUPLEX`"]
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                *self == RXONLY_A::FULLDUPLEX
            }
            #[doc = "Checks if the value of the field is `OUTPUTDISABLED`"]
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                *self == RXONLY_A::OUTPUTDISABLED
            }
        }
        #[doc = "Write proxy for field `RXONLY`"]
        pub struct RXONLY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXONLY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXONLY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Full duplex (Transmit and receive)"]
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(RXONLY_A::FULLDUPLEX)
            }
            #[doc = "Output disabled (Receive-only mode)"]
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(RXONLY_A::OUTPUTDISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Software slave management\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSM_A {
            #[doc = "0: Software slave management disabled"]
            DISABLED = 0,
            #[doc = "1: Software slave management enabled"]
            ENABLED = 1,
        }
        impl From<SSM_A> for bool {
            #[inline(always)]
            fn from(variant: SSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SSM`"]
        pub type SSM_R = crate::R<bool, SSM_A>;
        impl SSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SSM_A {
                match self.bits {
                    false => SSM_A::DISABLED,
                    true => SSM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SSM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SSM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SSM`"]
        pub struct SSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Software slave management disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSM_A::DISABLED)
            }
            #[doc = "Software slave management enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Internal slave select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSI_A {
            #[doc = "0: 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            SLAVESELECTED = 0,
            #[doc = "1: 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            SLAVENOTSELECTED = 1,
        }
        impl From<SSI_A> for bool {
            #[inline(always)]
            fn from(variant: SSI_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SSI`"]
        pub type SSI_R = crate::R<bool, SSI_A>;
        impl SSI_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SSI_A {
                match self.bits {
                    false => SSI_A::SLAVESELECTED,
                    true => SSI_A::SLAVENOTSELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVESELECTED`"]
            #[inline(always)]
            pub fn is_slave_selected(&self) -> bool {
                *self == SSI_A::SLAVESELECTED
            }
            #[doc = "Checks if the value of the field is `SLAVENOTSELECTED`"]
            #[inline(always)]
            pub fn is_slave_not_selected(&self) -> bool {
                *self == SSI_A::SLAVENOTSELECTED
            }
        }
        #[doc = "Write proxy for field `SSI`"]
        pub struct SSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSI_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            #[inline(always)]
            pub fn slave_selected(self) -> &'a mut W {
                self.variant(SSI_A::SLAVESELECTED)
            }
            #[doc = "1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"]
            #[inline(always)]
            pub fn slave_not_selected(self) -> &'a mut W {
                self.variant(SSI_A::SLAVENOTSELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Frame format\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSBFIRST_A {
            #[doc = "0: Data is transmitted/received with the MSB first"]
            MSBFIRST = 0,
            #[doc = "1: Data is transmitted/received with the LSB first"]
            LSBFIRST = 1,
        }
        impl From<LSBFIRST_A> for bool {
            #[inline(always)]
            fn from(variant: LSBFIRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LSBFIRST`"]
        pub type LSBFIRST_R = crate::R<bool, LSBFIRST_A>;
        impl LSBFIRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LSBFIRST_A {
                match self.bits {
                    false => LSBFIRST_A::MSBFIRST,
                    true => LSBFIRST_A::LSBFIRST,
                }
            }
            #[doc = "Checks if the value of the field is `MSBFIRST`"]
            #[inline(always)]
            pub fn is_msbfirst(&self) -> bool {
                *self == LSBFIRST_A::MSBFIRST
            }
            #[doc = "Checks if the value of the field is `LSBFIRST`"]
            #[inline(always)]
            pub fn is_lsbfirst(&self) -> bool {
                *self == LSBFIRST_A::LSBFIRST
            }
        }
        #[doc = "Write proxy for field `LSBFIRST`"]
        pub struct LSBFIRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSBFIRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSBFIRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Data is transmitted/received with the MSB first"]
            #[inline(always)]
            pub fn msbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::MSBFIRST)
            }
            #[doc = "Data is transmitted/received with the LSB first"]
            #[inline(always)]
            pub fn lsbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::LSBFIRST)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "SPI enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPE_A {
            #[doc = "0: Peripheral disabled"]
            DISABLED = 0,
            #[doc = "1: Peripheral enabled"]
            ENABLED = 1,
        }
        impl From<SPE_A> for bool {
            #[inline(always)]
            fn from(variant: SPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SPE`"]
        pub type SPE_R = crate::R<bool, SPE_A>;
        impl SPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SPE_A {
                match self.bits {
                    false => SPE_A::DISABLED,
                    true => SPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SPE`"]
        pub struct SPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Peripheral disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPE_A::DISABLED)
            }
            #[doc = "Peripheral enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Baud rate control\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum BR_A {
            #[doc = "0: f_PCLK / 2"]
            DIV2 = 0,
            #[doc = "1: f_PCLK / 4"]
            DIV4 = 1,
            #[doc = "2: f_PCLK / 8"]
            DIV8 = 2,
            #[doc = "3: f_PCLK / 16"]
            DIV16 = 3,
            #[doc = "4: f_PCLK / 32"]
            DIV32 = 4,
            #[doc = "5: f_PCLK / 64"]
            DIV64 = 5,
            #[doc = "6: f_PCLK / 128"]
            DIV128 = 6,
            #[doc = "7: f_PCLK / 256"]
            DIV256 = 7,
        }
        impl From<BR_A> for u8 {
            #[inline(always)]
            fn from(variant: BR_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `BR`"]
        pub type BR_R = crate::R<u8, BR_A>;
        impl BR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BR_A {
                match self.bits {
                    0 => BR_A::DIV2,
                    1 => BR_A::DIV4,
                    2 => BR_A::DIV8,
                    3 => BR_A::DIV16,
                    4 => BR_A::DIV32,
                    5 => BR_A::DIV64,
                    6 => BR_A::DIV128,
                    7 => BR_A::DIV256,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == BR_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == BR_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == BR_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == BR_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == BR_A::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == BR_A::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == BR_A::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == BR_A::DIV256
            }
        }
        #[doc = "Write proxy for field `BR`"]
        pub struct BR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BR_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "f_PCLK / 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(BR_A::DIV2)
            }
            #[doc = "f_PCLK / 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(BR_A::DIV4)
            }
            #[doc = "f_PCLK / 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(BR_A::DIV8)
            }
            #[doc = "f_PCLK / 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(BR_A::DIV16)
            }
            #[doc = "f_PCLK / 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(BR_A::DIV32)
            }
            #[doc = "f_PCLK / 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(BR_A::DIV64)
            }
            #[doc = "f_PCLK / 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(BR_A::DIV128)
            }
            #[doc = "f_PCLK / 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(BR_A::DIV256)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | (((value as u32) & 0x07) << 3);
                self.w
            }
        }
        #[doc = "Master selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTR_A {
            #[doc = "0: Slave configuration"]
            SLAVE = 0,
            #[doc = "1: Master configuration"]
            MASTER = 1,
        }
        impl From<MSTR_A> for bool {
            #[inline(always)]
            fn from(variant: MSTR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSTR`"]
        pub type MSTR_R = crate::R<bool, MSTR_A>;
        impl MSTR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSTR_A {
                match self.bits {
                    false => MSTR_A::SLAVE,
                    true => MSTR_A::MASTER,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE`"]
            #[inline(always)]
            pub fn is_slave(&self) -> bool {
                *self == MSTR_A::SLAVE
            }
            #[doc = "Checks if the value of the field is `MASTER`"]
            #[inline(always)]
            pub fn is_master(&self) -> bool {
                *self == MSTR_A::MASTER
            }
        }
        #[doc = "Write proxy for field `MSTR`"]
        pub struct MSTR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSTR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Slave configuration"]
            #[inline(always)]
            pub fn slave(self) -> &'a mut W {
                self.variant(MSTR_A::SLAVE)
            }
            #[doc = "Master configuration"]
            #[inline(always)]
            pub fn master(self) -> &'a mut W {
                self.variant(MSTR_A::MASTER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Clock polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOL_A {
            #[doc = "0: CK to 0 when idle"]
            IDLELOW = 0,
            #[doc = "1: CK to 1 when idle"]
            IDLEHIGH = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPOL`"]
        pub type CPOL_R = crate::R<bool, CPOL_A>;
        impl CPOL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::IDLELOW,
                    true => CPOL_A::IDLEHIGH,
                }
            }
            #[doc = "Checks if the value of the field is `IDLELOW`"]
            #[inline(always)]
            pub fn is_idle_low(&self) -> bool {
                *self == CPOL_A::IDLELOW
            }
            #[doc = "Checks if the value of the field is `IDLEHIGH`"]
            #[inline(always)]
            pub fn is_idle_high(&self) -> bool {
                *self == CPOL_A::IDLEHIGH
            }
        }
        #[doc = "Write proxy for field `CPOL`"]
        pub struct CPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPOL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPOL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CK to 0 when idle"]
            #[inline(always)]
            pub fn idle_low(self) -> &'a mut W {
                self.variant(CPOL_A::IDLELOW)
            }
            #[doc = "CK to 1 when idle"]
            #[inline(always)]
            pub fn idle_high(self) -> &'a mut W {
                self.variant(CPOL_A::IDLEHIGH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Clock phase\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHA_A {
            #[doc = "0: The first clock transition is the first data capture edge"]
            FIRSTEDGE = 0,
            #[doc = "1: The second clock transition is the first data capture edge"]
            SECONDEDGE = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CPHA`"]
        pub type CPHA_R = crate::R<bool, CPHA_A>;
        impl CPHA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FIRSTEDGE,
                    true => CPHA_A::SECONDEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `FIRSTEDGE`"]
            #[inline(always)]
            pub fn is_first_edge(&self) -> bool {
                *self == CPHA_A::FIRSTEDGE
            }
            #[doc = "Checks if the value of the field is `SECONDEDGE`"]
            #[inline(always)]
            pub fn is_second_edge(&self) -> bool {
                *self == CPHA_A::SECONDEDGE
            }
        }
        #[doc = "Write proxy for field `CPHA`"]
        pub struct CPHA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPHA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPHA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The first clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn first_edge(self) -> &'a mut W {
                self.variant(CPHA_A::FIRSTEDGE)
            }
            #[doc = "The second clock transition is the first data capture edge"]
            #[inline(always)]
            pub fn second_edge(self) -> &'a mut W {
                self.variant(CPHA_A::SECONDEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline(always)]
            pub fn bidimode(&self) -> BIDIMODE_R {
                BIDIMODE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline(always)]
            pub fn bidioe(&self) -> BIDIOE_R {
                BIDIOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline(always)]
            pub fn crcnext(&self) -> CRCNEXT_R {
                CRCNEXT_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline(always)]
            pub fn dff(&self) -> DFF_R {
                DFF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline(always)]
            pub fn rxonly(&self) -> RXONLY_R {
                RXONLY_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline(always)]
            pub fn ssm(&self) -> SSM_R {
                SSM_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline(always)]
            pub fn ssi(&self) -> SSI_R {
                SSI_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline(always)]
            pub fn spe(&self) -> SPE_R {
                SPE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline(always)]
            pub fn br(&self) -> BR_R {
                BR_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline(always)]
            pub fn mstr(&self) -> MSTR_R {
                MSTR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline(always)]
            pub fn bidimode(&mut self) -> BIDIMODE_W {
                BIDIMODE_W { w: self }
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline(always)]
            pub fn bidioe(&mut self) -> BIDIOE_W {
                BIDIOE_W { w: self }
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline(always)]
            pub fn crcen(&mut self) -> CRCEN_W {
                CRCEN_W { w: self }
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline(always)]
            pub fn crcnext(&mut self) -> CRCNEXT_W {
                CRCNEXT_W { w: self }
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline(always)]
            pub fn dff(&mut self) -> DFF_W {
                DFF_W { w: self }
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline(always)]
            pub fn rxonly(&mut self) -> RXONLY_W {
                RXONLY_W { w: self }
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline(always)]
            pub fn ssm(&mut self) -> SSM_W {
                SSM_W { w: self }
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline(always)]
            pub fn ssi(&mut self) -> SSI_W {
                SSI_W { w: self }
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline(always)]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W {
                LSBFIRST_W { w: self }
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline(always)]
            pub fn spe(&mut self) -> SPE_W {
                SPE_W { w: self }
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline(always)]
            pub fn br(&mut self) -> BR_W {
                BR_W { w: self }
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline(always)]
            pub fn mstr(&mut self) -> MSTR_W {
                MSTR_W { w: self }
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W {
                CPOL_W { w: self }
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W {
                CPHA_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Rx buffer DMA enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDMAEN_A {
            #[doc = "0: Rx buffer DMA disabled"]
            DISABLED = 0,
            #[doc = "1: Rx buffer DMA enabled"]
            ENABLED = 1,
        }
        impl From<RXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: RXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXDMAEN`"]
        pub type RXDMAEN_R = crate::R<bool, RXDMAEN_A>;
        impl RXDMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXDMAEN_A {
                match self.bits {
                    false => RXDMAEN_A::DISABLED,
                    true => RXDMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXDMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXDMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXDMAEN`"]
        pub struct RXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXDMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXDMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rx buffer DMA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::DISABLED)
            }
            #[doc = "Rx buffer DMA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Tx buffer DMA enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDMAEN_A {
            #[doc = "0: Tx buffer DMA disabled"]
            DISABLED = 0,
            #[doc = "1: Tx buffer DMA enabled"]
            ENABLED = 1,
        }
        impl From<TXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: TXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXDMAEN`"]
        pub type TXDMAEN_R = crate::R<bool, TXDMAEN_A>;
        impl TXDMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXDMAEN_A {
                match self.bits {
                    false => TXDMAEN_A::DISABLED,
                    true => TXDMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXDMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXDMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXDMAEN`"]
        pub struct TXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXDMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXDMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Tx buffer DMA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::DISABLED)
            }
            #[doc = "Tx buffer DMA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "SS output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSOE_A {
            #[doc = "0: SS output is disabled in master mode"]
            DISABLED = 0,
            #[doc = "1: SS output is enabled in master mode"]
            ENABLED = 1,
        }
        impl From<SSOE_A> for bool {
            #[inline(always)]
            fn from(variant: SSOE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SSOE`"]
        pub type SSOE_R = crate::R<bool, SSOE_A>;
        impl SSOE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SSOE_A {
                match self.bits {
                    false => SSOE_A::DISABLED,
                    true => SSOE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SSOE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SSOE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SSOE`"]
        pub struct SSOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSOE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSOE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "SS output is disabled in master mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSOE_A::DISABLED)
            }
            #[doc = "SS output is enabled in master mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSOE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `FRF`"]
        pub type FRF_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `FRF`"]
        pub struct FRF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRF_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRIE_A {
            #[doc = "0: Error interrupt masked"]
            MASKED = 0,
            #[doc = "1: Error interrupt not masked"]
            NOTMASKED = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERRIE`"]
        pub type ERRIE_R = crate::R<bool, ERRIE_A>;
        impl ERRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::MASKED,
                    true => ERRIE_A::NOTMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == ERRIE_A::MASKED
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == ERRIE_A::NOTMASKED
            }
        }
        #[doc = "Write proxy for field `ERRIE`"]
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error interrupt masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(ERRIE_A::MASKED)
            }
            #[doc = "Error interrupt not masked"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(ERRIE_A::NOTMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "RX buffer not empty interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            #[doc = "0: RXE interrupt masked"]
            MASKED = 0,
            #[doc = "1: RXE interrupt not masked"]
            NOTMASKED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNEIE`"]
        pub type RXNEIE_R = crate::R<bool, RXNEIE_A>;
        impl RXNEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::MASKED,
                    true => RXNEIE_A::NOTMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == RXNEIE_A::MASKED
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == RXNEIE_A::NOTMASKED
            }
        }
        #[doc = "Write proxy for field `RXNEIE`"]
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RXE interrupt masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(RXNEIE_A::MASKED)
            }
            #[doc = "RXE interrupt not masked"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(RXNEIE_A::NOTMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Tx buffer empty interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            #[doc = "0: TXE interrupt masked"]
            MASKED = 0,
            #[doc = "1: TXE interrupt not masked"]
            NOTMASKED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXEIE`"]
        pub type TXEIE_R = crate::R<bool, TXEIE_A>;
        impl TXEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::MASKED,
                    true => TXEIE_A::NOTMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == TXEIE_A::MASKED
            }
            #[doc = "Checks if the value of the field is `NOTMASKED`"]
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                *self == TXEIE_A::NOTMASKED
            }
        }
        #[doc = "Write proxy for field `TXEIE`"]
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TXE interrupt masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(TXEIE_A::MASKED)
            }
            #[doc = "TXE interrupt not masked"]
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(TXEIE_A::NOTMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline(always)]
            pub fn ssoe(&self) -> SSOE_R {
                SSOE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Frame format"]
            #[inline(always)]
            pub fn frf(&self) -> FRF_R {
                FRF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline(always)]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W {
                RXDMAEN_W { w: self }
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline(always)]
            pub fn txdmaen(&mut self) -> TXDMAEN_W {
                TXDMAEN_W { w: self }
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline(always)]
            pub fn ssoe(&mut self) -> SSOE_W {
                SSOE_W { w: self }
            }
            #[doc = "Bit 4 - Frame format"]
            #[inline(always)]
            pub fn frf(&mut self) -> FRF_W {
                FRF_W { w: self }
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0x02"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x02
            }
        }
        #[doc = "Receive buffer not empty\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNE_A {
            #[doc = "0: Rx buffer empty"]
            EMPTY = 0,
            #[doc = "1: Rx buffer not empty"]
            NOTEMPTY = 1,
        }
        impl From<RXNE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, RXNE_A>;
        impl RXNE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNE_A {
                match self.bits {
                    false => RXNE_A::EMPTY,
                    true => RXNE_A::NOTEMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RXNE_A::EMPTY
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == RXNE_A::NOTEMPTY
            }
        }
        #[doc = "Transmit buffer empty\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXE_A {
            #[doc = "0: Tx buffer not empty"]
            NOTEMPTY = 0,
            #[doc = "1: Tx buffer empty"]
            EMPTY = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, TXE_A>;
        impl TXE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NOTEMPTY,
                    true => TXE_A::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TXE_A::NOTEMPTY
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TXE_A::EMPTY
            }
        }
        #[doc = "Reader of field `CHSIDE`"]
        pub type CHSIDE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `UDR`"]
        pub type UDR_R = crate::R<bool, bool>;
        #[doc = "CRC error flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCERR_A {
            #[doc = "0: CRC value received matches the SPIx_RXCRCR value"]
            MATCH = 0,
            #[doc = "1: CRC value received does not match the SPIx_RXCRCR value"]
            NOMATCH = 1,
        }
        impl From<CRCERR_A> for bool {
            #[inline(always)]
            fn from(variant: CRCERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CRCERR`"]
        pub type CRCERR_R = crate::R<bool, CRCERR_A>;
        impl CRCERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CRCERR_A {
                match self.bits {
                    false => CRCERR_A::MATCH,
                    true => CRCERR_A::NOMATCH,
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CRCERR_A::MATCH
            }
            #[doc = "Checks if the value of the field is `NOMATCH`"]
            #[inline(always)]
            pub fn is_no_match(&self) -> bool {
                *self == CRCERR_A::NOMATCH
            }
        }
        #[doc = "Write proxy for field `CRCERR`"]
        pub struct CRCERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCERR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CRC value received matches the SPIx_RXCRCR value"]
            #[inline(always)]
            pub fn match_(self) -> &'a mut W {
                self.variant(CRCERR_A::MATCH)
            }
            #[doc = "CRC value received does not match the SPIx_RXCRCR value"]
            #[inline(always)]
            pub fn no_match(self) -> &'a mut W {
                self.variant(CRCERR_A::NOMATCH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Mode fault\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODF_A {
            #[doc = "0: No mode fault occurred"]
            NOFAULT = 0,
            #[doc = "1: Mode fault occurred"]
            FAULT = 1,
        }
        impl From<MODF_A> for bool {
            #[inline(always)]
            fn from(variant: MODF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MODF`"]
        pub type MODF_R = crate::R<bool, MODF_A>;
        impl MODF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODF_A {
                match self.bits {
                    false => MODF_A::NOFAULT,
                    true => MODF_A::FAULT,
                }
            }
            #[doc = "Checks if the value of the field is `NOFAULT`"]
            #[inline(always)]
            pub fn is_no_fault(&self) -> bool {
                *self == MODF_A::NOFAULT
            }
            #[doc = "Checks if the value of the field is `FAULT`"]
            #[inline(always)]
            pub fn is_fault(&self) -> bool {
                *self == MODF_A::FAULT
            }
        }
        #[doc = "Overrun flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            #[doc = "0: No overrun occurred"]
            NOOVERRUN = 0,
            #[doc = "1: Overrun occurred"]
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVR`"]
        pub type OVR_R = crate::R<bool, OVR_A>;
        impl OVR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOOVERRUN`"]
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVR_A::NOOVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVR_A::OVERRUN
            }
        }
        #[doc = "Busy flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BSY_A {
            #[doc = "0: SPI not busy"]
            NOTBUSY = 0,
            #[doc = "1: SPI busy"]
            BUSY = 1,
        }
        impl From<BSY_A> for bool {
            #[inline(always)]
            fn from(variant: BSY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BSY`"]
        pub type BSY_R = crate::R<bool, BSY_A>;
        impl BSY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BSY_A {
                match self.bits {
                    false => BSY_A::NOTBUSY,
                    true => BSY_A::BUSY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBUSY`"]
            #[inline(always)]
            pub fn is_not_busy(&self) -> bool {
                *self == BSY_A::NOTBUSY
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == BSY_A::BUSY
            }
        }
        #[doc = "Reader of field `FRE`"]
        pub type FRE_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - Receive buffer not empty"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Transmit buffer empty"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Channel side"]
            #[inline(always)]
            pub fn chside(&self) -> CHSIDE_R {
                CHSIDE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Underrun flag"]
            #[inline(always)]
            pub fn udr(&self) -> UDR_R {
                UDR_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - CRC error flag"]
            #[inline(always)]
            pub fn crcerr(&self) -> CRCERR_R {
                CRCERR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Mode fault"]
            #[inline(always)]
            pub fn modf(&self) -> MODF_R {
                MODF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Overrun flag"]
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Busy flag"]
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - TI frame format error"]
            #[inline(always)]
            pub fn fre(&self) -> FRE_R {
                FRE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - CRC error flag"]
            #[inline(always)]
            pub fn crcerr(&mut self) -> CRCERR_W {
                CRCERR_W { w: self }
            }
        }
    }
    #[doc = "data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register DR"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register DR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DR`"]
        pub type DR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DR`"]
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Data register"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Data register"]
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
        }
    }
    #[doc = "CRC polynomial register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcpr](crcpr) module"]
    pub type CRCPR = crate::Reg<u32, _CRCPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRCPR;
    #[doc = "`read()` method returns [crcpr::R](crcpr::R) reader structure"]
    impl crate::Readable for CRCPR {}
    #[doc = "`write(|w| ..)` method takes [crcpr::W](crcpr::W) writer structure"]
    impl crate::Writable for CRCPR {}
    #[doc = "CRC polynomial register"]
    pub mod crcpr {
        #[doc = "Reader of register CRCPR"]
        pub type R = crate::R<u32, super::CRCPR>;
        #[doc = "Writer for register CRCPR"]
        pub type W = crate::W<u32, super::CRCPR>;
        #[doc = "Register CRCPR `reset()`'s with value 0x07"]
        impl crate::ResetValue for super::CRCPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x07
            }
        }
        #[doc = "Reader of field `CRCPOLY`"]
        pub type CRCPOLY_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CRCPOLY`"]
        pub struct CRCPOLY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCPOLY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLY_R {
                CRCPOLY_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline(always)]
            pub fn crcpoly(&mut self) -> CRCPOLY_W {
                CRCPOLY_W { w: self }
            }
        }
    }
    #[doc = "RX CRC register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxcrcr](rxcrcr) module"]
    pub type RXCRCR = crate::Reg<u32, _RXCRCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXCRCR;
    #[doc = "`read()` method returns [rxcrcr::R](rxcrcr::R) reader structure"]
    impl crate::Readable for RXCRCR {}
    #[doc = "RX CRC register"]
    pub mod rxcrcr {
        #[doc = "Reader of register RXCRCR"]
        pub type R = crate::R<u32, super::RXCRCR>;
        #[doc = "Reader of field `RxCRC`"]
        pub type RXCRC_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Rx CRC register"]
            #[inline(always)]
            pub fn rx_crc(&self) -> RXCRC_R {
                RXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "TX CRC register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txcrcr](txcrcr) module"]
    pub type TXCRCR = crate::Reg<u32, _TXCRCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXCRCR;
    #[doc = "`read()` method returns [txcrcr::R](txcrcr::R) reader structure"]
    impl crate::Readable for TXCRCR {}
    #[doc = "TX CRC register"]
    pub mod txcrcr {
        #[doc = "Reader of register TXCRCR"]
        pub type R = crate::R<u32, super::TXCRCR>;
        #[doc = "Reader of field `TxCRC`"]
        pub type TXCRC_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Tx CRC register"]
            #[inline(always)]
            pub fn tx_crc(&self) -> TXCRC_R {
                TXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "I2S configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [i2scfgr](i2scfgr) module"]
    pub type I2SCFGR = crate::Reg<u32, _I2SCFGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _I2SCFGR;
    #[doc = "`read()` method returns [i2scfgr::R](i2scfgr::R) reader structure"]
    impl crate::Readable for I2SCFGR {}
    #[doc = "`write(|w| ..)` method takes [i2scfgr::W](i2scfgr::W) writer structure"]
    impl crate::Writable for I2SCFGR {}
    #[doc = "I2S configuration register"]
    pub mod i2scfgr {
        #[doc = "Reader of register I2SCFGR"]
        pub type R = crate::R<u32, super::I2SCFGR>;
        #[doc = "Writer for register I2SCFGR"]
        pub type W = crate::W<u32, super::I2SCFGR>;
        #[doc = "Register I2SCFGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::I2SCFGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `I2SMOD`"]
        pub type I2SMOD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `I2SMOD`"]
        pub struct I2SMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2SMOD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `I2SE`"]
        pub type I2SE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `I2SE`"]
        pub struct I2SE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2SE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `I2SCFG`"]
        pub type I2SCFG_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `I2SCFG`"]
        pub struct I2SCFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2SCFG_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `PCMSYNC`"]
        pub type PCMSYNC_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `PCMSYNC`"]
        pub struct PCMSYNC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCMSYNC_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `I2SSTD`"]
        pub type I2SSTD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `I2SSTD`"]
        pub struct I2SSTD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2SSTD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | (((value as u32) & 0x03) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `CKPOL`"]
        pub type CKPOL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CKPOL`"]
        pub struct CKPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKPOL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `DATLEN`"]
        pub type DATLEN_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DATLEN`"]
        pub struct DATLEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATLEN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 1)) | (((value as u32) & 0x03) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `CHLEN`"]
        pub type CHLEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `CHLEN`"]
        pub struct CHLEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHLEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 11 - I2S mode selection"]
            #[inline(always)]
            pub fn i2smod(&self) -> I2SMOD_R {
                I2SMOD_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - I2S Enable"]
            #[inline(always)]
            pub fn i2se(&self) -> I2SE_R {
                I2SE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - I2S configuration mode"]
            #[inline(always)]
            pub fn i2scfg(&self) -> I2SCFG_R {
                I2SCFG_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - PCM frame synchronization"]
            #[inline(always)]
            pub fn pcmsync(&self) -> PCMSYNC_R {
                PCMSYNC_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:5 - I2S standard selection"]
            #[inline(always)]
            pub fn i2sstd(&self) -> I2SSTD_R {
                I2SSTD_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            #[doc = "Bit 3 - Steady state clock polarity"]
            #[inline(always)]
            pub fn ckpol(&self) -> CKPOL_R {
                CKPOL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 1:2 - Data length to be transferred"]
            #[inline(always)]
            pub fn datlen(&self) -> DATLEN_R {
                DATLEN_R::new(((self.bits >> 1) & 0x03) as u8)
            }
            #[doc = "Bit 0 - Channel length (number of bits per audio channel)"]
            #[inline(always)]
            pub fn chlen(&self) -> CHLEN_R {
                CHLEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 11 - I2S mode selection"]
            #[inline(always)]
            pub fn i2smod(&mut self) -> I2SMOD_W {
                I2SMOD_W { w: self }
            }
            #[doc = "Bit 10 - I2S Enable"]
            #[inline(always)]
            pub fn i2se(&mut self) -> I2SE_W {
                I2SE_W { w: self }
            }
            #[doc = "Bits 8:9 - I2S configuration mode"]
            #[inline(always)]
            pub fn i2scfg(&mut self) -> I2SCFG_W {
                I2SCFG_W { w: self }
            }
            #[doc = "Bit 7 - PCM frame synchronization"]
            #[inline(always)]
            pub fn pcmsync(&mut self) -> PCMSYNC_W {
                PCMSYNC_W { w: self }
            }
            #[doc = "Bits 4:5 - I2S standard selection"]
            #[inline(always)]
            pub fn i2sstd(&mut self) -> I2SSTD_W {
                I2SSTD_W { w: self }
            }
            #[doc = "Bit 3 - Steady state clock polarity"]
            #[inline(always)]
            pub fn ckpol(&mut self) -> CKPOL_W {
                CKPOL_W { w: self }
            }
            #[doc = "Bits 1:2 - Data length to be transferred"]
            #[inline(always)]
            pub fn datlen(&mut self) -> DATLEN_W {
                DATLEN_W { w: self }
            }
            #[doc = "Bit 0 - Channel length (number of bits per audio channel)"]
            #[inline(always)]
            pub fn chlen(&mut self) -> CHLEN_W {
                CHLEN_W { w: self }
            }
        }
    }
    #[doc = "I2S prescaler register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [i2spr](i2spr) module"]
    pub type I2SPR = crate::Reg<u32, _I2SPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _I2SPR;
    #[doc = "`read()` method returns [i2spr::R](i2spr::R) reader structure"]
    impl crate::Readable for I2SPR {}
    #[doc = "`write(|w| ..)` method takes [i2spr::W](i2spr::W) writer structure"]
    impl crate::Writable for I2SPR {}
    #[doc = "I2S prescaler register"]
    pub mod i2spr {
        #[doc = "Reader of register I2SPR"]
        pub type R = crate::R<u32, super::I2SPR>;
        #[doc = "Writer for register I2SPR"]
        pub type W = crate::W<u32, super::I2SPR>;
        #[doc = "Register I2SPR `reset()`'s with value 0x10"]
        impl crate::ResetValue for super::I2SPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x10
            }
        }
        #[doc = "Reader of field `MCKOE`"]
        pub type MCKOE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `MCKOE`"]
        pub struct MCKOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MCKOE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `ODD`"]
        pub type ODD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ODD`"]
        pub struct ODD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `I2SDIV`"]
        pub type I2SDIV_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `I2SDIV`"]
        pub struct I2SDIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2SDIV_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 9 - Master clock output enable"]
            #[inline(always)]
            pub fn mckoe(&self) -> MCKOE_R {
                MCKOE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Odd factor for the prescaler"]
            #[inline(always)]
            pub fn odd(&self) -> ODD_R {
                ODD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bits 0:7 - I2S Linear prescaler"]
            #[inline(always)]
            pub fn i2sdiv(&self) -> I2SDIV_R {
                I2SDIV_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 9 - Master clock output enable"]
            #[inline(always)]
            pub fn mckoe(&mut self) -> MCKOE_W {
                MCKOE_W { w: self }
            }
            #[doc = "Bit 8 - Odd factor for the prescaler"]
            #[inline(always)]
            pub fn odd(&mut self) -> ODD_W {
                ODD_W { w: self }
            }
            #[doc = "Bits 0:7 - I2S Linear prescaler"]
            #[inline(always)]
            pub fn i2sdiv(&mut self) -> I2SDIV_W {
                I2SDIV_W { w: self }
            }
        }
    }
}
#[doc = "Serial peripheral interface"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        0x4000_3800 as *const _
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI2::ptr() }
    }
}
#[doc = "Inter-integrated circuit"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_5400 as *const _
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C1::ptr() }
    }
}
#[doc = "Inter-integrated circuit"]
pub mod i2c1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - Own address register 1"]
        pub oar1: OAR1,
        #[doc = "0x0c - Own address register 2"]
        pub oar2: OAR2,
        #[doc = "0x10 - Timing register"]
        pub timingr: TIMINGR,
        #[doc = "0x14 - Status register 1"]
        pub timeoutr: TIMEOUTR,
        #[doc = "0x18 - Interrupt and Status register"]
        pub isr: ISR,
        #[doc = "0x1c - Interrupt clear register"]
        pub icr: ICR,
        #[doc = "0x20 - PEC register"]
        pub pecr: PECR,
        #[doc = "0x24 - Receive data register"]
        pub rxdr: RXDR,
        #[doc = "0x28 - Transmit data register"]
        pub txdr: TXDR,
    }
    #[doc = "Control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Peripheral enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PE_A {
            #[doc = "0: Peripheral disabled"]
            DISABLED = 0,
            #[doc = "1: Peripheral enabled"]
            ENABLED = 1,
        }
        impl From<PE_A> for bool {
            #[inline(always)]
            fn from(variant: PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, PE_A>;
        impl PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PE_A {
                match self.bits {
                    false => PE_A::DISABLED,
                    true => PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PE`"]
        pub struct PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Peripheral disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PE_A::DISABLED)
            }
            #[doc = "Peripheral enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "TX Interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXIE_A {
            #[doc = "0: Transmit (TXIS) interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Transmit (TXIS) interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TXIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXIE`"]
        pub type TXIE_R = crate::R<bool, TXIE_A>;
        impl TXIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXIE_A {
                match self.bits {
                    false => TXIE_A::DISABLED,
                    true => TXIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXIE`"]
        pub struct TXIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Transmit (TXIS) interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXIE_A::DISABLED)
            }
            #[doc = "Transmit (TXIS) interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "RX Interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXIE_A {
            #[doc = "0: Receive (RXNE) interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Receive (RXNE) interrupt enabled"]
            ENABLED = 1,
        }
        impl From<RXIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXIE`"]
        pub type RXIE_R = crate::R<bool, RXIE_A>;
        impl RXIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXIE_A {
                match self.bits {
                    false => RXIE_A::DISABLED,
                    true => RXIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXIE`"]
        pub struct RXIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receive (RXNE) interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXIE_A::DISABLED)
            }
            #[doc = "Receive (RXNE) interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Address match interrupt enable (slave only)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRIE_A {
            #[doc = "0: Address match (ADDR) interrupts disabled"]
            DISABLED = 0,
            #[doc = "1: Address match (ADDR) interrupts enabled"]
            ENABLED = 1,
        }
        impl From<ADDRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ADDRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDRIE`"]
        pub type ADDRIE_R = crate::R<bool, ADDRIE_A>;
        impl ADDRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDRIE_A {
                match self.bits {
                    false => ADDRIE_A::DISABLED,
                    true => ADDRIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ADDRIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ADDRIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ADDRIE`"]
        pub struct ADDRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Address match (ADDR) interrupts disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDRIE_A::DISABLED)
            }
            #[doc = "Address match (ADDR) interrupts enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDRIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Not acknowledge received interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACKIE_A {
            #[doc = "0: Not acknowledge (NACKF) received interrupts disabled"]
            DISABLED = 0,
            #[doc = "1: Not acknowledge (NACKF) received interrupts enabled"]
            ENABLED = 1,
        }
        impl From<NACKIE_A> for bool {
            #[inline(always)]
            fn from(variant: NACKIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NACKIE`"]
        pub type NACKIE_R = crate::R<bool, NACKIE_A>;
        impl NACKIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NACKIE_A {
                match self.bits {
                    false => NACKIE_A::DISABLED,
                    true => NACKIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NACKIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NACKIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `NACKIE`"]
        pub struct NACKIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NACKIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NACKIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Not acknowledge (NACKF) received interrupts disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NACKIE_A::DISABLED)
            }
            #[doc = "Not acknowledge (NACKF) received interrupts enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NACKIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "STOP detection Interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPIE_A {
            #[doc = "0: Stop detection (STOPF) interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Stop detection (STOPF) interrupt enabled"]
            ENABLED = 1,
        }
        impl From<STOPIE_A> for bool {
            #[inline(always)]
            fn from(variant: STOPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STOPIE`"]
        pub type STOPIE_R = crate::R<bool, STOPIE_A>;
        impl STOPIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOPIE_A {
                match self.bits {
                    false => STOPIE_A::DISABLED,
                    true => STOPIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STOPIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == STOPIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `STOPIE`"]
        pub struct STOPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOPIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOPIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Stop detection (STOPF) interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STOPIE_A::DISABLED)
            }
            #[doc = "Stop detection (STOPF) interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(STOPIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Transfer Complete interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            #[doc = "0: Transfer Complete interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Transfer Complete interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIE`"]
        pub type TCIE_R = crate::R<bool, TCIE_A>;
        impl TCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TCIE`"]
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Transfer Complete interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            #[doc = "Transfer Complete interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Error interrupts enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRIE_A {
            #[doc = "0: Error detection interrupts disabled"]
            DISABLED = 0,
            #[doc = "1: Error detection interrupts enabled"]
            ENABLED = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERRIE`"]
        pub type ERRIE_R = crate::R<bool, ERRIE_A>;
        impl ERRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::DISABLED,
                    true => ERRIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ERRIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ERRIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ERRIE`"]
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error detection interrupts disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ERRIE_A::DISABLED)
            }
            #[doc = "Error detection interrupts enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ERRIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Digital noise filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum DNF_A {
            #[doc = "0: Digital filter disabled"]
            NOFILTER = 0,
            #[doc = "1: Digital filter enabled and filtering capability up to 1 tI2CCLK"]
            FILTER1 = 1,
            #[doc = "2: Digital filter enabled and filtering capability up to 2 tI2CCLK"]
            FILTER2 = 2,
            #[doc = "3: Digital filter enabled and filtering capability up to 3 tI2CCLK"]
            FILTER3 = 3,
            #[doc = "4: Digital filter enabled and filtering capability up to 4 tI2CCLK"]
            FILTER4 = 4,
            #[doc = "5: Digital filter enabled and filtering capability up to 5 tI2CCLK"]
            FILTER5 = 5,
            #[doc = "6: Digital filter enabled and filtering capability up to 6 tI2CCLK"]
            FILTER6 = 6,
            #[doc = "7: Digital filter enabled and filtering capability up to 7 tI2CCLK"]
            FILTER7 = 7,
            #[doc = "8: Digital filter enabled and filtering capability up to 8 tI2CCLK"]
            FILTER8 = 8,
            #[doc = "9: Digital filter enabled and filtering capability up to 9 tI2CCLK"]
            FILTER9 = 9,
            #[doc = "10: Digital filter enabled and filtering capability up to 10 tI2CCLK"]
            FILTER10 = 10,
            #[doc = "11: Digital filter enabled and filtering capability up to 11 tI2CCLK"]
            FILTER11 = 11,
            #[doc = "12: Digital filter enabled and filtering capability up to 12 tI2CCLK"]
            FILTER12 = 12,
            #[doc = "13: Digital filter enabled and filtering capability up to 13 tI2CCLK"]
            FILTER13 = 13,
            #[doc = "14: Digital filter enabled and filtering capability up to 14 tI2CCLK"]
            FILTER14 = 14,
            #[doc = "15: Digital filter enabled and filtering capability up to 15 tI2CCLK"]
            FILTER15 = 15,
        }
        impl From<DNF_A> for u8 {
            #[inline(always)]
            fn from(variant: DNF_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `DNF`"]
        pub type DNF_R = crate::R<u8, DNF_A>;
        impl DNF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DNF_A {
                match self.bits {
                    0 => DNF_A::NOFILTER,
                    1 => DNF_A::FILTER1,
                    2 => DNF_A::FILTER2,
                    3 => DNF_A::FILTER3,
                    4 => DNF_A::FILTER4,
                    5 => DNF_A::FILTER5,
                    6 => DNF_A::FILTER6,
                    7 => DNF_A::FILTER7,
                    8 => DNF_A::FILTER8,
                    9 => DNF_A::FILTER9,
                    10 => DNF_A::FILTER10,
                    11 => DNF_A::FILTER11,
                    12 => DNF_A::FILTER12,
                    13 => DNF_A::FILTER13,
                    14 => DNF_A::FILTER14,
                    15 => DNF_A::FILTER15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == DNF_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FILTER1`"]
            #[inline(always)]
            pub fn is_filter1(&self) -> bool {
                *self == DNF_A::FILTER1
            }
            #[doc = "Checks if the value of the field is `FILTER2`"]
            #[inline(always)]
            pub fn is_filter2(&self) -> bool {
                *self == DNF_A::FILTER2
            }
            #[doc = "Checks if the value of the field is `FILTER3`"]
            #[inline(always)]
            pub fn is_filter3(&self) -> bool {
                *self == DNF_A::FILTER3
            }
            #[doc = "Checks if the value of the field is `FILTER4`"]
            #[inline(always)]
            pub fn is_filter4(&self) -> bool {
                *self == DNF_A::FILTER4
            }
            #[doc = "Checks if the value of the field is `FILTER5`"]
            #[inline(always)]
            pub fn is_filter5(&self) -> bool {
                *self == DNF_A::FILTER5
            }
            #[doc = "Checks if the value of the field is `FILTER6`"]
            #[inline(always)]
            pub fn is_filter6(&self) -> bool {
                *self == DNF_A::FILTER6
            }
            #[doc = "Checks if the value of the field is `FILTER7`"]
            #[inline(always)]
            pub fn is_filter7(&self) -> bool {
                *self == DNF_A::FILTER7
            }
            #[doc = "Checks if the value of the field is `FILTER8`"]
            #[inline(always)]
            pub fn is_filter8(&self) -> bool {
                *self == DNF_A::FILTER8
            }
            #[doc = "Checks if the value of the field is `FILTER9`"]
            #[inline(always)]
            pub fn is_filter9(&self) -> bool {
                *self == DNF_A::FILTER9
            }
            #[doc = "Checks if the value of the field is `FILTER10`"]
            #[inline(always)]
            pub fn is_filter10(&self) -> bool {
                *self == DNF_A::FILTER10
            }
            #[doc = "Checks if the value of the field is `FILTER11`"]
            #[inline(always)]
            pub fn is_filter11(&self) -> bool {
                *self == DNF_A::FILTER11
            }
            #[doc = "Checks if the value of the field is `FILTER12`"]
            #[inline(always)]
            pub fn is_filter12(&self) -> bool {
                *self == DNF_A::FILTER12
            }
            #[doc = "Checks if the value of the field is `FILTER13`"]
            #[inline(always)]
            pub fn is_filter13(&self) -> bool {
                *self == DNF_A::FILTER13
            }
            #[doc = "Checks if the value of the field is `FILTER14`"]
            #[inline(always)]
            pub fn is_filter14(&self) -> bool {
                *self == DNF_A::FILTER14
            }
            #[doc = "Checks if the value of the field is `FILTER15`"]
            #[inline(always)]
            pub fn is_filter15(&self) -> bool {
                *self == DNF_A::FILTER15
            }
        }
        #[doc = "Write proxy for field `DNF`"]
        pub struct DNF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DNF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DNF_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Digital filter disabled"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(DNF_A::NOFILTER)
            }
            #[doc = "Digital filter enabled and filtering capability up to 1 tI2CCLK"]
            #[inline(always)]
            pub fn filter1(self) -> &'a mut W {
                self.variant(DNF_A::FILTER1)
            }
            #[doc = "Digital filter enabled and filtering capability up to 2 tI2CCLK"]
            #[inline(always)]
            pub fn filter2(self) -> &'a mut W {
                self.variant(DNF_A::FILTER2)
            }
            #[doc = "Digital filter enabled and filtering capability up to 3 tI2CCLK"]
            #[inline(always)]
            pub fn filter3(self) -> &'a mut W {
                self.variant(DNF_A::FILTER3)
            }
            #[doc = "Digital filter enabled and filtering capability up to 4 tI2CCLK"]
            #[inline(always)]
            pub fn filter4(self) -> &'a mut W {
                self.variant(DNF_A::FILTER4)
            }
            #[doc = "Digital filter enabled and filtering capability up to 5 tI2CCLK"]
            #[inline(always)]
            pub fn filter5(self) -> &'a mut W {
                self.variant(DNF_A::FILTER5)
            }
            #[doc = "Digital filter enabled and filtering capability up to 6 tI2CCLK"]
            #[inline(always)]
            pub fn filter6(self) -> &'a mut W {
                self.variant(DNF_A::FILTER6)
            }
            #[doc = "Digital filter enabled and filtering capability up to 7 tI2CCLK"]
            #[inline(always)]
            pub fn filter7(self) -> &'a mut W {
                self.variant(DNF_A::FILTER7)
            }
            #[doc = "Digital filter enabled and filtering capability up to 8 tI2CCLK"]
            #[inline(always)]
            pub fn filter8(self) -> &'a mut W {
                self.variant(DNF_A::FILTER8)
            }
            #[doc = "Digital filter enabled and filtering capability up to 9 tI2CCLK"]
            #[inline(always)]
            pub fn filter9(self) -> &'a mut W {
                self.variant(DNF_A::FILTER9)
            }
            #[doc = "Digital filter enabled and filtering capability up to 10 tI2CCLK"]
            #[inline(always)]
            pub fn filter10(self) -> &'a mut W {
                self.variant(DNF_A::FILTER10)
            }
            #[doc = "Digital filter enabled and filtering capability up to 11 tI2CCLK"]
            #[inline(always)]
            pub fn filter11(self) -> &'a mut W {
                self.variant(DNF_A::FILTER11)
            }
            #[doc = "Digital filter enabled and filtering capability up to 12 tI2CCLK"]
            #[inline(always)]
            pub fn filter12(self) -> &'a mut W {
                self.variant(DNF_A::FILTER12)
            }
            #[doc = "Digital filter enabled and filtering capability up to 13 tI2CCLK"]
            #[inline(always)]
            pub fn filter13(self) -> &'a mut W {
                self.variant(DNF_A::FILTER13)
            }
            #[doc = "Digital filter enabled and filtering capability up to 14 tI2CCLK"]
            #[inline(always)]
            pub fn filter14(self) -> &'a mut W {
                self.variant(DNF_A::FILTER14)
            }
            #[doc = "Digital filter enabled and filtering capability up to 15 tI2CCLK"]
            #[inline(always)]
            pub fn filter15(self) -> &'a mut W {
                self.variant(DNF_A::FILTER15)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Analog noise filter OFF\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ANFOFF_A {
            #[doc = "0: Analog noise filter enabled"]
            ENABLED = 0,
            #[doc = "1: Analog noise filter disabled"]
            DISABLED = 1,
        }
        impl From<ANFOFF_A> for bool {
            #[inline(always)]
            fn from(variant: ANFOFF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ANFOFF`"]
        pub type ANFOFF_R = crate::R<bool, ANFOFF_A>;
        impl ANFOFF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ANFOFF_A {
                match self.bits {
                    false => ANFOFF_A::ENABLED,
                    true => ANFOFF_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ANFOFF_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ANFOFF_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `ANFOFF`"]
        pub struct ANFOFF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ANFOFF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ANFOFF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog noise filter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ANFOFF_A::ENABLED)
            }
            #[doc = "Analog noise filter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ANFOFF_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "DMA transmission requests enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDMAEN_A {
            #[doc = "0: DMA mode disabled for transmission"]
            DISABLED = 0,
            #[doc = "1: DMA mode enabled for transmission"]
            ENABLED = 1,
        }
        impl From<TXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: TXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXDMAEN`"]
        pub type TXDMAEN_R = crate::R<bool, TXDMAEN_A>;
        impl TXDMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXDMAEN_A {
                match self.bits {
                    false => TXDMAEN_A::DISABLED,
                    true => TXDMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXDMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXDMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXDMAEN`"]
        pub struct TXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXDMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXDMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode disabled for transmission"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::DISABLED)
            }
            #[doc = "DMA mode enabled for transmission"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "DMA reception requests enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDMAEN_A {
            #[doc = "0: DMA mode disabled for reception"]
            DISABLED = 0,
            #[doc = "1: DMA mode enabled for reception"]
            ENABLED = 1,
        }
        impl From<RXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: RXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXDMAEN`"]
        pub type RXDMAEN_R = crate::R<bool, RXDMAEN_A>;
        impl RXDMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXDMAEN_A {
                match self.bits {
                    false => RXDMAEN_A::DISABLED,
                    true => RXDMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXDMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXDMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXDMAEN`"]
        pub struct RXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXDMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXDMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode disabled for reception"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::DISABLED)
            }
            #[doc = "DMA mode enabled for reception"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Slave byte control\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBC_A {
            #[doc = "0: Slave byte control disabled"]
            DISABLED = 0,
            #[doc = "1: Slave byte control enabled"]
            ENABLED = 1,
        }
        impl From<SBC_A> for bool {
            #[inline(always)]
            fn from(variant: SBC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SBC`"]
        pub type SBC_R = crate::R<bool, SBC_A>;
        impl SBC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SBC_A {
                match self.bits {
                    false => SBC_A::DISABLED,
                    true => SBC_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SBC_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SBC_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SBC`"]
        pub struct SBC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SBC_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Slave byte control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SBC_A::DISABLED)
            }
            #[doc = "Slave byte control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SBC_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Clock stretching disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOSTRETCH_A {
            #[doc = "0: Clock stretching enabled"]
            ENABLED = 0,
            #[doc = "1: Clock stretching disabled"]
            DISABLED = 1,
        }
        impl From<NOSTRETCH_A> for bool {
            #[inline(always)]
            fn from(variant: NOSTRETCH_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NOSTRETCH`"]
        pub type NOSTRETCH_R = crate::R<bool, NOSTRETCH_A>;
        impl NOSTRETCH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NOSTRETCH_A {
                match self.bits {
                    false => NOSTRETCH_A::ENABLED,
                    true => NOSTRETCH_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NOSTRETCH_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NOSTRETCH_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `NOSTRETCH`"]
        pub struct NOSTRETCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NOSTRETCH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NOSTRETCH_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clock stretching enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::ENABLED)
            }
            #[doc = "Clock stretching disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Wakeup from STOP enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUPEN_A {
            #[doc = "0: Wakeup from Stop mode disabled"]
            DISABLED = 0,
            #[doc = "1: Wakeup from Stop mode enabled"]
            ENABLED = 1,
        }
        impl From<WUPEN_A> for bool {
            #[inline(always)]
            fn from(variant: WUPEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUPEN`"]
        pub type WUPEN_R = crate::R<bool, WUPEN_A>;
        impl WUPEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUPEN_A {
                match self.bits {
                    false => WUPEN_A::DISABLED,
                    true => WUPEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WUPEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WUPEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WUPEN`"]
        pub struct WUPEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUPEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUPEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Wakeup from Stop mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WUPEN_A::DISABLED)
            }
            #[doc = "Wakeup from Stop mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WUPEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "General call enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GCEN_A {
            #[doc = "0: General call disabled. Address 0b00000000 is NACKed"]
            DISABLED = 0,
            #[doc = "1: General call enabled. Address 0b00000000 is ACKed"]
            ENABLED = 1,
        }
        impl From<GCEN_A> for bool {
            #[inline(always)]
            fn from(variant: GCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `GCEN`"]
        pub type GCEN_R = crate::R<bool, GCEN_A>;
        impl GCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> GCEN_A {
                match self.bits {
                    false => GCEN_A::DISABLED,
                    true => GCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == GCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == GCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `GCEN`"]
        pub struct GCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "General call disabled. Address 0b00000000 is NACKed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(GCEN_A::DISABLED)
            }
            #[doc = "General call enabled. Address 0b00000000 is ACKed"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(GCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "SMBus Host address enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBHEN_A {
            #[doc = "0: Host address disabled. Address 0b0001000x is NACKed"]
            DISABLED = 0,
            #[doc = "1: Host address enabled. Address 0b0001000x is ACKed"]
            ENABLED = 1,
        }
        impl From<SMBHEN_A> for bool {
            #[inline(always)]
            fn from(variant: SMBHEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SMBHEN`"]
        pub type SMBHEN_R = crate::R<bool, SMBHEN_A>;
        impl SMBHEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMBHEN_A {
                match self.bits {
                    false => SMBHEN_A::DISABLED,
                    true => SMBHEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMBHEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SMBHEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SMBHEN`"]
        pub struct SMBHEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBHEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMBHEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Host address disabled. Address 0b0001000x is NACKed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMBHEN_A::DISABLED)
            }
            #[doc = "Host address enabled. Address 0b0001000x is ACKed"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SMBHEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "SMBus Device Default address enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBDEN_A {
            #[doc = "0: Device default address disabled. Address 0b1100001x is NACKed"]
            DISABLED = 0,
            #[doc = "1: Device default address enabled. Address 0b1100001x is ACKed"]
            ENABLED = 1,
        }
        impl From<SMBDEN_A> for bool {
            #[inline(always)]
            fn from(variant: SMBDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SMBDEN`"]
        pub type SMBDEN_R = crate::R<bool, SMBDEN_A>;
        impl SMBDEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMBDEN_A {
                match self.bits {
                    false => SMBDEN_A::DISABLED,
                    true => SMBDEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMBDEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SMBDEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `SMBDEN`"]
        pub struct SMBDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMBDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Device default address disabled. Address 0b1100001x is NACKed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMBDEN_A::DISABLED)
            }
            #[doc = "Device default address enabled. Address 0b1100001x is ACKed"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SMBDEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "SMBUS alert enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALERTEN_A {
            #[doc = "0: In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported"]
            DISABLED = 0,
            #[doc = "1: In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported"]
            ENABLED = 1,
        }
        impl From<ALERTEN_A> for bool {
            #[inline(always)]
            fn from(variant: ALERTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALERTEN`"]
        pub type ALERTEN_R = crate::R<bool, ALERTEN_A>;
        impl ALERTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALERTEN_A {
                match self.bits {
                    false => ALERTEN_A::DISABLED,
                    true => ALERTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ALERTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ALERTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ALERTEN`"]
        pub struct ALERTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALERTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALERTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ALERTEN_A::DISABLED)
            }
            #[doc = "In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ALERTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "PEC enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECEN_A {
            #[doc = "0: PEC calculation disabled"]
            DISABLED = 0,
            #[doc = "1: PEC calculation enabled"]
            ENABLED = 1,
        }
        impl From<PECEN_A> for bool {
            #[inline(always)]
            fn from(variant: PECEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PECEN`"]
        pub type PECEN_R = crate::R<bool, PECEN_A>;
        impl PECEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PECEN_A {
                match self.bits {
                    false => PECEN_A::DISABLED,
                    true => PECEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PECEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PECEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PECEN`"]
        pub struct PECEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PECEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PEC calculation disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PECEN_A::DISABLED)
            }
            #[doc = "PEC calculation enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PECEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - TX Interrupt enable"]
            #[inline(always)]
            pub fn txie(&self) -> TXIE_R {
                TXIE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - RX Interrupt enable"]
            #[inline(always)]
            pub fn rxie(&self) -> RXIE_R {
                RXIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Address match interrupt enable (slave only)"]
            #[inline(always)]
            pub fn addrie(&self) -> ADDRIE_R {
                ADDRIE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Not acknowledge received interrupt enable"]
            #[inline(always)]
            pub fn nackie(&self) -> NACKIE_R {
                NACKIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - STOP detection Interrupt enable"]
            #[inline(always)]
            pub fn stopie(&self) -> STOPIE_R {
                STOPIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transfer Complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Error interrupts enable"]
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:11 - Digital noise filter"]
            #[inline(always)]
            pub fn dnf(&self) -> DNF_R {
                DNF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 12 - Analog noise filter OFF"]
            #[inline(always)]
            pub fn anfoff(&self) -> ANFOFF_R {
                ANFOFF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 14 - DMA transmission requests enable"]
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - DMA reception requests enable"]
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Slave byte control"]
            #[inline(always)]
            pub fn sbc(&self) -> SBC_R {
                SBC_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Clock stretching disable"]
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Wakeup from STOP enable"]
            #[inline(always)]
            pub fn wupen(&self) -> WUPEN_R {
                WUPEN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - General call enable"]
            #[inline(always)]
            pub fn gcen(&self) -> GCEN_R {
                GCEN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - SMBus Host address enable"]
            #[inline(always)]
            pub fn smbhen(&self) -> SMBHEN_R {
                SMBHEN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - SMBus Device Default address enable"]
            #[inline(always)]
            pub fn smbden(&self) -> SMBDEN_R {
                SMBDEN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - SMBUS alert enable"]
            #[inline(always)]
            pub fn alerten(&self) -> ALERTEN_R {
                ALERTEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - PEC enable"]
            #[inline(always)]
            pub fn pecen(&self) -> PECEN_R {
                PECEN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W {
                PE_W { w: self }
            }
            #[doc = "Bit 1 - TX Interrupt enable"]
            #[inline(always)]
            pub fn txie(&mut self) -> TXIE_W {
                TXIE_W { w: self }
            }
            #[doc = "Bit 2 - RX Interrupt enable"]
            #[inline(always)]
            pub fn rxie(&mut self) -> RXIE_W {
                RXIE_W { w: self }
            }
            #[doc = "Bit 3 - Address match interrupt enable (slave only)"]
            #[inline(always)]
            pub fn addrie(&mut self) -> ADDRIE_W {
                ADDRIE_W { w: self }
            }
            #[doc = "Bit 4 - Not acknowledge received interrupt enable"]
            #[inline(always)]
            pub fn nackie(&mut self) -> NACKIE_W {
                NACKIE_W { w: self }
            }
            #[doc = "Bit 5 - STOP detection Interrupt enable"]
            #[inline(always)]
            pub fn stopie(&mut self) -> STOPIE_W {
                STOPIE_W { w: self }
            }
            #[doc = "Bit 6 - Transfer Complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            #[doc = "Bit 7 - Error interrupts enable"]
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            #[doc = "Bits 8:11 - Digital noise filter"]
            #[inline(always)]
            pub fn dnf(&mut self) -> DNF_W {
                DNF_W { w: self }
            }
            #[doc = "Bit 12 - Analog noise filter OFF"]
            #[inline(always)]
            pub fn anfoff(&mut self) -> ANFOFF_W {
                ANFOFF_W { w: self }
            }
            #[doc = "Bit 14 - DMA transmission requests enable"]
            #[inline(always)]
            pub fn txdmaen(&mut self) -> TXDMAEN_W {
                TXDMAEN_W { w: self }
            }
            #[doc = "Bit 15 - DMA reception requests enable"]
            #[inline(always)]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W {
                RXDMAEN_W { w: self }
            }
            #[doc = "Bit 16 - Slave byte control"]
            #[inline(always)]
            pub fn sbc(&mut self) -> SBC_W {
                SBC_W { w: self }
            }
            #[doc = "Bit 17 - Clock stretching disable"]
            #[inline(always)]
            pub fn nostretch(&mut self) -> NOSTRETCH_W {
                NOSTRETCH_W { w: self }
            }
            #[doc = "Bit 18 - Wakeup from STOP enable"]
            #[inline(always)]
            pub fn wupen(&mut self) -> WUPEN_W {
                WUPEN_W { w: self }
            }
            #[doc = "Bit 19 - General call enable"]
            #[inline(always)]
            pub fn gcen(&mut self) -> GCEN_W {
                GCEN_W { w: self }
            }
            #[doc = "Bit 20 - SMBus Host address enable"]
            #[inline(always)]
            pub fn smbhen(&mut self) -> SMBHEN_W {
                SMBHEN_W { w: self }
            }
            #[doc = "Bit 21 - SMBus Device Default address enable"]
            #[inline(always)]
            pub fn smbden(&mut self) -> SMBDEN_W {
                SMBDEN_W { w: self }
            }
            #[doc = "Bit 22 - SMBUS alert enable"]
            #[inline(always)]
            pub fn alerten(&mut self) -> ALERTEN_W {
                ALERTEN_W { w: self }
            }
            #[doc = "Bit 23 - PEC enable"]
            #[inline(always)]
            pub fn pecen(&mut self) -> PECEN_W {
                PECEN_W { w: self }
            }
        }
    }
    #[doc = "Control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Packet error checking byte\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECBYTE_A {
            #[doc = "0: No PEC transfer"]
            NOPEC = 0,
            #[doc = "1: PEC transmission/reception is requested"]
            PEC = 1,
        }
        impl From<PECBYTE_A> for bool {
            #[inline(always)]
            fn from(variant: PECBYTE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PECBYTE`"]
        pub type PECBYTE_R = crate::R<bool, PECBYTE_A>;
        impl PECBYTE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PECBYTE_A {
                match self.bits {
                    false => PECBYTE_A::NOPEC,
                    true => PECBYTE_A::PEC,
                }
            }
            #[doc = "Checks if the value of the field is `NOPEC`"]
            #[inline(always)]
            pub fn is_no_pec(&self) -> bool {
                *self == PECBYTE_A::NOPEC
            }
            #[doc = "Checks if the value of the field is `PEC`"]
            #[inline(always)]
            pub fn is_pec(&self) -> bool {
                *self == PECBYTE_A::PEC
            }
        }
        #[doc = "Write proxy for field `PECBYTE`"]
        pub struct PECBYTE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECBYTE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PECBYTE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No PEC transfer"]
            #[inline(always)]
            pub fn no_pec(self) -> &'a mut W {
                self.variant(PECBYTE_A::NOPEC)
            }
            #[doc = "PEC transmission/reception is requested"]
            #[inline(always)]
            pub fn pec(self) -> &'a mut W {
                self.variant(PECBYTE_A::PEC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Automatic end mode (master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AUTOEND_A {
            #[doc = "0: Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low"]
            SOFTWARE = 0,
            #[doc = "1: Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred"]
            AUTOMATIC = 1,
        }
        impl From<AUTOEND_A> for bool {
            #[inline(always)]
            fn from(variant: AUTOEND_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AUTOEND`"]
        pub type AUTOEND_R = crate::R<bool, AUTOEND_A>;
        impl AUTOEND_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AUTOEND_A {
                match self.bits {
                    false => AUTOEND_A::SOFTWARE,
                    true => AUTOEND_A::AUTOMATIC,
                }
            }
            #[doc = "Checks if the value of the field is `SOFTWARE`"]
            #[inline(always)]
            pub fn is_software(&self) -> bool {
                *self == AUTOEND_A::SOFTWARE
            }
            #[doc = "Checks if the value of the field is `AUTOMATIC`"]
            #[inline(always)]
            pub fn is_automatic(&self) -> bool {
                *self == AUTOEND_A::AUTOMATIC
            }
        }
        #[doc = "Write proxy for field `AUTOEND`"]
        pub struct AUTOEND_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AUTOEND_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AUTOEND_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low"]
            #[inline(always)]
            pub fn software(self) -> &'a mut W {
                self.variant(AUTOEND_A::SOFTWARE)
            }
            #[doc = "Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred"]
            #[inline(always)]
            pub fn automatic(self) -> &'a mut W {
                self.variant(AUTOEND_A::AUTOMATIC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "NBYTES reload mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RELOAD_A {
            #[doc = "0: The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)"]
            COMPLETED = 0,
            #[doc = "1: The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)"]
            NOTCOMPLETED = 1,
        }
        impl From<RELOAD_A> for bool {
            #[inline(always)]
            fn from(variant: RELOAD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RELOAD`"]
        pub type RELOAD_R = crate::R<bool, RELOAD_A>;
        impl RELOAD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RELOAD_A {
                match self.bits {
                    false => RELOAD_A::COMPLETED,
                    true => RELOAD_A::NOTCOMPLETED,
                }
            }
            #[doc = "Checks if the value of the field is `COMPLETED`"]
            #[inline(always)]
            pub fn is_completed(&self) -> bool {
                *self == RELOAD_A::COMPLETED
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETED`"]
            #[inline(always)]
            pub fn is_not_completed(&self) -> bool {
                *self == RELOAD_A::NOTCOMPLETED
            }
        }
        #[doc = "Write proxy for field `RELOAD`"]
        pub struct RELOAD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RELOAD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RELOAD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)"]
            #[inline(always)]
            pub fn completed(self) -> &'a mut W {
                self.variant(RELOAD_A::COMPLETED)
            }
            #[doc = "The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)"]
            #[inline(always)]
            pub fn not_completed(self) -> &'a mut W {
                self.variant(RELOAD_A::NOTCOMPLETED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `NBYTES`"]
        pub type NBYTES_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `NBYTES`"]
        pub struct NBYTES_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NBYTES_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        #[doc = "NACK generation (slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACK_A {
            #[doc = "0: an ACK is sent after current received byte"]
            ACK = 0,
            #[doc = "1: a NACK is sent after current received byte"]
            NACK = 1,
        }
        impl From<NACK_A> for bool {
            #[inline(always)]
            fn from(variant: NACK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NACK`"]
        pub type NACK_R = crate::R<bool, NACK_A>;
        impl NACK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NACK_A {
                match self.bits {
                    false => NACK_A::ACK,
                    true => NACK_A::NACK,
                }
            }
            #[doc = "Checks if the value of the field is `ACK`"]
            #[inline(always)]
            pub fn is_ack(&self) -> bool {
                *self == NACK_A::ACK
            }
            #[doc = "Checks if the value of the field is `NACK`"]
            #[inline(always)]
            pub fn is_nack(&self) -> bool {
                *self == NACK_A::NACK
            }
        }
        #[doc = "Write proxy for field `NACK`"]
        pub struct NACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NACK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NACK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "an ACK is sent after current received byte"]
            #[inline(always)]
            pub fn ack(self) -> &'a mut W {
                self.variant(NACK_A::ACK)
            }
            #[doc = "a NACK is sent after current received byte"]
            #[inline(always)]
            pub fn nack(self) -> &'a mut W {
                self.variant(NACK_A::NACK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Stop generation (master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOP_A {
            #[doc = "0: No Stop generation"]
            NOSTOP = 0,
            #[doc = "1: Stop generation after current byte transfer"]
            STOP = 1,
        }
        impl From<STOP_A> for bool {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STOP`"]
        pub type STOP_R = crate::R<bool, STOP_A>;
        impl STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    false => STOP_A::NOSTOP,
                    true => STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTOP`"]
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                *self == STOP_A::NOSTOP
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `STOP`"]
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No Stop generation"]
            #[inline(always)]
            pub fn no_stop(self) -> &'a mut W {
                self.variant(STOP_A::NOSTOP)
            }
            #[doc = "Stop generation after current byte transfer"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Start generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum START_A {
            #[doc = "0: No Start generation"]
            NOSTART = 0,
            #[doc = "1: Restart/Start generation"]
            START = 1,
        }
        impl From<START_A> for bool {
            #[inline(always)]
            fn from(variant: START_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `START`"]
        pub type START_R = crate::R<bool, START_A>;
        impl START_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> START_A {
                match self.bits {
                    false => START_A::NOSTART,
                    true => START_A::START,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTART`"]
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                *self == START_A::NOSTART
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == START_A::START
            }
        }
        #[doc = "Write proxy for field `START`"]
        pub struct START_W<'a> {
            w: &'a mut W,
        }
        impl<'a> START_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: START_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No Start generation"]
            #[inline(always)]
            pub fn no_start(self) -> &'a mut W {
                self.variant(START_A::NOSTART)
            }
            #[doc = "Restart/Start generation"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(START_A::START)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "10-bit address header only read direction (master receiver mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEAD10R_A {
            #[doc = "0: The master sends the complete 10 bit slave address read sequence"]
            COMPLETE = 0,
            #[doc = "1: The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction"]
            PARTIAL = 1,
        }
        impl From<HEAD10R_A> for bool {
            #[inline(always)]
            fn from(variant: HEAD10R_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HEAD10R`"]
        pub type HEAD10R_R = crate::R<bool, HEAD10R_A>;
        impl HEAD10R_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HEAD10R_A {
                match self.bits {
                    false => HEAD10R_A::COMPLETE,
                    true => HEAD10R_A::PARTIAL,
                }
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == HEAD10R_A::COMPLETE
            }
            #[doc = "Checks if the value of the field is `PARTIAL`"]
            #[inline(always)]
            pub fn is_partial(&self) -> bool {
                *self == HEAD10R_A::PARTIAL
            }
        }
        #[doc = "Write proxy for field `HEAD10R`"]
        pub struct HEAD10R_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HEAD10R_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEAD10R_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The master sends the complete 10 bit slave address read sequence"]
            #[inline(always)]
            pub fn complete(self) -> &'a mut W {
                self.variant(HEAD10R_A::COMPLETE)
            }
            #[doc = "The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction"]
            #[inline(always)]
            pub fn partial(self) -> &'a mut W {
                self.variant(HEAD10R_A::PARTIAL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "10-bit addressing mode (master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADD10_A {
            #[doc = "0: The master operates in 7-bit addressing mode"]
            BIT7 = 0,
            #[doc = "1: The master operates in 10-bit addressing mode"]
            BIT10 = 1,
        }
        impl From<ADD10_A> for bool {
            #[inline(always)]
            fn from(variant: ADD10_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADD10`"]
        pub type ADD10_R = crate::R<bool, ADD10_A>;
        impl ADD10_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADD10_A {
                match self.bits {
                    false => ADD10_A::BIT7,
                    true => ADD10_A::BIT10,
                }
            }
            #[doc = "Checks if the value of the field is `BIT7`"]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == ADD10_A::BIT7
            }
            #[doc = "Checks if the value of the field is `BIT10`"]
            #[inline(always)]
            pub fn is_bit10(&self) -> bool {
                *self == ADD10_A::BIT10
            }
        }
        #[doc = "Write proxy for field `ADD10`"]
        pub struct ADD10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADD10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The master operates in 7-bit addressing mode"]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut W {
                self.variant(ADD10_A::BIT7)
            }
            #[doc = "The master operates in 10-bit addressing mode"]
            #[inline(always)]
            pub fn bit10(self) -> &'a mut W {
                self.variant(ADD10_A::BIT10)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Transfer direction (master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RD_WRN_A {
            #[doc = "0: Master requests a write transfer"]
            WRITE = 0,
            #[doc = "1: Master requests a read transfer"]
            READ = 1,
        }
        impl From<RD_WRN_A> for bool {
            #[inline(always)]
            fn from(variant: RD_WRN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RD_WRN`"]
        pub type RD_WRN_R = crate::R<bool, RD_WRN_A>;
        impl RD_WRN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RD_WRN_A {
                match self.bits {
                    false => RD_WRN_A::WRITE,
                    true => RD_WRN_A::READ,
                }
            }
            #[doc = "Checks if the value of the field is `WRITE`"]
            #[inline(always)]
            pub fn is_write(&self) -> bool {
                *self == RD_WRN_A::WRITE
            }
            #[doc = "Checks if the value of the field is `READ`"]
            #[inline(always)]
            pub fn is_read(&self) -> bool {
                *self == RD_WRN_A::READ
            }
        }
        #[doc = "Write proxy for field `RD_WRN`"]
        pub struct RD_WRN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RD_WRN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RD_WRN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Master requests a write transfer"]
            #[inline(always)]
            pub fn write(self) -> &'a mut W {
                self.variant(RD_WRN_A::WRITE)
            }
            #[doc = "Master requests a read transfer"]
            #[inline(always)]
            pub fn read(self) -> &'a mut W {
                self.variant(RD_WRN_A::READ)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `SADD`"]
        pub type SADD_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `SADD`"]
        pub struct SADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03ff) | ((value as u32) & 0x03ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 26 - Packet error checking byte"]
            #[inline(always)]
            pub fn pecbyte(&self) -> PECBYTE_R {
                PECBYTE_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Automatic end mode (master mode)"]
            #[inline(always)]
            pub fn autoend(&self) -> AUTOEND_R {
                AUTOEND_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 24 - NBYTES reload mode"]
            #[inline(always)]
            pub fn reload(&self) -> RELOAD_R {
                RELOAD_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bits 16:23 - Number of bytes"]
            #[inline(always)]
            pub fn nbytes(&self) -> NBYTES_R {
                NBYTES_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bit 15 - NACK generation (slave mode)"]
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Stop generation (master mode)"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Start generation"]
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - 10-bit address header only read direction (master receiver mode)"]
            #[inline(always)]
            pub fn head10r(&self) -> HEAD10R_R {
                HEAD10R_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - 10-bit addressing mode (master mode)"]
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Transfer direction (master mode)"]
            #[inline(always)]
            pub fn rd_wrn(&self) -> RD_WRN_R {
                RD_WRN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 0:9 - Slave address bit (master mode)"]
            #[inline(always)]
            pub fn sadd(&self) -> SADD_R {
                SADD_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bit 26 - Packet error checking byte"]
            #[inline(always)]
            pub fn pecbyte(&mut self) -> PECBYTE_W {
                PECBYTE_W { w: self }
            }
            #[doc = "Bit 25 - Automatic end mode (master mode)"]
            #[inline(always)]
            pub fn autoend(&mut self) -> AUTOEND_W {
                AUTOEND_W { w: self }
            }
            #[doc = "Bit 24 - NBYTES reload mode"]
            #[inline(always)]
            pub fn reload(&mut self) -> RELOAD_W {
                RELOAD_W { w: self }
            }
            #[doc = "Bits 16:23 - Number of bytes"]
            #[inline(always)]
            pub fn nbytes(&mut self) -> NBYTES_W {
                NBYTES_W { w: self }
            }
            #[doc = "Bit 15 - NACK generation (slave mode)"]
            #[inline(always)]
            pub fn nack(&mut self) -> NACK_W {
                NACK_W { w: self }
            }
            #[doc = "Bit 14 - Stop generation (master mode)"]
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            #[doc = "Bit 13 - Start generation"]
            #[inline(always)]
            pub fn start(&mut self) -> START_W {
                START_W { w: self }
            }
            #[doc = "Bit 12 - 10-bit address header only read direction (master receiver mode)"]
            #[inline(always)]
            pub fn head10r(&mut self) -> HEAD10R_W {
                HEAD10R_W { w: self }
            }
            #[doc = "Bit 11 - 10-bit addressing mode (master mode)"]
            #[inline(always)]
            pub fn add10(&mut self) -> ADD10_W {
                ADD10_W { w: self }
            }
            #[doc = "Bit 10 - Transfer direction (master mode)"]
            #[inline(always)]
            pub fn rd_wrn(&mut self) -> RD_WRN_W {
                RD_WRN_W { w: self }
            }
            #[doc = "Bits 0:9 - Slave address bit (master mode)"]
            #[inline(always)]
            pub fn sadd(&mut self) -> SADD_W {
                SADD_W { w: self }
            }
        }
    }
    #[doc = "Own address register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [oar1](oar1) module"]
    pub type OAR1 = crate::Reg<u32, _OAR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OAR1;
    #[doc = "`read()` method returns [oar1::R](oar1::R) reader structure"]
    impl crate::Readable for OAR1 {}
    #[doc = "`write(|w| ..)` method takes [oar1::W](oar1::W) writer structure"]
    impl crate::Writable for OAR1 {}
    #[doc = "Own address register 1"]
    pub mod oar1 {
        #[doc = "Reader of register OAR1"]
        pub type R = crate::R<u32, super::OAR1>;
        #[doc = "Writer for register OAR1"]
        pub type W = crate::W<u32, super::OAR1>;
        #[doc = "Register OAR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::OAR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OA1`"]
        pub type OA1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `OA1`"]
        pub struct OA1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03ff) | ((value as u32) & 0x03ff);
                self.w
            }
        }
        #[doc = "Own Address 1 10-bit mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OA1MODE_A {
            #[doc = "0: Own address 1 is a 7-bit address"]
            BIT7 = 0,
            #[doc = "1: Own address 1 is a 10-bit address"]
            BIT10 = 1,
        }
        impl From<OA1MODE_A> for bool {
            #[inline(always)]
            fn from(variant: OA1MODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OA1MODE`"]
        pub type OA1MODE_R = crate::R<bool, OA1MODE_A>;
        impl OA1MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OA1MODE_A {
                match self.bits {
                    false => OA1MODE_A::BIT7,
                    true => OA1MODE_A::BIT10,
                }
            }
            #[doc = "Checks if the value of the field is `BIT7`"]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == OA1MODE_A::BIT7
            }
            #[doc = "Checks if the value of the field is `BIT10`"]
            #[inline(always)]
            pub fn is_bit10(&self) -> bool {
                *self == OA1MODE_A::BIT10
            }
        }
        #[doc = "Write proxy for field `OA1MODE`"]
        pub struct OA1MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA1MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OA1MODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Own address 1 is a 7-bit address"]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut W {
                self.variant(OA1MODE_A::BIT7)
            }
            #[doc = "Own address 1 is a 10-bit address"]
            #[inline(always)]
            pub fn bit10(self) -> &'a mut W {
                self.variant(OA1MODE_A::BIT10)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Own Address 1 enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OA1EN_A {
            #[doc = "0: Own address 1 disabled. The received slave address OA1 is NACKed"]
            DISABLED = 0,
            #[doc = "1: Own address 1 enabled. The received slave address OA1 is ACKed"]
            ENABLED = 1,
        }
        impl From<OA1EN_A> for bool {
            #[inline(always)]
            fn from(variant: OA1EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OA1EN`"]
        pub type OA1EN_R = crate::R<bool, OA1EN_A>;
        impl OA1EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OA1EN_A {
                match self.bits {
                    false => OA1EN_A::DISABLED,
                    true => OA1EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OA1EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OA1EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OA1EN`"]
        pub struct OA1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA1EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OA1EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Own address 1 disabled. The received slave address OA1 is NACKed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OA1EN_A::DISABLED)
            }
            #[doc = "Own address 1 enabled. The received slave address OA1 is ACKed"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OA1EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:9 - Interface address"]
            #[inline(always)]
            pub fn oa1(&self) -> OA1_R {
                OA1_R::new((self.bits & 0x03ff) as u16)
            }
            #[doc = "Bit 10 - Own Address 1 10-bit mode"]
            #[inline(always)]
            pub fn oa1mode(&self) -> OA1MODE_R {
                OA1MODE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Own Address 1 enable"]
            #[inline(always)]
            pub fn oa1en(&self) -> OA1EN_R {
                OA1EN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - Interface address"]
            #[inline(always)]
            pub fn oa1(&mut self) -> OA1_W {
                OA1_W { w: self }
            }
            #[doc = "Bit 10 - Own Address 1 10-bit mode"]
            #[inline(always)]
            pub fn oa1mode(&mut self) -> OA1MODE_W {
                OA1MODE_W { w: self }
            }
            #[doc = "Bit 15 - Own Address 1 enable"]
            #[inline(always)]
            pub fn oa1en(&mut self) -> OA1EN_W {
                OA1EN_W { w: self }
            }
        }
    }
    #[doc = "Own address register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [oar2](oar2) module"]
    pub type OAR2 = crate::Reg<u32, _OAR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OAR2;
    #[doc = "`read()` method returns [oar2::R](oar2::R) reader structure"]
    impl crate::Readable for OAR2 {}
    #[doc = "`write(|w| ..)` method takes [oar2::W](oar2::W) writer structure"]
    impl crate::Writable for OAR2 {}
    #[doc = "Own address register 2"]
    pub mod oar2 {
        #[doc = "Reader of register OAR2"]
        pub type R = crate::R<u32, super::OAR2>;
        #[doc = "Writer for register OAR2"]
        pub type W = crate::W<u32, super::OAR2>;
        #[doc = "Register OAR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::OAR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OA2`"]
        pub type OA2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OA2`"]
        pub struct OA2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x7f << 1)) | (((value as u32) & 0x7f) << 1);
                self.w
            }
        }
        #[doc = "Own Address 2 masks\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OA2MSK_A {
            #[doc = "0: No mask"]
            NOMASK = 0,
            #[doc = "1: OA2\\[1\\]
is masked and dont care. Only OA2\\[7:2\\]
are compared"]
            MASK1 = 1,
            #[doc = "2: OA2\\[2:1\\]
are masked and dont care. Only OA2\\[7:3\\]
are compared"]
            MASK2 = 2,
            #[doc = "3: OA2\\[3:1\\]
are masked and dont care. Only OA2\\[7:4\\]
are compared"]
            MASK3 = 3,
            #[doc = "4: OA2\\[4:1\\]
are masked and dont care. Only OA2\\[7:5\\]
are compared"]
            MASK4 = 4,
            #[doc = "5: OA2\\[5:1\\]
are masked and dont care. Only OA2\\[7:6\\]
are compared"]
            MASK5 = 5,
            #[doc = "6: OA2\\[6:1\\]
are masked and dont care. Only OA2\\[7\\]
is compared."]
            MASK6 = 6,
            #[doc = "7: OA2\\[7:1\\]
are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged"]
            MASK7 = 7,
        }
        impl From<OA2MSK_A> for u8 {
            #[inline(always)]
            fn from(variant: OA2MSK_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OA2MSK`"]
        pub type OA2MSK_R = crate::R<u8, OA2MSK_A>;
        impl OA2MSK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OA2MSK_A {
                match self.bits {
                    0 => OA2MSK_A::NOMASK,
                    1 => OA2MSK_A::MASK1,
                    2 => OA2MSK_A::MASK2,
                    3 => OA2MSK_A::MASK3,
                    4 => OA2MSK_A::MASK4,
                    5 => OA2MSK_A::MASK5,
                    6 => OA2MSK_A::MASK6,
                    7 => OA2MSK_A::MASK7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOMASK`"]
            #[inline(always)]
            pub fn is_no_mask(&self) -> bool {
                *self == OA2MSK_A::NOMASK
            }
            #[doc = "Checks if the value of the field is `MASK1`"]
            #[inline(always)]
            pub fn is_mask1(&self) -> bool {
                *self == OA2MSK_A::MASK1
            }
            #[doc = "Checks if the value of the field is `MASK2`"]
            #[inline(always)]
            pub fn is_mask2(&self) -> bool {
                *self == OA2MSK_A::MASK2
            }
            #[doc = "Checks if the value of the field is `MASK3`"]
            #[inline(always)]
            pub fn is_mask3(&self) -> bool {
                *self == OA2MSK_A::MASK3
            }
            #[doc = "Checks if the value of the field is `MASK4`"]
            #[inline(always)]
            pub fn is_mask4(&self) -> bool {
                *self == OA2MSK_A::MASK4
            }
            #[doc = "Checks if the value of the field is `MASK5`"]
            #[inline(always)]
            pub fn is_mask5(&self) -> bool {
                *self == OA2MSK_A::MASK5
            }
            #[doc = "Checks if the value of the field is `MASK6`"]
            #[inline(always)]
            pub fn is_mask6(&self) -> bool {
                *self == OA2MSK_A::MASK6
            }
            #[doc = "Checks if the value of the field is `MASK7`"]
            #[inline(always)]
            pub fn is_mask7(&self) -> bool {
                *self == OA2MSK_A::MASK7
            }
        }
        #[doc = "Write proxy for field `OA2MSK`"]
        pub struct OA2MSK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA2MSK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OA2MSK_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No mask"]
            #[inline(always)]
            pub fn no_mask(self) -> &'a mut W {
                self.variant(OA2MSK_A::NOMASK)
            }
            #[doc = "OA2\\[1\\]
is masked and dont care. Only OA2\\[7:2\\]
are compared"]
            #[inline(always)]
            pub fn mask1(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK1)
            }
            #[doc = "OA2\\[2:1\\]
are masked and dont care. Only OA2\\[7:3\\]
are compared"]
            #[inline(always)]
            pub fn mask2(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK2)
            }
            #[doc = "OA2\\[3:1\\]
are masked and dont care. Only OA2\\[7:4\\]
are compared"]
            #[inline(always)]
            pub fn mask3(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK3)
            }
            #[doc = "OA2\\[4:1\\]
are masked and dont care. Only OA2\\[7:5\\]
are compared"]
            #[inline(always)]
            pub fn mask4(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK4)
            }
            #[doc = "OA2\\[5:1\\]
are masked and dont care. Only OA2\\[7:6\\]
are compared"]
            #[inline(always)]
            pub fn mask5(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK5)
            }
            #[doc = "OA2\\[6:1\\]
are masked and dont care. Only OA2\\[7\\]
is compared."]
            #[inline(always)]
            pub fn mask6(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK6)
            }
            #[doc = "OA2\\[7:1\\]
are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged"]
            #[inline(always)]
            pub fn mask7(self) -> &'a mut W {
                self.variant(OA2MSK_A::MASK7)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 8)) | (((value as u32) & 0x07) << 8);
                self.w
            }
        }
        #[doc = "Own Address 2 enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OA2EN_A {
            #[doc = "0: Own address 2 disabled. The received slave address OA2 is NACKed"]
            DISABLED = 0,
            #[doc = "1: Own address 2 enabled. The received slave address OA2 is ACKed"]
            ENABLED = 1,
        }
        impl From<OA2EN_A> for bool {
            #[inline(always)]
            fn from(variant: OA2EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OA2EN`"]
        pub type OA2EN_R = crate::R<bool, OA2EN_A>;
        impl OA2EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OA2EN_A {
                match self.bits {
                    false => OA2EN_A::DISABLED,
                    true => OA2EN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OA2EN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OA2EN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OA2EN`"]
        pub struct OA2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA2EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OA2EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Own address 2 disabled. The received slave address OA2 is NACKed"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OA2EN_A::DISABLED)
            }
            #[doc = "Own address 2 enabled. The received slave address OA2 is ACKed"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OA2EN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 1:7 - Interface address"]
            #[inline(always)]
            pub fn oa2(&self) -> OA2_R {
                OA2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            #[doc = "Bits 8:10 - Own Address 2 masks"]
            #[inline(always)]
            pub fn oa2msk(&self) -> OA2MSK_R {
                OA2MSK_R::new(((self.bits >> 8) & 0x07) as u8)
            }
            #[doc = "Bit 15 - Own Address 2 enable"]
            #[inline(always)]
            pub fn oa2en(&self) -> OA2EN_R {
                OA2EN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 1:7 - Interface address"]
            #[inline(always)]
            pub fn oa2(&mut self) -> OA2_W {
                OA2_W { w: self }
            }
            #[doc = "Bits 8:10 - Own Address 2 masks"]
            #[inline(always)]
            pub fn oa2msk(&mut self) -> OA2MSK_W {
                OA2MSK_W { w: self }
            }
            #[doc = "Bit 15 - Own Address 2 enable"]
            #[inline(always)]
            pub fn oa2en(&mut self) -> OA2EN_W {
                OA2EN_W { w: self }
            }
        }
    }
    #[doc = "Timing register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timingr](timingr) module"]
    pub type TIMINGR = crate::Reg<u32, _TIMINGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TIMINGR;
    #[doc = "`read()` method returns [timingr::R](timingr::R) reader structure"]
    impl crate::Readable for TIMINGR {}
    #[doc = "`write(|w| ..)` method takes [timingr::W](timingr::W) writer structure"]
    impl crate::Writable for TIMINGR {}
    #[doc = "Timing register"]
    pub mod timingr {
        #[doc = "Reader of register TIMINGR"]
        pub type R = crate::R<u32, super::TIMINGR>;
        #[doc = "Writer for register TIMINGR"]
        pub type W = crate::W<u32, super::TIMINGR>;
        #[doc = "Register TIMINGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TIMINGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `SCLL`"]
        pub type SCLL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SCLL`"]
        pub struct SCLL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCLL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `SCLH`"]
        pub type SCLH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SCLH`"]
        pub struct SCLH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCLH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `SDADEL`"]
        pub type SDADEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SDADEL`"]
        pub struct SDADEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SDADEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `SCLDEL`"]
        pub type SCLDEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `SCLDEL`"]
        pub struct SCLDEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCLDEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `PRESC`"]
        pub type PRESC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `PRESC`"]
        pub struct PRESC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRESC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 28)) | (((value as u32) & 0x0f) << 28);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - SCL low period (master mode)"]
            #[inline(always)]
            pub fn scll(&self) -> SCLL_R {
                SCLL_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - SCL high period (master mode)"]
            #[inline(always)]
            pub fn sclh(&self) -> SCLH_R {
                SCLH_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:19 - Data hold time"]
            #[inline(always)]
            pub fn sdadel(&self) -> SDADEL_R {
                SDADEL_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - Data setup time"]
            #[inline(always)]
            pub fn scldel(&self) -> SCLDEL_R {
                SCLDEL_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 28:31 - Timing prescaler"]
            #[inline(always)]
            pub fn presc(&self) -> PRESC_R {
                PRESC_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - SCL low period (master mode)"]
            #[inline(always)]
            pub fn scll(&mut self) -> SCLL_W {
                SCLL_W { w: self }
            }
            #[doc = "Bits 8:15 - SCL high period (master mode)"]
            #[inline(always)]
            pub fn sclh(&mut self) -> SCLH_W {
                SCLH_W { w: self }
            }
            #[doc = "Bits 16:19 - Data hold time"]
            #[inline(always)]
            pub fn sdadel(&mut self) -> SDADEL_W {
                SDADEL_W { w: self }
            }
            #[doc = "Bits 20:23 - Data setup time"]
            #[inline(always)]
            pub fn scldel(&mut self) -> SCLDEL_W {
                SCLDEL_W { w: self }
            }
            #[doc = "Bits 28:31 - Timing prescaler"]
            #[inline(always)]
            pub fn presc(&mut self) -> PRESC_W {
                PRESC_W { w: self }
            }
        }
    }
    #[doc = "Status register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timeoutr](timeoutr) module"]
    pub type TIMEOUTR = crate::Reg<u32, _TIMEOUTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TIMEOUTR;
    #[doc = "`read()` method returns [timeoutr::R](timeoutr::R) reader structure"]
    impl crate::Readable for TIMEOUTR {}
    #[doc = "`write(|w| ..)` method takes [timeoutr::W](timeoutr::W) writer structure"]
    impl crate::Writable for TIMEOUTR {}
    #[doc = "Status register 1"]
    pub mod timeoutr {
        #[doc = "Reader of register TIMEOUTR"]
        pub type R = crate::R<u32, super::TIMEOUTR>;
        #[doc = "Writer for register TIMEOUTR"]
        pub type W = crate::W<u32, super::TIMEOUTR>;
        #[doc = "Register TIMEOUTR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TIMEOUTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TIMEOUTA`"]
        pub type TIMEOUTA_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `TIMEOUTA`"]
        pub struct TIMEOUTA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMEOUTA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        #[doc = "Idle clock timeout detection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIDLE_A {
            #[doc = "0: TIMEOUTA is used to detect SCL low timeout"]
            DISABLED = 0,
            #[doc = "1: TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)"]
            ENABLED = 1,
        }
        impl From<TIDLE_A> for bool {
            #[inline(always)]
            fn from(variant: TIDLE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIDLE`"]
        pub type TIDLE_R = crate::R<bool, TIDLE_A>;
        impl TIDLE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIDLE_A {
                match self.bits {
                    false => TIDLE_A::DISABLED,
                    true => TIDLE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIDLE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIDLE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIDLE`"]
        pub struct TIDLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIDLE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIDLE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMEOUTA is used to detect SCL low timeout"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIDLE_A::DISABLED)
            }
            #[doc = "TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIDLE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Clock timeout enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMOUTEN_A {
            #[doc = "0: SCL timeout detection is disabled"]
            DISABLED = 0,
            #[doc = "1: SCL timeout detection is enabled"]
            ENABLED = 1,
        }
        impl From<TIMOUTEN_A> for bool {
            #[inline(always)]
            fn from(variant: TIMOUTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIMOUTEN`"]
        pub type TIMOUTEN_R = crate::R<bool, TIMOUTEN_A>;
        impl TIMOUTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIMOUTEN_A {
                match self.bits {
                    false => TIMOUTEN_A::DISABLED,
                    true => TIMOUTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIMOUTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIMOUTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIMOUTEN`"]
        pub struct TIMOUTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMOUTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIMOUTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "SCL timeout detection is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIMOUTEN_A::DISABLED)
            }
            #[doc = "SCL timeout detection is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIMOUTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `TIMEOUTB`"]
        pub type TIMEOUTB_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `TIMEOUTB`"]
        pub struct TIMEOUTB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMEOUTB_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 16)) | (((value as u32) & 0x0fff) << 16);
                self.w
            }
        }
        #[doc = "Extended clock timeout enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEXTEN_A {
            #[doc = "0: Extended clock timeout detection is disabled"]
            DISABLED = 0,
            #[doc = "1: Extended clock timeout detection is enabled"]
            ENABLED = 1,
        }
        impl From<TEXTEN_A> for bool {
            #[inline(always)]
            fn from(variant: TEXTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TEXTEN`"]
        pub type TEXTEN_R = crate::R<bool, TEXTEN_A>;
        impl TEXTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TEXTEN_A {
                match self.bits {
                    false => TEXTEN_A::DISABLED,
                    true => TEXTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TEXTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TEXTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TEXTEN`"]
        pub struct TEXTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEXTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TEXTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Extended clock timeout detection is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEXTEN_A::DISABLED)
            }
            #[doc = "Extended clock timeout detection is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEXTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:11 - Bus timeout A"]
            #[inline(always)]
            pub fn timeouta(&self) -> TIMEOUTA_R {
                TIMEOUTA_R::new((self.bits & 0x0fff) as u16)
            }
            #[doc = "Bit 12 - Idle clock timeout detection"]
            #[inline(always)]
            pub fn tidle(&self) -> TIDLE_R {
                TIDLE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Clock timeout enable"]
            #[inline(always)]
            pub fn timouten(&self) -> TIMOUTEN_R {
                TIMOUTEN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 16:27 - Bus timeout B"]
            #[inline(always)]
            pub fn timeoutb(&self) -> TIMEOUTB_R {
                TIMEOUTB_R::new(((self.bits >> 16) & 0x0fff) as u16)
            }
            #[doc = "Bit 31 - Extended clock timeout enable"]
            #[inline(always)]
            pub fn texten(&self) -> TEXTEN_R {
                TEXTEN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Bus timeout A"]
            #[inline(always)]
            pub fn timeouta(&mut self) -> TIMEOUTA_W {
                TIMEOUTA_W { w: self }
            }
            #[doc = "Bit 12 - Idle clock timeout detection"]
            #[inline(always)]
            pub fn tidle(&mut self) -> TIDLE_W {
                TIDLE_W { w: self }
            }
            #[doc = "Bit 15 - Clock timeout enable"]
            #[inline(always)]
            pub fn timouten(&mut self) -> TIMOUTEN_W {
                TIMOUTEN_W { w: self }
            }
            #[doc = "Bits 16:27 - Bus timeout B"]
            #[inline(always)]
            pub fn timeoutb(&mut self) -> TIMEOUTB_W {
                TIMEOUTB_W { w: self }
            }
            #[doc = "Bit 31 - Extended clock timeout enable"]
            #[inline(always)]
            pub fn texten(&mut self) -> TEXTEN_W {
                TEXTEN_W { w: self }
            }
        }
    }
    #[doc = "Interrupt and Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "`write(|w| ..)` method takes [isr::W](isr::W) writer structure"]
    impl crate::Writable for ISR {}
    #[doc = "Interrupt and Status register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Writer for register ISR"]
        pub type W = crate::W<u32, super::ISR>;
        #[doc = "Register ISR `reset()`'s with value 0x01"]
        impl crate::ResetValue for super::ISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x01
            }
        }
        #[doc = "Reader of field `ADDCODE`"]
        pub type ADDCODE_R = crate::R<u8, u8>;
        #[doc = "Transfer direction (Slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            #[doc = "0: Write transfer, slave enters receiver mode"]
            WRITE = 0,
            #[doc = "1: Read transfer, slave enters transmitter mode"]
            READ = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DIR`"]
        pub type DIR_R = crate::R<bool, DIR_A>;
        impl DIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::WRITE,
                    true => DIR_A::READ,
                }
            }
            #[doc = "Checks if the value of the field is `WRITE`"]
            #[inline(always)]
            pub fn is_write(&self) -> bool {
                *self == DIR_A::WRITE
            }
            #[doc = "Checks if the value of the field is `READ`"]
            #[inline(always)]
            pub fn is_read(&self) -> bool {
                *self == DIR_A::READ
            }
        }
        #[doc = "Bus busy\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BUSY_A {
            #[doc = "0: No communication is in progress on the bus"]
            NOTBUSY = 0,
            #[doc = "1: A communication is in progress on the bus"]
            BUSY = 1,
        }
        impl From<BUSY_A> for bool {
            #[inline(always)]
            fn from(variant: BUSY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BUSY`"]
        pub type BUSY_R = crate::R<bool, BUSY_A>;
        impl BUSY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BUSY_A {
                match self.bits {
                    false => BUSY_A::NOTBUSY,
                    true => BUSY_A::BUSY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBUSY`"]
            #[inline(always)]
            pub fn is_not_busy(&self) -> bool {
                *self == BUSY_A::NOTBUSY
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == BUSY_A::BUSY
            }
        }
        #[doc = "SMBus alert\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALERT_A {
            #[doc = "0: SMBA alert is not detected"]
            NOALERT = 0,
            #[doc = "1: SMBA alert event is detected on SMBA pin"]
            ALERT = 1,
        }
        impl From<ALERT_A> for bool {
            #[inline(always)]
            fn from(variant: ALERT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALERT`"]
        pub type ALERT_R = crate::R<bool, ALERT_A>;
        impl ALERT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALERT_A {
                match self.bits {
                    false => ALERT_A::NOALERT,
                    true => ALERT_A::ALERT,
                }
            }
            #[doc = "Checks if the value of the field is `NOALERT`"]
            #[inline(always)]
            pub fn is_no_alert(&self) -> bool {
                *self == ALERT_A::NOALERT
            }
            #[doc = "Checks if the value of the field is `ALERT`"]
            #[inline(always)]
            pub fn is_alert(&self) -> bool {
                *self == ALERT_A::ALERT
            }
        }
        #[doc = "Timeout or t_low detection flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUT_A {
            #[doc = "0: No timeout occured"]
            NOTIMEOUT = 0,
            #[doc = "1: Timeout occured"]
            TIMEOUT = 1,
        }
        impl From<TIMEOUT_A> for bool {
            #[inline(always)]
            fn from(variant: TIMEOUT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIMEOUT`"]
        pub type TIMEOUT_R = crate::R<bool, TIMEOUT_A>;
        impl TIMEOUT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIMEOUT_A {
                match self.bits {
                    false => TIMEOUT_A::NOTIMEOUT,
                    true => TIMEOUT_A::TIMEOUT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTIMEOUT`"]
            #[inline(always)]
            pub fn is_no_timeout(&self) -> bool {
                *self == TIMEOUT_A::NOTIMEOUT
            }
            #[doc = "Checks if the value of the field is `TIMEOUT`"]
            #[inline(always)]
            pub fn is_timeout(&self) -> bool {
                *self == TIMEOUT_A::TIMEOUT
            }
        }
        #[doc = "PEC Error in reception\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECERR_A {
            #[doc = "0: Received PEC does match with PEC register"]
            MATCH = 0,
            #[doc = "1: Received PEC does not match with PEC register"]
            NOMATCH = 1,
        }
        impl From<PECERR_A> for bool {
            #[inline(always)]
            fn from(variant: PECERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PECERR`"]
        pub type PECERR_R = crate::R<bool, PECERR_A>;
        impl PECERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PECERR_A {
                match self.bits {
                    false => PECERR_A::MATCH,
                    true => PECERR_A::NOMATCH,
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == PECERR_A::MATCH
            }
            #[doc = "Checks if the value of the field is `NOMATCH`"]
            #[inline(always)]
            pub fn is_no_match(&self) -> bool {
                *self == PECERR_A::NOMATCH
            }
        }
        #[doc = "Overrun/Underrun (slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            #[doc = "0: No overrun/underrun error occurs"]
            NOOVERRUN = 0,
            #[doc = "1: slave mode with NOSTRETCH=1, when an overrun/underrun error occurs"]
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVR`"]
        pub type OVR_R = crate::R<bool, OVR_A>;
        impl OVR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOOVERRUN`"]
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVR_A::NOOVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVR_A::OVERRUN
            }
        }
        #[doc = "Arbitration lost\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARLO_A {
            #[doc = "0: No arbitration lost"]
            NOTLOST = 0,
            #[doc = "1: Arbitration lost"]
            LOST = 1,
        }
        impl From<ARLO_A> for bool {
            #[inline(always)]
            fn from(variant: ARLO_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARLO`"]
        pub type ARLO_R = crate::R<bool, ARLO_A>;
        impl ARLO_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARLO_A {
                match self.bits {
                    false => ARLO_A::NOTLOST,
                    true => ARLO_A::LOST,
                }
            }
            #[doc = "Checks if the value of the field is `NOTLOST`"]
            #[inline(always)]
            pub fn is_not_lost(&self) -> bool {
                *self == ARLO_A::NOTLOST
            }
            #[doc = "Checks if the value of the field is `LOST`"]
            #[inline(always)]
            pub fn is_lost(&self) -> bool {
                *self == ARLO_A::LOST
            }
        }
        #[doc = "Bus error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BERR_A {
            #[doc = "0: No bus error"]
            NOERROR = 0,
            #[doc = "1: Misplaced Start and Stop condition is detected"]
            ERROR = 1,
        }
        impl From<BERR_A> for bool {
            #[inline(always)]
            fn from(variant: BERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BERR`"]
        pub type BERR_R = crate::R<bool, BERR_A>;
        impl BERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BERR_A {
                match self.bits {
                    false => BERR_A::NOERROR,
                    true => BERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == BERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == BERR_A::ERROR
            }
        }
        #[doc = "Transfer Complete Reload\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCR_A {
            #[doc = "0: Transfer is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: NBYTES has been transfered"]
            COMPLETE = 1,
        }
        impl From<TCR_A> for bool {
            #[inline(always)]
            fn from(variant: TCR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCR`"]
        pub type TCR_R = crate::R<bool, TCR_A>;
        impl TCR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCR_A {
                match self.bits {
                    false => TCR_A::NOTCOMPLETE,
                    true => TCR_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == TCR_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == TCR_A::COMPLETE
            }
        }
        #[doc = "Transfer Complete (master mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TC_A {
            #[doc = "0: Transfer is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: NBYTES has been transfered"]
            COMPLETE = 1,
        }
        impl From<TC_A> for bool {
            #[inline(always)]
            fn from(variant: TC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TC`"]
        pub type TC_R = crate::R<bool, TC_A>;
        impl TC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TC_A {
                match self.bits {
                    false => TC_A::NOTCOMPLETE,
                    true => TC_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == TC_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == TC_A::COMPLETE
            }
        }
        #[doc = "Stop detection flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPF_A {
            #[doc = "0: No Stop condition detected"]
            NOSTOP = 0,
            #[doc = "1: Stop condition detected"]
            STOP = 1,
        }
        impl From<STOPF_A> for bool {
            #[inline(always)]
            fn from(variant: STOPF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `STOPF`"]
        pub type STOPF_R = crate::R<bool, STOPF_A>;
        impl STOPF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOPF_A {
                match self.bits {
                    false => STOPF_A::NOSTOP,
                    true => STOPF_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTOP`"]
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                *self == STOPF_A::NOSTOP
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == STOPF_A::STOP
            }
        }
        #[doc = "Not acknowledge received flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACKF_A {
            #[doc = "0: No NACK has been received"]
            NONACK = 0,
            #[doc = "1: NACK has been received"]
            NACK = 1,
        }
        impl From<NACKF_A> for bool {
            #[inline(always)]
            fn from(variant: NACKF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NACKF`"]
        pub type NACKF_R = crate::R<bool, NACKF_A>;
        impl NACKF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NACKF_A {
                match self.bits {
                    false => NACKF_A::NONACK,
                    true => NACKF_A::NACK,
                }
            }
            #[doc = "Checks if the value of the field is `NONACK`"]
            #[inline(always)]
            pub fn is_no_nack(&self) -> bool {
                *self == NACKF_A::NONACK
            }
            #[doc = "Checks if the value of the field is `NACK`"]
            #[inline(always)]
            pub fn is_nack(&self) -> bool {
                *self == NACKF_A::NACK
            }
        }
        #[doc = "Address matched (slave mode)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_A {
            #[doc = "0: Adress mismatched or not received"]
            NOTMATCH = 0,
            #[doc = "1: Received slave address matched with one of the enabled slave addresses"]
            MATCH = 1,
        }
        impl From<ADDR_A> for bool {
            #[inline(always)]
            fn from(variant: ADDR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDR`"]
        pub type ADDR_R = crate::R<bool, ADDR_A>;
        impl ADDR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDR_A {
                match self.bits {
                    false => ADDR_A::NOTMATCH,
                    true => ADDR_A::MATCH,
                }
            }
            #[doc = "Checks if the value of the field is `NOTMATCH`"]
            #[inline(always)]
            pub fn is_not_match(&self) -> bool {
                *self == ADDR_A::NOTMATCH
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == ADDR_A::MATCH
            }
        }
        #[doc = "Receive data register not empty (receivers)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNE_A {
            #[doc = "0: The RXDR register is empty"]
            EMPTY = 0,
            #[doc = "1: Received data is copied into the RXDR register, and is ready to be read"]
            NOTEMPTY = 1,
        }
        impl From<RXNE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, RXNE_A>;
        impl RXNE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNE_A {
                match self.bits {
                    false => RXNE_A::EMPTY,
                    true => RXNE_A::NOTEMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RXNE_A::EMPTY
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == RXNE_A::NOTEMPTY
            }
        }
        #[doc = "Transmit interrupt status (transmitters)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXIS_A {
            #[doc = "0: The TXDR register is not empty"]
            NOTEMPTY = 0,
            #[doc = "1: The TXDR register is empty and the data to be transmitted must be written in the TXDR register"]
            EMPTY = 1,
        }
        impl From<TXIS_A> for bool {
            #[inline(always)]
            fn from(variant: TXIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXIS`"]
        pub type TXIS_R = crate::R<bool, TXIS_A>;
        impl TXIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXIS_A {
                match self.bits {
                    false => TXIS_A::NOTEMPTY,
                    true => TXIS_A::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TXIS_A::NOTEMPTY
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TXIS_A::EMPTY
            }
        }
        #[doc = "Write proxy for field `TXIS`"]
        pub struct TXIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TXDR register is not empty"]
            #[inline(always)]
            pub fn not_empty(self) -> &'a mut W {
                self.variant(TXIS_A::NOTEMPTY)
            }
            #[doc = "The TXDR register is empty and the data to be transmitted must be written in the TXDR register"]
            #[inline(always)]
            pub fn empty(self) -> &'a mut W {
                self.variant(TXIS_A::EMPTY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Transmit data register empty (transmitters)\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXE_A {
            #[doc = "0: TXDR register not empty"]
            NOTEMPTY = 0,
            #[doc = "1: TXDR register empty"]
            EMPTY = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, TXE_A>;
        impl TXE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NOTEMPTY,
                    true => TXE_A::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TXE_A::NOTEMPTY
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TXE_A::EMPTY
            }
        }
        #[doc = "Write proxy for field `TXE`"]
        pub struct TXE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TXDR register not empty"]
            #[inline(always)]
            pub fn not_empty(self) -> &'a mut W {
                self.variant(TXE_A::NOTEMPTY)
            }
            #[doc = "TXDR register empty"]
            #[inline(always)]
            pub fn empty(self) -> &'a mut W {
                self.variant(TXE_A::EMPTY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 17:23 - Address match code (Slave mode)"]
            #[inline(always)]
            pub fn addcode(&self) -> ADDCODE_R {
                ADDCODE_R::new(((self.bits >> 17) & 0x7f) as u8)
            }
            #[doc = "Bit 16 - Transfer direction (Slave mode)"]
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Bus busy"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 13 - SMBus alert"]
            #[inline(always)]
            pub fn alert(&self) -> ALERT_R {
                ALERT_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Timeout or t_low detection flag"]
            #[inline(always)]
            pub fn timeout(&self) -> TIMEOUT_R {
                TIMEOUT_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - PEC Error in reception"]
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Overrun/Underrun (slave mode)"]
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Arbitration lost"]
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Transfer Complete Reload"]
            #[inline(always)]
            pub fn tcr(&self) -> TCR_R {
                TCR_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transfer Complete (master mode)"]
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Stop detection flag"]
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Not acknowledge received flag"]
            #[inline(always)]
            pub fn nackf(&self) -> NACKF_R {
                NACKF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Address matched (slave mode)"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Receive data register not empty (receivers)"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Transmit interrupt status (transmitters)"]
            #[inline(always)]
            pub fn txis(&self) -> TXIS_R {
                TXIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Transmit data register empty (transmitters)"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - Transmit interrupt status (transmitters)"]
            #[inline(always)]
            pub fn txis(&mut self) -> TXIS_W {
                TXIS_W { w: self }
            }
            #[doc = "Bit 0 - Transmit data register empty (transmitters)"]
            #[inline(always)]
            pub fn txe(&mut self) -> TXE_W {
                TXE_W { w: self }
            }
        }
    }
    #[doc = "Interrupt clear register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
    pub type ICR = crate::Reg<u32, _ICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICR;
    #[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
    impl crate::Writable for ICR {}
    #[doc = "Interrupt clear register"]
    pub mod icr {
        #[doc = "Writer for register ICR"]
        pub type W = crate::W<u32, super::ICR>;
        #[doc = "Register ICR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Alert flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALERTCF_AW {
            #[doc = "1: Clears the ALERT flag in ISR register"]
            CLEAR = 1,
        }
        impl From<ALERTCF_AW> for bool {
            #[inline(always)]
            fn from(variant: ALERTCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ALERTCF`"]
        pub struct ALERTCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALERTCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALERTCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the ALERT flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ALERTCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Timeout detection flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMOUTCF_AW {
            #[doc = "1: Clears the TIMOUT flag in ISR register"]
            CLEAR = 1,
        }
        impl From<TIMOUTCF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIMOUTCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TIMOUTCF`"]
        pub struct TIMOUTCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMOUTCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIMOUTCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TIMOUT flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIMOUTCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "PEC Error flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECCF_AW {
            #[doc = "1: Clears the PEC flag in ISR register"]
            CLEAR = 1,
        }
        impl From<PECCF_AW> for bool {
            #[inline(always)]
            fn from(variant: PECCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `PECCF`"]
        pub struct PECCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PECCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the PEC flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PECCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Overrun/Underrun flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRCF_AW {
            #[doc = "1: Clears the OVR flag in ISR register"]
            CLEAR = 1,
        }
        impl From<OVRCF_AW> for bool {
            #[inline(always)]
            fn from(variant: OVRCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `OVRCF`"]
        pub struct OVRCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVRCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVRCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the OVR flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVRCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Arbitration lost flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARLOCF_AW {
            #[doc = "1: Clears the ARLO flag in ISR register"]
            CLEAR = 1,
        }
        impl From<ARLOCF_AW> for bool {
            #[inline(always)]
            fn from(variant: ARLOCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ARLOCF`"]
        pub struct ARLOCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARLOCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARLOCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the ARLO flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ARLOCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Bus error flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BERRCF_AW {
            #[doc = "1: Clears the BERR flag in ISR register"]
            CLEAR = 1,
        }
        impl From<BERRCF_AW> for bool {
            #[inline(always)]
            fn from(variant: BERRCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `BERRCF`"]
        pub struct BERRCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BERRCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BERRCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the BERR flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(BERRCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Stop detection flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPCF_AW {
            #[doc = "1: Clears the STOP flag in ISR register"]
            CLEAR = 1,
        }
        impl From<STOPCF_AW> for bool {
            #[inline(always)]
            fn from(variant: STOPCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `STOPCF`"]
        pub struct STOPCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOPCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOPCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the STOP flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(STOPCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Not Acknowledge flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACKCF_AW {
            #[doc = "1: Clears the NACK flag in ISR register"]
            CLEAR = 1,
        }
        impl From<NACKCF_AW> for bool {
            #[inline(always)]
            fn from(variant: NACKCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `NACKCF`"]
        pub struct NACKCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NACKCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NACKCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the NACK flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(NACKCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Address Matched flag clear\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRCF_AW {
            #[doc = "1: Clears the ADDR flag in ISR register"]
            CLEAR = 1,
        }
        impl From<ADDRCF_AW> for bool {
            #[inline(always)]
            fn from(variant: ADDRCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADDRCF`"]
        pub struct ADDRCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDRCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDRCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the ADDR flag in ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ADDRCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 13 - Alert flag clear"]
            #[inline(always)]
            pub fn alertcf(&mut self) -> ALERTCF_W {
                ALERTCF_W { w: self }
            }
            #[doc = "Bit 12 - Timeout detection flag clear"]
            #[inline(always)]
            pub fn timoutcf(&mut self) -> TIMOUTCF_W {
                TIMOUTCF_W { w: self }
            }
            #[doc = "Bit 11 - PEC Error flag clear"]
            #[inline(always)]
            pub fn peccf(&mut self) -> PECCF_W {
                PECCF_W { w: self }
            }
            #[doc = "Bit 10 - Overrun/Underrun flag clear"]
            #[inline(always)]
            pub fn ovrcf(&mut self) -> OVRCF_W {
                OVRCF_W { w: self }
            }
            #[doc = "Bit 9 - Arbitration lost flag clear"]
            #[inline(always)]
            pub fn arlocf(&mut self) -> ARLOCF_W {
                ARLOCF_W { w: self }
            }
            #[doc = "Bit 8 - Bus error flag clear"]
            #[inline(always)]
            pub fn berrcf(&mut self) -> BERRCF_W {
                BERRCF_W { w: self }
            }
            #[doc = "Bit 5 - Stop detection flag clear"]
            #[inline(always)]
            pub fn stopcf(&mut self) -> STOPCF_W {
                STOPCF_W { w: self }
            }
            #[doc = "Bit 4 - Not Acknowledge flag clear"]
            #[inline(always)]
            pub fn nackcf(&mut self) -> NACKCF_W {
                NACKCF_W { w: self }
            }
            #[doc = "Bit 3 - Address Matched flag clear"]
            #[inline(always)]
            pub fn addrcf(&mut self) -> ADDRCF_W {
                ADDRCF_W { w: self }
            }
        }
    }
    #[doc = "PEC register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pecr](pecr) module"]
    pub type PECR = crate::Reg<u32, _PECR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PECR;
    #[doc = "`read()` method returns [pecr::R](pecr::R) reader structure"]
    impl crate::Readable for PECR {}
    #[doc = "PEC register"]
    pub mod pecr {
        #[doc = "Reader of register PECR"]
        pub type R = crate::R<u32, super::PECR>;
        #[doc = "Reader of field `PEC`"]
        pub type PEC_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 0:7 - Packet error checking register"]
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new((self.bits & 0xff) as u8)
            }
        }
    }
    #[doc = "Receive data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdr](rxdr) module"]
    pub type RXDR = crate::Reg<u32, _RXDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXDR;
    #[doc = "`read()` method returns [rxdr::R](rxdr::R) reader structure"]
    impl crate::Readable for RXDR {}
    #[doc = "Receive data register"]
    pub mod rxdr {
        #[doc = "Reader of register RXDR"]
        pub type R = crate::R<u32, super::RXDR>;
        #[doc = "Reader of field `RXDATA`"]
        pub type RXDATA_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 0:7 - 8-bit receive data"]
            #[inline(always)]
            pub fn rxdata(&self) -> RXDATA_R {
                RXDATA_R::new((self.bits & 0xff) as u8)
            }
        }
    }
    #[doc = "Transmit data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdr](txdr) module"]
    pub type TXDR = crate::Reg<u32, _TXDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXDR;
    #[doc = "`read()` method returns [txdr::R](txdr::R) reader structure"]
    impl crate::Readable for TXDR {}
    #[doc = "`write(|w| ..)` method takes [txdr::W](txdr::W) writer structure"]
    impl crate::Writable for TXDR {}
    #[doc = "Transmit data register"]
    pub mod txdr {
        #[doc = "Reader of register TXDR"]
        pub type R = crate::R<u32, super::TXDR>;
        #[doc = "Writer for register TXDR"]
        pub type W = crate::W<u32, super::TXDR>;
        #[doc = "Register TXDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TXDATA`"]
        pub type TXDATA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `TXDATA`"]
        pub struct TXDATA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXDATA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - 8-bit transmit data"]
            #[inline(always)]
            pub fn txdata(&self) -> TXDATA_R {
                TXDATA_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - 8-bit transmit data"]
            #[inline(always)]
            pub fn txdata(&mut self) -> TXDATA_W {
                TXDATA_W { w: self }
            }
        }
    }
}
#[doc = "Inter-integrated circuit"]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_5800 as *const _
    }
}
impl Deref for I2C2 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C2::ptr() }
    }
}
#[doc = "Inter-integrated circuit"]
pub struct I2C3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C3 {}
impl I2C3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_7800 as *const _
    }
}
impl Deref for I2C3 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C3::ptr() }
    }
}
#[doc = "Power control"]
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR {}
impl PWR {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwr::RegisterBlock {
        0x4000_7000 as *const _
    }
}
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*PWR::ptr() }
    }
}
#[doc = "Power control"]
pub mod pwr {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - power control register"]
        pub cr: CR,
        #[doc = "0x04 - power control/status register"]
        pub csr: CSR,
    }
    #[doc = "power control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "power control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0x1000"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x1000
            }
        }
        #[doc = "Regulator in Low-power deepsleep mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPDS_A {
            #[doc = "0: Voltage regulator in Main mode during Deepsleep mode (Stop mode)"]
            MAIN_MODE = 0,
            #[doc = "1: Voltage regulator switches to low-power mode when the CPU enters Deepsleep mode (Stop mode)"]
            LOW_POWER_MODE = 1,
        }
        impl From<LPDS_A> for bool {
            #[inline(always)]
            fn from(variant: LPDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPDS`"]
        pub type LPDS_R = crate::R<bool, LPDS_A>;
        impl LPDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPDS_A {
                match self.bits {
                    false => LPDS_A::MAIN_MODE,
                    true => LPDS_A::LOW_POWER_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `MAIN_MODE`"]
            #[inline(always)]
            pub fn is_main_mode(&self) -> bool {
                *self == LPDS_A::MAIN_MODE
            }
            #[doc = "Checks if the value of the field is `LOW_POWER_MODE`"]
            #[inline(always)]
            pub fn is_low_power_mode(&self) -> bool {
                *self == LPDS_A::LOW_POWER_MODE
            }
        }
        #[doc = "Write proxy for field `LPDS`"]
        pub struct LPDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Voltage regulator in Main mode during Deepsleep mode (Stop mode)"]
            #[inline(always)]
            pub fn main_mode(self) -> &'a mut W {
                self.variant(LPDS_A::MAIN_MODE)
            }
            #[doc = "Voltage regulator switches to low-power mode when the CPU enters Deepsleep mode (Stop mode)"]
            #[inline(always)]
            pub fn low_power_mode(self) -> &'a mut W {
                self.variant(LPDS_A::LOW_POWER_MODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Power down deepsleep\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PDDS_A {
            #[doc = "0: Enter Stop mode when the CPU enters deepsleep"]
            STOP_MODE = 0,
            #[doc = "1: Enter Standby mode when the CPU enters deepsleep"]
            STANDBY_MODE = 1,
        }
        impl From<PDDS_A> for bool {
            #[inline(always)]
            fn from(variant: PDDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PDDS`"]
        pub type PDDS_R = crate::R<bool, PDDS_A>;
        impl PDDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PDDS_A {
                match self.bits {
                    false => PDDS_A::STOP_MODE,
                    true => PDDS_A::STANDBY_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `STOP_MODE`"]
            #[inline(always)]
            pub fn is_stop_mode(&self) -> bool {
                *self == PDDS_A::STOP_MODE
            }
            #[doc = "Checks if the value of the field is `STANDBY_MODE`"]
            #[inline(always)]
            pub fn is_standby_mode(&self) -> bool {
                *self == PDDS_A::STANDBY_MODE
            }
        }
        #[doc = "Write proxy for field `PDDS`"]
        pub struct PDDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PDDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PDDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Enter Stop mode when the CPU enters deepsleep"]
            #[inline(always)]
            pub fn stop_mode(self) -> &'a mut W {
                self.variant(PDDS_A::STOP_MODE)
            }
            #[doc = "Enter Standby mode when the CPU enters deepsleep"]
            #[inline(always)]
            pub fn standby_mode(self) -> &'a mut W {
                self.variant(PDDS_A::STANDBY_MODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Clear wakeup flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CWUF_A {
            #[doc = "1: Clear the WUF Wakeup flag after 2 system clock cycles"]
            CLEAR = 1,
        }
        impl From<CWUF_A> for bool {
            #[inline(always)]
            fn from(variant: CWUF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CWUF`"]
        pub type CWUF_R = crate::R<bool, CWUF_A>;
        impl CWUF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CWUF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CWUF_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CWUF_A::CLEAR
            }
        }
        #[doc = "Write proxy for field `CWUF`"]
        pub struct CWUF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CWUF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CWUF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the WUF Wakeup flag after 2 system clock cycles"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CWUF_A::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Clear standby flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSBF_A {
            #[doc = "1: Clear the SBF Standby flag"]
            CLEAR = 1,
        }
        impl From<CSBF_A> for bool {
            #[inline(always)]
            fn from(variant: CSBF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CSBF`"]
        pub type CSBF_R = crate::R<bool, CSBF_A>;
        impl CSBF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CSBF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CSBF_A::CLEAR),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CSBF_A::CLEAR
            }
        }
        #[doc = "Write proxy for field `CSBF`"]
        pub struct CSBF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSBF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CSBF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the SBF Standby flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CSBF_A::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Power voltage detector enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PVDE_A {
            #[doc = "0: PVD Disabled"]
            DISABLED = 0,
            #[doc = "1: PVD Enabled"]
            ENABLED = 1,
        }
        impl From<PVDE_A> for bool {
            #[inline(always)]
            fn from(variant: PVDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PVDE`"]
        pub type PVDE_R = crate::R<bool, PVDE_A>;
        impl PVDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PVDE_A {
                match self.bits {
                    false => PVDE_A::DISABLED,
                    true => PVDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PVDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PVDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PVDE`"]
        pub struct PVDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PVDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PVDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "PVD Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PVDE_A::DISABLED)
            }
            #[doc = "PVD Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PVDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "PVD level selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PLS_A {
            #[doc = "0: 1.9 V"]
            V1_9 = 0,
            #[doc = "1: 2.1 V"]
            V2_1 = 1,
            #[doc = "2: 2.3 V"]
            V2_3 = 2,
            #[doc = "3: 2.5 V"]
            V2_5 = 3,
            #[doc = "4: 2.7 V"]
            V2_7 = 4,
            #[doc = "5: 2.9 V"]
            V2_9 = 5,
            #[doc = "6: 3.1 V"]
            V3_1 = 6,
            #[doc = "7: External input analog voltage (Compare internally to VREFINT)"]
            EXTERNAL = 7,
        }
        impl From<PLS_A> for u8 {
            #[inline(always)]
            fn from(variant: PLS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PLS`"]
        pub type PLS_R = crate::R<u8, PLS_A>;
        impl PLS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PLS_A {
                match self.bits {
                    0 => PLS_A::V1_9,
                    1 => PLS_A::V2_1,
                    2 => PLS_A::V2_3,
                    3 => PLS_A::V2_5,
                    4 => PLS_A::V2_7,
                    5 => PLS_A::V2_9,
                    6 => PLS_A::V3_1,
                    7 => PLS_A::EXTERNAL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `V1_9`"]
            #[inline(always)]
            pub fn is_v1_9(&self) -> bool {
                *self == PLS_A::V1_9
            }
            #[doc = "Checks if the value of the field is `V2_1`"]
            #[inline(always)]
            pub fn is_v2_1(&self) -> bool {
                *self == PLS_A::V2_1
            }
            #[doc = "Checks if the value of the field is `V2_3`"]
            #[inline(always)]
            pub fn is_v2_3(&self) -> bool {
                *self == PLS_A::V2_3
            }
            #[doc = "Checks if the value of the field is `V2_5`"]
            #[inline(always)]
            pub fn is_v2_5(&self) -> bool {
                *self == PLS_A::V2_5
            }
            #[doc = "Checks if the value of the field is `V2_7`"]
            #[inline(always)]
            pub fn is_v2_7(&self) -> bool {
                *self == PLS_A::V2_7
            }
            #[doc = "Checks if the value of the field is `V2_9`"]
            #[inline(always)]
            pub fn is_v2_9(&self) -> bool {
                *self == PLS_A::V2_9
            }
            #[doc = "Checks if the value of the field is `V3_1`"]
            #[inline(always)]
            pub fn is_v3_1(&self) -> bool {
                *self == PLS_A::V3_1
            }
            #[doc = "Checks if the value of the field is `EXTERNAL`"]
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == PLS_A::EXTERNAL
            }
        }
        #[doc = "Write proxy for field `PLS`"]
        pub struct PLS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PLS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.9 V"]
            #[inline(always)]
            pub fn v1_9(self) -> &'a mut W {
                self.variant(PLS_A::V1_9)
            }
            #[doc = "2.1 V"]
            #[inline(always)]
            pub fn v2_1(self) -> &'a mut W {
                self.variant(PLS_A::V2_1)
            }
            #[doc = "2.3 V"]
            #[inline(always)]
            pub fn v2_3(self) -> &'a mut W {
                self.variant(PLS_A::V2_3)
            }
            #[doc = "2.5 V"]
            #[inline(always)]
            pub fn v2_5(self) -> &'a mut W {
                self.variant(PLS_A::V2_5)
            }
            #[doc = "2.7 V"]
            #[inline(always)]
            pub fn v2_7(self) -> &'a mut W {
                self.variant(PLS_A::V2_7)
            }
            #[doc = "2.9 V"]
            #[inline(always)]
            pub fn v2_9(self) -> &'a mut W {
                self.variant(PLS_A::V2_9)
            }
            #[doc = "3.1 V"]
            #[inline(always)]
            pub fn v3_1(self) -> &'a mut W {
                self.variant(PLS_A::V3_1)
            }
            #[doc = "External input analog voltage (Compare internally to VREFINT)"]
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(PLS_A::EXTERNAL)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 5)) | (((value as u32) & 0x07) << 5);
                self.w
            }
        }
        #[doc = "Disable backup domain write protection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBP_A {
            #[doc = "0: Access to RTC, RTC Backup and RCC CSR registers disabled"]
            DISABLED = 0,
            #[doc = "1: Access to RTC, RTC Backup and RCC CSR registers enabled"]
            ENABLED = 1,
        }
        impl From<DBP_A> for bool {
            #[inline(always)]
            fn from(variant: DBP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBP`"]
        pub type DBP_R = crate::R<bool, DBP_A>;
        impl DBP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBP_A {
                match self.bits {
                    false => DBP_A::DISABLED,
                    true => DBP_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DBP_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DBP_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DBP`"]
        pub struct DBP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Access to RTC, RTC Backup and RCC CSR registers disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBP_A::DISABLED)
            }
            #[doc = "Access to RTC, RTC Backup and RCC CSR registers enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBP_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Ultra-low-power mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ULP_A {
            #[doc = "0: VREFINT is on in low-power mode"]
            ENABLED = 0,
            #[doc = "1: VREFINT is off in low-power mode"]
            DISABLED = 1,
        }
        impl From<ULP_A> for bool {
            #[inline(always)]
            fn from(variant: ULP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ULP`"]
        pub type ULP_R = crate::R<bool, ULP_A>;
        impl ULP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ULP_A {
                match self.bits {
                    false => ULP_A::ENABLED,
                    true => ULP_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ULP_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ULP_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `ULP`"]
        pub struct ULP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ULP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ULP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "VREFINT is on in low-power mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ULP_A::ENABLED)
            }
            #[doc = "VREFINT is off in low-power mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ULP_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Fast wakeup\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FWU_A {
            #[doc = "0: Low-power modes exit occurs only when VREFINT is ready"]
            DISABLED = 0,
            #[doc = "1: VREFINT start up time is ignored when exiting low-power modes"]
            ENABLED = 1,
        }
        impl From<FWU_A> for bool {
            #[inline(always)]
            fn from(variant: FWU_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FWU`"]
        pub type FWU_R = crate::R<bool, FWU_A>;
        impl FWU_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FWU_A {
                match self.bits {
                    false => FWU_A::DISABLED,
                    true => FWU_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == FWU_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == FWU_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `FWU`"]
        pub struct FWU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FWU_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FWU_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Low-power modes exit occurs only when VREFINT is ready"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FWU_A::DISABLED)
            }
            #[doc = "VREFINT start up time is ignored when exiting low-power modes"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FWU_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Voltage scaling range selection\n\nValue on reset: 2"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum VOS_A {
            #[doc = "1: 1.8 V (range 1)"]
            V1_8 = 1,
            #[doc = "2: 1.5 V (range 2)"]
            V1_5 = 2,
            #[doc = "3: 1.2 V (range 3)"]
            V1_2 = 3,
        }
        impl From<VOS_A> for u8 {
            #[inline(always)]
            fn from(variant: VOS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `VOS`"]
        pub type VOS_R = crate::R<u8, VOS_A>;
        impl VOS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, VOS_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(VOS_A::V1_8),
                    2 => Val(VOS_A::V1_5),
                    3 => Val(VOS_A::V1_2),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `V1_8`"]
            #[inline(always)]
            pub fn is_v1_8(&self) -> bool {
                *self == VOS_A::V1_8
            }
            #[doc = "Checks if the value of the field is `V1_5`"]
            #[inline(always)]
            pub fn is_v1_5(&self) -> bool {
                *self == VOS_A::V1_5
            }
            #[doc = "Checks if the value of the field is `V1_2`"]
            #[inline(always)]
            pub fn is_v1_2(&self) -> bool {
                *self == VOS_A::V1_2
            }
        }
        #[doc = "Write proxy for field `VOS`"]
        pub struct VOS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VOS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: VOS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "1.8 V (range 1)"]
            #[inline(always)]
            pub fn v1_8(self) -> &'a mut W {
                self.variant(VOS_A::V1_8)
            }
            #[doc = "1.5 V (range 2)"]
            #[inline(always)]
            pub fn v1_5(self) -> &'a mut W {
                self.variant(VOS_A::V1_5)
            }
            #[doc = "1.2 V (range 3)"]
            #[inline(always)]
            pub fn v1_2(self) -> &'a mut W {
                self.variant(VOS_A::V1_2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 11)) | (((value as u32) & 0x03) << 11);
                self.w
            }
        }
        #[doc = "Deep sleep mode with Flash memory kept off\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DS_EE_KOFF_A {
            #[doc = "0: NVM woken up when exiting from Deepsleep mode even if the bit RUN_PD is set"]
            NVMWAKEUP = 0,
            #[doc = "1: NVM not woken up when exiting from low-power mode (if the bit RUN_PD is set)"]
            NVMSLEEP = 1,
        }
        impl From<DS_EE_KOFF_A> for bool {
            #[inline(always)]
            fn from(variant: DS_EE_KOFF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DS_EE_KOFF`"]
        pub type DS_EE_KOFF_R = crate::R<bool, DS_EE_KOFF_A>;
        impl DS_EE_KOFF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DS_EE_KOFF_A {
                match self.bits {
                    false => DS_EE_KOFF_A::NVMWAKEUP,
                    true => DS_EE_KOFF_A::NVMSLEEP,
                }
            }
            #[doc = "Checks if the value of the field is `NVMWAKEUP`"]
            #[inline(always)]
            pub fn is_nvmwake_up(&self) -> bool {
                *self == DS_EE_KOFF_A::NVMWAKEUP
            }
            #[doc = "Checks if the value of the field is `NVMSLEEP`"]
            #[inline(always)]
            pub fn is_nvmsleep(&self) -> bool {
                *self == DS_EE_KOFF_A::NVMSLEEP
            }
        }
        #[doc = "Write proxy for field `DS_EE_KOFF`"]
        pub struct DS_EE_KOFF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DS_EE_KOFF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DS_EE_KOFF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "NVM woken up when exiting from Deepsleep mode even if the bit RUN_PD is set"]
            #[inline(always)]
            pub fn nvmwake_up(self) -> &'a mut W {
                self.variant(DS_EE_KOFF_A::NVMWAKEUP)
            }
            #[doc = "NVM not woken up when exiting from low-power mode (if the bit RUN_PD is set)"]
            #[inline(always)]
            pub fn nvmsleep(self) -> &'a mut W {
                self.variant(DS_EE_KOFF_A::NVMSLEEP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Low power run mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPRUN_A {
            #[doc = "0: Voltage regulator in Main mode in Low-power run mode"]
            MAIN_MODE = 0,
            #[doc = "1: Voltage regulator in low-power mode in Low-power run mode"]
            LOW_POWER_MODE = 1,
        }
        impl From<LPRUN_A> for bool {
            #[inline(always)]
            fn from(variant: LPRUN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPRUN`"]
        pub type LPRUN_R = crate::R<bool, LPRUN_A>;
        impl LPRUN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPRUN_A {
                match self.bits {
                    false => LPRUN_A::MAIN_MODE,
                    true => LPRUN_A::LOW_POWER_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `MAIN_MODE`"]
            #[inline(always)]
            pub fn is_main_mode(&self) -> bool {
                *self == LPRUN_A::MAIN_MODE
            }
            #[doc = "Checks if the value of the field is `LOW_POWER_MODE`"]
            #[inline(always)]
            pub fn is_low_power_mode(&self) -> bool {
                *self == LPRUN_A::LOW_POWER_MODE
            }
        }
        #[doc = "Write proxy for field `LPRUN`"]
        pub struct LPRUN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPRUN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPRUN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Voltage regulator in Main mode in Low-power run mode"]
            #[inline(always)]
            pub fn main_mode(self) -> &'a mut W {
                self.variant(LPRUN_A::MAIN_MODE)
            }
            #[doc = "Voltage regulator in low-power mode in Low-power run mode"]
            #[inline(always)]
            pub fn low_power_mode(self) -> &'a mut W {
                self.variant(LPRUN_A::LOW_POWER_MODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Low-power deepsleep/Sleep/Low-power run\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPSDSR_A {
            #[doc = "0: Voltage regulator on during Deepsleep/Sleep/Low-power run mode"]
            MAIN_MODE = 0,
            #[doc = "1: Voltage regulator in low-power mode during Deepsleep/Sleep/Low-power run mode"]
            LOW_POWER_MODE = 1,
        }
        impl From<LPSDSR_A> for bool {
            #[inline(always)]
            fn from(variant: LPSDSR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LPSDSR`"]
        pub type LPSDSR_R = crate::R<bool, LPSDSR_A>;
        impl LPSDSR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LPSDSR_A {
                match self.bits {
                    false => LPSDSR_A::MAIN_MODE,
                    true => LPSDSR_A::LOW_POWER_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `MAIN_MODE`"]
            #[inline(always)]
            pub fn is_main_mode(&self) -> bool {
                *self == LPSDSR_A::MAIN_MODE
            }
            #[doc = "Checks if the value of the field is `LOW_POWER_MODE`"]
            #[inline(always)]
            pub fn is_low_power_mode(&self) -> bool {
                *self == LPSDSR_A::LOW_POWER_MODE
            }
        }
        #[doc = "Write proxy for field `LPSDSR`"]
        pub struct LPSDSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPSDSR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPSDSR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Voltage regulator on during Deepsleep/Sleep/Low-power run mode"]
            #[inline(always)]
            pub fn main_mode(self) -> &'a mut W {
                self.variant(LPSDSR_A::MAIN_MODE)
            }
            #[doc = "Voltage regulator in low-power mode during Deepsleep/Sleep/Low-power run mode"]
            #[inline(always)]
            pub fn low_power_mode(self) -> &'a mut W {
                self.variant(LPSDSR_A::LOW_POWER_MODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 16 - Regulator in Low-power deepsleep mode"]
            #[inline(always)]
            pub fn lpds(&self) -> LPDS_R {
                LPDS_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Power down deepsleep"]
            #[inline(always)]
            pub fn pdds(&self) -> PDDS_R {
                PDDS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Clear wakeup flag"]
            #[inline(always)]
            pub fn cwuf(&self) -> CWUF_R {
                CWUF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Clear standby flag"]
            #[inline(always)]
            pub fn csbf(&self) -> CSBF_R {
                CSBF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Power voltage detector enable"]
            #[inline(always)]
            pub fn pvde(&self) -> PVDE_R {
                PVDE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 5:7 - PVD level selection"]
            #[inline(always)]
            pub fn pls(&self) -> PLS_R {
                PLS_R::new(((self.bits >> 5) & 0x07) as u8)
            }
            #[doc = "Bit 8 - Disable backup domain write protection"]
            #[inline(always)]
            pub fn dbp(&self) -> DBP_R {
                DBP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Ultra-low-power mode"]
            #[inline(always)]
            pub fn ulp(&self) -> ULP_R {
                ULP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Fast wakeup"]
            #[inline(always)]
            pub fn fwu(&self) -> FWU_R {
                FWU_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 11:12 - Voltage scaling range selection"]
            #[inline(always)]
            pub fn vos(&self) -> VOS_R {
                VOS_R::new(((self.bits >> 11) & 0x03) as u8)
            }
            #[doc = "Bit 13 - Deep sleep mode with Flash memory kept off"]
            #[inline(always)]
            pub fn ds_ee_koff(&self) -> DS_EE_KOFF_R {
                DS_EE_KOFF_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Low power run mode"]
            #[inline(always)]
            pub fn lprun(&self) -> LPRUN_R {
                LPRUN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Low-power deepsleep/Sleep/Low-power run"]
            #[inline(always)]
            pub fn lpsdsr(&self) -> LPSDSR_R {
                LPSDSR_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 16 - Regulator in Low-power deepsleep mode"]
            #[inline(always)]
            pub fn lpds(&mut self) -> LPDS_W {
                LPDS_W { w: self }
            }
            #[doc = "Bit 1 - Power down deepsleep"]
            #[inline(always)]
            pub fn pdds(&mut self) -> PDDS_W {
                PDDS_W { w: self }
            }
            #[doc = "Bit 2 - Clear wakeup flag"]
            #[inline(always)]
            pub fn cwuf(&mut self) -> CWUF_W {
                CWUF_W { w: self }
            }
            #[doc = "Bit 3 - Clear standby flag"]
            #[inline(always)]
            pub fn csbf(&mut self) -> CSBF_W {
                CSBF_W { w: self }
            }
            #[doc = "Bit 4 - Power voltage detector enable"]
            #[inline(always)]
            pub fn pvde(&mut self) -> PVDE_W {
                PVDE_W { w: self }
            }
            #[doc = "Bits 5:7 - PVD level selection"]
            #[inline(always)]
            pub fn pls(&mut self) -> PLS_W {
                PLS_W { w: self }
            }
            #[doc = "Bit 8 - Disable backup domain write protection"]
            #[inline(always)]
            pub fn dbp(&mut self) -> DBP_W {
                DBP_W { w: self }
            }
            #[doc = "Bit 9 - Ultra-low-power mode"]
            #[inline(always)]
            pub fn ulp(&mut self) -> ULP_W {
                ULP_W { w: self }
            }
            #[doc = "Bit 10 - Fast wakeup"]
            #[inline(always)]
            pub fn fwu(&mut self) -> FWU_W {
                FWU_W { w: self }
            }
            #[doc = "Bits 11:12 - Voltage scaling range selection"]
            #[inline(always)]
            pub fn vos(&mut self) -> VOS_W {
                VOS_W { w: self }
            }
            #[doc = "Bit 13 - Deep sleep mode with Flash memory kept off"]
            #[inline(always)]
            pub fn ds_ee_koff(&mut self) -> DS_EE_KOFF_W {
                DS_EE_KOFF_W { w: self }
            }
            #[doc = "Bit 14 - Low power run mode"]
            #[inline(always)]
            pub fn lprun(&mut self) -> LPRUN_W {
                LPRUN_W { w: self }
            }
            #[doc = "Bit 0 - Low-power deepsleep/Sleep/Low-power run"]
            #[inline(always)]
            pub fn lpsdsr(&mut self) -> LPSDSR_W {
                LPSDSR_W { w: self }
            }
        }
    }
    #[doc = "power control/status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csr](csr) module"]
    pub type CSR = crate::Reg<u32, _CSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CSR;
    #[doc = "`read()` method returns [csr::R](csr::R) reader structure"]
    impl crate::Readable for CSR {}
    #[doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure"]
    impl crate::Writable for CSR {}
    #[doc = "power control/status register"]
    pub mod csr {
        #[doc = "Reader of register CSR"]
        pub type R = crate::R<u32, super::CSR>;
        #[doc = "Writer for register CSR"]
        pub type W = crate::W<u32, super::CSR>;
        #[doc = "Register CSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Enable WKUP pin 2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWUP2_A {
            #[doc = "0: WKUP pin 2 is used for general purpose I/Os. An event on the WKUP pin 2 does not wakeup the device from Standby mode"]
            DISABLED = 0,
            #[doc = "1: WKUP pin 2 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 2 wakes-up the system from Standby mode)"]
            ENABLED = 1,
        }
        impl From<EWUP2_A> for bool {
            #[inline(always)]
            fn from(variant: EWUP2_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWUP2`"]
        pub type EWUP2_R = crate::R<bool, EWUP2_A>;
        impl EWUP2_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EWUP2_A {
                match self.bits {
                    false => EWUP2_A::DISABLED,
                    true => EWUP2_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EWUP2_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EWUP2_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EWUP2`"]
        pub struct EWUP2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWUP2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWUP2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "WKUP pin 2 is used for general purpose I/Os. An event on the WKUP pin 2 does not wakeup the device from Standby mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EWUP2_A::DISABLED)
            }
            #[doc = "WKUP pin 2 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 2 wakes-up the system from Standby mode)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EWUP2_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Enable WKUP pin 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWUP1_A {
            #[doc = "0: WKUP pin 1 is used for general purpose I/Os. An event on the WKUP pin 1 does not wakeup the device from Standby mode"]
            DISABLED = 0,
            #[doc = "1: WKUP pin 1 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 1 wakes-up the system from Standby mode)"]
            ENABLED = 1,
        }
        impl From<EWUP1_A> for bool {
            #[inline(always)]
            fn from(variant: EWUP1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWUP1`"]
        pub type EWUP1_R = crate::R<bool, EWUP1_A>;
        impl EWUP1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EWUP1_A {
                match self.bits {
                    false => EWUP1_A::DISABLED,
                    true => EWUP1_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EWUP1_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EWUP1_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EWUP1`"]
        pub struct EWUP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWUP1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWUP1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "WKUP pin 1 is used for general purpose I/Os. An event on the WKUP pin 1 does not wakeup the device from Standby mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EWUP1_A::DISABLED)
            }
            #[doc = "WKUP pin 1 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 1 wakes-up the system from Standby mode)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EWUP1_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Internal voltage reference ready flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VREFINTRDYF_A {
            #[doc = "0: VREFINT is OFF"]
            NOTREADY = 0,
            #[doc = "1: VREFINT is ready"]
            READY = 1,
        }
        impl From<VREFINTRDYF_A> for bool {
            #[inline(always)]
            fn from(variant: VREFINTRDYF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VREFINTRDYF`"]
        pub type VREFINTRDYF_R = crate::R<bool, VREFINTRDYF_A>;
        impl VREFINTRDYF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VREFINTRDYF_A {
                match self.bits {
                    false => VREFINTRDYF_A::NOTREADY,
                    true => VREFINTRDYF_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == VREFINTRDYF_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == VREFINTRDYF_A::READY
            }
        }
        #[doc = "PVD output\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PVDO_A {
            #[doc = "0: VDD is higher than the PVD threshold selected with the PLS\\[2:0\\]
bits"]
            ABOVETHRESHOLD = 0,
            #[doc = "1: VDD is lower than the PVD threshold selected with the PLS\\[2:0\\]
bits"]
            BELOWTHRESHOLD = 1,
        }
        impl From<PVDO_A> for bool {
            #[inline(always)]
            fn from(variant: PVDO_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PVDO`"]
        pub type PVDO_R = crate::R<bool, PVDO_A>;
        impl PVDO_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PVDO_A {
                match self.bits {
                    false => PVDO_A::ABOVETHRESHOLD,
                    true => PVDO_A::BELOWTHRESHOLD,
                }
            }
            #[doc = "Checks if the value of the field is `ABOVETHRESHOLD`"]
            #[inline(always)]
            pub fn is_above_threshold(&self) -> bool {
                *self == PVDO_A::ABOVETHRESHOLD
            }
            #[doc = "Checks if the value of the field is `BELOWTHRESHOLD`"]
            #[inline(always)]
            pub fn is_below_threshold(&self) -> bool {
                *self == PVDO_A::BELOWTHRESHOLD
            }
        }
        #[doc = "Standby flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBF_A {
            #[doc = "0: Device has not been in Standby mode"]
            NOSTANDBYEVENT = 0,
            #[doc = "1: Device has been in Standby mode"]
            STANDBYEVENT = 1,
        }
        impl From<SBF_A> for bool {
            #[inline(always)]
            fn from(variant: SBF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SBF`"]
        pub type SBF_R = crate::R<bool, SBF_A>;
        impl SBF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SBF_A {
                match self.bits {
                    false => SBF_A::NOSTANDBYEVENT,
                    true => SBF_A::STANDBYEVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTANDBYEVENT`"]
            #[inline(always)]
            pub fn is_no_standby_event(&self) -> bool {
                *self == SBF_A::NOSTANDBYEVENT
            }
            #[doc = "Checks if the value of the field is `STANDBYEVENT`"]
            #[inline(always)]
            pub fn is_standby_event(&self) -> bool {
                *self == SBF_A::STANDBYEVENT
            }
        }
        #[doc = "Wakeup flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUF_A {
            #[doc = "0: No wakeup event occurred"]
            NOWAKEUPEVENT = 0,
            #[doc = "1: A wakeup event was received from the WKUP pin or from the RTC alarm (Alarm A or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup)"]
            WAKEUPEVENT = 1,
        }
        impl From<WUF_A> for bool {
            #[inline(always)]
            fn from(variant: WUF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUF`"]
        pub type WUF_R = crate::R<bool, WUF_A>;
        impl WUF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUF_A {
                match self.bits {
                    false => WUF_A::NOWAKEUPEVENT,
                    true => WUF_A::WAKEUPEVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOWAKEUPEVENT`"]
            #[inline(always)]
            pub fn is_no_wakeup_event(&self) -> bool {
                *self == WUF_A::NOWAKEUPEVENT
            }
            #[doc = "Checks if the value of the field is `WAKEUPEVENT`"]
            #[inline(always)]
            pub fn is_wakeup_event(&self) -> bool {
                *self == WUF_A::WAKEUPEVENT
            }
        }
        #[doc = "Voltage Scaling select flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VOSF_A {
            #[doc = "0: Regulator is ready in the selected voltage range"]
            READY = 0,
            #[doc = "1: Regulator voltage output is changing to the required VOS level"]
            NOTREADY = 1,
        }
        impl From<VOSF_A> for bool {
            #[inline(always)]
            fn from(variant: VOSF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VOSF`"]
        pub type VOSF_R = crate::R<bool, VOSF_A>;
        impl VOSF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VOSF_A {
                match self.bits {
                    false => VOSF_A::READY,
                    true => VOSF_A::NOTREADY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == VOSF_A::READY
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == VOSF_A::NOTREADY
            }
        }
        #[doc = "Regulator LP flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REGLPF_A {
            #[doc = "0: Regulator is ready in Main mode"]
            READY = 0,
            #[doc = "1: Regulator voltage is in low-power mode"]
            NOTREADY = 1,
        }
        impl From<REGLPF_A> for bool {
            #[inline(always)]
            fn from(variant: REGLPF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `REGLPF`"]
        pub type REGLPF_R = crate::R<bool, REGLPF_A>;
        impl REGLPF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> REGLPF_A {
                match self.bits {
                    false => REGLPF_A::READY,
                    true => REGLPF_A::NOTREADY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == REGLPF_A::READY
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == REGLPF_A::NOTREADY
            }
        }
        #[doc = "Enable WKUP pin 3\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWUP3_A {
            #[doc = "0: WKUP pin 3 is used for general purpose I/Os. An event on the WKUP pin 3 does not wakeup the device from Standby mode"]
            DISABLED = 0,
            #[doc = "1: WKUP pin 3 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 3wakes-up the system from Standby mode)"]
            ENABLED = 1,
        }
        impl From<EWUP3_A> for bool {
            #[inline(always)]
            fn from(variant: EWUP3_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EWUP3`"]
        pub type EWUP3_R = crate::R<bool, EWUP3_A>;
        impl EWUP3_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EWUP3_A {
                match self.bits {
                    false => EWUP3_A::DISABLED,
                    true => EWUP3_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EWUP3_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EWUP3_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EWUP3`"]
        pub struct EWUP3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWUP3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EWUP3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "WKUP pin 3 is used for general purpose I/Os. An event on the WKUP pin 3 does not wakeup the device from Standby mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EWUP3_A::DISABLED)
            }
            #[doc = "WKUP pin 3 is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin 3wakes-up the system from Standby mode)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EWUP3_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 9 - Enable WKUP pin 2"]
            #[inline(always)]
            pub fn ewup2(&self) -> EWUP2_R {
                EWUP2_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Enable WKUP pin 1"]
            #[inline(always)]
            pub fn ewup1(&self) -> EWUP1_R {
                EWUP1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Internal voltage reference ready flag"]
            #[inline(always)]
            pub fn vrefintrdyf(&self) -> VREFINTRDYF_R {
                VREFINTRDYF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - PVD output"]
            #[inline(always)]
            pub fn pvdo(&self) -> PVDO_R {
                PVDO_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Standby flag"]
            #[inline(always)]
            pub fn sbf(&self) -> SBF_R {
                SBF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Wakeup flag"]
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 4 - Voltage Scaling select flag"]
            #[inline(always)]
            pub fn vosf(&self) -> VOSF_R {
                VOSF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Regulator LP flag"]
            #[inline(always)]
            pub fn reglpf(&self) -> REGLPF_R {
                REGLPF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Enable WKUP pin 3"]
            #[inline(always)]
            pub fn ewup3(&self) -> EWUP3_R {
                EWUP3_R::new(((self.bits >> 10) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 9 - Enable WKUP pin 2"]
            #[inline(always)]
            pub fn ewup2(&mut self) -> EWUP2_W {
                EWUP2_W { w: self }
            }
            #[doc = "Bit 8 - Enable WKUP pin 1"]
            #[inline(always)]
            pub fn ewup1(&mut self) -> EWUP1_W {
                EWUP1_W { w: self }
            }
            #[doc = "Bit 10 - Enable WKUP pin 3"]
            #[inline(always)]
            pub fn ewup3(&mut self) -> EWUP3_W {
                EWUP3_W { w: self }
            }
        }
    }
}
#[doc = "Flash"]
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        0x4002_2000 as *const _
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*FLASH::ptr() }
    }
}
#[doc = "Flash"]
pub mod flash {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Access control register"]
        pub acr: ACR,
        #[doc = "0x04 - Program/erase control register"]
        pub pecr: PECR,
        #[doc = "0x08 - Power down key register"]
        pub pdkeyr: PDKEYR,
        #[doc = "0x0c - Program/erase key register"]
        pub pekeyr: PEKEYR,
        #[doc = "0x10 - Program memory key register"]
        pub prgkeyr: PRGKEYR,
        #[doc = "0x14 - Option byte key register"]
        pub optkeyr: OPTKEYR,
        #[doc = "0x18 - Status register"]
        pub sr: SR,
        #[doc = "0x1c - Option byte register"]
        pub optr: OPTR,
        #[doc = "0x20 - Write Protection Register 1"]
        pub wrprot1: WRPROT1,
        _reserved9: [u8; 92usize],
        #[doc = "0x80 - Write Protection Register 2"]
        pub wrprot2: WRPROT2,
    }
    #[doc = "Access control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [acr](acr) module"]
    pub type ACR = crate::Reg<u32, _ACR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ACR;
    #[doc = "`read()` method returns [acr::R](acr::R) reader structure"]
    impl crate::Readable for ACR {}
    #[doc = "`write(|w| ..)` method takes [acr::W](acr::W) writer structure"]
    impl crate::Writable for ACR {}
    #[doc = "Access control register"]
    pub mod acr {
        #[doc = "Reader of register ACR"]
        pub type R = crate::R<u32, super::ACR>;
        #[doc = "Writer for register ACR"]
        pub type W = crate::W<u32, super::ACR>;
        #[doc = "Register ACR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ACR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Latency\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LATENCY_A {
            #[doc = "0: Zero wait state is used to read a word in the NVM"]
            WS0 = 0,
            #[doc = "1: One wait state is used to read a word in the NVM"]
            WS1 = 1,
        }
        impl From<LATENCY_A> for bool {
            #[inline(always)]
            fn from(variant: LATENCY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LATENCY`"]
        pub type LATENCY_R = crate::R<bool, LATENCY_A>;
        impl LATENCY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LATENCY_A {
                match self.bits {
                    false => LATENCY_A::WS0,
                    true => LATENCY_A::WS1,
                }
            }
            #[doc = "Checks if the value of the field is `WS0`"]
            #[inline(always)]
            pub fn is_ws0(&self) -> bool {
                *self == LATENCY_A::WS0
            }
            #[doc = "Checks if the value of the field is `WS1`"]
            #[inline(always)]
            pub fn is_ws1(&self) -> bool {
                *self == LATENCY_A::WS1
            }
        }
        #[doc = "Write proxy for field `LATENCY`"]
        pub struct LATENCY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LATENCY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LATENCY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Zero wait state is used to read a word in the NVM"]
            #[inline(always)]
            pub fn ws0(self) -> &'a mut W {
                self.variant(LATENCY_A::WS0)
            }
            #[doc = "One wait state is used to read a word in the NVM"]
            #[inline(always)]
            pub fn ws1(self) -> &'a mut W {
                self.variant(LATENCY_A::WS1)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Prefetch enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRFTEN_A {
            #[doc = "0: Prefetch is disabled"]
            DISABLED = 0,
            #[doc = "1: Prefetch is enabled"]
            ENABLED = 1,
        }
        impl From<PRFTEN_A> for bool {
            #[inline(always)]
            fn from(variant: PRFTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PRFTEN`"]
        pub type PRFTEN_R = crate::R<bool, PRFTEN_A>;
        impl PRFTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PRFTEN_A {
                match self.bits {
                    false => PRFTEN_A::DISABLED,
                    true => PRFTEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PRFTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PRFTEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PRFTEN`"]
        pub struct PRFTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRFTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRFTEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Prefetch is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PRFTEN_A::DISABLED)
            }
            #[doc = "Prefetch is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PRFTEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Flash mode during Sleep\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEP_PD_A {
            #[doc = "0: When the device is in Sleep mode, the NVM is in Idle mode"]
            NVMIDLEMODE = 0,
            #[doc = "1: When the device is in Sleep mode, the NVM is in power-down mode"]
            NVMPWRDOWNMODE = 1,
        }
        impl From<SLEEP_PD_A> for bool {
            #[inline(always)]
            fn from(variant: SLEEP_PD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SLEEP_PD`"]
        pub type SLEEP_PD_R = crate::R<bool, SLEEP_PD_A>;
        impl SLEEP_PD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SLEEP_PD_A {
                match self.bits {
                    false => SLEEP_PD_A::NVMIDLEMODE,
                    true => SLEEP_PD_A::NVMPWRDOWNMODE,
                }
            }
            #[doc = "Checks if the value of the field is `NVMIDLEMODE`"]
            #[inline(always)]
            pub fn is_nvmidle_mode(&self) -> bool {
                *self == SLEEP_PD_A::NVMIDLEMODE
            }
            #[doc = "Checks if the value of the field is `NVMPWRDOWNMODE`"]
            #[inline(always)]
            pub fn is_nvmpwr_down_mode(&self) -> bool {
                *self == SLEEP_PD_A::NVMPWRDOWNMODE
            }
        }
        #[doc = "Write proxy for field `SLEEP_PD`"]
        pub struct SLEEP_PD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLEEP_PD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLEEP_PD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "When the device is in Sleep mode, the NVM is in Idle mode"]
            #[inline(always)]
            pub fn nvmidle_mode(self) -> &'a mut W {
                self.variant(SLEEP_PD_A::NVMIDLEMODE)
            }
            #[doc = "When the device is in Sleep mode, the NVM is in power-down mode"]
            #[inline(always)]
            pub fn nvmpwr_down_mode(self) -> &'a mut W {
                self.variant(SLEEP_PD_A::NVMPWRDOWNMODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Flash mode during Run\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RUN_PD_A {
            #[doc = "0: When the device is in Run mode, the NVM is in Idle mode"]
            NVMIDLEMODE = 0,
            #[doc = "1: When the device is in Run mode, the NVM is in power-down mode"]
            NVMPWRDOWNMODE = 1,
        }
        impl From<RUN_PD_A> for bool {
            #[inline(always)]
            fn from(variant: RUN_PD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RUN_PD`"]
        pub type RUN_PD_R = crate::R<bool, RUN_PD_A>;
        impl RUN_PD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RUN_PD_A {
                match self.bits {
                    false => RUN_PD_A::NVMIDLEMODE,
                    true => RUN_PD_A::NVMPWRDOWNMODE,
                }
            }
            #[doc = "Checks if the value of the field is `NVMIDLEMODE`"]
            #[inline(always)]
            pub fn is_nvmidle_mode(&self) -> bool {
                *self == RUN_PD_A::NVMIDLEMODE
            }
            #[doc = "Checks if the value of the field is `NVMPWRDOWNMODE`"]
            #[inline(always)]
            pub fn is_nvmpwr_down_mode(&self) -> bool {
                *self == RUN_PD_A::NVMPWRDOWNMODE
            }
        }
        #[doc = "Write proxy for field `RUN_PD`"]
        pub struct RUN_PD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RUN_PD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RUN_PD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "When the device is in Run mode, the NVM is in Idle mode"]
            #[inline(always)]
            pub fn nvmidle_mode(self) -> &'a mut W {
                self.variant(RUN_PD_A::NVMIDLEMODE)
            }
            #[doc = "When the device is in Run mode, the NVM is in power-down mode"]
            #[inline(always)]
            pub fn nvmpwr_down_mode(self) -> &'a mut W {
                self.variant(RUN_PD_A::NVMPWRDOWNMODE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Disable Buffer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISAB_BUF_A {
            #[doc = "0: The buffers are enabled"]
            ENABLED = 0,
            #[doc = "1: The buffers are disabled"]
            DISABLED = 1,
        }
        impl From<DISAB_BUF_A> for bool {
            #[inline(always)]
            fn from(variant: DISAB_BUF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DISAB_BUF`"]
        pub type DISAB_BUF_R = crate::R<bool, DISAB_BUF_A>;
        impl DISAB_BUF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DISAB_BUF_A {
                match self.bits {
                    false => DISAB_BUF_A::ENABLED,
                    true => DISAB_BUF_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DISAB_BUF_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DISAB_BUF_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `DISAB_BUF`"]
        pub struct DISAB_BUF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISAB_BUF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DISAB_BUF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The buffers are enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISAB_BUF_A::ENABLED)
            }
            #[doc = "The buffers are disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISAB_BUF_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Pre-read data address\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRE_READ_A {
            #[doc = "0: The pre-read is disabled"]
            DISABLED = 0,
            #[doc = "1: The pre-read is enabled"]
            ENABLED = 1,
        }
        impl From<PRE_READ_A> for bool {
            #[inline(always)]
            fn from(variant: PRE_READ_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PRE_READ`"]
        pub type PRE_READ_R = crate::R<bool, PRE_READ_A>;
        impl PRE_READ_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PRE_READ_A {
                match self.bits {
                    false => PRE_READ_A::DISABLED,
                    true => PRE_READ_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PRE_READ_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PRE_READ_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PRE_READ`"]
        pub struct PRE_READ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRE_READ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRE_READ_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The pre-read is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PRE_READ_A::DISABLED)
            }
            #[doc = "The pre-read is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PRE_READ_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Latency"]
            #[inline(always)]
            pub fn latency(&self) -> LATENCY_R {
                LATENCY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Prefetch enable"]
            #[inline(always)]
            pub fn prften(&self) -> PRFTEN_R {
                PRFTEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Flash mode during Sleep"]
            #[inline(always)]
            pub fn sleep_pd(&self) -> SLEEP_PD_R {
                SLEEP_PD_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Flash mode during Run"]
            #[inline(always)]
            pub fn run_pd(&self) -> RUN_PD_R {
                RUN_PD_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Disable Buffer"]
            #[inline(always)]
            pub fn disab_buf(&self) -> DISAB_BUF_R {
                DISAB_BUF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Pre-read data address"]
            #[inline(always)]
            pub fn pre_read(&self) -> PRE_READ_R {
                PRE_READ_R::new(((self.bits >> 6) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Latency"]
            #[inline(always)]
            pub fn latency(&mut self) -> LATENCY_W {
                LATENCY_W { w: self }
            }
            #[doc = "Bit 1 - Prefetch enable"]
            #[inline(always)]
            pub fn prften(&mut self) -> PRFTEN_W {
                PRFTEN_W { w: self }
            }
            #[doc = "Bit 3 - Flash mode during Sleep"]
            #[inline(always)]
            pub fn sleep_pd(&mut self) -> SLEEP_PD_W {
                SLEEP_PD_W { w: self }
            }
            #[doc = "Bit 4 - Flash mode during Run"]
            #[inline(always)]
            pub fn run_pd(&mut self) -> RUN_PD_W {
                RUN_PD_W { w: self }
            }
            #[doc = "Bit 5 - Disable Buffer"]
            #[inline(always)]
            pub fn disab_buf(&mut self) -> DISAB_BUF_W {
                DISAB_BUF_W { w: self }
            }
            #[doc = "Bit 6 - Pre-read data address"]
            #[inline(always)]
            pub fn pre_read(&mut self) -> PRE_READ_W {
                PRE_READ_W { w: self }
            }
        }
    }
    #[doc = "Program/erase control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pecr](pecr) module"]
    pub type PECR = crate::Reg<u32, _PECR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PECR;
    #[doc = "`read()` method returns [pecr::R](pecr::R) reader structure"]
    impl crate::Readable for PECR {}
    #[doc = "`write(|w| ..)` method takes [pecr::W](pecr::W) writer structure"]
    impl crate::Writable for PECR {}
    #[doc = "Program/erase control register"]
    pub mod pecr {
        #[doc = "Reader of register PECR"]
        pub type R = crate::R<u32, super::PECR>;
        #[doc = "Writer for register PECR"]
        pub type W = crate::W<u32, super::PECR>;
        #[doc = "Register PECR `reset()`'s with value 0x07"]
        impl crate::ResetValue for super::PECR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x07
            }
        }
        #[doc = "FLASH_PECR and data EEPROM lock\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PELOCK_A {
            #[doc = "0: The FLASH_PECR register is unlocked"]
            UNLOCKED = 0,
            #[doc = "1: The FLASH_PECR register is locked and no write/erase operation can start"]
            LOCKED = 1,
        }
        impl From<PELOCK_A> for bool {
            #[inline(always)]
            fn from(variant: PELOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PELOCK`"]
        pub type PELOCK_R = crate::R<bool, PELOCK_A>;
        impl PELOCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PELOCK_A {
                match self.bits {
                    false => PELOCK_A::UNLOCKED,
                    true => PELOCK_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == PELOCK_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == PELOCK_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `PELOCK`"]
        pub struct PELOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PELOCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PELOCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The FLASH_PECR register is unlocked"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(PELOCK_A::UNLOCKED)
            }
            #[doc = "The FLASH_PECR register is locked and no write/erase operation can start"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(PELOCK_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Program memory lock\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRGLOCK_A {
            #[doc = "0: The write and erase operations in the Flash program memory are disabled"]
            UNLOCKED = 0,
            #[doc = "1: The write and erase operations in the Flash program memory are enabled"]
            LOCKED = 1,
        }
        impl From<PRGLOCK_A> for bool {
            #[inline(always)]
            fn from(variant: PRGLOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PRGLOCK`"]
        pub type PRGLOCK_R = crate::R<bool, PRGLOCK_A>;
        impl PRGLOCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PRGLOCK_A {
                match self.bits {
                    false => PRGLOCK_A::UNLOCKED,
                    true => PRGLOCK_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == PRGLOCK_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == PRGLOCK_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `PRGLOCK`"]
        pub struct PRGLOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRGLOCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRGLOCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The write and erase operations in the Flash program memory are disabled"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(PRGLOCK_A::UNLOCKED)
            }
            #[doc = "The write and erase operations in the Flash program memory are enabled"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(PRGLOCK_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Option bytes block lock\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPTLOCK_A {
            #[doc = "0: The write and erase operations in the Option bytes area are disabled"]
            UNLOCKED = 0,
            #[doc = "1: The write and erase operations in the Option bytes area are enabled"]
            LOCKED = 1,
        }
        impl From<OPTLOCK_A> for bool {
            #[inline(always)]
            fn from(variant: OPTLOCK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPTLOCK`"]
        pub type OPTLOCK_R = crate::R<bool, OPTLOCK_A>;
        impl OPTLOCK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPTLOCK_A {
                match self.bits {
                    false => OPTLOCK_A::UNLOCKED,
                    true => OPTLOCK_A::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == OPTLOCK_A::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == OPTLOCK_A::LOCKED
            }
        }
        #[doc = "Write proxy for field `OPTLOCK`"]
        pub struct OPTLOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTLOCK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPTLOCK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The write and erase operations in the Option bytes area are disabled"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(OPTLOCK_A::UNLOCKED)
            }
            #[doc = "The write and erase operations in the Option bytes area are enabled"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(OPTLOCK_A::LOCKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Program memory selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PROG_A {
            #[doc = "0: The Flash program memory is not selected"]
            NOTSELECTED = 0,
            #[doc = "1: The Flash program memory is selected"]
            SELECTED = 1,
        }
        impl From<PROG_A> for bool {
            #[inline(always)]
            fn from(variant: PROG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PROG`"]
        pub type PROG_R = crate::R<bool, PROG_A>;
        impl PROG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PROG_A {
                match self.bits {
                    false => PROG_A::NOTSELECTED,
                    true => PROG_A::SELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSELECTED`"]
            #[inline(always)]
            pub fn is_not_selected(&self) -> bool {
                *self == PROG_A::NOTSELECTED
            }
            #[doc = "Checks if the value of the field is `SELECTED`"]
            #[inline(always)]
            pub fn is_selected(&self) -> bool {
                *self == PROG_A::SELECTED
            }
        }
        #[doc = "Write proxy for field `PROG`"]
        pub struct PROG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PROG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PROG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The Flash program memory is not selected"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(PROG_A::NOTSELECTED)
            }
            #[doc = "The Flash program memory is selected"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(PROG_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Data EEPROM selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_A {
            #[doc = "0: Data EEPROM not selected"]
            NOTSELECTED = 0,
            #[doc = "1: Data memory selected"]
            SELECTED = 1,
        }
        impl From<DATA_A> for bool {
            #[inline(always)]
            fn from(variant: DATA_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DATA`"]
        pub type DATA_R = crate::R<bool, DATA_A>;
        impl DATA_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATA_A {
                match self.bits {
                    false => DATA_A::NOTSELECTED,
                    true => DATA_A::SELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSELECTED`"]
            #[inline(always)]
            pub fn is_not_selected(&self) -> bool {
                *self == DATA_A::NOTSELECTED
            }
            #[doc = "Checks if the value of the field is `SELECTED`"]
            #[inline(always)]
            pub fn is_selected(&self) -> bool {
                *self == DATA_A::SELECTED
            }
        }
        #[doc = "Write proxy for field `DATA`"]
        pub struct DATA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATA_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Data EEPROM not selected"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(DATA_A::NOTSELECTED)
            }
            #[doc = "Data memory selected"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(DATA_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Fixed time data write for Byte, Half Word and Word programming\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FIX_A {
            #[doc = "0: An erase phase is automatically performed"]
            AUTOERASE = 0,
            #[doc = "1: The program operation is always performed with a preliminary erase"]
            PRELIMERASE = 1,
        }
        impl From<FIX_A> for bool {
            #[inline(always)]
            fn from(variant: FIX_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FIX`"]
        pub type FIX_R = crate::R<bool, FIX_A>;
        impl FIX_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FIX_A {
                match self.bits {
                    false => FIX_A::AUTOERASE,
                    true => FIX_A::PRELIMERASE,
                }
            }
            #[doc = "Checks if the value of the field is `AUTOERASE`"]
            #[inline(always)]
            pub fn is_auto_erase(&self) -> bool {
                *self == FIX_A::AUTOERASE
            }
            #[doc = "Checks if the value of the field is `PRELIMERASE`"]
            #[inline(always)]
            pub fn is_prelim_erase(&self) -> bool {
                *self == FIX_A::PRELIMERASE
            }
        }
        #[doc = "Write proxy for field `FIX`"]
        pub struct FIX_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FIX_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FIX_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "An erase phase is automatically performed"]
            #[inline(always)]
            pub fn auto_erase(self) -> &'a mut W {
                self.variant(FIX_A::AUTOERASE)
            }
            #[doc = "The program operation is always performed with a preliminary erase"]
            #[inline(always)]
            pub fn prelim_erase(self) -> &'a mut W {
                self.variant(FIX_A::PRELIMERASE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Page or Double Word erase mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERASE_A {
            #[doc = "0: No erase operation requested"]
            NOERASE = 0,
            #[doc = "1: Erase operation requested"]
            ERASE = 1,
        }
        impl From<ERASE_A> for bool {
            #[inline(always)]
            fn from(variant: ERASE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERASE`"]
        pub type ERASE_R = crate::R<bool, ERASE_A>;
        impl ERASE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERASE_A {
                match self.bits {
                    false => ERASE_A::NOERASE,
                    true => ERASE_A::ERASE,
                }
            }
            #[doc = "Checks if the value of the field is `NOERASE`"]
            #[inline(always)]
            pub fn is_no_erase(&self) -> bool {
                *self == ERASE_A::NOERASE
            }
            #[doc = "Checks if the value of the field is `ERASE`"]
            #[inline(always)]
            pub fn is_erase(&self) -> bool {
                *self == ERASE_A::ERASE
            }
        }
        #[doc = "Write proxy for field `ERASE`"]
        pub struct ERASE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERASE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERASE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No erase operation requested"]
            #[inline(always)]
            pub fn no_erase(self) -> &'a mut W {
                self.variant(ERASE_A::NOERASE)
            }
            #[doc = "Erase operation requested"]
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(ERASE_A::ERASE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Half Page/Double Word programming mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FPRG_A {
            #[doc = "0: Half Page programming disabled"]
            DISABLED = 0,
            #[doc = "1: Half Page programming enabled"]
            ENABLED = 1,
        }
        impl From<FPRG_A> for bool {
            #[inline(always)]
            fn from(variant: FPRG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FPRG`"]
        pub type FPRG_R = crate::R<bool, FPRG_A>;
        impl FPRG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FPRG_A {
                match self.bits {
                    false => FPRG_A::DISABLED,
                    true => FPRG_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == FPRG_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == FPRG_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `FPRG`"]
        pub struct FPRG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FPRG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FPRG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Half Page programming disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FPRG_A::DISABLED)
            }
            #[doc = "Half Page programming enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FPRG_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Parallel bank mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PARALLELBANK_A {
            #[doc = "0: Parallel bank mode disabled"]
            DISABLED = 0,
            #[doc = "1: Parallel bank mode enabled"]
            ENABLED = 1,
        }
        impl From<PARALLELBANK_A> for bool {
            #[inline(always)]
            fn from(variant: PARALLELBANK_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PARALLELBANK`"]
        pub type PARALLELBANK_R = crate::R<bool, PARALLELBANK_A>;
        impl PARALLELBANK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PARALLELBANK_A {
                match self.bits {
                    false => PARALLELBANK_A::DISABLED,
                    true => PARALLELBANK_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PARALLELBANK_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PARALLELBANK_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PARALLELBANK`"]
        pub struct PARALLELBANK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PARALLELBANK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PARALLELBANK_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Parallel bank mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PARALLELBANK_A::DISABLED)
            }
            #[doc = "Parallel bank mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PARALLELBANK_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "End of programming interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOPIE_A {
            #[doc = "0: End of program interrupt disable"]
            DISABLED = 0,
            #[doc = "1: End of program interrupt enable"]
            ENABLED = 1,
        }
        impl From<EOPIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOPIE`"]
        pub type EOPIE_R = crate::R<bool, EOPIE_A>;
        impl EOPIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOPIE_A {
                match self.bits {
                    false => EOPIE_A::DISABLED,
                    true => EOPIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOPIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOPIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOPIE`"]
        pub struct EOPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOPIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOPIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "End of program interrupt disable"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOPIE_A::DISABLED)
            }
            #[doc = "End of program interrupt enable"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOPIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRIE_A {
            #[doc = "0: Error interrupt disable"]
            DISABLED = 0,
            #[doc = "1: Error interrupt enable"]
            ENABLED = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ERRIE`"]
        pub type ERRIE_R = crate::R<bool, ERRIE_A>;
        impl ERRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::DISABLED,
                    true => ERRIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ERRIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ERRIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ERRIE`"]
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ERRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Error interrupt disable"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ERRIE_A::DISABLED)
            }
            #[doc = "Error interrupt enable"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ERRIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Launch the option byte loading\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OBL_LAUNCH_A {
            #[doc = "0: Option byte loaded"]
            COMPLETE = 0,
            #[doc = "1: Option byte loading to be done"]
            NOTCOMPLETE = 1,
        }
        impl From<OBL_LAUNCH_A> for bool {
            #[inline(always)]
            fn from(variant: OBL_LAUNCH_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OBL_LAUNCH`"]
        pub type OBL_LAUNCH_R = crate::R<bool, OBL_LAUNCH_A>;
        impl OBL_LAUNCH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OBL_LAUNCH_A {
                match self.bits {
                    false => OBL_LAUNCH_A::COMPLETE,
                    true => OBL_LAUNCH_A::NOTCOMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == OBL_LAUNCH_A::COMPLETE
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == OBL_LAUNCH_A::NOTCOMPLETE
            }
        }
        #[doc = "Launch the option byte loading\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OBL_LAUNCH_AW {
            #[doc = "1: Reload option byte"]
            RELOAD = 1,
        }
        impl From<OBL_LAUNCH_AW> for bool {
            #[inline(always)]
            fn from(variant: OBL_LAUNCH_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `OBL_LAUNCH`"]
        pub struct OBL_LAUNCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OBL_LAUNCH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OBL_LAUNCH_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Reload option byte"]
            #[inline(always)]
            pub fn reload(self) -> &'a mut W {
                self.variant(OBL_LAUNCH_AW::RELOAD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - FLASH_PECR and data EEPROM lock"]
            #[inline(always)]
            pub fn pelock(&self) -> PELOCK_R {
                PELOCK_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Program memory lock"]
            #[inline(always)]
            pub fn prglock(&self) -> PRGLOCK_R {
                PRGLOCK_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Option bytes block lock"]
            #[inline(always)]
            pub fn optlock(&self) -> OPTLOCK_R {
                OPTLOCK_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Program memory selection"]
            #[inline(always)]
            pub fn prog(&self) -> PROG_R {
                PROG_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Data EEPROM selection"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Fixed time data write for Byte, Half Word and Word programming"]
            #[inline(always)]
            pub fn fix(&self) -> FIX_R {
                FIX_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Page or Double Word erase mode"]
            #[inline(always)]
            pub fn erase(&self) -> ERASE_R {
                ERASE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Half Page/Double Word programming mode"]
            #[inline(always)]
            pub fn fprg(&self) -> FPRG_R {
                FPRG_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Parallel bank mode"]
            #[inline(always)]
            pub fn parallelbank(&self) -> PARALLELBANK_R {
                PARALLELBANK_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - End of programming interrupt enable"]
            #[inline(always)]
            pub fn eopie(&self) -> EOPIE_R {
                EOPIE_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Launch the option byte loading"]
            #[inline(always)]
            pub fn obl_launch(&self) -> OBL_LAUNCH_R {
                OBL_LAUNCH_R::new(((self.bits >> 18) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - FLASH_PECR and data EEPROM lock"]
            #[inline(always)]
            pub fn pelock(&mut self) -> PELOCK_W {
                PELOCK_W { w: self }
            }
            #[doc = "Bit 1 - Program memory lock"]
            #[inline(always)]
            pub fn prglock(&mut self) -> PRGLOCK_W {
                PRGLOCK_W { w: self }
            }
            #[doc = "Bit 2 - Option bytes block lock"]
            #[inline(always)]
            pub fn optlock(&mut self) -> OPTLOCK_W {
                OPTLOCK_W { w: self }
            }
            #[doc = "Bit 3 - Program memory selection"]
            #[inline(always)]
            pub fn prog(&mut self) -> PROG_W {
                PROG_W { w: self }
            }
            #[doc = "Bit 4 - Data EEPROM selection"]
            #[inline(always)]
            pub fn data(&mut self) -> DATA_W {
                DATA_W { w: self }
            }
            #[doc = "Bit 8 - Fixed time data write for Byte, Half Word and Word programming"]
            #[inline(always)]
            pub fn fix(&mut self) -> FIX_W {
                FIX_W { w: self }
            }
            #[doc = "Bit 9 - Page or Double Word erase mode"]
            #[inline(always)]
            pub fn erase(&mut self) -> ERASE_W {
                ERASE_W { w: self }
            }
            #[doc = "Bit 10 - Half Page/Double Word programming mode"]
            #[inline(always)]
            pub fn fprg(&mut self) -> FPRG_W {
                FPRG_W { w: self }
            }
            #[doc = "Bit 15 - Parallel bank mode"]
            #[inline(always)]
            pub fn parallelbank(&mut self) -> PARALLELBANK_W {
                PARALLELBANK_W { w: self }
            }
            #[doc = "Bit 16 - End of programming interrupt enable"]
            #[inline(always)]
            pub fn eopie(&mut self) -> EOPIE_W {
                EOPIE_W { w: self }
            }
            #[doc = "Bit 17 - Error interrupt enable"]
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            #[doc = "Bit 18 - Launch the option byte loading"]
            #[inline(always)]
            pub fn obl_launch(&mut self) -> OBL_LAUNCH_W {
                OBL_LAUNCH_W { w: self }
            }
        }
    }
    #[doc = "Power down key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pdkeyr](pdkeyr) module"]
    pub type PDKEYR = crate::Reg<u32, _PDKEYR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PDKEYR;
    #[doc = "`write(|w| ..)` method takes [pdkeyr::W](pdkeyr::W) writer structure"]
    impl crate::Writable for PDKEYR {}
    #[doc = "Power down key register"]
    pub mod pdkeyr {
        #[doc = "Writer for register PDKEYR"]
        pub type W = crate::W<u32, super::PDKEYR>;
        #[doc = "Register PDKEYR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PDKEYR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `PDKEYR`"]
        pub struct PDKEYR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PDKEYR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RUN_PD in FLASH_ACR key"]
            #[inline(always)]
            pub fn pdkeyr(&mut self) -> PDKEYR_W {
                PDKEYR_W { w: self }
            }
        }
    }
    #[doc = "Program/erase key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pekeyr](pekeyr) module"]
    pub type PEKEYR = crate::Reg<u32, _PEKEYR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PEKEYR;
    #[doc = "`write(|w| ..)` method takes [pekeyr::W](pekeyr::W) writer structure"]
    impl crate::Writable for PEKEYR {}
    #[doc = "Program/erase key register"]
    pub mod pekeyr {
        #[doc = "Writer for register PEKEYR"]
        pub type W = crate::W<u32, super::PEKEYR>;
        #[doc = "Register PEKEYR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PEKEYR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `PEKEYR`"]
        pub struct PEKEYR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEKEYR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - FLASH_PEC and data EEPROM key"]
            #[inline(always)]
            pub fn pekeyr(&mut self) -> PEKEYR_W {
                PEKEYR_W { w: self }
            }
        }
    }
    #[doc = "Program memory key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prgkeyr](prgkeyr) module"]
    pub type PRGKEYR = crate::Reg<u32, _PRGKEYR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRGKEYR;
    #[doc = "`write(|w| ..)` method takes [prgkeyr::W](prgkeyr::W) writer structure"]
    impl crate::Writable for PRGKEYR {}
    #[doc = "Program memory key register"]
    pub mod prgkeyr {
        #[doc = "Writer for register PRGKEYR"]
        pub type W = crate::W<u32, super::PRGKEYR>;
        #[doc = "Register PRGKEYR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PRGKEYR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `PRGKEYR`"]
        pub struct PRGKEYR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRGKEYR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Program memory key"]
            #[inline(always)]
            pub fn prgkeyr(&mut self) -> PRGKEYR_W {
                PRGKEYR_W { w: self }
            }
        }
    }
    #[doc = "Option byte key register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [optkeyr](optkeyr) module"]
    pub type OPTKEYR = crate::Reg<u32, _OPTKEYR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OPTKEYR;
    #[doc = "`write(|w| ..)` method takes [optkeyr::W](optkeyr::W) writer structure"]
    impl crate::Writable for OPTKEYR {}
    #[doc = "Option byte key register"]
    pub mod optkeyr {
        #[doc = "Writer for register OPTKEYR"]
        pub type W = crate::W<u32, super::OPTKEYR>;
        #[doc = "Register OPTKEYR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OPTKEYR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Write proxy for field `OPTKEYR`"]
        pub struct OPTKEYR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTKEYR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Option byte key"]
            #[inline(always)]
            pub fn optkeyr(&mut self) -> OPTKEYR_W {
                OPTKEYR_W { w: self }
            }
        }
    }
    #[doc = "Status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0x04"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x04
            }
        }
        #[doc = "Write/erase operations in progress\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BSY_A {
            #[doc = "0: No write/erase operation is in progress"]
            INACTIVE = 0,
            #[doc = "1: No write/erase operation is in progress"]
            ACTIVE = 1,
        }
        impl From<BSY_A> for bool {
            #[inline(always)]
            fn from(variant: BSY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `BSY`"]
        pub type BSY_R = crate::R<bool, BSY_A>;
        impl BSY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> BSY_A {
                match self.bits {
                    false => BSY_A::INACTIVE,
                    true => BSY_A::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline(always)]
            pub fn is_inactive(&self) -> bool {
                *self == BSY_A::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == BSY_A::ACTIVE
            }
        }
        #[doc = "End of operation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOP_A {
            #[doc = "0: No EOP operation occurred"]
            NOEVENT = 0,
            #[doc = "1: An EOP event occurred"]
            EVENT = 1,
        }
        impl From<EOP_A> for bool {
            #[inline(always)]
            fn from(variant: EOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOP`"]
        pub type EOP_R = crate::R<bool, EOP_A>;
        impl EOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOP_A {
                match self.bits {
                    false => EOP_A::NOEVENT,
                    true => EOP_A::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == EOP_A::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                *self == EOP_A::EVENT
            }
        }
        #[doc = "Write proxy for field `EOP`"]
        pub struct EOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No EOP operation occurred"]
            #[inline(always)]
            pub fn no_event(self) -> &'a mut W {
                self.variant(EOP_A::NOEVENT)
            }
            #[doc = "An EOP event occurred"]
            #[inline(always)]
            pub fn event(self) -> &'a mut W {
                self.variant(EOP_A::EVENT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "End of high voltage\n\nValue on reset: 1"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDHV_A {
            #[doc = "0: High voltage is executing a write/erase operation in the NVM"]
            ACTIVE = 0,
            #[doc = "1: High voltage is off, no write/erase operation is ongoing"]
            INACTIVE = 1,
        }
        impl From<ENDHV_A> for bool {
            #[inline(always)]
            fn from(variant: ENDHV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ENDHV`"]
        pub type ENDHV_R = crate::R<bool, ENDHV_A>;
        impl ENDHV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENDHV_A {
                match self.bits {
                    false => ENDHV_A::ACTIVE,
                    true => ENDHV_A::INACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == ENDHV_A::ACTIVE
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline(always)]
            pub fn is_inactive(&self) -> bool {
                *self == ENDHV_A::INACTIVE
            }
        }
        #[doc = "Flash memory module ready after low power mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READY_A {
            #[doc = "0: The NVM is not ready"]
            NOTREADY = 0,
            #[doc = "1: The NVM is ready"]
            READY = 1,
        }
        impl From<READY_A> for bool {
            #[inline(always)]
            fn from(variant: READY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `READY`"]
        pub type READY_R = crate::R<bool, READY_A>;
        impl READY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> READY_A {
                match self.bits {
                    false => READY_A::NOTREADY,
                    true => READY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == READY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == READY_A::READY
            }
        }
        #[doc = "Write protected error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WRPERR_A {
            #[doc = "0: No protection error happened"]
            NOERROR = 0,
            #[doc = "1: One protection error happened"]
            ERROR = 1,
        }
        impl From<WRPERR_A> for bool {
            #[inline(always)]
            fn from(variant: WRPERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WRPERR`"]
        pub type WRPERR_R = crate::R<bool, WRPERR_A>;
        impl WRPERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WRPERR_A {
                match self.bits {
                    false => WRPERR_A::NOERROR,
                    true => WRPERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == WRPERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == WRPERR_A::ERROR
            }
        }
        #[doc = "Write protected error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WRPERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<WRPERR_AW> for bool {
            #[inline(always)]
            fn from(variant: WRPERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `WRPERR`"]
        pub struct WRPERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRPERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WRPERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(WRPERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Programming alignment error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PGAERR_A {
            #[doc = "0: No alignment error happened"]
            NOERROR = 0,
            #[doc = "1: One alignment error happened"]
            ERROR = 1,
        }
        impl From<PGAERR_A> for bool {
            #[inline(always)]
            fn from(variant: PGAERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PGAERR`"]
        pub type PGAERR_R = crate::R<bool, PGAERR_A>;
        impl PGAERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PGAERR_A {
                match self.bits {
                    false => PGAERR_A::NOERROR,
                    true => PGAERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == PGAERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == PGAERR_A::ERROR
            }
        }
        #[doc = "Programming alignment error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PGAERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<PGAERR_AW> for bool {
            #[inline(always)]
            fn from(variant: PGAERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `PGAERR`"]
        pub struct PGAERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PGAERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PGAERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PGAERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Size error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SIZERR_A {
            #[doc = "0: No size error happened"]
            NOERROR = 0,
            #[doc = "1: One size error happened"]
            ERROR = 1,
        }
        impl From<SIZERR_A> for bool {
            #[inline(always)]
            fn from(variant: SIZERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SIZERR`"]
        pub type SIZERR_R = crate::R<bool, SIZERR_A>;
        impl SIZERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SIZERR_A {
                match self.bits {
                    false => SIZERR_A::NOERROR,
                    true => SIZERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == SIZERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == SIZERR_A::ERROR
            }
        }
        #[doc = "Size error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SIZERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<SIZERR_AW> for bool {
            #[inline(always)]
            fn from(variant: SIZERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `SIZERR`"]
        pub struct SIZERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SIZERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SIZERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(SIZERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Option validity error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPTVERR_A {
            #[doc = "0: No error happened during the Option bytes loading"]
            NOERROR = 0,
            #[doc = "1: One or more errors happened during the Option bytes loading"]
            ERROR = 1,
        }
        impl From<OPTVERR_A> for bool {
            #[inline(always)]
            fn from(variant: OPTVERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPTVERR`"]
        pub type OPTVERR_R = crate::R<bool, OPTVERR_A>;
        impl OPTVERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPTVERR_A {
                match self.bits {
                    false => OPTVERR_A::NOERROR,
                    true => OPTVERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == OPTVERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == OPTVERR_A::ERROR
            }
        }
        #[doc = "Option validity error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPTVERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<OPTVERR_AW> for bool {
            #[inline(always)]
            fn from(variant: OPTVERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `OPTVERR`"]
        pub struct OPTVERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTVERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPTVERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(OPTVERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "RDERR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RDERR_A {
            #[doc = "0: No read protection error happened."]
            NOERROR = 0,
            #[doc = "1: One read protection error happened"]
            ERROR = 1,
        }
        impl From<RDERR_A> for bool {
            #[inline(always)]
            fn from(variant: RDERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RDERR`"]
        pub type RDERR_R = crate::R<bool, RDERR_A>;
        impl RDERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RDERR_A {
                match self.bits {
                    false => RDERR_A::NOERROR,
                    true => RDERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == RDERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == RDERR_A::ERROR
            }
        }
        #[doc = "RDERR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RDERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<RDERR_AW> for bool {
            #[inline(always)]
            fn from(variant: RDERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RDERR`"]
        pub struct RDERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RDERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RDERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RDERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "NOTZEROERR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOTZEROERR_A {
            #[doc = "0: The write operation is done in an erased region or the memory interface can apply an erase before a write"]
            NOEVENT = 0,
            #[doc = "1: The write operation is attempting to write to a not-erased region and the memory interface cannot apply an erase before a write"]
            EVENT = 1,
        }
        impl From<NOTZEROERR_A> for bool {
            #[inline(always)]
            fn from(variant: NOTZEROERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `NOTZEROERR`"]
        pub type NOTZEROERR_R = crate::R<bool, NOTZEROERR_A>;
        impl NOTZEROERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> NOTZEROERR_A {
                match self.bits {
                    false => NOTZEROERR_A::NOEVENT,
                    true => NOTZEROERR_A::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == NOTZEROERR_A::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                *self == NOTZEROERR_A::EVENT
            }
        }
        #[doc = "NOTZEROERR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOTZEROERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<NOTZEROERR_AW> for bool {
            #[inline(always)]
            fn from(variant: NOTZEROERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `NOTZEROERR`"]
        pub struct NOTZEROERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NOTZEROERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NOTZEROERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(NOTZEROERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "FWWERR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FWWERR_A {
            #[doc = "0: No write/erase operation aborted to perform a fetch"]
            NOERROR = 0,
            #[doc = "1: A write/erase operation aborted to perform a fetch"]
            ERROR = 1,
        }
        impl From<FWWERR_A> for bool {
            #[inline(always)]
            fn from(variant: FWWERR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FWWERR`"]
        pub type FWWERR_R = crate::R<bool, FWWERR_A>;
        impl FWWERR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FWWERR_A {
                match self.bits {
                    false => FWWERR_A::NOERROR,
                    true => FWWERR_A::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == FWWERR_A::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == FWWERR_A::ERROR
            }
        }
        #[doc = "FWWERR\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FWWERR_AW {
            #[doc = "1: Clear the flag"]
            CLEAR = 1,
        }
        impl From<FWWERR_AW> for bool {
            #[inline(always)]
            fn from(variant: FWWERR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `FWWERR`"]
        pub struct FWWERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FWWERR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FWWERR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(FWWERR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Write/erase operations in progress"]
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - End of operation"]
            #[inline(always)]
            pub fn eop(&self) -> EOP_R {
                EOP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - End of high voltage"]
            #[inline(always)]
            pub fn endhv(&self) -> ENDHV_R {
                ENDHV_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Flash memory module ready after low power mode"]
            #[inline(always)]
            pub fn ready(&self) -> READY_R {
                READY_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Write protected error"]
            #[inline(always)]
            pub fn wrperr(&self) -> WRPERR_R {
                WRPERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Programming alignment error"]
            #[inline(always)]
            pub fn pgaerr(&self) -> PGAERR_R {
                PGAERR_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Size error"]
            #[inline(always)]
            pub fn sizerr(&self) -> SIZERR_R {
                SIZERR_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Option validity error"]
            #[inline(always)]
            pub fn optverr(&self) -> OPTVERR_R {
                OPTVERR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 14 - RDERR"]
            #[inline(always)]
            pub fn rderr(&self) -> RDERR_R {
                RDERR_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 16 - NOTZEROERR"]
            #[inline(always)]
            pub fn notzeroerr(&self) -> NOTZEROERR_R {
                NOTZEROERR_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - FWWERR"]
            #[inline(always)]
            pub fn fwwerr(&self) -> FWWERR_R {
                FWWERR_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - End of operation"]
            #[inline(always)]
            pub fn eop(&mut self) -> EOP_W {
                EOP_W { w: self }
            }
            #[doc = "Bit 8 - Write protected error"]
            #[inline(always)]
            pub fn wrperr(&mut self) -> WRPERR_W {
                WRPERR_W { w: self }
            }
            #[doc = "Bit 9 - Programming alignment error"]
            #[inline(always)]
            pub fn pgaerr(&mut self) -> PGAERR_W {
                PGAERR_W { w: self }
            }
            #[doc = "Bit 10 - Size error"]
            #[inline(always)]
            pub fn sizerr(&mut self) -> SIZERR_W {
                SIZERR_W { w: self }
            }
            #[doc = "Bit 11 - Option validity error"]
            #[inline(always)]
            pub fn optverr(&mut self) -> OPTVERR_W {
                OPTVERR_W { w: self }
            }
            #[doc = "Bit 14 - RDERR"]
            #[inline(always)]
            pub fn rderr(&mut self) -> RDERR_W {
                RDERR_W { w: self }
            }
            #[doc = "Bit 16 - NOTZEROERR"]
            #[inline(always)]
            pub fn notzeroerr(&mut self) -> NOTZEROERR_W {
                NOTZEROERR_W { w: self }
            }
            #[doc = "Bit 17 - FWWERR"]
            #[inline(always)]
            pub fn fwwerr(&mut self) -> FWWERR_W {
                FWWERR_W { w: self }
            }
        }
    }
    #[doc = "Option byte register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [optr](optr) module"]
    pub type OPTR = crate::Reg<u32, _OPTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OPTR;
    #[doc = "`read()` method returns [optr::R](optr::R) reader structure"]
    impl crate::Readable for OPTR {}
    #[doc = "Option byte register"]
    pub mod optr {
        #[doc = "Reader of register OPTR"]
        pub type R = crate::R<u32, super::OPTR>;
        #[doc = "Read protection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum RDPROT_A {
            #[doc = "170: Level 0"]
            LEVEL0 = 170,
            #[doc = "0: Level 1"]
            LEVEL1 = 0,
            #[doc = "204: Level 2"]
            LEVEL2 = 204,
        }
        impl From<RDPROT_A> for u8 {
            #[inline(always)]
            fn from(variant: RDPROT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `RDPROT`"]
        pub type RDPROT_R = crate::R<u8, RDPROT_A>;
        impl RDPROT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, RDPROT_A> {
                use crate::Variant::*;
                match self.bits {
                    170 => Val(RDPROT_A::LEVEL0),
                    0 => Val(RDPROT_A::LEVEL1),
                    204 => Val(RDPROT_A::LEVEL2),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `LEVEL0`"]
            #[inline(always)]
            pub fn is_level0(&self) -> bool {
                *self == RDPROT_A::LEVEL0
            }
            #[doc = "Checks if the value of the field is `LEVEL1`"]
            #[inline(always)]
            pub fn is_level1(&self) -> bool {
                *self == RDPROT_A::LEVEL1
            }
            #[doc = "Checks if the value of the field is `LEVEL2`"]
            #[inline(always)]
            pub fn is_level2(&self) -> bool {
                *self == RDPROT_A::LEVEL2
            }
        }
        #[doc = "BOR_LEV\n\nValue on reset: 8"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum BOR_LEV_A {
            #[doc = "0: This is the reset threshold level for the 1.45 V - 1.55 V voltage range (power-down only)"]
            BOR_OFF = 0,
            #[doc = "1: Reset threshold level for VBOR0 (around 1.8 V)"]
            BOR_LEVEL1 = 1,
            #[doc = "2: Reset threshold level for VBOR1 (around 2.0 V)"]
            BOR_LEVEL2 = 2,
            #[doc = "3: Reset threshold level for VBOR2 (around 2.5 V)"]
            BOR_LEVEL3 = 3,
            #[doc = "4: Reset threshold level for VBOR3 (around 2.7 V)"]
            BOR_LEVEL4 = 4,
            #[doc = "5: Reset threshold level for VBOR4 (around 3.0 V)"]
            BOR_LEVEL5 = 5,
        }
        impl From<BOR_LEV_A> for u8 {
            #[inline(always)]
            fn from(variant: BOR_LEV_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `BOR_LEV`"]
        pub type BOR_LEV_R = crate::R<u8, BOR_LEV_A>;
        impl BOR_LEV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, BOR_LEV_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(BOR_LEV_A::BOR_OFF),
                    1 => Val(BOR_LEV_A::BOR_LEVEL1),
                    2 => Val(BOR_LEV_A::BOR_LEVEL2),
                    3 => Val(BOR_LEV_A::BOR_LEVEL3),
                    4 => Val(BOR_LEV_A::BOR_LEVEL4),
                    5 => Val(BOR_LEV_A::BOR_LEVEL5),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `BOR_OFF`"]
            #[inline(always)]
            pub fn is_bor_off(&self) -> bool {
                *self == BOR_LEV_A::BOR_OFF
            }
            #[doc = "Checks if the value of the field is `BOR_LEVEL1`"]
            #[inline(always)]
            pub fn is_bor_level1(&self) -> bool {
                *self == BOR_LEV_A::BOR_LEVEL1
            }
            #[doc = "Checks if the value of the field is `BOR_LEVEL2`"]
            #[inline(always)]
            pub fn is_bor_level2(&self) -> bool {
                *self == BOR_LEV_A::BOR_LEVEL2
            }
            #[doc = "Checks if the value of the field is `BOR_LEVEL3`"]
            #[inline(always)]
            pub fn is_bor_level3(&self) -> bool {
                *self == BOR_LEV_A::BOR_LEVEL3
            }
            #[doc = "Checks if the value of the field is `BOR_LEVEL4`"]
            #[inline(always)]
            pub fn is_bor_level4(&self) -> bool {
                *self == BOR_LEV_A::BOR_LEVEL4
            }
            #[doc = "Checks if the value of the field is `BOR_LEVEL5`"]
            #[inline(always)]
            pub fn is_bor_level5(&self) -> bool {
                *self == BOR_LEV_A::BOR_LEVEL5
            }
        }
        #[doc = "Selection of protection mode of WPR bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WPRMOD_A {
            #[doc = "0: PCROP disabled. The WRPROT bits are used as a write protection on a sector."]
            DISABLED = 0,
            #[doc = "1: PCROP enabled. The WRPROT bits are used as a read protection on a sector."]
            ENABLED = 1,
        }
        impl From<WPRMOD_A> for bool {
            #[inline(always)]
            fn from(variant: WPRMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WPRMOD`"]
        pub type WPRMOD_R = crate::R<bool, WPRMOD_A>;
        impl WPRMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WPRMOD_A {
                match self.bits {
                    false => WPRMOD_A::DISABLED,
                    true => WPRMOD_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WPRMOD_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WPRMOD_A::ENABLED
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Read protection"]
            #[inline(always)]
            pub fn rdprot(&self) -> RDPROT_R {
                RDPROT_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 16:19 - BOR_LEV"]
            #[inline(always)]
            pub fn bor_lev(&self) -> BOR_LEV_R {
                BOR_LEV_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bit 8 - Selection of protection mode of WPR bits"]
            #[inline(always)]
            pub fn wprmod(&self) -> WPRMOD_R {
                WPRMOD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
    }
    #[doc = "Write Protection Register 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wrprot1](wrprot1) module"]
    pub type WRPROT1 = crate::Reg<u32, _WRPROT1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _WRPROT1;
    #[doc = "`read()` method returns [wrprot1::R](wrprot1::R) reader structure"]
    impl crate::Readable for WRPROT1 {}
    #[doc = "Write Protection Register 1"]
    pub mod wrprot1 {
        #[doc = "Reader of register WRPROT1"]
        pub type R = crate::R<u32, super::WRPROT1>;
        #[doc = "Reader of field `WRPROT1`"]
        pub type WRPROT1_R = crate::R<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Write Protection"]
            #[inline(always)]
            pub fn wrprot1(&self) -> WRPROT1_R {
                WRPROT1_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
    }
    #[doc = "Write Protection Register 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wrprot2](wrprot2) module"]
    pub type WRPROT2 = crate::Reg<u32, _WRPROT2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _WRPROT2;
    #[doc = "`read()` method returns [wrprot2::R](wrprot2::R) reader structure"]
    impl crate::Readable for WRPROT2 {}
    #[doc = "Write Protection Register 2"]
    pub mod wrprot2 {
        #[doc = "Reader of register WRPROT2"]
        pub type R = crate::R<u32, super::WRPROT2>;
        #[doc = "Reader of field `WRPROT2`"]
        pub type WRPROT2_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Write Protection"]
            #[inline(always)]
            pub fn wrprot2(&self) -> WRPROT2_R {
                WRPROT2_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
}
#[doc = "External interrupt/event controller"]
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        0x4001_0400 as *const _
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*EXTI::ptr() }
    }
}
#[doc = "External interrupt/event controller"]
pub mod exti {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt mask register (EXTI_IMR)"]
        pub imr: IMR,
        #[doc = "0x04 - Event mask register (EXTI_EMR)"]
        pub emr: EMR,
        #[doc = "0x08 - Rising Trigger selection register (EXTI_RTSR)"]
        pub rtsr: RTSR,
        #[doc = "0x0c - Falling Trigger selection register (EXTI_FTSR)"]
        pub ftsr: FTSR,
        #[doc = "0x10 - Software interrupt event register (EXTI_SWIER)"]
        pub swier: SWIER,
        #[doc = "0x14 - Pending register (EXTI_PR)"]
        pub pr: PR,
    }
    #[doc = "Interrupt mask register (EXTI_IMR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [imr](imr) module"]
    pub type IMR = crate::Reg<u32, _IMR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IMR;
    #[doc = "`read()` method returns [imr::R](imr::R) reader structure"]
    impl crate::Readable for IMR {}
    #[doc = "`write(|w| ..)` method takes [imr::W](imr::W) writer structure"]
    impl crate::Writable for IMR {}
    #[doc = "Interrupt mask register (EXTI_IMR)"]
    pub mod imr {
        #[doc = "Reader of register IMR"]
        pub type R = crate::R<u32, super::IMR>;
        #[doc = "Writer for register IMR"]
        pub type W = crate::W<u32, super::IMR>;
        #[doc = "Register IMR `reset()`'s with value 0xff84_0000"]
        impl crate::ResetValue for super::IMR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xff84_0000
            }
        }
        #[doc = "Interrupt Mask on line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IM0_A {
            #[doc = "0: Interrupt request line is masked"]
            MASKED = 0,
            #[doc = "1: Interrupt request line is unmasked"]
            UNMASKED = 1,
        }
        impl From<IM0_A> for bool {
            #[inline(always)]
            fn from(variant: IM0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IM0`"]
        pub type IM0_R = crate::R<bool, IM0_A>;
        impl IM0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IM0_A {
                match self.bits {
                    false => IM0_A::MASKED,
                    true => IM0_A::UNMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == IM0_A::MASKED
            }
            #[doc = "Checks if the value of the field is `UNMASKED`"]
            #[inline(always)]
            pub fn is_unmasked(&self) -> bool {
                *self == IM0_A::UNMASKED
            }
        }
        #[doc = "Write proxy for field `IM0`"]
        pub struct IM0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 1"]
        pub type IM1_A = IM0_A;
        #[doc = "Reader of field `IM1`"]
        pub type IM1_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM1`"]
        pub struct IM1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 2"]
        pub type IM2_A = IM0_A;
        #[doc = "Reader of field `IM2`"]
        pub type IM2_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM2`"]
        pub struct IM2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 3"]
        pub type IM3_A = IM0_A;
        #[doc = "Reader of field `IM3`"]
        pub type IM3_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM3`"]
        pub struct IM3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 4"]
        pub type IM4_A = IM0_A;
        #[doc = "Reader of field `IM4`"]
        pub type IM4_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM4`"]
        pub struct IM4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 5"]
        pub type IM5_A = IM0_A;
        #[doc = "Reader of field `IM5`"]
        pub type IM5_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM5`"]
        pub struct IM5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 6"]
        pub type IM6_A = IM0_A;
        #[doc = "Reader of field `IM6`"]
        pub type IM6_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM6`"]
        pub struct IM6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 7"]
        pub type IM7_A = IM0_A;
        #[doc = "Reader of field `IM7`"]
        pub type IM7_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM7`"]
        pub struct IM7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 8"]
        pub type IM8_A = IM0_A;
        #[doc = "Reader of field `IM8`"]
        pub type IM8_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM8`"]
        pub struct IM8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 9"]
        pub type IM9_A = IM0_A;
        #[doc = "Reader of field `IM9`"]
        pub type IM9_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM9`"]
        pub struct IM9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 10"]
        pub type IM10_A = IM0_A;
        #[doc = "Reader of field `IM10`"]
        pub type IM10_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM10`"]
        pub struct IM10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 11"]
        pub type IM11_A = IM0_A;
        #[doc = "Reader of field `IM11`"]
        pub type IM11_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM11`"]
        pub struct IM11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 12"]
        pub type IM12_A = IM0_A;
        #[doc = "Reader of field `IM12`"]
        pub type IM12_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM12`"]
        pub struct IM12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 13"]
        pub type IM13_A = IM0_A;
        #[doc = "Reader of field `IM13`"]
        pub type IM13_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM13`"]
        pub struct IM13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 14"]
        pub type IM14_A = IM0_A;
        #[doc = "Reader of field `IM14`"]
        pub type IM14_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM14`"]
        pub struct IM14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 15"]
        pub type IM15_A = IM0_A;
        #[doc = "Reader of field `IM15`"]
        pub type IM15_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM15`"]
        pub struct IM15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 16"]
        pub type IM16_A = IM0_A;
        #[doc = "Reader of field `IM16`"]
        pub type IM16_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM16`"]
        pub struct IM16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 17"]
        pub type IM17_A = IM0_A;
        #[doc = "Reader of field `IM17`"]
        pub type IM17_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM17`"]
        pub struct IM17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 18"]
        pub type IM18_A = IM0_A;
        #[doc = "Reader of field `IM18`"]
        pub type IM18_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM18`"]
        pub struct IM18_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM18_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM18_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 19"]
        pub type IM19_A = IM0_A;
        #[doc = "Reader of field `IM19`"]
        pub type IM19_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM19`"]
        pub struct IM19_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM19_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM19_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 20"]
        pub type IM20_A = IM0_A;
        #[doc = "Reader of field `IM20`"]
        pub type IM20_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM20`"]
        pub struct IM20_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM20_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM20_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 21"]
        pub type IM21_A = IM0_A;
        #[doc = "Reader of field `IM21`"]
        pub type IM21_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM21`"]
        pub struct IM21_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM21_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM21_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 22"]
        pub type IM22_A = IM0_A;
        #[doc = "Reader of field `IM22`"]
        pub type IM22_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM22`"]
        pub struct IM22_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM22_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM22_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 23"]
        pub type IM23_A = IM0_A;
        #[doc = "Reader of field `IM23`"]
        pub type IM23_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM23`"]
        pub struct IM23_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM23_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM23_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 24"]
        pub type IM24_A = IM0_A;
        #[doc = "Reader of field `IM24`"]
        pub type IM24_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM24`"]
        pub struct IM24_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM24_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM24_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 25"]
        pub type IM25_A = IM0_A;
        #[doc = "Reader of field `IM25`"]
        pub type IM25_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM25`"]
        pub struct IM25_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM25_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM25_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 27"]
        pub type IM26_A = IM0_A;
        #[doc = "Reader of field `IM26`"]
        pub type IM26_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM26`"]
        pub struct IM26_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM26_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM26_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 27"]
        pub type IM28_A = IM0_A;
        #[doc = "Reader of field `IM28`"]
        pub type IM28_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM28`"]
        pub struct IM28_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM28_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM28_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Interrupt Mask on line 27"]
        pub type IM29_A = IM0_A;
        #[doc = "Reader of field `IM29`"]
        pub type IM29_R = crate::R<bool, IM0_A>;
        #[doc = "Write proxy for field `IM29`"]
        pub struct IM29_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IM29_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IM29_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(IM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(IM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline(always)]
            pub fn im0(&self) -> IM0_R {
                IM0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline(always)]
            pub fn im1(&self) -> IM1_R {
                IM1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline(always)]
            pub fn im2(&self) -> IM2_R {
                IM2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline(always)]
            pub fn im3(&self) -> IM3_R {
                IM3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline(always)]
            pub fn im4(&self) -> IM4_R {
                IM4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline(always)]
            pub fn im5(&self) -> IM5_R {
                IM5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline(always)]
            pub fn im6(&self) -> IM6_R {
                IM6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline(always)]
            pub fn im7(&self) -> IM7_R {
                IM7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline(always)]
            pub fn im8(&self) -> IM8_R {
                IM8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline(always)]
            pub fn im9(&self) -> IM9_R {
                IM9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline(always)]
            pub fn im10(&self) -> IM10_R {
                IM10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline(always)]
            pub fn im11(&self) -> IM11_R {
                IM11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline(always)]
            pub fn im12(&self) -> IM12_R {
                IM12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline(always)]
            pub fn im13(&self) -> IM13_R {
                IM13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline(always)]
            pub fn im14(&self) -> IM14_R {
                IM14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline(always)]
            pub fn im15(&self) -> IM15_R {
                IM15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline(always)]
            pub fn im16(&self) -> IM16_R {
                IM16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline(always)]
            pub fn im17(&self) -> IM17_R {
                IM17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Interrupt Mask on line 18"]
            #[inline(always)]
            pub fn im18(&self) -> IM18_R {
                IM18_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Interrupt Mask on line 19"]
            #[inline(always)]
            pub fn im19(&self) -> IM19_R {
                IM19_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Interrupt Mask on line 20"]
            #[inline(always)]
            pub fn im20(&self) -> IM20_R {
                IM20_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Interrupt Mask on line 21"]
            #[inline(always)]
            pub fn im21(&self) -> IM21_R {
                IM21_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Interrupt Mask on line 22"]
            #[inline(always)]
            pub fn im22(&self) -> IM22_R {
                IM22_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Interrupt Mask on line 23"]
            #[inline(always)]
            pub fn im23(&self) -> IM23_R {
                IM23_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Interrupt Mask on line 24"]
            #[inline(always)]
            pub fn im24(&self) -> IM24_R {
                IM24_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Interrupt Mask on line 25"]
            #[inline(always)]
            pub fn im25(&self) -> IM25_R {
                IM25_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26 - Interrupt Mask on line 27"]
            #[inline(always)]
            pub fn im26(&self) -> IM26_R {
                IM26_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Interrupt Mask on line 27"]
            #[inline(always)]
            pub fn im28(&self) -> IM28_R {
                IM28_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29 - Interrupt Mask on line 27"]
            #[inline(always)]
            pub fn im29(&self) -> IM29_R {
                IM29_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline(always)]
            pub fn im0(&mut self) -> IM0_W {
                IM0_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline(always)]
            pub fn im1(&mut self) -> IM1_W {
                IM1_W { w: self }
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline(always)]
            pub fn im2(&mut self) -> IM2_W {
                IM2_W { w: self }
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline(always)]
            pub fn im3(&mut self) -> IM3_W {
                IM3_W { w: self }
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline(always)]
            pub fn im4(&mut self) -> IM4_W {
                IM4_W { w: self }
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline(always)]
            pub fn im5(&mut self) -> IM5_W {
                IM5_W { w: self }
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline(always)]
            pub fn im6(&mut self) -> IM6_W {
                IM6_W { w: self }
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline(always)]
            pub fn im7(&mut self) -> IM7_W {
                IM7_W { w: self }
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline(always)]
            pub fn im8(&mut self) -> IM8_W {
                IM8_W { w: self }
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline(always)]
            pub fn im9(&mut self) -> IM9_W {
                IM9_W { w: self }
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline(always)]
            pub fn im10(&mut self) -> IM10_W {
                IM10_W { w: self }
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline(always)]
            pub fn im11(&mut self) -> IM11_W {
                IM11_W { w: self }
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline(always)]
            pub fn im12(&mut self) -> IM12_W {
                IM12_W { w: self }
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline(always)]
            pub fn im13(&mut self) -> IM13_W {
                IM13_W { w: self }
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline(always)]
            pub fn im14(&mut self) -> IM14_W {
                IM14_W { w: self }
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline(always)]
            pub fn im15(&mut self) -> IM15_W {
                IM15_W { w: self }
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline(always)]
            pub fn im16(&mut self) -> IM16_W {
                IM16_W { w: self }
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline(always)]
            pub fn im17(&mut self) -> IM17_W {
                IM17_W { w: self }
            }
            #[doc = "Bit 18 - Interrupt Mask on line 18"]
            #[inline(always)]
            pub fn im18(&mut self) -> IM18_W {
                IM18_W { w: self }
            }
            #[doc = "Bit 19 - Interrupt Mask on line 19"]
            #[inline(always)]
            pub fn im19(&mut self) -> IM19_W {
                IM19_W { w: self }
            }
            #[doc = "Bit 20 - Interrupt Mask on line 20"]
            #[inline(always)]
            pub fn im20(&mut self) -> IM20_W {
                IM20_W { w: self }
            }
            #[doc = "Bit 21 - Interrupt Mask on line 21"]
            #[inline(always)]
            pub fn im21(&mut self) -> IM21_W {
                IM21_W { w: self }
            }
            #[doc = "Bit 22 - Interrupt Mask on line 22"]
            #[inline(always)]
            pub fn im22(&mut self) -> IM22_W {
                IM22_W { w: self }
            }
            #[doc = "Bit 23 - Interrupt Mask on line 23"]
            #[inline(always)]
            pub fn im23(&mut self) -> IM23_W {
                IM23_W { w: self }
            }
            #[doc = "Bit 24 - Interrupt Mask on line 24"]
            #[inline(always)]
            pub fn im24(&mut self) -> IM24_W {
                IM24_W { w: self }
            }
            #[doc = "Bit 25 - Interrupt Mask on line 25"]
            #[inline(always)]
            pub fn im25(&mut self) -> IM25_W {
                IM25_W { w: self }
            }
            #[doc = "Bit 26 - Interrupt Mask on line 27"]
            #[inline(always)]
            pub fn im26(&mut self) -> IM26_W {
                IM26_W { w: self }
            }
            #[doc = "Bit 28 - Interrupt Mask on line 27"]
            #[inline(always)]
            pub fn im28(&mut self) -> IM28_W {
                IM28_W { w: self }
            }
            #[doc = "Bit 29 - Interrupt Mask on line 27"]
            #[inline(always)]
            pub fn im29(&mut self) -> IM29_W {
                IM29_W { w: self }
            }
        }
    }
    #[doc = "Event mask register (EXTI_EMR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [emr](emr) module"]
    pub type EMR = crate::Reg<u32, _EMR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EMR;
    #[doc = "`read()` method returns [emr::R](emr::R) reader structure"]
    impl crate::Readable for EMR {}
    #[doc = "`write(|w| ..)` method takes [emr::W](emr::W) writer structure"]
    impl crate::Writable for EMR {}
    #[doc = "Event mask register (EXTI_EMR)"]
    pub mod emr {
        #[doc = "Reader of register EMR"]
        pub type R = crate::R<u32, super::EMR>;
        #[doc = "Writer for register EMR"]
        pub type W = crate::W<u32, super::EMR>;
        #[doc = "Register EMR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EMR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Event Mask on line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EM0_A {
            #[doc = "0: Interrupt request line is masked"]
            MASKED = 0,
            #[doc = "1: Interrupt request line is unmasked"]
            UNMASKED = 1,
        }
        impl From<EM0_A> for bool {
            #[inline(always)]
            fn from(variant: EM0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EM0`"]
        pub type EM0_R = crate::R<bool, EM0_A>;
        impl EM0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EM0_A {
                match self.bits {
                    false => EM0_A::MASKED,
                    true => EM0_A::UNMASKED,
                }
            }
            #[doc = "Checks if the value of the field is `MASKED`"]
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                *self == EM0_A::MASKED
            }
            #[doc = "Checks if the value of the field is `UNMASKED`"]
            #[inline(always)]
            pub fn is_unmasked(&self) -> bool {
                *self == EM0_A::UNMASKED
            }
        }
        #[doc = "Write proxy for field `EM0`"]
        pub struct EM0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Event Mask on line 1"]
        pub type EM1_A = EM0_A;
        #[doc = "Reader of field `EM1`"]
        pub type EM1_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM1`"]
        pub struct EM1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Event Mask on line 2"]
        pub type EM2_A = EM0_A;
        #[doc = "Reader of field `EM2`"]
        pub type EM2_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM2`"]
        pub struct EM2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Event Mask on line 3"]
        pub type EM3_A = EM0_A;
        #[doc = "Reader of field `EM3`"]
        pub type EM3_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM3`"]
        pub struct EM3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Event Mask on line 4"]
        pub type EM4_A = EM0_A;
        #[doc = "Reader of field `EM4`"]
        pub type EM4_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM4`"]
        pub struct EM4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Event Mask on line 5"]
        pub type EM5_A = EM0_A;
        #[doc = "Reader of field `EM5`"]
        pub type EM5_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM5`"]
        pub struct EM5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Event Mask on line 6"]
        pub type EM6_A = EM0_A;
        #[doc = "Reader of field `EM6`"]
        pub type EM6_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM6`"]
        pub struct EM6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Event Mask on line 7"]
        pub type EM7_A = EM0_A;
        #[doc = "Reader of field `EM7`"]
        pub type EM7_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM7`"]
        pub struct EM7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Event Mask on line 8"]
        pub type EM8_A = EM0_A;
        #[doc = "Reader of field `EM8`"]
        pub type EM8_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM8`"]
        pub struct EM8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Event Mask on line 9"]
        pub type EM9_A = EM0_A;
        #[doc = "Reader of field `EM9`"]
        pub type EM9_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM9`"]
        pub struct EM9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Event Mask on line 10"]
        pub type EM10_A = EM0_A;
        #[doc = "Reader of field `EM10`"]
        pub type EM10_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM10`"]
        pub struct EM10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Event Mask on line 11"]
        pub type EM11_A = EM0_A;
        #[doc = "Reader of field `EM11`"]
        pub type EM11_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM11`"]
        pub struct EM11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Event Mask on line 12"]
        pub type EM12_A = EM0_A;
        #[doc = "Reader of field `EM12`"]
        pub type EM12_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM12`"]
        pub struct EM12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Event Mask on line 13"]
        pub type EM13_A = EM0_A;
        #[doc = "Reader of field `EM13`"]
        pub type EM13_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM13`"]
        pub struct EM13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Event Mask on line 14"]
        pub type EM14_A = EM0_A;
        #[doc = "Reader of field `EM14`"]
        pub type EM14_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM14`"]
        pub struct EM14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Event Mask on line 15"]
        pub type EM15_A = EM0_A;
        #[doc = "Reader of field `EM15`"]
        pub type EM15_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM15`"]
        pub struct EM15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Event Mask on line 16"]
        pub type EM16_A = EM0_A;
        #[doc = "Reader of field `EM16`"]
        pub type EM16_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM16`"]
        pub struct EM16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Event Mask on line 17"]
        pub type EM17_A = EM0_A;
        #[doc = "Reader of field `EM17`"]
        pub type EM17_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM17`"]
        pub struct EM17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Event Mask on line 18"]
        pub type EM18_A = EM0_A;
        #[doc = "Reader of field `EM18`"]
        pub type EM18_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM18`"]
        pub struct EM18_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM18_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM18_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Event Mask on line 19"]
        pub type EM19_A = EM0_A;
        #[doc = "Reader of field `EM19`"]
        pub type EM19_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM19`"]
        pub struct EM19_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM19_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM19_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Event Mask on line 20"]
        pub type EM20_A = EM0_A;
        #[doc = "Reader of field `EM20`"]
        pub type EM20_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM20`"]
        pub struct EM20_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM20_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM20_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Event Mask on line 21"]
        pub type EM21_A = EM0_A;
        #[doc = "Reader of field `EM21`"]
        pub type EM21_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM21`"]
        pub struct EM21_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM21_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM21_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Event Mask on line 22"]
        pub type EM22_A = EM0_A;
        #[doc = "Reader of field `EM22`"]
        pub type EM22_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM22`"]
        pub struct EM22_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM22_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM22_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Event Mask on line 23"]
        pub type EM23_A = EM0_A;
        #[doc = "Reader of field `EM23`"]
        pub type EM23_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM23`"]
        pub struct EM23_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM23_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM23_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Event Mask on line 24"]
        pub type EM24_A = EM0_A;
        #[doc = "Reader of field `EM24`"]
        pub type EM24_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM24`"]
        pub struct EM24_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM24_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM24_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Event Mask on line 25"]
        pub type EM25_A = EM0_A;
        #[doc = "Reader of field `EM25`"]
        pub type EM25_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM25`"]
        pub struct EM25_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM25_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM25_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Event Mask on line 26"]
        pub type EM26_A = EM0_A;
        #[doc = "Reader of field `EM26`"]
        pub type EM26_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM26`"]
        pub struct EM26_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM26_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM26_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Event Mask on line 28"]
        pub type EM28_A = EM0_A;
        #[doc = "Reader of field `EM28`"]
        pub type EM28_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM28`"]
        pub struct EM28_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM28_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM28_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Event Mask on line 29"]
        pub type EM29_A = EM0_A;
        #[doc = "Reader of field `EM29`"]
        pub type EM29_R = crate::R<bool, EM0_A>;
        #[doc = "Write proxy for field `EM29`"]
        pub struct EM29_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EM29_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EM29_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt request line is masked"]
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(EM0_A::MASKED)
            }
            #[doc = "Interrupt request line is unmasked"]
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(EM0_A::UNMASKED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline(always)]
            pub fn em0(&self) -> EM0_R {
                EM0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline(always)]
            pub fn em1(&self) -> EM1_R {
                EM1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline(always)]
            pub fn em2(&self) -> EM2_R {
                EM2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline(always)]
            pub fn em3(&self) -> EM3_R {
                EM3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline(always)]
            pub fn em4(&self) -> EM4_R {
                EM4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline(always)]
            pub fn em5(&self) -> EM5_R {
                EM5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline(always)]
            pub fn em6(&self) -> EM6_R {
                EM6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline(always)]
            pub fn em7(&self) -> EM7_R {
                EM7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline(always)]
            pub fn em8(&self) -> EM8_R {
                EM8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline(always)]
            pub fn em9(&self) -> EM9_R {
                EM9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline(always)]
            pub fn em10(&self) -> EM10_R {
                EM10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline(always)]
            pub fn em11(&self) -> EM11_R {
                EM11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline(always)]
            pub fn em12(&self) -> EM12_R {
                EM12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline(always)]
            pub fn em13(&self) -> EM13_R {
                EM13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline(always)]
            pub fn em14(&self) -> EM14_R {
                EM14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline(always)]
            pub fn em15(&self) -> EM15_R {
                EM15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline(always)]
            pub fn em16(&self) -> EM16_R {
                EM16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline(always)]
            pub fn em17(&self) -> EM17_R {
                EM17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Event Mask on line 18"]
            #[inline(always)]
            pub fn em18(&self) -> EM18_R {
                EM18_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Event Mask on line 19"]
            #[inline(always)]
            pub fn em19(&self) -> EM19_R {
                EM19_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Event Mask on line 20"]
            #[inline(always)]
            pub fn em20(&self) -> EM20_R {
                EM20_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Event Mask on line 21"]
            #[inline(always)]
            pub fn em21(&self) -> EM21_R {
                EM21_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Event Mask on line 22"]
            #[inline(always)]
            pub fn em22(&self) -> EM22_R {
                EM22_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Event Mask on line 23"]
            #[inline(always)]
            pub fn em23(&self) -> EM23_R {
                EM23_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Event Mask on line 24"]
            #[inline(always)]
            pub fn em24(&self) -> EM24_R {
                EM24_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Event Mask on line 25"]
            #[inline(always)]
            pub fn em25(&self) -> EM25_R {
                EM25_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26 - Event Mask on line 26"]
            #[inline(always)]
            pub fn em26(&self) -> EM26_R {
                EM26_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Event Mask on line 28"]
            #[inline(always)]
            pub fn em28(&self) -> EM28_R {
                EM28_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29 - Event Mask on line 29"]
            #[inline(always)]
            pub fn em29(&self) -> EM29_R {
                EM29_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline(always)]
            pub fn em0(&mut self) -> EM0_W {
                EM0_W { w: self }
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline(always)]
            pub fn em1(&mut self) -> EM1_W {
                EM1_W { w: self }
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline(always)]
            pub fn em2(&mut self) -> EM2_W {
                EM2_W { w: self }
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline(always)]
            pub fn em3(&mut self) -> EM3_W {
                EM3_W { w: self }
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline(always)]
            pub fn em4(&mut self) -> EM4_W {
                EM4_W { w: self }
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline(always)]
            pub fn em5(&mut self) -> EM5_W {
                EM5_W { w: self }
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline(always)]
            pub fn em6(&mut self) -> EM6_W {
                EM6_W { w: self }
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline(always)]
            pub fn em7(&mut self) -> EM7_W {
                EM7_W { w: self }
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline(always)]
            pub fn em8(&mut self) -> EM8_W {
                EM8_W { w: self }
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline(always)]
            pub fn em9(&mut self) -> EM9_W {
                EM9_W { w: self }
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline(always)]
            pub fn em10(&mut self) -> EM10_W {
                EM10_W { w: self }
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline(always)]
            pub fn em11(&mut self) -> EM11_W {
                EM11_W { w: self }
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline(always)]
            pub fn em12(&mut self) -> EM12_W {
                EM12_W { w: self }
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline(always)]
            pub fn em13(&mut self) -> EM13_W {
                EM13_W { w: self }
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline(always)]
            pub fn em14(&mut self) -> EM14_W {
                EM14_W { w: self }
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline(always)]
            pub fn em15(&mut self) -> EM15_W {
                EM15_W { w: self }
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline(always)]
            pub fn em16(&mut self) -> EM16_W {
                EM16_W { w: self }
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline(always)]
            pub fn em17(&mut self) -> EM17_W {
                EM17_W { w: self }
            }
            #[doc = "Bit 18 - Event Mask on line 18"]
            #[inline(always)]
            pub fn em18(&mut self) -> EM18_W {
                EM18_W { w: self }
            }
            #[doc = "Bit 19 - Event Mask on line 19"]
            #[inline(always)]
            pub fn em19(&mut self) -> EM19_W {
                EM19_W { w: self }
            }
            #[doc = "Bit 20 - Event Mask on line 20"]
            #[inline(always)]
            pub fn em20(&mut self) -> EM20_W {
                EM20_W { w: self }
            }
            #[doc = "Bit 21 - Event Mask on line 21"]
            #[inline(always)]
            pub fn em21(&mut self) -> EM21_W {
                EM21_W { w: self }
            }
            #[doc = "Bit 22 - Event Mask on line 22"]
            #[inline(always)]
            pub fn em22(&mut self) -> EM22_W {
                EM22_W { w: self }
            }
            #[doc = "Bit 23 - Event Mask on line 23"]
            #[inline(always)]
            pub fn em23(&mut self) -> EM23_W {
                EM23_W { w: self }
            }
            #[doc = "Bit 24 - Event Mask on line 24"]
            #[inline(always)]
            pub fn em24(&mut self) -> EM24_W {
                EM24_W { w: self }
            }
            #[doc = "Bit 25 - Event Mask on line 25"]
            #[inline(always)]
            pub fn em25(&mut self) -> EM25_W {
                EM25_W { w: self }
            }
            #[doc = "Bit 26 - Event Mask on line 26"]
            #[inline(always)]
            pub fn em26(&mut self) -> EM26_W {
                EM26_W { w: self }
            }
            #[doc = "Bit 28 - Event Mask on line 28"]
            #[inline(always)]
            pub fn em28(&mut self) -> EM28_W {
                EM28_W { w: self }
            }
            #[doc = "Bit 29 - Event Mask on line 29"]
            #[inline(always)]
            pub fn em29(&mut self) -> EM29_W {
                EM29_W { w: self }
            }
        }
    }
    #[doc = "Rising Trigger selection register (EXTI_RTSR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtsr](rtsr) module"]
    pub type RTSR = crate::Reg<u32, _RTSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RTSR;
    #[doc = "`read()` method returns [rtsr::R](rtsr::R) reader structure"]
    impl crate::Readable for RTSR {}
    #[doc = "`write(|w| ..)` method takes [rtsr::W](rtsr::W) writer structure"]
    impl crate::Writable for RTSR {}
    #[doc = "Rising Trigger selection register (EXTI_RTSR)"]
    pub mod rtsr {
        #[doc = "Reader of register RTSR"]
        pub type R = crate::R<u32, super::RTSR>;
        #[doc = "Writer for register RTSR"]
        pub type W = crate::W<u32, super::RTSR>;
        #[doc = "Register RTSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RTSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Rising trigger event configuration of line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RT0_A {
            #[doc = "0: Rising edge trigger is disabled"]
            DISABLED = 0,
            #[doc = "1: Rising edge trigger is enabled"]
            ENABLED = 1,
        }
        impl From<RT0_A> for bool {
            #[inline(always)]
            fn from(variant: RT0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RT0`"]
        pub type RT0_R = crate::R<bool, RT0_A>;
        impl RT0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RT0_A {
                match self.bits {
                    false => RT0_A::DISABLED,
                    true => RT0_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RT0_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RT0_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RT0`"]
        pub struct RT0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 1"]
        pub type RT1_A = RT0_A;
        #[doc = "Reader of field `RT1`"]
        pub type RT1_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT1`"]
        pub struct RT1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 2"]
        pub type RT2_A = RT0_A;
        #[doc = "Reader of field `RT2`"]
        pub type RT2_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT2`"]
        pub struct RT2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 3"]
        pub type RT3_A = RT0_A;
        #[doc = "Reader of field `RT3`"]
        pub type RT3_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT3`"]
        pub struct RT3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 4"]
        pub type RT4_A = RT0_A;
        #[doc = "Reader of field `RT4`"]
        pub type RT4_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT4`"]
        pub struct RT4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 5"]
        pub type RT5_A = RT0_A;
        #[doc = "Reader of field `RT5`"]
        pub type RT5_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT5`"]
        pub struct RT5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 6"]
        pub type RT6_A = RT0_A;
        #[doc = "Reader of field `RT6`"]
        pub type RT6_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT6`"]
        pub struct RT6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 7"]
        pub type RT7_A = RT0_A;
        #[doc = "Reader of field `RT7`"]
        pub type RT7_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT7`"]
        pub struct RT7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 8"]
        pub type RT8_A = RT0_A;
        #[doc = "Reader of field `RT8`"]
        pub type RT8_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT8`"]
        pub struct RT8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 9"]
        pub type RT9_A = RT0_A;
        #[doc = "Reader of field `RT9`"]
        pub type RT9_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT9`"]
        pub struct RT9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 10"]
        pub type RT10_A = RT0_A;
        #[doc = "Reader of field `RT10`"]
        pub type RT10_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT10`"]
        pub struct RT10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 11"]
        pub type RT11_A = RT0_A;
        #[doc = "Reader of field `RT11`"]
        pub type RT11_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT11`"]
        pub struct RT11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 12"]
        pub type RT12_A = RT0_A;
        #[doc = "Reader of field `RT12`"]
        pub type RT12_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT12`"]
        pub struct RT12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 13"]
        pub type RT13_A = RT0_A;
        #[doc = "Reader of field `RT13`"]
        pub type RT13_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT13`"]
        pub struct RT13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 14"]
        pub type RT14_A = RT0_A;
        #[doc = "Reader of field `RT14`"]
        pub type RT14_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT14`"]
        pub struct RT14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 15"]
        pub type RT15_A = RT0_A;
        #[doc = "Reader of field `RT15`"]
        pub type RT15_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT15`"]
        pub struct RT15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 16"]
        pub type RT16_A = RT0_A;
        #[doc = "Reader of field `RT16`"]
        pub type RT16_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT16`"]
        pub struct RT16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 17"]
        pub type RT17_A = RT0_A;
        #[doc = "Reader of field `RT17`"]
        pub type RT17_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT17`"]
        pub struct RT17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 19"]
        pub type RT19_A = RT0_A;
        #[doc = "Reader of field `RT19`"]
        pub type RT19_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT19`"]
        pub struct RT19_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT19_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT19_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 20"]
        pub type RT20_A = RT0_A;
        #[doc = "Reader of field `RT20`"]
        pub type RT20_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT20`"]
        pub struct RT20_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT20_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT20_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 21"]
        pub type RT21_A = RT0_A;
        #[doc = "Reader of field `RT21`"]
        pub type RT21_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT21`"]
        pub struct RT21_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT21_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT21_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Rising trigger event configuration of line 22"]
        pub type RT22_A = RT0_A;
        #[doc = "Reader of field `RT22`"]
        pub type RT22_R = crate::R<bool, RT0_A>;
        #[doc = "Write proxy for field `RT22`"]
        pub struct RT22_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RT22_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RT22_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Rising edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RT0_A::DISABLED)
            }
            #[doc = "Rising edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline(always)]
            pub fn rt0(&self) -> RT0_R {
                RT0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline(always)]
            pub fn rt1(&self) -> RT1_R {
                RT1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline(always)]
            pub fn rt2(&self) -> RT2_R {
                RT2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline(always)]
            pub fn rt3(&self) -> RT3_R {
                RT3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline(always)]
            pub fn rt4(&self) -> RT4_R {
                RT4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline(always)]
            pub fn rt5(&self) -> RT5_R {
                RT5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline(always)]
            pub fn rt6(&self) -> RT6_R {
                RT6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline(always)]
            pub fn rt7(&self) -> RT7_R {
                RT7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline(always)]
            pub fn rt8(&self) -> RT8_R {
                RT8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline(always)]
            pub fn rt9(&self) -> RT9_R {
                RT9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline(always)]
            pub fn rt10(&self) -> RT10_R {
                RT10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline(always)]
            pub fn rt11(&self) -> RT11_R {
                RT11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline(always)]
            pub fn rt12(&self) -> RT12_R {
                RT12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline(always)]
            pub fn rt13(&self) -> RT13_R {
                RT13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline(always)]
            pub fn rt14(&self) -> RT14_R {
                RT14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline(always)]
            pub fn rt15(&self) -> RT15_R {
                RT15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline(always)]
            pub fn rt16(&self) -> RT16_R {
                RT16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline(always)]
            pub fn rt17(&self) -> RT17_R {
                RT17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Rising trigger event configuration of line 19"]
            #[inline(always)]
            pub fn rt19(&self) -> RT19_R {
                RT19_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Rising trigger event configuration of line 20"]
            #[inline(always)]
            pub fn rt20(&self) -> RT20_R {
                RT20_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Rising trigger event configuration of line 21"]
            #[inline(always)]
            pub fn rt21(&self) -> RT21_R {
                RT21_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Rising trigger event configuration of line 22"]
            #[inline(always)]
            pub fn rt22(&self) -> RT22_R {
                RT22_R::new(((self.bits >> 22) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline(always)]
            pub fn rt0(&mut self) -> RT0_W {
                RT0_W { w: self }
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline(always)]
            pub fn rt1(&mut self) -> RT1_W {
                RT1_W { w: self }
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline(always)]
            pub fn rt2(&mut self) -> RT2_W {
                RT2_W { w: self }
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline(always)]
            pub fn rt3(&mut self) -> RT3_W {
                RT3_W { w: self }
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline(always)]
            pub fn rt4(&mut self) -> RT4_W {
                RT4_W { w: self }
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline(always)]
            pub fn rt5(&mut self) -> RT5_W {
                RT5_W { w: self }
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline(always)]
            pub fn rt6(&mut self) -> RT6_W {
                RT6_W { w: self }
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline(always)]
            pub fn rt7(&mut self) -> RT7_W {
                RT7_W { w: self }
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline(always)]
            pub fn rt8(&mut self) -> RT8_W {
                RT8_W { w: self }
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline(always)]
            pub fn rt9(&mut self) -> RT9_W {
                RT9_W { w: self }
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline(always)]
            pub fn rt10(&mut self) -> RT10_W {
                RT10_W { w: self }
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline(always)]
            pub fn rt11(&mut self) -> RT11_W {
                RT11_W { w: self }
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline(always)]
            pub fn rt12(&mut self) -> RT12_W {
                RT12_W { w: self }
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline(always)]
            pub fn rt13(&mut self) -> RT13_W {
                RT13_W { w: self }
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline(always)]
            pub fn rt14(&mut self) -> RT14_W {
                RT14_W { w: self }
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline(always)]
            pub fn rt15(&mut self) -> RT15_W {
                RT15_W { w: self }
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline(always)]
            pub fn rt16(&mut self) -> RT16_W {
                RT16_W { w: self }
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline(always)]
            pub fn rt17(&mut self) -> RT17_W {
                RT17_W { w: self }
            }
            #[doc = "Bit 19 - Rising trigger event configuration of line 19"]
            #[inline(always)]
            pub fn rt19(&mut self) -> RT19_W {
                RT19_W { w: self }
            }
            #[doc = "Bit 20 - Rising trigger event configuration of line 20"]
            #[inline(always)]
            pub fn rt20(&mut self) -> RT20_W {
                RT20_W { w: self }
            }
            #[doc = "Bit 21 - Rising trigger event configuration of line 21"]
            #[inline(always)]
            pub fn rt21(&mut self) -> RT21_W {
                RT21_W { w: self }
            }
            #[doc = "Bit 22 - Rising trigger event configuration of line 22"]
            #[inline(always)]
            pub fn rt22(&mut self) -> RT22_W {
                RT22_W { w: self }
            }
        }
    }
    #[doc = "Falling Trigger selection register (EXTI_FTSR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ftsr](ftsr) module"]
    pub type FTSR = crate::Reg<u32, _FTSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FTSR;
    #[doc = "`read()` method returns [ftsr::R](ftsr::R) reader structure"]
    impl crate::Readable for FTSR {}
    #[doc = "`write(|w| ..)` method takes [ftsr::W](ftsr::W) writer structure"]
    impl crate::Writable for FTSR {}
    #[doc = "Falling Trigger selection register (EXTI_FTSR)"]
    pub mod ftsr {
        #[doc = "Reader of register FTSR"]
        pub type R = crate::R<u32, super::FTSR>;
        #[doc = "Writer for register FTSR"]
        pub type W = crate::W<u32, super::FTSR>;
        #[doc = "Register FTSR `reset()`'s with value 0"]
        impl crate::ResetValue for super::FTSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Falling trigger event configuration of line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FT0_A {
            #[doc = "0: Falling edge trigger is disabled"]
            DISABLED = 0,
            #[doc = "1: Falling edge trigger is enabled"]
            ENABLED = 1,
        }
        impl From<FT0_A> for bool {
            #[inline(always)]
            fn from(variant: FT0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `FT0`"]
        pub type FT0_R = crate::R<bool, FT0_A>;
        impl FT0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FT0_A {
                match self.bits {
                    false => FT0_A::DISABLED,
                    true => FT0_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == FT0_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == FT0_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `FT0`"]
        pub struct FT0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 1"]
        pub type FT1_A = FT0_A;
        #[doc = "Reader of field `FT1`"]
        pub type FT1_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT1`"]
        pub struct FT1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 2"]
        pub type FT2_A = FT0_A;
        #[doc = "Reader of field `FT2`"]
        pub type FT2_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT2`"]
        pub struct FT2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 3"]
        pub type FT3_A = FT0_A;
        #[doc = "Reader of field `FT3`"]
        pub type FT3_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT3`"]
        pub struct FT3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 4"]
        pub type FT4_A = FT0_A;
        #[doc = "Reader of field `FT4`"]
        pub type FT4_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT4`"]
        pub struct FT4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 5"]
        pub type FT5_A = FT0_A;
        #[doc = "Reader of field `FT5`"]
        pub type FT5_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT5`"]
        pub struct FT5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 6"]
        pub type FT6_A = FT0_A;
        #[doc = "Reader of field `FT6`"]
        pub type FT6_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT6`"]
        pub struct FT6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 7"]
        pub type FT7_A = FT0_A;
        #[doc = "Reader of field `FT7`"]
        pub type FT7_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT7`"]
        pub struct FT7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 8"]
        pub type FT8_A = FT0_A;
        #[doc = "Reader of field `FT8`"]
        pub type FT8_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT8`"]
        pub struct FT8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 9"]
        pub type FT9_A = FT0_A;
        #[doc = "Reader of field `FT9`"]
        pub type FT9_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT9`"]
        pub struct FT9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 10"]
        pub type FT10_A = FT0_A;
        #[doc = "Reader of field `FT10`"]
        pub type FT10_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT10`"]
        pub struct FT10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 11"]
        pub type FT11_A = FT0_A;
        #[doc = "Reader of field `FT11`"]
        pub type FT11_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT11`"]
        pub struct FT11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 12"]
        pub type FT12_A = FT0_A;
        #[doc = "Reader of field `FT12`"]
        pub type FT12_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT12`"]
        pub struct FT12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 13"]
        pub type FT13_A = FT0_A;
        #[doc = "Reader of field `FT13`"]
        pub type FT13_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT13`"]
        pub struct FT13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 14"]
        pub type FT14_A = FT0_A;
        #[doc = "Reader of field `FT14`"]
        pub type FT14_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT14`"]
        pub struct FT14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 15"]
        pub type FT15_A = FT0_A;
        #[doc = "Reader of field `FT15`"]
        pub type FT15_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT15`"]
        pub struct FT15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 16"]
        pub type FT16_A = FT0_A;
        #[doc = "Reader of field `FT16`"]
        pub type FT16_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT16`"]
        pub struct FT16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 17"]
        pub type FT17_A = FT0_A;
        #[doc = "Reader of field `FT17`"]
        pub type FT17_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT17`"]
        pub struct FT17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 19"]
        pub type FT19_A = FT0_A;
        #[doc = "Reader of field `FT19`"]
        pub type FT19_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT19`"]
        pub struct FT19_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT19_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT19_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 20"]
        pub type FT20_A = FT0_A;
        #[doc = "Reader of field `FT20`"]
        pub type FT20_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT20`"]
        pub struct FT20_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT20_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT20_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 21"]
        pub type FT21_A = FT0_A;
        #[doc = "Reader of field `FT21`"]
        pub type FT21_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT21`"]
        pub struct FT21_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT21_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT21_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Falling trigger event configuration of line 22"]
        pub type FT22_A = FT0_A;
        #[doc = "Reader of field `FT22`"]
        pub type FT22_R = crate::R<bool, FT0_A>;
        #[doc = "Write proxy for field `FT22`"]
        pub struct FT22_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FT22_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FT22_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Falling edge trigger is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FT0_A::DISABLED)
            }
            #[doc = "Falling edge trigger is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FT0_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline(always)]
            pub fn ft0(&self) -> FT0_R {
                FT0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline(always)]
            pub fn ft1(&self) -> FT1_R {
                FT1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline(always)]
            pub fn ft2(&self) -> FT2_R {
                FT2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline(always)]
            pub fn ft3(&self) -> FT3_R {
                FT3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline(always)]
            pub fn ft4(&self) -> FT4_R {
                FT4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline(always)]
            pub fn ft5(&self) -> FT5_R {
                FT5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline(always)]
            pub fn ft6(&self) -> FT6_R {
                FT6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline(always)]
            pub fn ft7(&self) -> FT7_R {
                FT7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline(always)]
            pub fn ft8(&self) -> FT8_R {
                FT8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline(always)]
            pub fn ft9(&self) -> FT9_R {
                FT9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline(always)]
            pub fn ft10(&self) -> FT10_R {
                FT10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline(always)]
            pub fn ft11(&self) -> FT11_R {
                FT11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline(always)]
            pub fn ft12(&self) -> FT12_R {
                FT12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline(always)]
            pub fn ft13(&self) -> FT13_R {
                FT13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline(always)]
            pub fn ft14(&self) -> FT14_R {
                FT14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline(always)]
            pub fn ft15(&self) -> FT15_R {
                FT15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline(always)]
            pub fn ft16(&self) -> FT16_R {
                FT16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline(always)]
            pub fn ft17(&self) -> FT17_R {
                FT17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Falling trigger event configuration of line 19"]
            #[inline(always)]
            pub fn ft19(&self) -> FT19_R {
                FT19_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Falling trigger event configuration of line 20"]
            #[inline(always)]
            pub fn ft20(&self) -> FT20_R {
                FT20_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Falling trigger event configuration of line 21"]
            #[inline(always)]
            pub fn ft21(&self) -> FT21_R {
                FT21_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Falling trigger event configuration of line 22"]
            #[inline(always)]
            pub fn ft22(&self) -> FT22_R {
                FT22_R::new(((self.bits >> 22) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline(always)]
            pub fn ft0(&mut self) -> FT0_W {
                FT0_W { w: self }
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline(always)]
            pub fn ft1(&mut self) -> FT1_W {
                FT1_W { w: self }
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline(always)]
            pub fn ft2(&mut self) -> FT2_W {
                FT2_W { w: self }
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline(always)]
            pub fn ft3(&mut self) -> FT3_W {
                FT3_W { w: self }
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline(always)]
            pub fn ft4(&mut self) -> FT4_W {
                FT4_W { w: self }
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline(always)]
            pub fn ft5(&mut self) -> FT5_W {
                FT5_W { w: self }
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline(always)]
            pub fn ft6(&mut self) -> FT6_W {
                FT6_W { w: self }
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline(always)]
            pub fn ft7(&mut self) -> FT7_W {
                FT7_W { w: self }
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline(always)]
            pub fn ft8(&mut self) -> FT8_W {
                FT8_W { w: self }
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline(always)]
            pub fn ft9(&mut self) -> FT9_W {
                FT9_W { w: self }
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline(always)]
            pub fn ft10(&mut self) -> FT10_W {
                FT10_W { w: self }
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline(always)]
            pub fn ft11(&mut self) -> FT11_W {
                FT11_W { w: self }
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline(always)]
            pub fn ft12(&mut self) -> FT12_W {
                FT12_W { w: self }
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline(always)]
            pub fn ft13(&mut self) -> FT13_W {
                FT13_W { w: self }
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline(always)]
            pub fn ft14(&mut self) -> FT14_W {
                FT14_W { w: self }
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline(always)]
            pub fn ft15(&mut self) -> FT15_W {
                FT15_W { w: self }
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline(always)]
            pub fn ft16(&mut self) -> FT16_W {
                FT16_W { w: self }
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline(always)]
            pub fn ft17(&mut self) -> FT17_W {
                FT17_W { w: self }
            }
            #[doc = "Bit 19 - Falling trigger event configuration of line 19"]
            #[inline(always)]
            pub fn ft19(&mut self) -> FT19_W {
                FT19_W { w: self }
            }
            #[doc = "Bit 20 - Falling trigger event configuration of line 20"]
            #[inline(always)]
            pub fn ft20(&mut self) -> FT20_W {
                FT20_W { w: self }
            }
            #[doc = "Bit 21 - Falling trigger event configuration of line 21"]
            #[inline(always)]
            pub fn ft21(&mut self) -> FT21_W {
                FT21_W { w: self }
            }
            #[doc = "Bit 22 - Falling trigger event configuration of line 22"]
            #[inline(always)]
            pub fn ft22(&mut self) -> FT22_W {
                FT22_W { w: self }
            }
        }
    }
    #[doc = "Software interrupt event register (EXTI_SWIER)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swier](swier) module"]
    pub type SWIER = crate::Reg<u32, _SWIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SWIER;
    #[doc = "`read()` method returns [swier::R](swier::R) reader structure"]
    impl crate::Readable for SWIER {}
    #[doc = "`write(|w| ..)` method takes [swier::W](swier::W) writer structure"]
    impl crate::Writable for SWIER {}
    #[doc = "Software interrupt event register (EXTI_SWIER)"]
    pub mod swier {
        #[doc = "Reader of register SWIER"]
        pub type R = crate::R<u32, super::SWIER>;
        #[doc = "Writer for register SWIER"]
        pub type W = crate::W<u32, super::SWIER>;
        #[doc = "Register SWIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::SWIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Software Interrupt on line 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWI0_A {
            #[doc = "1: Generates an interrupt request"]
            PEND = 1,
        }
        impl From<SWI0_A> for bool {
            #[inline(always)]
            fn from(variant: SWI0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SWI0`"]
        pub type SWI0_R = crate::R<bool, SWI0_A>;
        impl SWI0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, SWI0_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(SWI0_A::PEND),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `PEND`"]
            #[inline(always)]
            pub fn is_pend(&self) -> bool {
                *self == SWI0_A::PEND
            }
        }
        #[doc = "Write proxy for field `SWI0`"]
        pub struct SWI0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 1"]
        pub type SWI1_A = SWI0_A;
        #[doc = "Reader of field `SWI1`"]
        pub type SWI1_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI1`"]
        pub struct SWI1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 2"]
        pub type SWI2_A = SWI0_A;
        #[doc = "Reader of field `SWI2`"]
        pub type SWI2_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI2`"]
        pub struct SWI2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 3"]
        pub type SWI3_A = SWI0_A;
        #[doc = "Reader of field `SWI3`"]
        pub type SWI3_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI3`"]
        pub struct SWI3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 4"]
        pub type SWI4_A = SWI0_A;
        #[doc = "Reader of field `SWI4`"]
        pub type SWI4_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI4`"]
        pub struct SWI4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 5"]
        pub type SWI5_A = SWI0_A;
        #[doc = "Reader of field `SWI5`"]
        pub type SWI5_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI5`"]
        pub struct SWI5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 6"]
        pub type SWI6_A = SWI0_A;
        #[doc = "Reader of field `SWI6`"]
        pub type SWI6_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI6`"]
        pub struct SWI6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 7"]
        pub type SWI7_A = SWI0_A;
        #[doc = "Reader of field `SWI7`"]
        pub type SWI7_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI7`"]
        pub struct SWI7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 8"]
        pub type SWI8_A = SWI0_A;
        #[doc = "Reader of field `SWI8`"]
        pub type SWI8_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI8`"]
        pub struct SWI8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 9"]
        pub type SWI9_A = SWI0_A;
        #[doc = "Reader of field `SWI9`"]
        pub type SWI9_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI9`"]
        pub struct SWI9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 10"]
        pub type SWI10_A = SWI0_A;
        #[doc = "Reader of field `SWI10`"]
        pub type SWI10_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI10`"]
        pub struct SWI10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 11"]
        pub type SWI11_A = SWI0_A;
        #[doc = "Reader of field `SWI11`"]
        pub type SWI11_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI11`"]
        pub struct SWI11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 12"]
        pub type SWI12_A = SWI0_A;
        #[doc = "Reader of field `SWI12`"]
        pub type SWI12_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI12`"]
        pub struct SWI12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 13"]
        pub type SWI13_A = SWI0_A;
        #[doc = "Reader of field `SWI13`"]
        pub type SWI13_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI13`"]
        pub struct SWI13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 14"]
        pub type SWI14_A = SWI0_A;
        #[doc = "Reader of field `SWI14`"]
        pub type SWI14_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI14`"]
        pub struct SWI14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 15"]
        pub type SWI15_A = SWI0_A;
        #[doc = "Reader of field `SWI15`"]
        pub type SWI15_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI15`"]
        pub struct SWI15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 16"]
        pub type SWI16_A = SWI0_A;
        #[doc = "Reader of field `SWI16`"]
        pub type SWI16_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI16`"]
        pub struct SWI16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 17"]
        pub type SWI17_A = SWI0_A;
        #[doc = "Reader of field `SWI17`"]
        pub type SWI17_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI17`"]
        pub struct SWI17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 19"]
        pub type SWI19_A = SWI0_A;
        #[doc = "Reader of field `SWI19`"]
        pub type SWI19_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI19`"]
        pub struct SWI19_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI19_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI19_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 20"]
        pub type SWI20_A = SWI0_A;
        #[doc = "Reader of field `SWI20`"]
        pub type SWI20_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI20`"]
        pub struct SWI20_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI20_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI20_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 21"]
        pub type SWI21_A = SWI0_A;
        #[doc = "Reader of field `SWI21`"]
        pub type SWI21_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI21`"]
        pub struct SWI21_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI21_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI21_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Software Interrupt on line 22"]
        pub type SWI22_A = SWI0_A;
        #[doc = "Reader of field `SWI22`"]
        pub type SWI22_R = crate::R<bool, SWI0_A>;
        #[doc = "Write proxy for field `SWI22`"]
        pub struct SWI22_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWI22_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWI22_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Generates an interrupt request"]
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWI0_A::PEND)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline(always)]
            pub fn swi0(&self) -> SWI0_R {
                SWI0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline(always)]
            pub fn swi1(&self) -> SWI1_R {
                SWI1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline(always)]
            pub fn swi2(&self) -> SWI2_R {
                SWI2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline(always)]
            pub fn swi3(&self) -> SWI3_R {
                SWI3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline(always)]
            pub fn swi4(&self) -> SWI4_R {
                SWI4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline(always)]
            pub fn swi5(&self) -> SWI5_R {
                SWI5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline(always)]
            pub fn swi6(&self) -> SWI6_R {
                SWI6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline(always)]
            pub fn swi7(&self) -> SWI7_R {
                SWI7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline(always)]
            pub fn swi8(&self) -> SWI8_R {
                SWI8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline(always)]
            pub fn swi9(&self) -> SWI9_R {
                SWI9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline(always)]
            pub fn swi10(&self) -> SWI10_R {
                SWI10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline(always)]
            pub fn swi11(&self) -> SWI11_R {
                SWI11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline(always)]
            pub fn swi12(&self) -> SWI12_R {
                SWI12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline(always)]
            pub fn swi13(&self) -> SWI13_R {
                SWI13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline(always)]
            pub fn swi14(&self) -> SWI14_R {
                SWI14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline(always)]
            pub fn swi15(&self) -> SWI15_R {
                SWI15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline(always)]
            pub fn swi16(&self) -> SWI16_R {
                SWI16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline(always)]
            pub fn swi17(&self) -> SWI17_R {
                SWI17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Software Interrupt on line 19"]
            #[inline(always)]
            pub fn swi19(&self) -> SWI19_R {
                SWI19_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Software Interrupt on line 20"]
            #[inline(always)]
            pub fn swi20(&self) -> SWI20_R {
                SWI20_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Software Interrupt on line 21"]
            #[inline(always)]
            pub fn swi21(&self) -> SWI21_R {
                SWI21_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Software Interrupt on line 22"]
            #[inline(always)]
            pub fn swi22(&self) -> SWI22_R {
                SWI22_R::new(((self.bits >> 22) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline(always)]
            pub fn swi0(&mut self) -> SWI0_W {
                SWI0_W { w: self }
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline(always)]
            pub fn swi1(&mut self) -> SWI1_W {
                SWI1_W { w: self }
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline(always)]
            pub fn swi2(&mut self) -> SWI2_W {
                SWI2_W { w: self }
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline(always)]
            pub fn swi3(&mut self) -> SWI3_W {
                SWI3_W { w: self }
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline(always)]
            pub fn swi4(&mut self) -> SWI4_W {
                SWI4_W { w: self }
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline(always)]
            pub fn swi5(&mut self) -> SWI5_W {
                SWI5_W { w: self }
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline(always)]
            pub fn swi6(&mut self) -> SWI6_W {
                SWI6_W { w: self }
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline(always)]
            pub fn swi7(&mut self) -> SWI7_W {
                SWI7_W { w: self }
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline(always)]
            pub fn swi8(&mut self) -> SWI8_W {
                SWI8_W { w: self }
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline(always)]
            pub fn swi9(&mut self) -> SWI9_W {
                SWI9_W { w: self }
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline(always)]
            pub fn swi10(&mut self) -> SWI10_W {
                SWI10_W { w: self }
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline(always)]
            pub fn swi11(&mut self) -> SWI11_W {
                SWI11_W { w: self }
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline(always)]
            pub fn swi12(&mut self) -> SWI12_W {
                SWI12_W { w: self }
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline(always)]
            pub fn swi13(&mut self) -> SWI13_W {
                SWI13_W { w: self }
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline(always)]
            pub fn swi14(&mut self) -> SWI14_W {
                SWI14_W { w: self }
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline(always)]
            pub fn swi15(&mut self) -> SWI15_W {
                SWI15_W { w: self }
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline(always)]
            pub fn swi16(&mut self) -> SWI16_W {
                SWI16_W { w: self }
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline(always)]
            pub fn swi17(&mut self) -> SWI17_W {
                SWI17_W { w: self }
            }
            #[doc = "Bit 19 - Software Interrupt on line 19"]
            #[inline(always)]
            pub fn swi19(&mut self) -> SWI19_W {
                SWI19_W { w: self }
            }
            #[doc = "Bit 20 - Software Interrupt on line 20"]
            #[inline(always)]
            pub fn swi20(&mut self) -> SWI20_W {
                SWI20_W { w: self }
            }
            #[doc = "Bit 21 - Software Interrupt on line 21"]
            #[inline(always)]
            pub fn swi21(&mut self) -> SWI21_W {
                SWI21_W { w: self }
            }
            #[doc = "Bit 22 - Software Interrupt on line 22"]
            #[inline(always)]
            pub fn swi22(&mut self) -> SWI22_W {
                SWI22_W { w: self }
            }
        }
    }
    #[doc = "Pending register (EXTI_PR)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pr](pr) module"]
    pub type PR = crate::Reg<u32, _PR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PR;
    #[doc = "`read()` method returns [pr::R](pr::R) reader structure"]
    impl crate::Readable for PR {}
    #[doc = "`write(|w| ..)` method takes [pr::W](pr::W) writer structure"]
    impl crate::Writable for PR {}
    #[doc = "Pending register (EXTI_PR)"]
    pub mod pr {
        #[doc = "Reader of register PR"]
        pub type R = crate::R<u32, super::PR>;
        #[doc = "Writer for register PR"]
        pub type W = crate::W<u32, super::PR>;
        #[doc = "Register PR `reset()`'s with value 0"]
        impl crate::ResetValue for super::PR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Pending bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIF0_A {
            #[doc = "0: No trigger request occurred"]
            NOTPENDING = 0,
            #[doc = "1: Selected trigger request occurred"]
            PENDING = 1,
        }
        impl From<PIF0_A> for bool {
            #[inline(always)]
            fn from(variant: PIF0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PIF0`"]
        pub type PIF0_R = crate::R<bool, PIF0_A>;
        impl PIF0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PIF0_A {
                match self.bits {
                    false => PIF0_A::NOTPENDING,
                    true => PIF0_A::PENDING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPENDING`"]
            #[inline(always)]
            pub fn is_not_pending(&self) -> bool {
                *self == PIF0_A::NOTPENDING
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                *self == PIF0_A::PENDING
            }
        }
        #[doc = "Pending bit 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIF0_AW {
            #[doc = "1: Clears pending bit"]
            CLEAR = 1,
        }
        impl From<PIF0_AW> for bool {
            #[inline(always)]
            fn from(variant: PIF0_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `PIF0`"]
        pub struct PIF0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF0_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Pending bit 1"]
        pub type PIF1_A = PIF0_A;
        #[doc = "Reader of field `PIF1`"]
        pub type PIF1_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 1"]
        pub type PIF1_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF1`"]
        pub struct PIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF1_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Pending bit 2"]
        pub type PIF2_A = PIF0_A;
        #[doc = "Reader of field `PIF2`"]
        pub type PIF2_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 2"]
        pub type PIF2_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF2`"]
        pub struct PIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF2_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Pending bit 3"]
        pub type PIF3_A = PIF0_A;
        #[doc = "Reader of field `PIF3`"]
        pub type PIF3_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 3"]
        pub type PIF3_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF3`"]
        pub struct PIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF3_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Pending bit 4"]
        pub type PIF4_A = PIF0_A;
        #[doc = "Reader of field `PIF4`"]
        pub type PIF4_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 4"]
        pub type PIF4_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF4`"]
        pub struct PIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF4_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Pending bit 5"]
        pub type PIF5_A = PIF0_A;
        #[doc = "Reader of field `PIF5`"]
        pub type PIF5_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 5"]
        pub type PIF5_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF5`"]
        pub struct PIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF5_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Pending bit 6"]
        pub type PIF6_A = PIF0_A;
        #[doc = "Reader of field `PIF6`"]
        pub type PIF6_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 6"]
        pub type PIF6_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF6`"]
        pub struct PIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF6_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Pending bit 7"]
        pub type PIF7_A = PIF0_A;
        #[doc = "Reader of field `PIF7`"]
        pub type PIF7_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 7"]
        pub type PIF7_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF7`"]
        pub struct PIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF7_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Pending bit 8"]
        pub type PIF8_A = PIF0_A;
        #[doc = "Reader of field `PIF8`"]
        pub type PIF8_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 8"]
        pub type PIF8_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF8`"]
        pub struct PIF8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF8_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Pending bit 9"]
        pub type PIF9_A = PIF0_A;
        #[doc = "Reader of field `PIF9`"]
        pub type PIF9_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 9"]
        pub type PIF9_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF9`"]
        pub struct PIF9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF9_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Pending bit 10"]
        pub type PIF10_A = PIF0_A;
        #[doc = "Reader of field `PIF10`"]
        pub type PIF10_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 10"]
        pub type PIF10_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF10`"]
        pub struct PIF10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF10_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Pending bit 11"]
        pub type PIF11_A = PIF0_A;
        #[doc = "Reader of field `PIF11`"]
        pub type PIF11_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 11"]
        pub type PIF11_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF11`"]
        pub struct PIF11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF11_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Pending bit 12"]
        pub type PIF12_A = PIF0_A;
        #[doc = "Reader of field `PIF12`"]
        pub type PIF12_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 12"]
        pub type PIF12_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF12`"]
        pub struct PIF12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF12_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Pending bit 13"]
        pub type PIF13_A = PIF0_A;
        #[doc = "Reader of field `PIF13`"]
        pub type PIF13_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 13"]
        pub type PIF13_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF13`"]
        pub struct PIF13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF13_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Pending bit 14"]
        pub type PIF14_A = PIF0_A;
        #[doc = "Reader of field `PIF14`"]
        pub type PIF14_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 14"]
        pub type PIF14_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF14`"]
        pub struct PIF14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF14_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Pending bit 15"]
        pub type PIF15_A = PIF0_A;
        #[doc = "Reader of field `PIF15`"]
        pub type PIF15_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 15"]
        pub type PIF15_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF15`"]
        pub struct PIF15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF15_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Pending bit 16"]
        pub type PIF16_A = PIF0_A;
        #[doc = "Reader of field `PIF16`"]
        pub type PIF16_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 16"]
        pub type PIF16_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF16`"]
        pub struct PIF16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF16_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Pending bit 17"]
        pub type PIF17_A = PIF0_A;
        #[doc = "Reader of field `PIF17`"]
        pub type PIF17_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 17"]
        pub type PIF17_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF17`"]
        pub struct PIF17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF17_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Pending bit 19"]
        pub type PIF19_A = PIF0_A;
        #[doc = "Reader of field `PIF19`"]
        pub type PIF19_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 19"]
        pub type PIF19_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF19`"]
        pub struct PIF19_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF19_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF19_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Pending bit 20"]
        pub type PIF20_A = PIF0_A;
        #[doc = "Reader of field `PIF20`"]
        pub type PIF20_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 20"]
        pub type PIF20_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF20`"]
        pub struct PIF20_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF20_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF20_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Pending bit 21"]
        pub type PIF21_A = PIF0_A;
        #[doc = "Reader of field `PIF21`"]
        pub type PIF21_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 21"]
        pub type PIF21_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF21`"]
        pub struct PIF21_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF21_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF21_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Pending bit 22"]
        pub type PIF22_A = PIF0_A;
        #[doc = "Reader of field `PIF22`"]
        pub type PIF22_R = crate::R<bool, PIF0_A>;
        #[doc = "Pending bit 22"]
        pub type PIF22_AW = PIF0_AW;
        #[doc = "Write proxy for field `PIF22`"]
        pub struct PIF22_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIF22_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIF22_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears pending bit"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIF0_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline(always)]
            pub fn pif0(&self) -> PIF0_R {
                PIF0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline(always)]
            pub fn pif1(&self) -> PIF1_R {
                PIF1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline(always)]
            pub fn pif2(&self) -> PIF2_R {
                PIF2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline(always)]
            pub fn pif3(&self) -> PIF3_R {
                PIF3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline(always)]
            pub fn pif4(&self) -> PIF4_R {
                PIF4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline(always)]
            pub fn pif5(&self) -> PIF5_R {
                PIF5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline(always)]
            pub fn pif6(&self) -> PIF6_R {
                PIF6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline(always)]
            pub fn pif7(&self) -> PIF7_R {
                PIF7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline(always)]
            pub fn pif8(&self) -> PIF8_R {
                PIF8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline(always)]
            pub fn pif9(&self) -> PIF9_R {
                PIF9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline(always)]
            pub fn pif10(&self) -> PIF10_R {
                PIF10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline(always)]
            pub fn pif11(&self) -> PIF11_R {
                PIF11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline(always)]
            pub fn pif12(&self) -> PIF12_R {
                PIF12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline(always)]
            pub fn pif13(&self) -> PIF13_R {
                PIF13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline(always)]
            pub fn pif14(&self) -> PIF14_R {
                PIF14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline(always)]
            pub fn pif15(&self) -> PIF15_R {
                PIF15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline(always)]
            pub fn pif16(&self) -> PIF16_R {
                PIF16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline(always)]
            pub fn pif17(&self) -> PIF17_R {
                PIF17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Pending bit 19"]
            #[inline(always)]
            pub fn pif19(&self) -> PIF19_R {
                PIF19_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Pending bit 20"]
            #[inline(always)]
            pub fn pif20(&self) -> PIF20_R {
                PIF20_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Pending bit 21"]
            #[inline(always)]
            pub fn pif21(&self) -> PIF21_R {
                PIF21_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Pending bit 22"]
            #[inline(always)]
            pub fn pif22(&self) -> PIF22_R {
                PIF22_R::new(((self.bits >> 22) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline(always)]
            pub fn pif0(&mut self) -> PIF0_W {
                PIF0_W { w: self }
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline(always)]
            pub fn pif1(&mut self) -> PIF1_W {
                PIF1_W { w: self }
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline(always)]
            pub fn pif2(&mut self) -> PIF2_W {
                PIF2_W { w: self }
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline(always)]
            pub fn pif3(&mut self) -> PIF3_W {
                PIF3_W { w: self }
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline(always)]
            pub fn pif4(&mut self) -> PIF4_W {
                PIF4_W { w: self }
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline(always)]
            pub fn pif5(&mut self) -> PIF5_W {
                PIF5_W { w: self }
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline(always)]
            pub fn pif6(&mut self) -> PIF6_W {
                PIF6_W { w: self }
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline(always)]
            pub fn pif7(&mut self) -> PIF7_W {
                PIF7_W { w: self }
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline(always)]
            pub fn pif8(&mut self) -> PIF8_W {
                PIF8_W { w: self }
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline(always)]
            pub fn pif9(&mut self) -> PIF9_W {
                PIF9_W { w: self }
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline(always)]
            pub fn pif10(&mut self) -> PIF10_W {
                PIF10_W { w: self }
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline(always)]
            pub fn pif11(&mut self) -> PIF11_W {
                PIF11_W { w: self }
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline(always)]
            pub fn pif12(&mut self) -> PIF12_W {
                PIF12_W { w: self }
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline(always)]
            pub fn pif13(&mut self) -> PIF13_W {
                PIF13_W { w: self }
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline(always)]
            pub fn pif14(&mut self) -> PIF14_W {
                PIF14_W { w: self }
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline(always)]
            pub fn pif15(&mut self) -> PIF15_W {
                PIF15_W { w: self }
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline(always)]
            pub fn pif16(&mut self) -> PIF16_W {
                PIF16_W { w: self }
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline(always)]
            pub fn pif17(&mut self) -> PIF17_W {
                PIF17_W { w: self }
            }
            #[doc = "Bit 19 - Pending bit 19"]
            #[inline(always)]
            pub fn pif19(&mut self) -> PIF19_W {
                PIF19_W { w: self }
            }
            #[doc = "Bit 20 - Pending bit 20"]
            #[inline(always)]
            pub fn pif20(&mut self) -> PIF20_W {
                PIF20_W { w: self }
            }
            #[doc = "Bit 21 - Pending bit 21"]
            #[inline(always)]
            pub fn pif21(&mut self) -> PIF21_W {
                PIF21_W { w: self }
            }
            #[doc = "Bit 22 - Pending bit 22"]
            #[inline(always)]
            pub fn pif22(&mut self) -> PIF22_W {
                PIF22_W { w: self }
            }
        }
    }
}
#[doc = "Analog-to-digital converter"]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        0x4001_2400 as *const _
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*ADC::ptr() }
    }
}
#[doc = "Analog-to-digital converter"]
pub mod adc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - interrupt and status register"]
        pub isr: ISR,
        #[doc = "0x04 - interrupt enable register"]
        pub ier: IER,
        #[doc = "0x08 - control register"]
        pub cr: CR,
        #[doc = "0x0c - configuration register 1"]
        pub cfgr1: CFGR1,
        #[doc = "0x10 - configuration register 2"]
        pub cfgr2: CFGR2,
        #[doc = "0x14 - sampling time register"]
        pub smpr: SMPR,
        _reserved6: [u8; 8usize],
        #[doc = "0x20 - watchdog threshold register"]
        pub tr: TR,
        _reserved7: [u8; 4usize],
        #[doc = "0x28 - channel selection register"]
        pub chselr: CHSELR,
        _reserved8: [u8; 20usize],
        #[doc = "0x40 - data register"]
        pub dr: DR,
        _reserved9: [u8; 112usize],
        #[doc = "0xb4 - ADC Calibration factor"]
        pub calfact: CALFACT,
        _reserved10: [u8; 592usize],
        #[doc = "0x308 - ADC common configuration register"]
        pub ccr: CCR,
    }
    #[doc = "interrupt and status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "`write(|w| ..)` method takes [isr::W](isr::W) writer structure"]
    impl crate::Writable for ISR {}
    #[doc = "interrupt and status register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Writer for register ISR"]
        pub type W = crate::W<u32, super::ISR>;
        #[doc = "Register ISR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "ADC ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADRDY_A {
            #[doc = "0: ADC not yet ready to start conversion"]
            NOTREADY = 0,
            #[doc = "1: ADC ready to start conversion"]
            READY = 1,
        }
        impl From<ADRDY_A> for bool {
            #[inline(always)]
            fn from(variant: ADRDY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADRDY`"]
        pub type ADRDY_R = crate::R<bool, ADRDY_A>;
        impl ADRDY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADRDY_A {
                match self.bits {
                    false => ADRDY_A::NOTREADY,
                    true => ADRDY_A::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == ADRDY_A::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == ADRDY_A::READY
            }
        }
        #[doc = "ADC ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADRDY_AW {
            #[doc = "1: Clear the ADC ready flag"]
            CLEAR = 1,
        }
        impl From<ADRDY_AW> for bool {
            #[inline(always)]
            fn from(variant: ADRDY_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADRDY`"]
        pub struct ADRDY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADRDY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADRDY_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the ADC ready flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ADRDY_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "End of sampling flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOSMP_A {
            #[doc = "0: Not at the end of the samplings phase"]
            NOTATEND = 0,
            #[doc = "1: End of sampling phase reached"]
            ATEND = 1,
        }
        impl From<EOSMP_A> for bool {
            #[inline(always)]
            fn from(variant: EOSMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOSMP`"]
        pub type EOSMP_R = crate::R<bool, EOSMP_A>;
        impl EOSMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOSMP_A {
                match self.bits {
                    false => EOSMP_A::NOTATEND,
                    true => EOSMP_A::ATEND,
                }
            }
            #[doc = "Checks if the value of the field is `NOTATEND`"]
            #[inline(always)]
            pub fn is_not_at_end(&self) -> bool {
                *self == EOSMP_A::NOTATEND
            }
            #[doc = "Checks if the value of the field is `ATEND`"]
            #[inline(always)]
            pub fn is_at_end(&self) -> bool {
                *self == EOSMP_A::ATEND
            }
        }
        #[doc = "End of sampling flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOSMP_AW {
            #[doc = "1: Clear the sampling phase flag"]
            CLEAR = 1,
        }
        impl From<EOSMP_AW> for bool {
            #[inline(always)]
            fn from(variant: EOSMP_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EOSMP`"]
        pub struct EOSMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOSMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOSMP_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the sampling phase flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOSMP_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "End of conversion flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOC_A {
            #[doc = "0: Channel conversion is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: Channel conversion complete"]
            COMPLETE = 1,
        }
        impl From<EOC_A> for bool {
            #[inline(always)]
            fn from(variant: EOC_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOC`"]
        pub type EOC_R = crate::R<bool, EOC_A>;
        impl EOC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOC_A {
                match self.bits {
                    false => EOC_A::NOTCOMPLETE,
                    true => EOC_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == EOC_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == EOC_A::COMPLETE
            }
        }
        #[doc = "End of conversion flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOC_AW {
            #[doc = "1: Clear the channel conversion flag"]
            CLEAR = 1,
        }
        impl From<EOC_AW> for bool {
            #[inline(always)]
            fn from(variant: EOC_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EOC`"]
        pub struct EOC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOC_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the channel conversion flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOC_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "End of sequence flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOS_A {
            #[doc = "0: Conversion sequence is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: Conversion sequence complete"]
            COMPLETE = 1,
        }
        impl From<EOS_A> for bool {
            #[inline(always)]
            fn from(variant: EOS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOS`"]
        pub type EOS_R = crate::R<bool, EOS_A>;
        impl EOS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOS_A {
                match self.bits {
                    false => EOS_A::NOTCOMPLETE,
                    true => EOS_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == EOS_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == EOS_A::COMPLETE
            }
        }
        #[doc = "End of sequence flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOS_AW {
            #[doc = "1: Clear the conversion sequence flag"]
            CLEAR = 1,
        }
        impl From<EOS_AW> for bool {
            #[inline(always)]
            fn from(variant: EOS_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EOS`"]
        pub struct EOS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOS_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the conversion sequence flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOS_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "ADC overrun\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            #[doc = "0: No overrun occurred"]
            NOOVERRUN = 0,
            #[doc = "1: Overrun occurred"]
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVR`"]
        pub type OVR_R = crate::R<bool, OVR_A>;
        impl OVR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOOVERRUN`"]
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVR_A::NOOVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVR_A::OVERRUN
            }
        }
        #[doc = "ADC overrun\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_AW {
            #[doc = "1: Clear the overrun flag"]
            CLEAR = 1,
        }
        impl From<OVR_AW> for bool {
            #[inline(always)]
            fn from(variant: OVR_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `OVR`"]
        pub struct OVR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVR_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the overrun flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVR_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Analog watchdog flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWD_A {
            #[doc = "0: No analog watchdog event occurred"]
            NOEVENT = 0,
            #[doc = "1: Analog watchdog event occurred"]
            EVENT = 1,
        }
        impl From<AWD_A> for bool {
            #[inline(always)]
            fn from(variant: AWD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWD`"]
        pub type AWD_R = crate::R<bool, AWD_A>;
        impl AWD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWD_A {
                match self.bits {
                    false => AWD_A::NOEVENT,
                    true => AWD_A::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == AWD_A::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                *self == AWD_A::EVENT
            }
        }
        #[doc = "Analog watchdog flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWD_AW {
            #[doc = "1: Clear the analog watchdog event flag"]
            CLEAR = 1,
        }
        impl From<AWD_AW> for bool {
            #[inline(always)]
            fn from(variant: AWD_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `AWD`"]
        pub struct AWD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWD_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the analog watchdog event flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(AWD_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "End Of Calibration flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOCAL_A {
            #[doc = "0: Calibration is not complete"]
            NOTCOMPLETE = 0,
            #[doc = "1: Calibration complete"]
            COMPLETE = 1,
        }
        impl From<EOCAL_A> for bool {
            #[inline(always)]
            fn from(variant: EOCAL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOCAL`"]
        pub type EOCAL_R = crate::R<bool, EOCAL_A>;
        impl EOCAL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOCAL_A {
                match self.bits {
                    false => EOCAL_A::NOTCOMPLETE,
                    true => EOCAL_A::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                *self == EOCAL_A::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                *self == EOCAL_A::COMPLETE
            }
        }
        #[doc = "End Of Calibration flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOCAL_AW {
            #[doc = "1: Clear the calibration flag"]
            CLEAR = 1,
        }
        impl From<EOCAL_AW> for bool {
            #[inline(always)]
            fn from(variant: EOCAL_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `EOCAL`"]
        pub struct EOCAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOCAL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOCAL_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear the calibration flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOCAL_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - ADC ready"]
            #[inline(always)]
            pub fn adrdy(&self) -> ADRDY_R {
                ADRDY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - End of sampling flag"]
            #[inline(always)]
            pub fn eosmp(&self) -> EOSMP_R {
                EOSMP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - End of conversion flag"]
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - End of sequence flag"]
            #[inline(always)]
            pub fn eos(&self) -> EOS_R {
                EOS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - ADC overrun"]
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Analog watchdog flag"]
            #[inline(always)]
            pub fn awd(&self) -> AWD_R {
                AWD_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 11 - End Of Calibration flag"]
            #[inline(always)]
            pub fn eocal(&self) -> EOCAL_R {
                EOCAL_R::new(((self.bits >> 11) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC ready"]
            #[inline(always)]
            pub fn adrdy(&mut self) -> ADRDY_W {
                ADRDY_W { w: self }
            }
            #[doc = "Bit 1 - End of sampling flag"]
            #[inline(always)]
            pub fn eosmp(&mut self) -> EOSMP_W {
                EOSMP_W { w: self }
            }
            #[doc = "Bit 2 - End of conversion flag"]
            #[inline(always)]
            pub fn eoc(&mut self) -> EOC_W {
                EOC_W { w: self }
            }
            #[doc = "Bit 3 - End of sequence flag"]
            #[inline(always)]
            pub fn eos(&mut self) -> EOS_W {
                EOS_W { w: self }
            }
            #[doc = "Bit 4 - ADC overrun"]
            #[inline(always)]
            pub fn ovr(&mut self) -> OVR_W {
                OVR_W { w: self }
            }
            #[doc = "Bit 7 - Analog watchdog flag"]
            #[inline(always)]
            pub fn awd(&mut self) -> AWD_W {
                AWD_W { w: self }
            }
            #[doc = "Bit 11 - End Of Calibration flag"]
            #[inline(always)]
            pub fn eocal(&mut self) -> EOCAL_W {
                EOCAL_W { w: self }
            }
        }
    }
    #[doc = "interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ier](ier) module"]
    pub type IER = crate::Reg<u32, _IER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IER;
    #[doc = "`read()` method returns [ier::R](ier::R) reader structure"]
    impl crate::Readable for IER {}
    #[doc = "`write(|w| ..)` method takes [ier::W](ier::W) writer structure"]
    impl crate::Writable for IER {}
    #[doc = "interrupt enable register"]
    pub mod ier {
        #[doc = "Reader of register IER"]
        pub type R = crate::R<u32, super::IER>;
        #[doc = "Writer for register IER"]
        pub type W = crate::W<u32, super::IER>;
        #[doc = "Register IER `reset()`'s with value 0"]
        impl crate::ResetValue for super::IER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "ADC ready interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADRDYIE_A {
            #[doc = "0: ADRDY interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set."]
            ENABLED = 1,
        }
        impl From<ADRDYIE_A> for bool {
            #[inline(always)]
            fn from(variant: ADRDYIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADRDYIE`"]
        pub type ADRDYIE_R = crate::R<bool, ADRDYIE_A>;
        impl ADRDYIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADRDYIE_A {
                match self.bits {
                    false => ADRDYIE_A::DISABLED,
                    true => ADRDYIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ADRDYIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ADRDYIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ADRDYIE`"]
        pub struct ADRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADRDYIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADRDYIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ADRDY interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADRDYIE_A::DISABLED)
            }
            #[doc = "ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADRDYIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "End of sampling flag interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOSMPIE_A {
            #[doc = "0: EOSMP interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set."]
            ENABLED = 1,
        }
        impl From<EOSMPIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOSMPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOSMPIE`"]
        pub type EOSMPIE_R = crate::R<bool, EOSMPIE_A>;
        impl EOSMPIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOSMPIE_A {
                match self.bits {
                    false => EOSMPIE_A::DISABLED,
                    true => EOSMPIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOSMPIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOSMPIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOSMPIE`"]
        pub struct EOSMPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOSMPIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOSMPIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "EOSMP interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOSMPIE_A::DISABLED)
            }
            #[doc = "EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOSMPIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "End of conversion interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOCIE_A {
            #[doc = "0: EOC interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set."]
            ENABLED = 1,
        }
        impl From<EOCIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOCIE`"]
        pub type EOCIE_R = crate::R<bool, EOCIE_A>;
        impl EOCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOCIE_A {
                match self.bits {
                    false => EOCIE_A::DISABLED,
                    true => EOCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOCIE`"]
        pub struct EOCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "EOC interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOCIE_A::DISABLED)
            }
            #[doc = "EOC interrupt enabled. An interrupt is generated when the EOC bit is set."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "End of conversion sequence interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOSIE_A {
            #[doc = "0: EOS interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: EOS interrupt enabled. An interrupt is generated when the EOS bit is set."]
            ENABLED = 1,
        }
        impl From<EOSIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOSIE`"]
        pub type EOSIE_R = crate::R<bool, EOSIE_A>;
        impl EOSIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOSIE_A {
                match self.bits {
                    false => EOSIE_A::DISABLED,
                    true => EOSIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOSIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOSIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOSIE`"]
        pub struct EOSIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOSIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOSIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "EOS interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOSIE_A::DISABLED)
            }
            #[doc = "EOS interrupt enabled. An interrupt is generated when the EOS bit is set."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOSIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Overrun interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRIE_A {
            #[doc = "0: Overrun interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Overrun interrupt enabled. An interrupt is generated when the OVR bit is set."]
            ENABLED = 1,
        }
        impl From<OVRIE_A> for bool {
            #[inline(always)]
            fn from(variant: OVRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVRIE`"]
        pub type OVRIE_R = crate::R<bool, OVRIE_A>;
        impl OVRIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVRIE_A {
                match self.bits {
                    false => OVRIE_A::DISABLED,
                    true => OVRIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OVRIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OVRIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OVRIE`"]
        pub struct OVRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVRIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVRIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Overrun interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OVRIE_A::DISABLED)
            }
            #[doc = "Overrun interrupt enabled. An interrupt is generated when the OVR bit is set."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OVRIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Analog watchdog interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDIE_A {
            #[doc = "0: Analog watchdog interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Analog watchdog interrupt enabled"]
            ENABLED = 1,
        }
        impl From<AWDIE_A> for bool {
            #[inline(always)]
            fn from(variant: AWDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWDIE`"]
        pub type AWDIE_R = crate::R<bool, AWDIE_A>;
        impl AWDIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWDIE_A {
                match self.bits {
                    false => AWDIE_A::DISABLED,
                    true => AWDIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AWDIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AWDIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `AWDIE`"]
        pub struct AWDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWDIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AWDIE_A::DISABLED)
            }
            #[doc = "Analog watchdog interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AWDIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "End of calibration interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOCALIE_A {
            #[doc = "0: End of calibration interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: End of calibration interrupt enabled"]
            ENABLED = 1,
        }
        impl From<EOCALIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOCALIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EOCALIE`"]
        pub type EOCALIE_R = crate::R<bool, EOCALIE_A>;
        impl EOCALIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EOCALIE_A {
                match self.bits {
                    false => EOCALIE_A::DISABLED,
                    true => EOCALIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOCALIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOCALIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EOCALIE`"]
        pub struct EOCALIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOCALIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOCALIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "End of calibration interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOCALIE_A::DISABLED)
            }
            #[doc = "End of calibration interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOCALIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - ADC ready interrupt enable"]
            #[inline(always)]
            pub fn adrdyie(&self) -> ADRDYIE_R {
                ADRDYIE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - End of sampling flag interrupt enable"]
            #[inline(always)]
            pub fn eosmpie(&self) -> EOSMPIE_R {
                EOSMPIE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - End of conversion interrupt enable"]
            #[inline(always)]
            pub fn eocie(&self) -> EOCIE_R {
                EOCIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - End of conversion sequence interrupt enable"]
            #[inline(always)]
            pub fn eosie(&self) -> EOSIE_R {
                EOSIE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Overrun interrupt enable"]
            #[inline(always)]
            pub fn ovrie(&self) -> OVRIE_R {
                OVRIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Analog watchdog interrupt enable"]
            #[inline(always)]
            pub fn awdie(&self) -> AWDIE_R {
                AWDIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 11 - End of calibration interrupt enable"]
            #[inline(always)]
            pub fn eocalie(&self) -> EOCALIE_R {
                EOCALIE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC ready interrupt enable"]
            #[inline(always)]
            pub fn adrdyie(&mut self) -> ADRDYIE_W {
                ADRDYIE_W { w: self }
            }
            #[doc = "Bit 1 - End of sampling flag interrupt enable"]
            #[inline(always)]
            pub fn eosmpie(&mut self) -> EOSMPIE_W {
                EOSMPIE_W { w: self }
            }
            #[doc = "Bit 2 - End of conversion interrupt enable"]
            #[inline(always)]
            pub fn eocie(&mut self) -> EOCIE_W {
                EOCIE_W { w: self }
            }
            #[doc = "Bit 3 - End of conversion sequence interrupt enable"]
            #[inline(always)]
            pub fn eosie(&mut self) -> EOSIE_W {
                EOSIE_W { w: self }
            }
            #[doc = "Bit 4 - Overrun interrupt enable"]
            #[inline(always)]
            pub fn ovrie(&mut self) -> OVRIE_W {
                OVRIE_W { w: self }
            }
            #[doc = "Bit 7 - Analog watchdog interrupt enable"]
            #[inline(always)]
            pub fn awdie(&mut self) -> AWDIE_W {
                AWDIE_W { w: self }
            }
            #[doc = "Bit 11 - End of calibration interrupt enable"]
            #[inline(always)]
            pub fn eocalie(&mut self) -> EOCALIE_W {
                EOCALIE_W { w: self }
            }
        }
    }
    #[doc = "control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "control register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "ADC enable command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADEN_A {
            #[doc = "0: ADC disabled"]
            DISABLED = 0,
            #[doc = "1: ADC enabled"]
            ENABLED = 1,
        }
        impl From<ADEN_A> for bool {
            #[inline(always)]
            fn from(variant: ADEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADEN`"]
        pub type ADEN_R = crate::R<bool, ADEN_A>;
        impl ADEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADEN_A {
                match self.bits {
                    false => ADEN_A::DISABLED,
                    true => ADEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ADEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ADEN_A::ENABLED
            }
        }
        #[doc = "ADC enable command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADEN_AW {
            #[doc = "1: Enable the ADC"]
            ENABLED = 1,
        }
        impl From<ADEN_AW> for bool {
            #[inline(always)]
            fn from(variant: ADEN_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADEN`"]
        pub struct ADEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADEN_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Enable the ADC"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADEN_AW::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "ADC disable command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDIS_A {
            #[doc = "0: No disable command active"]
            NOTDISABLING = 0,
            #[doc = "1: ADC disabling"]
            DISABLING = 1,
        }
        impl From<ADDIS_A> for bool {
            #[inline(always)]
            fn from(variant: ADDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDIS`"]
        pub type ADDIS_R = crate::R<bool, ADDIS_A>;
        impl ADDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDIS_A {
                match self.bits {
                    false => ADDIS_A::NOTDISABLING,
                    true => ADDIS_A::DISABLING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDISABLING`"]
            #[inline(always)]
            pub fn is_not_disabling(&self) -> bool {
                *self == ADDIS_A::NOTDISABLING
            }
            #[doc = "Checks if the value of the field is `DISABLING`"]
            #[inline(always)]
            pub fn is_disabling(&self) -> bool {
                *self == ADDIS_A::DISABLING
            }
        }
        #[doc = "ADC disable command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDIS_AW {
            #[doc = "1: Disable the ADC"]
            DISABLE = 1,
        }
        impl From<ADDIS_AW> for bool {
            #[inline(always)]
            fn from(variant: ADDIS_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADDIS`"]
        pub struct ADDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDIS_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable the ADC"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ADDIS_AW::DISABLE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "ADC start conversion command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADSTART_A {
            #[doc = "0: No conversion ongoing"]
            NOTACTIVE = 0,
            #[doc = "1: ADC operating and may be converting"]
            ACTIVE = 1,
        }
        impl From<ADSTART_A> for bool {
            #[inline(always)]
            fn from(variant: ADSTART_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADSTART`"]
        pub type ADSTART_R = crate::R<bool, ADSTART_A>;
        impl ADSTART_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADSTART_A {
                match self.bits {
                    false => ADSTART_A::NOTACTIVE,
                    true => ADSTART_A::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTACTIVE`"]
            #[inline(always)]
            pub fn is_not_active(&self) -> bool {
                *self == ADSTART_A::NOTACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == ADSTART_A::ACTIVE
            }
        }
        #[doc = "ADC start conversion command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADSTART_AW {
            #[doc = "1: Start the ADC conversion (may be delayed for hardware triggers)"]
            STARTCONVERSION = 1,
        }
        impl From<ADSTART_AW> for bool {
            #[inline(always)]
            fn from(variant: ADSTART_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADSTART`"]
        pub struct ADSTART_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADSTART_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADSTART_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Start the ADC conversion (may be delayed for hardware triggers)"]
            #[inline(always)]
            pub fn start_conversion(self) -> &'a mut W {
                self.variant(ADSTART_AW::STARTCONVERSION)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "ADC stop conversion command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADSTP_A {
            #[doc = "0: No stop command active"]
            NOTSTOPPING = 0,
            #[doc = "1: ADC stopping conversion"]
            STOPPING = 1,
        }
        impl From<ADSTP_A> for bool {
            #[inline(always)]
            fn from(variant: ADSTP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADSTP`"]
        pub type ADSTP_R = crate::R<bool, ADSTP_A>;
        impl ADSTP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADSTP_A {
                match self.bits {
                    false => ADSTP_A::NOTSTOPPING,
                    true => ADSTP_A::STOPPING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTOPPING`"]
            #[inline(always)]
            pub fn is_not_stopping(&self) -> bool {
                *self == ADSTP_A::NOTSTOPPING
            }
            #[doc = "Checks if the value of the field is `STOPPING`"]
            #[inline(always)]
            pub fn is_stopping(&self) -> bool {
                *self == ADSTP_A::STOPPING
            }
        }
        #[doc = "ADC stop conversion command\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADSTP_AW {
            #[doc = "1: Stop the active conversion"]
            STOPCONVERSION = 1,
        }
        impl From<ADSTP_AW> for bool {
            #[inline(always)]
            fn from(variant: ADSTP_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADSTP`"]
        pub struct ADSTP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADSTP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADSTP_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Stop the active conversion"]
            #[inline(always)]
            pub fn stop_conversion(self) -> &'a mut W {
                self.variant(ADSTP_AW::STOPCONVERSION)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "ADC Voltage Regulator Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADVREGEN_A {
            #[doc = "0: ADC voltage regulator disabled"]
            DISABLED = 0,
            #[doc = "1: ADC voltage regulator enabled"]
            ENABLED = 1,
        }
        impl From<ADVREGEN_A> for bool {
            #[inline(always)]
            fn from(variant: ADVREGEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADVREGEN`"]
        pub type ADVREGEN_R = crate::R<bool, ADVREGEN_A>;
        impl ADVREGEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADVREGEN_A {
                match self.bits {
                    false => ADVREGEN_A::DISABLED,
                    true => ADVREGEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ADVREGEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ADVREGEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ADVREGEN`"]
        pub struct ADVREGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADVREGEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADVREGEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ADC voltage regulator disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADVREGEN_A::DISABLED)
            }
            #[doc = "ADC voltage regulator enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADVREGEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "ADC calibration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCAL_A {
            #[doc = "0: ADC calibration either not yet performed or completed"]
            NOTCALIBRATING = 0,
            #[doc = "1: ADC calibration in progress"]
            CALIBRATING = 1,
        }
        impl From<ADCAL_A> for bool {
            #[inline(always)]
            fn from(variant: ADCAL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADCAL`"]
        pub type ADCAL_R = crate::R<bool, ADCAL_A>;
        impl ADCAL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADCAL_A {
                match self.bits {
                    false => ADCAL_A::NOTCALIBRATING,
                    true => ADCAL_A::CALIBRATING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCALIBRATING`"]
            #[inline(always)]
            pub fn is_not_calibrating(&self) -> bool {
                *self == ADCAL_A::NOTCALIBRATING
            }
            #[doc = "Checks if the value of the field is `CALIBRATING`"]
            #[inline(always)]
            pub fn is_calibrating(&self) -> bool {
                *self == ADCAL_A::CALIBRATING
            }
        }
        #[doc = "ADC calibration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCAL_AW {
            #[doc = "1: Start the ADC calibration sequence"]
            STARTCALIBRATION = 1,
        }
        impl From<ADCAL_AW> for bool {
            #[inline(always)]
            fn from(variant: ADCAL_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ADCAL`"]
        pub struct ADCAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADCAL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADCAL_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Start the ADC calibration sequence"]
            #[inline(always)]
            pub fn start_calibration(self) -> &'a mut W {
                self.variant(ADCAL_AW::STARTCALIBRATION)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - ADC enable command"]
            #[inline(always)]
            pub fn aden(&self) -> ADEN_R {
                ADEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - ADC disable command"]
            #[inline(always)]
            pub fn addis(&self) -> ADDIS_R {
                ADDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - ADC start conversion command"]
            #[inline(always)]
            pub fn adstart(&self) -> ADSTART_R {
                ADSTART_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 4 - ADC stop conversion command"]
            #[inline(always)]
            pub fn adstp(&self) -> ADSTP_R {
                ADSTP_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 28 - ADC Voltage Regulator Enable"]
            #[inline(always)]
            pub fn advregen(&self) -> ADVREGEN_R {
                ADVREGEN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 31 - ADC calibration"]
            #[inline(always)]
            pub fn adcal(&self) -> ADCAL_R {
                ADCAL_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC enable command"]
            #[inline(always)]
            pub fn aden(&mut self) -> ADEN_W {
                ADEN_W { w: self }
            }
            #[doc = "Bit 1 - ADC disable command"]
            #[inline(always)]
            pub fn addis(&mut self) -> ADDIS_W {
                ADDIS_W { w: self }
            }
            #[doc = "Bit 2 - ADC start conversion command"]
            #[inline(always)]
            pub fn adstart(&mut self) -> ADSTART_W {
                ADSTART_W { w: self }
            }
            #[doc = "Bit 4 - ADC stop conversion command"]
            #[inline(always)]
            pub fn adstp(&mut self) -> ADSTP_W {
                ADSTP_W { w: self }
            }
            #[doc = "Bit 28 - ADC Voltage Regulator Enable"]
            #[inline(always)]
            pub fn advregen(&mut self) -> ADVREGEN_W {
                ADVREGEN_W { w: self }
            }
            #[doc = "Bit 31 - ADC calibration"]
            #[inline(always)]
            pub fn adcal(&mut self) -> ADCAL_W {
                ADCAL_W { w: self }
            }
        }
    }
    #[doc = "configuration register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr1](cfgr1) module"]
    pub type CFGR1 = crate::Reg<u32, _CFGR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR1;
    #[doc = "`read()` method returns [cfgr1::R](cfgr1::R) reader structure"]
    impl crate::Readable for CFGR1 {}
    #[doc = "`write(|w| ..)` method takes [cfgr1::W](cfgr1::W) writer structure"]
    impl crate::Writable for CFGR1 {}
    #[doc = "configuration register 1"]
    pub mod cfgr1 {
        #[doc = "Reader of register CFGR1"]
        pub type R = crate::R<u32, super::CFGR1>;
        #[doc = "Writer for register CFGR1"]
        pub type W = crate::W<u32, super::CFGR1>;
        #[doc = "Register CFGR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `AWDCH`"]
        pub type AWDCH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `AWDCH`"]
        pub struct AWDCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDCH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 26)) | (((value as u32) & 0x1f) << 26);
                self.w
            }
        }
        #[doc = "Analog watchdog enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDEN_A {
            #[doc = "0: Analog watchdog disabled"]
            DISABLED = 0,
            #[doc = "1: Analog watchdog enabled"]
            ENABLED = 1,
        }
        impl From<AWDEN_A> for bool {
            #[inline(always)]
            fn from(variant: AWDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWDEN`"]
        pub type AWDEN_R = crate::R<bool, AWDEN_A>;
        impl AWDEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWDEN_A {
                match self.bits {
                    false => AWDEN_A::DISABLED,
                    true => AWDEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AWDEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AWDEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `AWDEN`"]
        pub struct AWDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AWDEN_A::DISABLED)
            }
            #[doc = "Analog watchdog enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AWDEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Enable the watchdog on a single channel or on all channels\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDSGL_A {
            #[doc = "0: Analog watchdog enabled on all channels"]
            ALLCHANNELS = 0,
            #[doc = "1: Analog watchdog enabled on a single channel"]
            SINGLECHANNEL = 1,
        }
        impl From<AWDSGL_A> for bool {
            #[inline(always)]
            fn from(variant: AWDSGL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AWDSGL`"]
        pub type AWDSGL_R = crate::R<bool, AWDSGL_A>;
        impl AWDSGL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AWDSGL_A {
                match self.bits {
                    false => AWDSGL_A::ALLCHANNELS,
                    true => AWDSGL_A::SINGLECHANNEL,
                }
            }
            #[doc = "Checks if the value of the field is `ALLCHANNELS`"]
            #[inline(always)]
            pub fn is_all_channels(&self) -> bool {
                *self == AWDSGL_A::ALLCHANNELS
            }
            #[doc = "Checks if the value of the field is `SINGLECHANNEL`"]
            #[inline(always)]
            pub fn is_single_channel(&self) -> bool {
                *self == AWDSGL_A::SINGLECHANNEL
            }
        }
        #[doc = "Write proxy for field `AWDSGL`"]
        pub struct AWDSGL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDSGL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AWDSGL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Analog watchdog enabled on all channels"]
            #[inline(always)]
            pub fn all_channels(self) -> &'a mut W {
                self.variant(AWDSGL_A::ALLCHANNELS)
            }
            #[doc = "Analog watchdog enabled on a single channel"]
            #[inline(always)]
            pub fn single_channel(self) -> &'a mut W {
                self.variant(AWDSGL_A::SINGLECHANNEL)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Discontinuous mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISCEN_A {
            #[doc = "0: Discontinuous mode disabled"]
            DISABLED = 0,
            #[doc = "1: Discontinuous mode enabled"]
            ENABLED = 1,
        }
        impl From<DISCEN_A> for bool {
            #[inline(always)]
            fn from(variant: DISCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DISCEN`"]
        pub type DISCEN_R = crate::R<bool, DISCEN_A>;
        impl DISCEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DISCEN_A {
                match self.bits {
                    false => DISCEN_A::DISABLED,
                    true => DISCEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DISCEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DISCEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DISCEN`"]
        pub struct DISCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISCEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DISCEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Discontinuous mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISCEN_A::DISABLED)
            }
            #[doc = "Discontinuous mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISCEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Auto-off mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AUTOFF_A {
            #[doc = "0: Auto-off mode disabled"]
            DISABLED = 0,
            #[doc = "1: Auto-off mode enabled"]
            ENABLED = 1,
        }
        impl From<AUTOFF_A> for bool {
            #[inline(always)]
            fn from(variant: AUTOFF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `AUTOFF`"]
        pub type AUTOFF_R = crate::R<bool, AUTOFF_A>;
        impl AUTOFF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> AUTOFF_A {
                match self.bits {
                    false => AUTOFF_A::DISABLED,
                    true => AUTOFF_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == AUTOFF_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AUTOFF_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `AUTOFF`"]
        pub struct AUTOFF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AUTOFF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AUTOFF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Auto-off mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AUTOFF_A::DISABLED)
            }
            #[doc = "Auto-off mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AUTOFF_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Auto-delayed conversion mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAIT_A {
            #[doc = "0: Wait conversion mode off"]
            DISABLED = 0,
            #[doc = "1: Wait conversion mode on"]
            ENABLED = 1,
        }
        impl From<WAIT_A> for bool {
            #[inline(always)]
            fn from(variant: WAIT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAIT`"]
        pub type WAIT_R = crate::R<bool, WAIT_A>;
        impl WAIT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAIT_A {
                match self.bits {
                    false => WAIT_A::DISABLED,
                    true => WAIT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WAIT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WAIT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WAIT`"]
        pub struct WAIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAIT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAIT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Wait conversion mode off"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAIT_A::DISABLED)
            }
            #[doc = "Wait conversion mode on"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAIT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Single / continuous conversion mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CONT_A {
            #[doc = "0: Single conversion mode"]
            SINGLE = 0,
            #[doc = "1: Continuous conversion mode"]
            CONTINUOUS = 1,
        }
        impl From<CONT_A> for bool {
            #[inline(always)]
            fn from(variant: CONT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CONT`"]
        pub type CONT_R = crate::R<bool, CONT_A>;
        impl CONT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CONT_A {
                match self.bits {
                    false => CONT_A::SINGLE,
                    true => CONT_A::CONTINUOUS,
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == CONT_A::SINGLE
            }
            #[doc = "Checks if the value of the field is `CONTINUOUS`"]
            #[inline(always)]
            pub fn is_continuous(&self) -> bool {
                *self == CONT_A::CONTINUOUS
            }
        }
        #[doc = "Write proxy for field `CONT`"]
        pub struct CONT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CONT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CONT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Single conversion mode"]
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(CONT_A::SINGLE)
            }
            #[doc = "Continuous conversion mode"]
            #[inline(always)]
            pub fn continuous(self) -> &'a mut W {
                self.variant(CONT_A::CONTINUOUS)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Overrun management mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRMOD_A {
            #[doc = "0: ADC_DR register is preserved with the old data when an overrun is detected"]
            PRESERVE = 0,
            #[doc = "1: ADC_DR register is overwritten with the last conversion result when an overrun is detected"]
            OVERWRITE = 1,
        }
        impl From<OVRMOD_A> for bool {
            #[inline(always)]
            fn from(variant: OVRMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVRMOD`"]
        pub type OVRMOD_R = crate::R<bool, OVRMOD_A>;
        impl OVRMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVRMOD_A {
                match self.bits {
                    false => OVRMOD_A::PRESERVE,
                    true => OVRMOD_A::OVERWRITE,
                }
            }
            #[doc = "Checks if the value of the field is `PRESERVE`"]
            #[inline(always)]
            pub fn is_preserve(&self) -> bool {
                *self == OVRMOD_A::PRESERVE
            }
            #[doc = "Checks if the value of the field is `OVERWRITE`"]
            #[inline(always)]
            pub fn is_overwrite(&self) -> bool {
                *self == OVRMOD_A::OVERWRITE
            }
        }
        #[doc = "Write proxy for field `OVRMOD`"]
        pub struct OVRMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVRMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVRMOD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ADC_DR register is preserved with the old data when an overrun is detected"]
            #[inline(always)]
            pub fn preserve(self) -> &'a mut W {
                self.variant(OVRMOD_A::PRESERVE)
            }
            #[doc = "ADC_DR register is overwritten with the last conversion result when an overrun is detected"]
            #[inline(always)]
            pub fn overwrite(self) -> &'a mut W {
                self.variant(OVRMOD_A::OVERWRITE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "External trigger enable and polarity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTEN_A {
            #[doc = "0: Hardware trigger detection disabled"]
            DISABLED = 0,
            #[doc = "1: Hardware trigger detection on the rising edge"]
            RISINGEDGE = 1,
            #[doc = "2: Hardware trigger detection on the falling edge"]
            FALLINGEDGE = 2,
            #[doc = "3: Hardware trigger detection on both the rising and falling edges"]
            BOTHEDGES = 3,
        }
        impl From<EXTEN_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTEN_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTEN`"]
        pub type EXTEN_R = crate::R<u8, EXTEN_A>;
        impl EXTEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTEN_A {
                match self.bits {
                    0 => EXTEN_A::DISABLED,
                    1 => EXTEN_A::RISINGEDGE,
                    2 => EXTEN_A::FALLINGEDGE,
                    3 => EXTEN_A::BOTHEDGES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EXTEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == EXTEN_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == EXTEN_A::FALLINGEDGE
            }
            #[doc = "Checks if the value of the field is `BOTHEDGES`"]
            #[inline(always)]
            pub fn is_both_edges(&self) -> bool {
                *self == EXTEN_A::BOTHEDGES
            }
        }
        #[doc = "Write proxy for field `EXTEN`"]
        pub struct EXTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTEN_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Hardware trigger detection disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTEN_A::DISABLED)
            }
            #[doc = "Hardware trigger detection on the rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(EXTEN_A::RISINGEDGE)
            }
            #[doc = "Hardware trigger detection on the falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(EXTEN_A::FALLINGEDGE)
            }
            #[doc = "Hardware trigger detection on both the rising and falling edges"]
            #[inline(always)]
            pub fn both_edges(self) -> &'a mut W {
                self.variant(EXTEN_A::BOTHEDGES)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "External trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTSEL_A {
            #[doc = "0: Timer 6 TRGO event"]
            TIM6_TRGO = 0,
            #[doc = "1: Timer 21 CH2 event"]
            TIM21_CH2 = 1,
            #[doc = "2: Timer 2 TRGO event"]
            TIM2_TRGO = 2,
            #[doc = "3: Timer 2 CH4 event"]
            TIM2_CH4 = 3,
            #[doc = "4: Timer 22 TRGO, Timer 21 TRGO event"]
            TIM22_TRGO = 4,
            #[doc = "5: Timer 2 CH3 event"]
            TIM2_CH3 = 5,
            #[doc = "6: Timer 3 TRGO event"]
            TIM3_TRGO = 6,
            #[doc = "7: EXTI line 11 event"]
            EXTI_LINE11 = 7,
        }
        impl From<EXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTSEL_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `EXTSEL`"]
        pub type EXTSEL_R = crate::R<u8, EXTSEL_A>;
        impl EXTSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EXTSEL_A {
                match self.bits {
                    0 => EXTSEL_A::TIM6_TRGO,
                    1 => EXTSEL_A::TIM21_CH2,
                    2 => EXTSEL_A::TIM2_TRGO,
                    3 => EXTSEL_A::TIM2_CH4,
                    4 => EXTSEL_A::TIM22_TRGO,
                    5 => EXTSEL_A::TIM2_CH3,
                    6 => EXTSEL_A::TIM3_TRGO,
                    7 => EXTSEL_A::EXTI_LINE11,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIM6_TRGO`"]
            #[inline(always)]
            pub fn is_tim6_trgo(&self) -> bool {
                *self == EXTSEL_A::TIM6_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM21_CH2`"]
            #[inline(always)]
            pub fn is_tim21_ch2(&self) -> bool {
                *self == EXTSEL_A::TIM21_CH2
            }
            #[doc = "Checks if the value of the field is `TIM2_TRGO`"]
            #[inline(always)]
            pub fn is_tim2_trgo(&self) -> bool {
                *self == EXTSEL_A::TIM2_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2_CH4`"]
            #[inline(always)]
            pub fn is_tim2_ch4(&self) -> bool {
                *self == EXTSEL_A::TIM2_CH4
            }
            #[doc = "Checks if the value of the field is `TIM22_TRGO`"]
            #[inline(always)]
            pub fn is_tim22_trgo(&self) -> bool {
                *self == EXTSEL_A::TIM22_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2_CH3`"]
            #[inline(always)]
            pub fn is_tim2_ch3(&self) -> bool {
                *self == EXTSEL_A::TIM2_CH3
            }
            #[doc = "Checks if the value of the field is `TIM3_TRGO`"]
            #[inline(always)]
            pub fn is_tim3_trgo(&self) -> bool {
                *self == EXTSEL_A::TIM3_TRGO
            }
            #[doc = "Checks if the value of the field is `EXTI_LINE11`"]
            #[inline(always)]
            pub fn is_exti_line11(&self) -> bool {
                *self == EXTSEL_A::EXTI_LINE11
            }
        }
        #[doc = "Write proxy for field `EXTSEL`"]
        pub struct EXTSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTSEL_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Timer 6 TRGO event"]
            #[inline(always)]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM6_TRGO)
            }
            #[doc = "Timer 21 CH2 event"]
            #[inline(always)]
            pub fn tim21_ch2(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM21_CH2)
            }
            #[doc = "Timer 2 TRGO event"]
            #[inline(always)]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM2_TRGO)
            }
            #[doc = "Timer 2 CH4 event"]
            #[inline(always)]
            pub fn tim2_ch4(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM2_CH4)
            }
            #[doc = "Timer 22 TRGO, Timer 21 TRGO event"]
            #[inline(always)]
            pub fn tim22_trgo(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM22_TRGO)
            }
            #[doc = "Timer 2 CH3 event"]
            #[inline(always)]
            pub fn tim2_ch3(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM2_CH3)
            }
            #[doc = "Timer 3 TRGO event"]
            #[inline(always)]
            pub fn tim3_trgo(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM3_TRGO)
            }
            #[doc = "EXTI line 11 event"]
            #[inline(always)]
            pub fn exti_line11(self) -> &'a mut W {
                self.variant(EXTSEL_A::EXTI_LINE11)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 6)) | (((value as u32) & 0x07) << 6);
                self.w
            }
        }
        #[doc = "Data alignment\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALIGN_A {
            #[doc = "0: Right alignment"]
            RIGHT = 0,
            #[doc = "1: Left alignment"]
            LEFT = 1,
        }
        impl From<ALIGN_A> for bool {
            #[inline(always)]
            fn from(variant: ALIGN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ALIGN`"]
        pub type ALIGN_R = crate::R<bool, ALIGN_A>;
        impl ALIGN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ALIGN_A {
                match self.bits {
                    false => ALIGN_A::RIGHT,
                    true => ALIGN_A::LEFT,
                }
            }
            #[doc = "Checks if the value of the field is `RIGHT`"]
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == ALIGN_A::RIGHT
            }
            #[doc = "Checks if the value of the field is `LEFT`"]
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == ALIGN_A::LEFT
            }
        }
        #[doc = "Write proxy for field `ALIGN`"]
        pub struct ALIGN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALIGN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALIGN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Right alignment"]
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(ALIGN_A::RIGHT)
            }
            #[doc = "Left alignment"]
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(ALIGN_A::LEFT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Data resolution\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum RES_A {
            #[doc = "0: 12 bits"]
            TWELVEBIT = 0,
            #[doc = "1: 10 bits"]
            TENBIT = 1,
            #[doc = "2: 8 bits"]
            EIGHTBIT = 2,
            #[doc = "3: 6 bits"]
            SIXBIT = 3,
        }
        impl From<RES_A> for u8 {
            #[inline(always)]
            fn from(variant: RES_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `RES`"]
        pub type RES_R = crate::R<u8, RES_A>;
        impl RES_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RES_A {
                match self.bits {
                    0 => RES_A::TWELVEBIT,
                    1 => RES_A::TENBIT,
                    2 => RES_A::EIGHTBIT,
                    3 => RES_A::SIXBIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TWELVEBIT`"]
            #[inline(always)]
            pub fn is_twelve_bit(&self) -> bool {
                *self == RES_A::TWELVEBIT
            }
            #[doc = "Checks if the value of the field is `TENBIT`"]
            #[inline(always)]
            pub fn is_ten_bit(&self) -> bool {
                *self == RES_A::TENBIT
            }
            #[doc = "Checks if the value of the field is `EIGHTBIT`"]
            #[inline(always)]
            pub fn is_eight_bit(&self) -> bool {
                *self == RES_A::EIGHTBIT
            }
            #[doc = "Checks if the value of the field is `SIXBIT`"]
            #[inline(always)]
            pub fn is_six_bit(&self) -> bool {
                *self == RES_A::SIXBIT
            }
        }
        #[doc = "Write proxy for field `RES`"]
        pub struct RES_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RES_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RES_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "12 bits"]
            #[inline(always)]
            pub fn twelve_bit(self) -> &'a mut W {
                self.variant(RES_A::TWELVEBIT)
            }
            #[doc = "10 bits"]
            #[inline(always)]
            pub fn ten_bit(self) -> &'a mut W {
                self.variant(RES_A::TENBIT)
            }
            #[doc = "8 bits"]
            #[inline(always)]
            pub fn eight_bit(self) -> &'a mut W {
                self.variant(RES_A::EIGHTBIT)
            }
            #[doc = "6 bits"]
            #[inline(always)]
            pub fn six_bit(self) -> &'a mut W {
                self.variant(RES_A::SIXBIT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        #[doc = "Scan sequence direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCANDIR_A {
            #[doc = "0: Upward scan (from CHSEL0 to CHSEL18)"]
            UPWARD = 0,
            #[doc = "1: Backward scan (from CHSEL18 to CHSEL0)"]
            BACKWARD = 1,
        }
        impl From<SCANDIR_A> for bool {
            #[inline(always)]
            fn from(variant: SCANDIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SCANDIR`"]
        pub type SCANDIR_R = crate::R<bool, SCANDIR_A>;
        impl SCANDIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SCANDIR_A {
                match self.bits {
                    false => SCANDIR_A::UPWARD,
                    true => SCANDIR_A::BACKWARD,
                }
            }
            #[doc = "Checks if the value of the field is `UPWARD`"]
            #[inline(always)]
            pub fn is_upward(&self) -> bool {
                *self == SCANDIR_A::UPWARD
            }
            #[doc = "Checks if the value of the field is `BACKWARD`"]
            #[inline(always)]
            pub fn is_backward(&self) -> bool {
                *self == SCANDIR_A::BACKWARD
            }
        }
        #[doc = "Write proxy for field `SCANDIR`"]
        pub struct SCANDIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCANDIR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCANDIR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Upward scan (from CHSEL0 to CHSEL18)"]
            #[inline(always)]
            pub fn upward(self) -> &'a mut W {
                self.variant(SCANDIR_A::UPWARD)
            }
            #[doc = "Backward scan (from CHSEL18 to CHSEL0)"]
            #[inline(always)]
            pub fn backward(self) -> &'a mut W {
                self.variant(SCANDIR_A::BACKWARD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Direct memery access configuration\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMACFG_A {
            #[doc = "0: DMA one shot mode selected"]
            ONESHOT = 0,
            #[doc = "1: DMA circular mode selected"]
            CIRCULAR = 1,
        }
        impl From<DMACFG_A> for bool {
            #[inline(always)]
            fn from(variant: DMACFG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMACFG`"]
        pub type DMACFG_R = crate::R<bool, DMACFG_A>;
        impl DMACFG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMACFG_A {
                match self.bits {
                    false => DMACFG_A::ONESHOT,
                    true => DMACFG_A::CIRCULAR,
                }
            }
            #[doc = "Checks if the value of the field is `ONESHOT`"]
            #[inline(always)]
            pub fn is_one_shot(&self) -> bool {
                *self == DMACFG_A::ONESHOT
            }
            #[doc = "Checks if the value of the field is `CIRCULAR`"]
            #[inline(always)]
            pub fn is_circular(&self) -> bool {
                *self == DMACFG_A::CIRCULAR
            }
        }
        #[doc = "Write proxy for field `DMACFG`"]
        pub struct DMACFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMACFG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMACFG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA one shot mode selected"]
            #[inline(always)]
            pub fn one_shot(self) -> &'a mut W {
                self.variant(DMACFG_A::ONESHOT)
            }
            #[doc = "DMA circular mode selected"]
            #[inline(always)]
            pub fn circular(self) -> &'a mut W {
                self.variant(DMACFG_A::CIRCULAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Direct memory access enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN_A {
            #[doc = "0: DMA disabled"]
            DISABLED = 0,
            #[doc = "1: DMA enabled"]
            ENABLED = 1,
        }
        impl From<DMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAEN`"]
        pub type DMAEN_R = crate::R<bool, DMAEN_A>;
        impl DMAEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAEN_A {
                match self.bits {
                    false => DMAEN_A::DISABLED,
                    true => DMAEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAEN`"]
        pub struct DMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN_A::DISABLED)
            }
            #[doc = "DMA enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 26:30 - Analog watchdog channel selection"]
            #[inline(always)]
            pub fn awdch(&self) -> AWDCH_R {
                AWDCH_R::new(((self.bits >> 26) & 0x1f) as u8)
            }
            #[doc = "Bit 23 - Analog watchdog enable"]
            #[inline(always)]
            pub fn awden(&self) -> AWDEN_R {
                AWDEN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Enable the watchdog on a single channel or on all channels"]
            #[inline(always)]
            pub fn awdsgl(&self) -> AWDSGL_R {
                AWDSGL_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Discontinuous mode"]
            #[inline(always)]
            pub fn discen(&self) -> DISCEN_R {
                DISCEN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Auto-off mode"]
            #[inline(always)]
            pub fn autoff(&self) -> AUTOFF_R {
                AUTOFF_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Auto-delayed conversion mode"]
            #[inline(always)]
            pub fn wait(&self) -> WAIT_R {
                WAIT_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Single / continuous conversion mode"]
            #[inline(always)]
            pub fn cont(&self) -> CONT_R {
                CONT_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Overrun management mode"]
            #[inline(always)]
            pub fn ovrmod(&self) -> OVRMOD_R {
                OVRMOD_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bits 10:11 - External trigger enable and polarity selection"]
            #[inline(always)]
            pub fn exten(&self) -> EXTEN_R {
                EXTEN_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 6:8 - External trigger selection"]
            #[inline(always)]
            pub fn extsel(&self) -> EXTSEL_R {
                EXTSEL_R::new(((self.bits >> 6) & 0x07) as u8)
            }
            #[doc = "Bit 5 - Data alignment"]
            #[inline(always)]
            pub fn align(&self) -> ALIGN_R {
                ALIGN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bits 3:4 - Data resolution"]
            #[inline(always)]
            pub fn res(&self) -> RES_R {
                RES_R::new(((self.bits >> 3) & 0x03) as u8)
            }
            #[doc = "Bit 2 - Scan sequence direction"]
            #[inline(always)]
            pub fn scandir(&self) -> SCANDIR_R {
                SCANDIR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Direct memery access configuration"]
            #[inline(always)]
            pub fn dmacfg(&self) -> DMACFG_R {
                DMACFG_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Direct memory access enable"]
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 26:30 - Analog watchdog channel selection"]
            #[inline(always)]
            pub fn awdch(&mut self) -> AWDCH_W {
                AWDCH_W { w: self }
            }
            #[doc = "Bit 23 - Analog watchdog enable"]
            #[inline(always)]
            pub fn awden(&mut self) -> AWDEN_W {
                AWDEN_W { w: self }
            }
            #[doc = "Bit 22 - Enable the watchdog on a single channel or on all channels"]
            #[inline(always)]
            pub fn awdsgl(&mut self) -> AWDSGL_W {
                AWDSGL_W { w: self }
            }
            #[doc = "Bit 16 - Discontinuous mode"]
            #[inline(always)]
            pub fn discen(&mut self) -> DISCEN_W {
                DISCEN_W { w: self }
            }
            #[doc = "Bit 15 - Auto-off mode"]
            #[inline(always)]
            pub fn autoff(&mut self) -> AUTOFF_W {
                AUTOFF_W { w: self }
            }
            #[doc = "Bit 14 - Auto-delayed conversion mode"]
            #[inline(always)]
            pub fn wait(&mut self) -> WAIT_W {
                WAIT_W { w: self }
            }
            #[doc = "Bit 13 - Single / continuous conversion mode"]
            #[inline(always)]
            pub fn cont(&mut self) -> CONT_W {
                CONT_W { w: self }
            }
            #[doc = "Bit 12 - Overrun management mode"]
            #[inline(always)]
            pub fn ovrmod(&mut self) -> OVRMOD_W {
                OVRMOD_W { w: self }
            }
            #[doc = "Bits 10:11 - External trigger enable and polarity selection"]
            #[inline(always)]
            pub fn exten(&mut self) -> EXTEN_W {
                EXTEN_W { w: self }
            }
            #[doc = "Bits 6:8 - External trigger selection"]
            #[inline(always)]
            pub fn extsel(&mut self) -> EXTSEL_W {
                EXTSEL_W { w: self }
            }
            #[doc = "Bit 5 - Data alignment"]
            #[inline(always)]
            pub fn align(&mut self) -> ALIGN_W {
                ALIGN_W { w: self }
            }
            #[doc = "Bits 3:4 - Data resolution"]
            #[inline(always)]
            pub fn res(&mut self) -> RES_W {
                RES_W { w: self }
            }
            #[doc = "Bit 2 - Scan sequence direction"]
            #[inline(always)]
            pub fn scandir(&mut self) -> SCANDIR_W {
                SCANDIR_W { w: self }
            }
            #[doc = "Bit 1 - Direct memery access configuration"]
            #[inline(always)]
            pub fn dmacfg(&mut self) -> DMACFG_W {
                DMACFG_W { w: self }
            }
            #[doc = "Bit 0 - Direct memory access enable"]
            #[inline(always)]
            pub fn dmaen(&mut self) -> DMAEN_W {
                DMAEN_W { w: self }
            }
        }
    }
    #[doc = "configuration register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cfgr2](cfgr2) module"]
    pub type CFGR2 = crate::Reg<u32, _CFGR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFGR2;
    #[doc = "`read()` method returns [cfgr2::R](cfgr2::R) reader structure"]
    impl crate::Readable for CFGR2 {}
    #[doc = "`write(|w| ..)` method takes [cfgr2::W](cfgr2::W) writer structure"]
    impl crate::Writable for CFGR2 {}
    #[doc = "configuration register 2"]
    pub mod cfgr2 {
        #[doc = "Reader of register CFGR2"]
        pub type R = crate::R<u32, super::CFGR2>;
        #[doc = "Writer for register CFGR2"]
        pub type W = crate::W<u32, super::CFGR2>;
        #[doc = "Register CFGR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFGR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Oversampler Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVSE_A {
            #[doc = "0: Oversampler disabled"]
            DISABLED = 0,
            #[doc = "1: Oversampler enabled"]
            ENABLED = 1,
        }
        impl From<OVSE_A> for bool {
            #[inline(always)]
            fn from(variant: OVSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVSE`"]
        pub type OVSE_R = crate::R<bool, OVSE_A>;
        impl OVSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVSE_A {
                match self.bits {
                    false => OVSE_A::DISABLED,
                    true => OVSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OVSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OVSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OVSE`"]
        pub struct OVSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Oversampler disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OVSE_A::DISABLED)
            }
            #[doc = "Oversampler enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OVSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Oversampling ratio\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OVSR_A {
            #[doc = "0: 2x"]
            MUL2 = 0,
            #[doc = "1: 4x"]
            MUL4 = 1,
            #[doc = "2: 8x"]
            MUL8 = 2,
            #[doc = "3: 16x"]
            MUL16 = 3,
            #[doc = "4: 32x"]
            MUL32 = 4,
            #[doc = "5: 64x"]
            MUL64 = 5,
            #[doc = "6: 128x"]
            MUL128 = 6,
            #[doc = "7: 256x"]
            MUL256 = 7,
        }
        impl From<OVSR_A> for u8 {
            #[inline(always)]
            fn from(variant: OVSR_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OVSR`"]
        pub type OVSR_R = crate::R<u8, OVSR_A>;
        impl OVSR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVSR_A {
                match self.bits {
                    0 => OVSR_A::MUL2,
                    1 => OVSR_A::MUL4,
                    2 => OVSR_A::MUL8,
                    3 => OVSR_A::MUL16,
                    4 => OVSR_A::MUL32,
                    5 => OVSR_A::MUL64,
                    6 => OVSR_A::MUL128,
                    7 => OVSR_A::MUL256,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MUL2`"]
            #[inline(always)]
            pub fn is_mul2(&self) -> bool {
                *self == OVSR_A::MUL2
            }
            #[doc = "Checks if the value of the field is `MUL4`"]
            #[inline(always)]
            pub fn is_mul4(&self) -> bool {
                *self == OVSR_A::MUL4
            }
            #[doc = "Checks if the value of the field is `MUL8`"]
            #[inline(always)]
            pub fn is_mul8(&self) -> bool {
                *self == OVSR_A::MUL8
            }
            #[doc = "Checks if the value of the field is `MUL16`"]
            #[inline(always)]
            pub fn is_mul16(&self) -> bool {
                *self == OVSR_A::MUL16
            }
            #[doc = "Checks if the value of the field is `MUL32`"]
            #[inline(always)]
            pub fn is_mul32(&self) -> bool {
                *self == OVSR_A::MUL32
            }
            #[doc = "Checks if the value of the field is `MUL64`"]
            #[inline(always)]
            pub fn is_mul64(&self) -> bool {
                *self == OVSR_A::MUL64
            }
            #[doc = "Checks if the value of the field is `MUL128`"]
            #[inline(always)]
            pub fn is_mul128(&self) -> bool {
                *self == OVSR_A::MUL128
            }
            #[doc = "Checks if the value of the field is `MUL256`"]
            #[inline(always)]
            pub fn is_mul256(&self) -> bool {
                *self == OVSR_A::MUL256
            }
        }
        #[doc = "Write proxy for field `OVSR`"]
        pub struct OVSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVSR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVSR_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "2x"]
            #[inline(always)]
            pub fn mul2(self) -> &'a mut W {
                self.variant(OVSR_A::MUL2)
            }
            #[doc = "4x"]
            #[inline(always)]
            pub fn mul4(self) -> &'a mut W {
                self.variant(OVSR_A::MUL4)
            }
            #[doc = "8x"]
            #[inline(always)]
            pub fn mul8(self) -> &'a mut W {
                self.variant(OVSR_A::MUL8)
            }
            #[doc = "16x"]
            #[inline(always)]
            pub fn mul16(self) -> &'a mut W {
                self.variant(OVSR_A::MUL16)
            }
            #[doc = "32x"]
            #[inline(always)]
            pub fn mul32(self) -> &'a mut W {
                self.variant(OVSR_A::MUL32)
            }
            #[doc = "64x"]
            #[inline(always)]
            pub fn mul64(self) -> &'a mut W {
                self.variant(OVSR_A::MUL64)
            }
            #[doc = "128x"]
            #[inline(always)]
            pub fn mul128(self) -> &'a mut W {
                self.variant(OVSR_A::MUL128)
            }
            #[doc = "256x"]
            #[inline(always)]
            pub fn mul256(self) -> &'a mut W {
                self.variant(OVSR_A::MUL256)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 2)) | (((value as u32) & 0x07) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `OVSS`"]
        pub type OVSS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `OVSS`"]
        pub struct OVSS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVSS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 5)) | (((value as u32) & 0x0f) << 5);
                self.w
            }
        }
        #[doc = "Triggered Oversampling\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TOVS_A {
            #[doc = "0: All oversampled conversions for a channel are done consecutively after a trigger"]
            TRIGGERALL = 0,
            #[doc = "1: Each oversampled conversion for a channel needs a trigger"]
            TRIGGEREACH = 1,
        }
        impl From<TOVS_A> for bool {
            #[inline(always)]
            fn from(variant: TOVS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TOVS`"]
        pub type TOVS_R = crate::R<bool, TOVS_A>;
        impl TOVS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TOVS_A {
                match self.bits {
                    false => TOVS_A::TRIGGERALL,
                    true => TOVS_A::TRIGGEREACH,
                }
            }
            #[doc = "Checks if the value of the field is `TRIGGERALL`"]
            #[inline(always)]
            pub fn is_trigger_all(&self) -> bool {
                *self == TOVS_A::TRIGGERALL
            }
            #[doc = "Checks if the value of the field is `TRIGGEREACH`"]
            #[inline(always)]
            pub fn is_trigger_each(&self) -> bool {
                *self == TOVS_A::TRIGGEREACH
            }
        }
        #[doc = "Write proxy for field `TOVS`"]
        pub struct TOVS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TOVS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TOVS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "All oversampled conversions for a channel are done consecutively after a trigger"]
            #[inline(always)]
            pub fn trigger_all(self) -> &'a mut W {
                self.variant(TOVS_A::TRIGGERALL)
            }
            #[doc = "Each oversampled conversion for a channel needs a trigger"]
            #[inline(always)]
            pub fn trigger_each(self) -> &'a mut W {
                self.variant(TOVS_A::TRIGGEREACH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "ADC clock mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKMODE_A {
            #[doc = "0: ADCCLK (Asynchronous clock mode)"]
            ADCLK = 0,
            #[doc = "1: PCLK/2 (Synchronous clock mode)"]
            PCLK_DIV2 = 1,
            #[doc = "2: PCLK/4 (Synchronous clock mode)"]
            PCLK_DIV4 = 2,
            #[doc = "3: PCLK (Synchronous clock mode)"]
            PCLK = 3,
        }
        impl From<CKMODE_A> for u8 {
            #[inline(always)]
            fn from(variant: CKMODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKMODE`"]
        pub type CKMODE_R = crate::R<u8, CKMODE_A>;
        impl CKMODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CKMODE_A {
                match self.bits {
                    0 => CKMODE_A::ADCLK,
                    1 => CKMODE_A::PCLK_DIV2,
                    2 => CKMODE_A::PCLK_DIV4,
                    3 => CKMODE_A::PCLK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ADCLK`"]
            #[inline(always)]
            pub fn is_adclk(&self) -> bool {
                *self == CKMODE_A::ADCLK
            }
            #[doc = "Checks if the value of the field is `PCLK_DIV2`"]
            #[inline(always)]
            pub fn is_pclk_div2(&self) -> bool {
                *self == CKMODE_A::PCLK_DIV2
            }
            #[doc = "Checks if the value of the field is `PCLK_DIV4`"]
            #[inline(always)]
            pub fn is_pclk_div4(&self) -> bool {
                *self == CKMODE_A::PCLK_DIV4
            }
            #[doc = "Checks if the value of the field is `PCLK`"]
            #[inline(always)]
            pub fn is_pclk(&self) -> bool {
                *self == CKMODE_A::PCLK
            }
        }
        #[doc = "Write proxy for field `CKMODE`"]
        pub struct CKMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKMODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKMODE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "ADCCLK (Asynchronous clock mode)"]
            #[inline(always)]
            pub fn adclk(self) -> &'a mut W {
                self.variant(CKMODE_A::ADCLK)
            }
            #[doc = "PCLK/2 (Synchronous clock mode)"]
            #[inline(always)]
            pub fn pclk_div2(self) -> &'a mut W {
                self.variant(CKMODE_A::PCLK_DIV2)
            }
            #[doc = "PCLK/4 (Synchronous clock mode)"]
            #[inline(always)]
            pub fn pclk_div4(self) -> &'a mut W {
                self.variant(CKMODE_A::PCLK_DIV4)
            }
            #[doc = "PCLK (Synchronous clock mode)"]
            #[inline(always)]
            pub fn pclk(self) -> &'a mut W {
                self.variant(CKMODE_A::PCLK)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | (((value as u32) & 0x03) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Oversampler Enable"]
            #[inline(always)]
            pub fn ovse(&self) -> OVSE_R {
                OVSE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 2:4 - Oversampling ratio"]
            #[inline(always)]
            pub fn ovsr(&self) -> OVSR_R {
                OVSR_R::new(((self.bits >> 2) & 0x07) as u8)
            }
            #[doc = "Bits 5:8 - Oversampling shift"]
            #[inline(always)]
            pub fn ovss(&self) -> OVSS_R {
                OVSS_R::new(((self.bits >> 5) & 0x0f) as u8)
            }
            #[doc = "Bit 9 - Triggered Oversampling"]
            #[inline(always)]
            pub fn tovs(&self) -> TOVS_R {
                TOVS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bits 30:31 - ADC clock mode"]
            #[inline(always)]
            pub fn ckmode(&self) -> CKMODE_R {
                CKMODE_R::new(((self.bits >> 30) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Oversampler Enable"]
            #[inline(always)]
            pub fn ovse(&mut self) -> OVSE_W {
                OVSE_W { w: self }
            }
            #[doc = "Bits 2:4 - Oversampling ratio"]
            #[inline(always)]
            pub fn ovsr(&mut self) -> OVSR_W {
                OVSR_W { w: self }
            }
            #[doc = "Bits 5:8 - Oversampling shift"]
            #[inline(always)]
            pub fn ovss(&mut self) -> OVSS_W {
                OVSS_W { w: self }
            }
            #[doc = "Bit 9 - Triggered Oversampling"]
            #[inline(always)]
            pub fn tovs(&mut self) -> TOVS_W {
                TOVS_W { w: self }
            }
            #[doc = "Bits 30:31 - ADC clock mode"]
            #[inline(always)]
            pub fn ckmode(&mut self) -> CKMODE_W {
                CKMODE_W { w: self }
            }
        }
    }
    #[doc = "sampling time register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smpr](smpr) module"]
    pub type SMPR = crate::Reg<u32, _SMPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMPR;
    #[doc = "`read()` method returns [smpr::R](smpr::R) reader structure"]
    impl crate::Readable for SMPR {}
    #[doc = "`write(|w| ..)` method takes [smpr::W](smpr::W) writer structure"]
    impl crate::Writable for SMPR {}
    #[doc = "sampling time register"]
    pub mod smpr {
        #[doc = "Reader of register SMPR"]
        pub type R = crate::R<u32, super::SMPR>;
        #[doc = "Writer for register SMPR"]
        pub type W = crate::W<u32, super::SMPR>;
        #[doc = "Register SMPR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Sampling time selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMP_A {
            #[doc = "0: 1.5 ADC clock cycles"]
            CYCLES1_5 = 0,
            #[doc = "1: 3.5 ADC clock cycles"]
            CYCLES3_5 = 1,
            #[doc = "2: 7.5 ADC clock cycles"]
            CYCLES7_5 = 2,
            #[doc = "3: 12.5 ADC clock cycles"]
            CYCLES12_5 = 3,
            #[doc = "4: 19.5 ADC clock cycles"]
            CYCLES19_5 = 4,
            #[doc = "5: 39.5 ADC clock cycles"]
            CYCLES39_5 = 5,
            #[doc = "6: 79.5 ADC clock cycles"]
            CYCLES79_5 = 6,
            #[doc = "7: 160.5 ADC clock cycles"]
            CYCLES160_5 = 7,
        }
        impl From<SMP_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMP`"]
        pub type SMP_R = crate::R<u8, SMP_A>;
        impl SMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMP_A {
                match self.bits {
                    0 => SMP_A::CYCLES1_5,
                    1 => SMP_A::CYCLES3_5,
                    2 => SMP_A::CYCLES7_5,
                    3 => SMP_A::CYCLES12_5,
                    4 => SMP_A::CYCLES19_5,
                    5 => SMP_A::CYCLES39_5,
                    6 => SMP_A::CYCLES79_5,
                    7 => SMP_A::CYCLES160_5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CYCLES1_5`"]
            #[inline(always)]
            pub fn is_cycles1_5(&self) -> bool {
                *self == SMP_A::CYCLES1_5
            }
            #[doc = "Checks if the value of the field is `CYCLES3_5`"]
            #[inline(always)]
            pub fn is_cycles3_5(&self) -> bool {
                *self == SMP_A::CYCLES3_5
            }
            #[doc = "Checks if the value of the field is `CYCLES7_5`"]
            #[inline(always)]
            pub fn is_cycles7_5(&self) -> bool {
                *self == SMP_A::CYCLES7_5
            }
            #[doc = "Checks if the value of the field is `CYCLES12_5`"]
            #[inline(always)]
            pub fn is_cycles12_5(&self) -> bool {
                *self == SMP_A::CYCLES12_5
            }
            #[doc = "Checks if the value of the field is `CYCLES19_5`"]
            #[inline(always)]
            pub fn is_cycles19_5(&self) -> bool {
                *self == SMP_A::CYCLES19_5
            }
            #[doc = "Checks if the value of the field is `CYCLES39_5`"]
            #[inline(always)]
            pub fn is_cycles39_5(&self) -> bool {
                *self == SMP_A::CYCLES39_5
            }
            #[doc = "Checks if the value of the field is `CYCLES79_5`"]
            #[inline(always)]
            pub fn is_cycles79_5(&self) -> bool {
                *self == SMP_A::CYCLES79_5
            }
            #[doc = "Checks if the value of the field is `CYCLES160_5`"]
            #[inline(always)]
            pub fn is_cycles160_5(&self) -> bool {
                *self == SMP_A::CYCLES160_5
            }
        }
        #[doc = "Write proxy for field `SMP`"]
        pub struct SMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMP_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES1_5)
            }
            #[doc = "3.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles3_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES3_5)
            }
            #[doc = "7.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES7_5)
            }
            #[doc = "12.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles12_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES12_5)
            }
            #[doc = "19.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles19_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES19_5)
            }
            #[doc = "39.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles39_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES39_5)
            }
            #[doc = "79.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles79_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES79_5)
            }
            #[doc = "160.5 ADC clock cycles"]
            #[inline(always)]
            pub fn cycles160_5(self) -> &'a mut W {
                self.variant(SMP_A::CYCLES160_5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Sampling time selection"]
            #[inline(always)]
            pub fn smp(&self) -> SMP_R {
                SMP_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Sampling time selection"]
            #[inline(always)]
            pub fn smp(&mut self) -> SMP_W {
                SMP_W { w: self }
            }
        }
    }
    #[doc = "watchdog threshold register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tr](tr) module"]
    pub type TR = crate::Reg<u32, _TR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TR;
    #[doc = "`read()` method returns [tr::R](tr::R) reader structure"]
    impl crate::Readable for TR {}
    #[doc = "`write(|w| ..)` method takes [tr::W](tr::W) writer structure"]
    impl crate::Writable for TR {}
    #[doc = "watchdog threshold register"]
    pub mod tr {
        #[doc = "Reader of register TR"]
        pub type R = crate::R<u32, super::TR>;
        #[doc = "Writer for register TR"]
        pub type W = crate::W<u32, super::TR>;
        #[doc = "Register TR `reset()`'s with value 0x0fff_0000"]
        impl crate::ResetValue for super::TR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0x0fff_0000
            }
        }
        #[doc = "Reader of field `HT`"]
        pub type HT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `HT`"]
        pub struct HT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 16)) | (((value as u32) & 0x0fff) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `LT`"]
        pub type LT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `LT`"]
        pub struct LT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | ((value as u32) & 0x0fff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 16:27 - Analog watchdog higher threshold"]
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new(((self.bits >> 16) & 0x0fff) as u16)
            }
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline(always)]
            pub fn lt(&self) -> LT_R {
                LT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 16:27 - Analog watchdog higher threshold"]
            #[inline(always)]
            pub fn ht(&mut self) -> HT_W {
                HT_W { w: self }
            }
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline(always)]
            pub fn lt(&mut self) -> LT_W {
                LT_W { w: self }
            }
        }
    }
    #[doc = "channel selection register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chselr](chselr) module"]
    pub type CHSELR = crate::Reg<u32, _CHSELR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CHSELR;
    #[doc = "`read()` method returns [chselr::R](chselr::R) reader structure"]
    impl crate::Readable for CHSELR {}
    #[doc = "`write(|w| ..)` method takes [chselr::W](chselr::W) writer structure"]
    impl crate::Writable for CHSELR {}
    #[doc = "channel selection register"]
    pub mod chselr {
        #[doc = "Reader of register CHSELR"]
        pub type R = crate::R<u32, super::CHSELR>;
        #[doc = "Writer for register CHSELR"]
        pub type W = crate::W<u32, super::CHSELR>;
        #[doc = "Register CHSELR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CHSELR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Channel-x selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHSEL18_A {
            #[doc = "0: Input Channel is not selected for conversion"]
            NOTSELECTED = 0,
            #[doc = "1: Input Channel is selected for conversion"]
            SELECTED = 1,
        }
        impl From<CHSEL18_A> for bool {
            #[inline(always)]
            fn from(variant: CHSEL18_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CHSEL18`"]
        pub type CHSEL18_R = crate::R<bool, CHSEL18_A>;
        impl CHSEL18_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CHSEL18_A {
                match self.bits {
                    false => CHSEL18_A::NOTSELECTED,
                    true => CHSEL18_A::SELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSELECTED`"]
            #[inline(always)]
            pub fn is_not_selected(&self) -> bool {
                *self == CHSEL18_A::NOTSELECTED
            }
            #[doc = "Checks if the value of the field is `SELECTED`"]
            #[inline(always)]
            pub fn is_selected(&self) -> bool {
                *self == CHSEL18_A::SELECTED
            }
        }
        #[doc = "Write proxy for field `CHSEL18`"]
        pub struct CHSEL18_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL18_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL18_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL17_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL17`"]
        pub type CHSEL17_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL17`"]
        pub struct CHSEL17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL17_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL17_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL16_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL16`"]
        pub type CHSEL16_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL16`"]
        pub struct CHSEL16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL16_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL16_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL15_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL15`"]
        pub type CHSEL15_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL15`"]
        pub struct CHSEL15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL15_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL15_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL14_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL14`"]
        pub type CHSEL14_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL14`"]
        pub struct CHSEL14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL14_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL14_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL13_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL13`"]
        pub type CHSEL13_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL13`"]
        pub struct CHSEL13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL13_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL13_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL12_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL12`"]
        pub type CHSEL12_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL12`"]
        pub struct CHSEL12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL12_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL12_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL11_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL11`"]
        pub type CHSEL11_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL11`"]
        pub struct CHSEL11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL11_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL11_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL10_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL10`"]
        pub type CHSEL10_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL10`"]
        pub struct CHSEL10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL10_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL10_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL9_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL9`"]
        pub type CHSEL9_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL9`"]
        pub struct CHSEL9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL9_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL9_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL8_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL8`"]
        pub type CHSEL8_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL8`"]
        pub struct CHSEL8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL8_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL8_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL7_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL7`"]
        pub type CHSEL7_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL7`"]
        pub struct CHSEL7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL6_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL6`"]
        pub type CHSEL6_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL6`"]
        pub struct CHSEL6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL6_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL6_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL5_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL5`"]
        pub type CHSEL5_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL5`"]
        pub struct CHSEL5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL5_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL4_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL4`"]
        pub type CHSEL4_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL4`"]
        pub struct CHSEL4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL4_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL3_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL3`"]
        pub type CHSEL3_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL3`"]
        pub struct CHSEL3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL3_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL2_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL2`"]
        pub type CHSEL2_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL2`"]
        pub struct CHSEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL2_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL1_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL1`"]
        pub type CHSEL1_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL1`"]
        pub struct CHSEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Channel-x selection"]
        pub type CHSEL0_A = CHSEL18_A;
        #[doc = "Reader of field `CHSEL0`"]
        pub type CHSEL0_R = crate::R<bool, CHSEL18_A>;
        #[doc = "Write proxy for field `CHSEL0`"]
        pub struct CHSEL0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHSEL0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CHSEL0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Input Channel is not selected for conversion"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::NOTSELECTED)
            }
            #[doc = "Input Channel is selected for conversion"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(CHSEL18_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 18 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel18(&self) -> CHSEL18_R {
                CHSEL18_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel17(&self) -> CHSEL17_R {
                CHSEL17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel16(&self) -> CHSEL16_R {
                CHSEL16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel15(&self) -> CHSEL15_R {
                CHSEL15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel14(&self) -> CHSEL14_R {
                CHSEL14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel13(&self) -> CHSEL13_R {
                CHSEL13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel12(&self) -> CHSEL12_R {
                CHSEL12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel11(&self) -> CHSEL11_R {
                CHSEL11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel10(&self) -> CHSEL10_R {
                CHSEL10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel9(&self) -> CHSEL9_R {
                CHSEL9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel8(&self) -> CHSEL8_R {
                CHSEL8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel7(&self) -> CHSEL7_R {
                CHSEL7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel6(&self) -> CHSEL6_R {
                CHSEL6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel5(&self) -> CHSEL5_R {
                CHSEL5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel4(&self) -> CHSEL4_R {
                CHSEL4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel3(&self) -> CHSEL3_R {
                CHSEL3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel2(&self) -> CHSEL2_R {
                CHSEL2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel1(&self) -> CHSEL1_R {
                CHSEL1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel0(&self) -> CHSEL0_R {
                CHSEL0_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 18 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel18(&mut self) -> CHSEL18_W {
                CHSEL18_W { w: self }
            }
            #[doc = "Bit 17 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel17(&mut self) -> CHSEL17_W {
                CHSEL17_W { w: self }
            }
            #[doc = "Bit 16 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel16(&mut self) -> CHSEL16_W {
                CHSEL16_W { w: self }
            }
            #[doc = "Bit 15 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel15(&mut self) -> CHSEL15_W {
                CHSEL15_W { w: self }
            }
            #[doc = "Bit 14 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel14(&mut self) -> CHSEL14_W {
                CHSEL14_W { w: self }
            }
            #[doc = "Bit 13 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel13(&mut self) -> CHSEL13_W {
                CHSEL13_W { w: self }
            }
            #[doc = "Bit 12 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel12(&mut self) -> CHSEL12_W {
                CHSEL12_W { w: self }
            }
            #[doc = "Bit 11 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel11(&mut self) -> CHSEL11_W {
                CHSEL11_W { w: self }
            }
            #[doc = "Bit 10 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel10(&mut self) -> CHSEL10_W {
                CHSEL10_W { w: self }
            }
            #[doc = "Bit 9 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel9(&mut self) -> CHSEL9_W {
                CHSEL9_W { w: self }
            }
            #[doc = "Bit 8 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel8(&mut self) -> CHSEL8_W {
                CHSEL8_W { w: self }
            }
            #[doc = "Bit 7 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel7(&mut self) -> CHSEL7_W {
                CHSEL7_W { w: self }
            }
            #[doc = "Bit 6 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel6(&mut self) -> CHSEL6_W {
                CHSEL6_W { w: self }
            }
            #[doc = "Bit 5 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel5(&mut self) -> CHSEL5_W {
                CHSEL5_W { w: self }
            }
            #[doc = "Bit 4 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel4(&mut self) -> CHSEL4_W {
                CHSEL4_W { w: self }
            }
            #[doc = "Bit 3 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel3(&mut self) -> CHSEL3_W {
                CHSEL3_W { w: self }
            }
            #[doc = "Bit 2 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel2(&mut self) -> CHSEL2_W {
                CHSEL2_W { w: self }
            }
            #[doc = "Bit 1 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel1(&mut self) -> CHSEL1_W {
                CHSEL1_W { w: self }
            }
            #[doc = "Bit 0 - Channel-x selection"]
            #[inline(always)]
            pub fn chsel0(&mut self) -> CHSEL0_W {
                CHSEL0_W { w: self }
            }
        }
    }
    #[doc = "data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "data register"]
    pub mod dr {
        #[doc = "Reader of register DR"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Reader of field `DATA`"]
        pub type DATA_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Converted data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
        }
    }
    #[doc = "ADC Calibration factor\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calfact](calfact) module"]
    pub type CALFACT = crate::Reg<u32, _CALFACT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CALFACT;
    #[doc = "`read()` method returns [calfact::R](calfact::R) reader structure"]
    impl crate::Readable for CALFACT {}
    #[doc = "`write(|w| ..)` method takes [calfact::W](calfact::W) writer structure"]
    impl crate::Writable for CALFACT {}
    #[doc = "ADC Calibration factor"]
    pub mod calfact {
        #[doc = "Reader of register CALFACT"]
        pub type R = crate::R<u32, super::CALFACT>;
        #[doc = "Writer for register CALFACT"]
        pub type W = crate::W<u32, super::CALFACT>;
        #[doc = "Register CALFACT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CALFACT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CALFACT`"]
        pub type CALFACT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `CALFACT`"]
        pub struct CALFACT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALFACT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | ((value as u32) & 0x7f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:6 - Calibration factor"]
            #[inline(always)]
            pub fn calfact(&self) -> CALFACT_R {
                CALFACT_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - Calibration factor"]
            #[inline(always)]
            pub fn calfact(&mut self) -> CALFACT_W {
                CALFACT_W { w: self }
            }
        }
    }
    #[doc = "ADC common configuration register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "ADC common configuration register"]
    pub mod ccr {
        #[doc = "Reader of register CCR"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "ADC prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PRESC_A {
            #[doc = "0: Input ADC clock not divided"]
            DIV1 = 0,
            #[doc = "1: Input ADC clock divided by 2"]
            DIV2 = 1,
            #[doc = "2: Input ADC clock divided by 4"]
            DIV4 = 2,
            #[doc = "3: Input ADC clock divided by 6"]
            DIV6 = 3,
            #[doc = "4: Input ADC clock divided by 8"]
            DIV8 = 4,
            #[doc = "5: Input ADC clock divided by 10"]
            DIV10 = 5,
            #[doc = "6: Input ADC clock divided by 12"]
            DIV12 = 6,
            #[doc = "7: Input ADC clock divided by 16"]
            DIV16 = 7,
            #[doc = "8: Input ADC clock divided by 32"]
            DIV32 = 8,
            #[doc = "9: Input ADC clock divided by 64"]
            DIV64 = 9,
            #[doc = "10: Input ADC clock divided by 128"]
            DIV128 = 10,
            #[doc = "11: Input ADC clock divided by 256"]
            DIV256 = 11,
        }
        impl From<PRESC_A> for u8 {
            #[inline(always)]
            fn from(variant: PRESC_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `PRESC`"]
        pub type PRESC_R = crate::R<u8, PRESC_A>;
        impl PRESC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, PRESC_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(PRESC_A::DIV1),
                    1 => Val(PRESC_A::DIV2),
                    2 => Val(PRESC_A::DIV4),
                    3 => Val(PRESC_A::DIV6),
                    4 => Val(PRESC_A::DIV8),
                    5 => Val(PRESC_A::DIV10),
                    6 => Val(PRESC_A::DIV12),
                    7 => Val(PRESC_A::DIV16),
                    8 => Val(PRESC_A::DIV32),
                    9 => Val(PRESC_A::DIV64),
                    10 => Val(PRESC_A::DIV128),
                    11 => Val(PRESC_A::DIV256),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PRESC_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PRESC_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PRESC_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV6`"]
            #[inline(always)]
            pub fn is_div6(&self) -> bool {
                *self == PRESC_A::DIV6
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PRESC_A::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV10`"]
            #[inline(always)]
            pub fn is_div10(&self) -> bool {
                *self == PRESC_A::DIV10
            }
            #[doc = "Checks if the value of the field is `DIV12`"]
            #[inline(always)]
            pub fn is_div12(&self) -> bool {
                *self == PRESC_A::DIV12
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PRESC_A::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV32`"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == PRESC_A::DIV32
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PRESC_A::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == PRESC_A::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PRESC_A::DIV256
            }
        }
        #[doc = "Write proxy for field `PRESC`"]
        pub struct PRESC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRESC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PRESC_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Input ADC clock not divided"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PRESC_A::DIV1)
            }
            #[doc = "Input ADC clock divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PRESC_A::DIV2)
            }
            #[doc = "Input ADC clock divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PRESC_A::DIV4)
            }
            #[doc = "Input ADC clock divided by 6"]
            #[inline(always)]
            pub fn div6(self) -> &'a mut W {
                self.variant(PRESC_A::DIV6)
            }
            #[doc = "Input ADC clock divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PRESC_A::DIV8)
            }
            #[doc = "Input ADC clock divided by 10"]
            #[inline(always)]
            pub fn div10(self) -> &'a mut W {
                self.variant(PRESC_A::DIV10)
            }
            #[doc = "Input ADC clock divided by 12"]
            #[inline(always)]
            pub fn div12(self) -> &'a mut W {
                self.variant(PRESC_A::DIV12)
            }
            #[doc = "Input ADC clock divided by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PRESC_A::DIV16)
            }
            #[doc = "Input ADC clock divided by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(PRESC_A::DIV32)
            }
            #[doc = "Input ADC clock divided by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(PRESC_A::DIV64)
            }
            #[doc = "Input ADC clock divided by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(PRESC_A::DIV128)
            }
            #[doc = "Input ADC clock divided by 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(PRESC_A::DIV256)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 18)) | (((value as u32) & 0x0f) << 18);
                self.w
            }
        }
        #[doc = "VREFINT enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VREFEN_A {
            #[doc = "0: VREFINT disabled"]
            DISABLED = 0,
            #[doc = "1: VREFINT enabled"]
            ENABLED = 1,
        }
        impl From<VREFEN_A> for bool {
            #[inline(always)]
            fn from(variant: VREFEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VREFEN`"]
        pub type VREFEN_R = crate::R<bool, VREFEN_A>;
        impl VREFEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VREFEN_A {
                match self.bits {
                    false => VREFEN_A::DISABLED,
                    true => VREFEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == VREFEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == VREFEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `VREFEN`"]
        pub struct VREFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VREFEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: VREFEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "VREFINT disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(VREFEN_A::DISABLED)
            }
            #[doc = "VREFINT enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(VREFEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Temperature sensor enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSEN_A {
            #[doc = "0: Temperature sensor disabled"]
            DISABLED = 0,
            #[doc = "1: Temperature sensor enabled"]
            ENABLED = 1,
        }
        impl From<TSEN_A> for bool {
            #[inline(always)]
            fn from(variant: TSEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TSEN`"]
        pub type TSEN_R = crate::R<bool, TSEN_A>;
        impl TSEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TSEN_A {
                match self.bits {
                    false => TSEN_A::DISABLED,
                    true => TSEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TSEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TSEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TSEN`"]
        pub struct TSEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TSEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Temperature sensor disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TSEN_A::DISABLED)
            }
            #[doc = "Temperature sensor enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TSEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "VLCD enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VLCDEN_A {
            #[doc = "0: VLCD reading circuitry disabled"]
            DISABLED = 0,
            #[doc = "1: VLCD reading circuitry enabled"]
            ENABLED = 1,
        }
        impl From<VLCDEN_A> for bool {
            #[inline(always)]
            fn from(variant: VLCDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `VLCDEN`"]
        pub type VLCDEN_R = crate::R<bool, VLCDEN_A>;
        impl VLCDEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> VLCDEN_A {
                match self.bits {
                    false => VLCDEN_A::DISABLED,
                    true => VLCDEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == VLCDEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == VLCDEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `VLCDEN`"]
        pub struct VLCDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VLCDEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: VLCDEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "VLCD reading circuitry disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(VLCDEN_A::DISABLED)
            }
            #[doc = "VLCD reading circuitry enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(VLCDEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Low Frequency Mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LFMEN_A {
            #[doc = "0: Low Frequency Mode disabled"]
            DISABLED = 0,
            #[doc = "1: Low Frequency Mode enabled"]
            ENABLED = 1,
        }
        impl From<LFMEN_A> for bool {
            #[inline(always)]
            fn from(variant: LFMEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `LFMEN`"]
        pub type LFMEN_R = crate::R<bool, LFMEN_A>;
        impl LFMEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LFMEN_A {
                match self.bits {
                    false => LFMEN_A::DISABLED,
                    true => LFMEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LFMEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LFMEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `LFMEN`"]
        pub struct LFMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LFMEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LFMEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Low Frequency Mode disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LFMEN_A::DISABLED)
            }
            #[doc = "Low Frequency Mode enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LFMEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 18:21 - ADC prescaler"]
            #[inline(always)]
            pub fn presc(&self) -> PRESC_R {
                PRESC_R::new(((self.bits >> 18) & 0x0f) as u8)
            }
            #[doc = "Bit 22 - VREFINT enable"]
            #[inline(always)]
            pub fn vrefen(&self) -> VREFEN_R {
                VREFEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Temperature sensor enable"]
            #[inline(always)]
            pub fn tsen(&self) -> TSEN_R {
                TSEN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24 - VLCD enable"]
            #[inline(always)]
            pub fn vlcden(&self) -> VLCDEN_R {
                VLCDEN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Low Frequency Mode enable"]
            #[inline(always)]
            pub fn lfmen(&self) -> LFMEN_R {
                LFMEN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 18:21 - ADC prescaler"]
            #[inline(always)]
            pub fn presc(&mut self) -> PRESC_W {
                PRESC_W { w: self }
            }
            #[doc = "Bit 22 - VREFINT enable"]
            #[inline(always)]
            pub fn vrefen(&mut self) -> VREFEN_W {
                VREFEN_W { w: self }
            }
            #[doc = "Bit 23 - Temperature sensor enable"]
            #[inline(always)]
            pub fn tsen(&mut self) -> TSEN_W {
                TSEN_W { w: self }
            }
            #[doc = "Bit 24 - VLCD enable"]
            #[inline(always)]
            pub fn vlcden(&mut self) -> VLCDEN_W {
                VLCDEN_W { w: self }
            }
            #[doc = "Bit 25 - Low Frequency Mode enable"]
            #[inline(always)]
            pub fn lfmen(&mut self) -> LFMEN_W {
                LFMEN_W { w: self }
            }
        }
    }
}
#[doc = "Debug support"]
pub struct DBG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DBG {}
impl DBG {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dbg::RegisterBlock {
        0x4001_5800 as *const _
    }
}
impl Deref for DBG {
    type Target = dbg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DBG::ptr() }
    }
}
#[doc = "Debug support"]
pub mod dbg {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - MCU Device ID Code Register"]
        pub idcode: IDCODE,
        #[doc = "0x04 - Debug MCU Configuration Register"]
        pub cr: CR,
        #[doc = "0x08 - APB Low Freeze Register"]
        pub apb1_fz: APB1_FZ,
        #[doc = "0x0c - APB High Freeze Register"]
        pub apb2_fz: APB2_FZ,
    }
    #[doc = "MCU Device ID Code Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idcode](idcode) module"]
    pub type IDCODE = crate::Reg<u32, _IDCODE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDCODE;
    #[doc = "`read()` method returns [idcode::R](idcode::R) reader structure"]
    impl crate::Readable for IDCODE {}
    #[doc = "MCU Device ID Code Register"]
    pub mod idcode {
        #[doc = "Reader of register IDCODE"]
        pub type R = crate::R<u32, super::IDCODE>;
        #[doc = "Reader of field `DEV_ID`"]
        pub type DEV_ID_R = crate::R<u16, u16>;
        #[doc = "Reader of field `REV_ID`"]
        pub type REV_ID_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:11 - Device Identifier"]
            #[inline(always)]
            pub fn dev_id(&self) -> DEV_ID_R {
                DEV_ID_R::new((self.bits & 0x0fff) as u16)
            }
            #[doc = "Bits 16:31 - Revision Identifier"]
            #[inline(always)]
            pub fn rev_id(&self) -> REV_ID_R {
                REV_ID_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
    }
    #[doc = "Debug MCU Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Debug MCU Configuration Register"]
    pub mod cr {
        #[doc = "Reader of register CR"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register CR"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register CR `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Debug Stop Mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_STOP_A {
            #[doc = "0: Debug Stop Mode Disabled"]
            DISABLED = 0,
            #[doc = "1: Debug Stop Mode Enabled"]
            ENABLED = 1,
        }
        impl From<DBG_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_STOP`"]
        pub type DBG_STOP_R = crate::R<bool, DBG_STOP_A>;
        impl DBG_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_STOP_A {
                match self.bits {
                    false => DBG_STOP_A::DISABLED,
                    true => DBG_STOP_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DBG_STOP_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DBG_STOP_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DBG_STOP`"]
        pub struct DBG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Debug Stop Mode Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBG_STOP_A::DISABLED)
            }
            #[doc = "Debug Stop Mode Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBG_STOP_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Debug Standby Mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_STANDBY_A {
            #[doc = "0: Debug Standby Mode Disabled"]
            DISABLED = 0,
            #[doc = "1: Debug Standby Mode Enabled"]
            ENABLED = 1,
        }
        impl From<DBG_STANDBY_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_STANDBY_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_STANDBY`"]
        pub type DBG_STANDBY_R = crate::R<bool, DBG_STANDBY_A>;
        impl DBG_STANDBY_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_STANDBY_A {
                match self.bits {
                    false => DBG_STANDBY_A::DISABLED,
                    true => DBG_STANDBY_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DBG_STANDBY_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DBG_STANDBY_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DBG_STANDBY`"]
        pub struct DBG_STANDBY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_STANDBY_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_STANDBY_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Debug Standby Mode Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBG_STANDBY_A::DISABLED)
            }
            #[doc = "Debug Standby Mode Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBG_STANDBY_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Debug Sleep Mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_SLEEP_A {
            #[doc = "0: Debug Sleep Mode Disabled"]
            DISABLED = 0,
            #[doc = "1: Debug Sleep Mode Enabled"]
            ENABLED = 1,
        }
        impl From<DBG_SLEEP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_SLEEP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_SLEEP`"]
        pub type DBG_SLEEP_R = crate::R<bool, DBG_SLEEP_A>;
        impl DBG_SLEEP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_SLEEP_A {
                match self.bits {
                    false => DBG_SLEEP_A::DISABLED,
                    true => DBG_SLEEP_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DBG_SLEEP_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DBG_SLEEP_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DBG_SLEEP`"]
        pub struct DBG_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_SLEEP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_SLEEP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Debug Sleep Mode Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBG_SLEEP_A::DISABLED)
            }
            #[doc = "Debug Sleep Mode Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBG_SLEEP_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 1 - Debug Stop Mode"]
            #[inline(always)]
            pub fn dbg_stop(&self) -> DBG_STOP_R {
                DBG_STOP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Debug Standby Mode"]
            #[inline(always)]
            pub fn dbg_standby(&self) -> DBG_STANDBY_R {
                DBG_STANDBY_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Debug Sleep Mode"]
            #[inline(always)]
            pub fn dbg_sleep(&self) -> DBG_SLEEP_R {
                DBG_SLEEP_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - Debug Stop Mode"]
            #[inline(always)]
            pub fn dbg_stop(&mut self) -> DBG_STOP_W {
                DBG_STOP_W { w: self }
            }
            #[doc = "Bit 2 - Debug Standby Mode"]
            #[inline(always)]
            pub fn dbg_standby(&mut self) -> DBG_STANDBY_W {
                DBG_STANDBY_W { w: self }
            }
            #[doc = "Bit 0 - Debug Sleep Mode"]
            #[inline(always)]
            pub fn dbg_sleep(&mut self) -> DBG_SLEEP_W {
                DBG_SLEEP_W { w: self }
            }
        }
    }
    #[doc = "APB Low Freeze Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb1_fz](apb1_fz) module"]
    pub type APB1_FZ = crate::Reg<u32, _APB1_FZ>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB1_FZ;
    #[doc = "`read()` method returns [apb1_fz::R](apb1_fz::R) reader structure"]
    impl crate::Readable for APB1_FZ {}
    #[doc = "`write(|w| ..)` method takes [apb1_fz::W](apb1_fz::W) writer structure"]
    impl crate::Writable for APB1_FZ {}
    #[doc = "APB Low Freeze Register"]
    pub mod apb1_fz {
        #[doc = "Reader of register APB1_FZ"]
        pub type R = crate::R<u32, super::APB1_FZ>;
        #[doc = "Writer for register APB1_FZ"]
        pub type W = crate::W<u32, super::APB1_FZ>;
        #[doc = "Register APB1_FZ `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB1_FZ {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Debug Timer 2 stopped when Core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_TIMER2_STOP_A {
            #[doc = "0: The counter clock of TIMx is fed even if the core is halted"]
            CONTINUE = 0,
            #[doc = "1: The counter clock of TIMx is stopped when the core is halted"]
            STOP = 1,
        }
        impl From<DBG_TIMER2_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_TIMER2_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_TIMER2_STOP`"]
        pub type DBG_TIMER2_STOP_R = crate::R<bool, DBG_TIMER2_STOP_A>;
        impl DBG_TIMER2_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_TIMER2_STOP_A {
                match self.bits {
                    false => DBG_TIMER2_STOP_A::CONTINUE,
                    true => DBG_TIMER2_STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline(always)]
            pub fn is_continue_(&self) -> bool {
                *self == DBG_TIMER2_STOP_A::CONTINUE
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == DBG_TIMER2_STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `DBG_TIMER2_STOP`"]
        pub struct DBG_TIMER2_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIMER2_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_TIMER2_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The counter clock of TIMx is fed even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_TIMER2_STOP_A::CONTINUE)
            }
            #[doc = "The counter clock of TIMx is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_TIMER2_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Debug Timer 6 stopped when Core is halted"]
        pub type DBG_TIMER6_STOP_A = DBG_TIMER2_STOP_A;
        #[doc = "Reader of field `DBG_TIMER6_STOP`"]
        pub type DBG_TIMER6_STOP_R = crate::R<bool, DBG_TIMER2_STOP_A>;
        #[doc = "Write proxy for field `DBG_TIMER6_STOP`"]
        pub struct DBG_TIMER6_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIMER6_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_TIMER6_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The counter clock of TIMx is fed even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_TIMER2_STOP_A::CONTINUE)
            }
            #[doc = "The counter clock of TIMx is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_TIMER2_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Debug RTC stopped when Core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_RTC_STOP_A {
            #[doc = "0: The clock of the RTC counter is fed even if the core is halted"]
            CONTINUE = 0,
            #[doc = "1: The clock of the RTC counter is stopped when the core is halted"]
            STOP = 1,
        }
        impl From<DBG_RTC_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_RTC_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_RTC_STOP`"]
        pub type DBG_RTC_STOP_R = crate::R<bool, DBG_RTC_STOP_A>;
        impl DBG_RTC_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_RTC_STOP_A {
                match self.bits {
                    false => DBG_RTC_STOP_A::CONTINUE,
                    true => DBG_RTC_STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline(always)]
            pub fn is_continue_(&self) -> bool {
                *self == DBG_RTC_STOP_A::CONTINUE
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == DBG_RTC_STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `DBG_RTC_STOP`"]
        pub struct DBG_RTC_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_RTC_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_RTC_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The clock of the RTC counter is fed even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_RTC_STOP_A::CONTINUE)
            }
            #[doc = "The clock of the RTC counter is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_RTC_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Debug Window Wachdog stopped when Core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_WWDG_STOP_A {
            #[doc = "0: The window watchdog counter clock continues even if the core is halted"]
            CONTINUE = 0,
            #[doc = "1: The window watchdog counter clock is stopped when the core is halted"]
            STOP = 1,
        }
        impl From<DBG_WWDG_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_WWDG_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_WWDG_STOP`"]
        pub type DBG_WWDG_STOP_R = crate::R<bool, DBG_WWDG_STOP_A>;
        impl DBG_WWDG_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_WWDG_STOP_A {
                match self.bits {
                    false => DBG_WWDG_STOP_A::CONTINUE,
                    true => DBG_WWDG_STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline(always)]
            pub fn is_continue_(&self) -> bool {
                *self == DBG_WWDG_STOP_A::CONTINUE
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == DBG_WWDG_STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `DBG_WWDG_STOP`"]
        pub struct DBG_WWDG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_WWDG_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_WWDG_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The window watchdog counter clock continues even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_WWDG_STOP_A::CONTINUE)
            }
            #[doc = "The window watchdog counter clock is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_WWDG_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Debug Independent Wachdog stopped when Core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_IWDG_STOP_A {
            #[doc = "0: The independent watchdog counter clock continues even if the core is halted"]
            CONTINUE = 0,
            #[doc = "1: The independent watchdog counter clock is stopped when the core is halted"]
            STOP = 1,
        }
        impl From<DBG_IWDG_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_IWDG_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_IWDG_STOP`"]
        pub type DBG_IWDG_STOP_R = crate::R<bool, DBG_IWDG_STOP_A>;
        impl DBG_IWDG_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_IWDG_STOP_A {
                match self.bits {
                    false => DBG_IWDG_STOP_A::CONTINUE,
                    true => DBG_IWDG_STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline(always)]
            pub fn is_continue_(&self) -> bool {
                *self == DBG_IWDG_STOP_A::CONTINUE
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == DBG_IWDG_STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `DBG_IWDG_STOP`"]
        pub struct DBG_IWDG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_IWDG_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_IWDG_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The independent watchdog counter clock continues even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_IWDG_STOP_A::CONTINUE)
            }
            #[doc = "The independent watchdog counter clock is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_IWDG_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "I2C1 SMBUS timeout mode stopped when core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_I2C1_STOP_A {
            #[doc = "0: Same behavior as in normal mode"]
            NORMALMODE = 0,
            #[doc = "1: I2C3 SMBUS timeout is frozen"]
            SMBUSTIMEOUTFROZEN = 1,
        }
        impl From<DBG_I2C1_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_I2C1_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_I2C1_STOP`"]
        pub type DBG_I2C1_STOP_R = crate::R<bool, DBG_I2C1_STOP_A>;
        impl DBG_I2C1_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_I2C1_STOP_A {
                match self.bits {
                    false => DBG_I2C1_STOP_A::NORMALMODE,
                    true => DBG_I2C1_STOP_A::SMBUSTIMEOUTFROZEN,
                }
            }
            #[doc = "Checks if the value of the field is `NORMALMODE`"]
            #[inline(always)]
            pub fn is_normal_mode(&self) -> bool {
                *self == DBG_I2C1_STOP_A::NORMALMODE
            }
            #[doc = "Checks if the value of the field is `SMBUSTIMEOUTFROZEN`"]
            #[inline(always)]
            pub fn is_smbus_timeout_frozen(&self) -> bool {
                *self == DBG_I2C1_STOP_A::SMBUSTIMEOUTFROZEN
            }
        }
        #[doc = "Write proxy for field `DBG_I2C1_STOP`"]
        pub struct DBG_I2C1_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_I2C1_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_I2C1_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Same behavior as in normal mode"]
            #[inline(always)]
            pub fn normal_mode(self) -> &'a mut W {
                self.variant(DBG_I2C1_STOP_A::NORMALMODE)
            }
            #[doc = "I2C3 SMBUS timeout is frozen"]
            #[inline(always)]
            pub fn smbus_timeout_frozen(self) -> &'a mut W {
                self.variant(DBG_I2C1_STOP_A::SMBUSTIMEOUTFROZEN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "I2C2 SMBUS timeout mode stopped when core is halted"]
        pub type DBG_I2C2_STOP_A = DBG_I2C1_STOP_A;
        #[doc = "Reader of field `DBG_I2C2_STOP`"]
        pub type DBG_I2C2_STOP_R = crate::R<bool, DBG_I2C1_STOP_A>;
        #[doc = "Write proxy for field `DBG_I2C2_STOP`"]
        pub struct DBG_I2C2_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_I2C2_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_I2C2_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Same behavior as in normal mode"]
            #[inline(always)]
            pub fn normal_mode(self) -> &'a mut W {
                self.variant(DBG_I2C1_STOP_A::NORMALMODE)
            }
            #[doc = "I2C3 SMBUS timeout is frozen"]
            #[inline(always)]
            pub fn smbus_timeout_frozen(self) -> &'a mut W {
                self.variant(DBG_I2C1_STOP_A::SMBUSTIMEOUTFROZEN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "LPTIM1 counter stopped when core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_LPTIMER_STOP_A {
            #[doc = "0: LPTIM1 counter clock is fed even if the core is halted"]
            CONTINUE = 0,
            #[doc = "1: LPTIM1 counter clock is stopped when the core is halted"]
            STOP = 1,
        }
        impl From<DBG_LPTIMER_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_LPTIMER_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_LPTIMER_STOP`"]
        pub type DBG_LPTIMER_STOP_R = crate::R<bool, DBG_LPTIMER_STOP_A>;
        impl DBG_LPTIMER_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_LPTIMER_STOP_A {
                match self.bits {
                    false => DBG_LPTIMER_STOP_A::CONTINUE,
                    true => DBG_LPTIMER_STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline(always)]
            pub fn is_continue_(&self) -> bool {
                *self == DBG_LPTIMER_STOP_A::CONTINUE
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == DBG_LPTIMER_STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `DBG_LPTIMER_STOP`"]
        pub struct DBG_LPTIMER_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_LPTIMER_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_LPTIMER_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "LPTIM1 counter clock is fed even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_LPTIMER_STOP_A::CONTINUE)
            }
            #[doc = "LPTIM1 counter clock is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_LPTIMER_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Debug Timer 2 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer2_stop(&self) -> DBG_TIMER2_STOP_R {
                DBG_TIMER2_STOP_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 4 - Debug Timer 6 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer6_stop(&self) -> DBG_TIMER6_STOP_R {
                DBG_TIMER6_STOP_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Debug RTC stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_rtc_stop(&self) -> DBG_RTC_STOP_R {
                DBG_RTC_STOP_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Debug Window Wachdog stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_wwdg_stop(&self) -> DBG_WWDG_STOP_R {
                DBG_WWDG_STOP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Debug Independent Wachdog stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_iwdg_stop(&self) -> DBG_IWDG_STOP_R {
                DBG_IWDG_STOP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 21 - I2C1 SMBUS timeout mode stopped when core is halted"]
            #[inline(always)]
            pub fn dbg_i2c1_stop(&self) -> DBG_I2C1_STOP_R {
                DBG_I2C1_STOP_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - I2C2 SMBUS timeout mode stopped when core is halted"]
            #[inline(always)]
            pub fn dbg_i2c2_stop(&self) -> DBG_I2C2_STOP_R {
                DBG_I2C2_STOP_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 31 - LPTIM1 counter stopped when core is halted"]
            #[inline(always)]
            pub fn dbg_lptimer_stop(&self) -> DBG_LPTIMER_STOP_R {
                DBG_LPTIMER_STOP_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Debug Timer 2 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer2_stop(&mut self) -> DBG_TIMER2_STOP_W {
                DBG_TIMER2_STOP_W { w: self }
            }
            #[doc = "Bit 4 - Debug Timer 6 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer6_stop(&mut self) -> DBG_TIMER6_STOP_W {
                DBG_TIMER6_STOP_W { w: self }
            }
            #[doc = "Bit 10 - Debug RTC stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_rtc_stop(&mut self) -> DBG_RTC_STOP_W {
                DBG_RTC_STOP_W { w: self }
            }
            #[doc = "Bit 11 - Debug Window Wachdog stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_wwdg_stop(&mut self) -> DBG_WWDG_STOP_W {
                DBG_WWDG_STOP_W { w: self }
            }
            #[doc = "Bit 12 - Debug Independent Wachdog stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_iwdg_stop(&mut self) -> DBG_IWDG_STOP_W {
                DBG_IWDG_STOP_W { w: self }
            }
            #[doc = "Bit 21 - I2C1 SMBUS timeout mode stopped when core is halted"]
            #[inline(always)]
            pub fn dbg_i2c1_stop(&mut self) -> DBG_I2C1_STOP_W {
                DBG_I2C1_STOP_W { w: self }
            }
            #[doc = "Bit 22 - I2C2 SMBUS timeout mode stopped when core is halted"]
            #[inline(always)]
            pub fn dbg_i2c2_stop(&mut self) -> DBG_I2C2_STOP_W {
                DBG_I2C2_STOP_W { w: self }
            }
            #[doc = "Bit 31 - LPTIM1 counter stopped when core is halted"]
            #[inline(always)]
            pub fn dbg_lptimer_stop(&mut self) -> DBG_LPTIMER_STOP_W {
                DBG_LPTIMER_STOP_W { w: self }
            }
        }
    }
    #[doc = "APB High Freeze Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apb2_fz](apb2_fz) module"]
    pub type APB2_FZ = crate::Reg<u32, _APB2_FZ>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _APB2_FZ;
    #[doc = "`read()` method returns [apb2_fz::R](apb2_fz::R) reader structure"]
    impl crate::Readable for APB2_FZ {}
    #[doc = "`write(|w| ..)` method takes [apb2_fz::W](apb2_fz::W) writer structure"]
    impl crate::Writable for APB2_FZ {}
    #[doc = "APB High Freeze Register"]
    pub mod apb2_fz {
        #[doc = "Reader of register APB2_FZ"]
        pub type R = crate::R<u32, super::APB2_FZ>;
        #[doc = "Writer for register APB2_FZ"]
        pub type W = crate::W<u32, super::APB2_FZ>;
        #[doc = "Register APB2_FZ `reset()`'s with value 0"]
        impl crate::ResetValue for super::APB2_FZ {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Debug Timer 21 stopped when Core is halted\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBG_TIMER21_STOP_A {
            #[doc = "0: The counter clock of TIMx is fed even if the core is halted"]
            CONTINUE = 0,
            #[doc = "1: The counter clock of TIMx is stopped when the core is halted"]
            STOP = 1,
        }
        impl From<DBG_TIMER21_STOP_A> for bool {
            #[inline(always)]
            fn from(variant: DBG_TIMER21_STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DBG_TIMER21_STOP`"]
        pub type DBG_TIMER21_STOP_R = crate::R<bool, DBG_TIMER21_STOP_A>;
        impl DBG_TIMER21_STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DBG_TIMER21_STOP_A {
                match self.bits {
                    false => DBG_TIMER21_STOP_A::CONTINUE,
                    true => DBG_TIMER21_STOP_A::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `CONTINUE`"]
            #[inline(always)]
            pub fn is_continue_(&self) -> bool {
                *self == DBG_TIMER21_STOP_A::CONTINUE
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == DBG_TIMER21_STOP_A::STOP
            }
        }
        #[doc = "Write proxy for field `DBG_TIMER21_STOP`"]
        pub struct DBG_TIMER21_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIMER21_STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DBG_TIMER21_STOP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The counter clock of TIMx is fed even if the core is halted"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(DBG_TIMER21_STOP_A::CONTINUE)
            }
            #[doc = "The counter clock of TIMx is stopped when the core is halted"]
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(DBG_TIMER21_STOP_A::STOP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `DBG_TIMER22_STO`"]
        pub type DBG_TIMER22_STO_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `DBG_TIMER22_STO`"]
        pub struct DBG_TIMER22_STO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIMER22_STO_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 2 - Debug Timer 21 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer21_stop(&self) -> DBG_TIMER21_STOP_R {
                DBG_TIMER21_STOP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Debug Timer 22 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer22_sto(&self) -> DBG_TIMER22_STO_R {
                DBG_TIMER22_STO_R::new(((self.bits >> 6) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - Debug Timer 21 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer21_stop(&mut self) -> DBG_TIMER21_STOP_W {
                DBG_TIMER21_STOP_W { w: self }
            }
            #[doc = "Bit 6 - Debug Timer 22 stopped when Core is halted"]
            #[inline(always)]
            pub fn dbg_timer22_sto(&mut self) -> DBG_TIMER22_STO_W {
                DBG_TIMER22_STO_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM2 {}
impl TIM2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0000 as *const _
    }
}
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM2::ptr() }
    }
}
#[doc = "General-purpose-timers"]
pub mod tim2 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved_7_ccmr2: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - TIMx counter"]
        pub cnt: CNT,
        _reserved10: [u8; 2usize],
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - TIMx auto-reload register"]
        pub arr: ARR,
        _reserved12: [u8; 6usize],
        #[doc = "0x34 - TIMx capture/compare register 1"]
        pub ccr1: CCR,
        _reserved13: [u8; 2usize],
        #[doc = "0x38 - TIMx capture/compare register 1"]
        pub ccr2: CCR,
        _reserved14: [u8; 2usize],
        #[doc = "0x3c - TIMx capture/compare register 1"]
        pub ccr3: CCR,
        _reserved15: [u8; 2usize],
        #[doc = "0x40 - TIMx capture/compare register 1"]
        pub ccr4: CCR,
        _reserved16: [u8; 6usize],
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
        #[doc = "0x50 - TIM2 option register"]
        pub or: OR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (input mode)"]
        #[inline(always)]
        pub fn ccmr2_input(&self) -> &CCMR2_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(28usize) as *const CCMR2_INPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (input mode)"]
        #[inline(always)]
        pub fn ccmr2_input_mut(&self) -> &mut CCMR2_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(28usize) as *mut CCMR2_INPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (output mode)"]
        #[inline(always)]
        pub fn ccmr2_output(&self) -> &CCMR2_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(28usize) as *const CCMR2_OUTPUT) }
        }
        #[doc = "0x1c - capture/compare mode register 2 (output mode)"]
        #[inline(always)]
        pub fn ccmr2_output_mut(&self) -> &mut CCMR2_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(28usize) as *mut CCMR2_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Center-aligned mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            #[doc = "0: The counter counts up or down depending on the direction bit"]
            EDGEALIGNED = 0,
            #[doc = "1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            CENTERALIGNED1 = 1,
            #[doc = "2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            CENTERALIGNED2 = 2,
            #[doc = "3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CMS`"]
        pub type CMS_R = crate::R<u8, CMS_A>;
        impl CMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `EDGEALIGNED`"]
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                *self == CMS_A::EDGEALIGNED
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED1`"]
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                *self == CMS_A::CENTERALIGNED1
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED2`"]
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                *self == CMS_A::CENTERALIGNED2
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED3`"]
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                *self == CMS_A::CENTERALIGNED3
            }
        }
        #[doc = "Write proxy for field `CMS`"]
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The counter counts up or down depending on the direction bit"]
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "Direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            #[doc = "0: Counter used as upcounter"]
            UP = 0,
            #[doc = "1: Counter used as downcounter"]
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DIR`"]
        pub type DIR_R = crate::R<bool, DIR_A>;
        impl DIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                *self == DIR_A::UP
            }
            #[doc = "Checks if the value of the field is `DOWN`"]
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                *self == DIR_A::DOWN
            }
        }
        #[doc = "Write proxy for field `DIR`"]
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter used as upcounter"]
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            #[doc = "Counter used as downcounter"]
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped at update event"]
            DISABLED = 0,
            #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "TI1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI1S_A {
            #[doc = "0: The TIMx_CH1 pin is connected to TI1 input"]
            NORMAL = 0,
            #[doc = "1: The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            XOR = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TI1S`"]
        pub type TI1S_R = crate::R<bool, TI1S_A>;
        impl TI1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::NORMAL,
                    true => TI1S_A::XOR,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == TI1S_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `XOR`"]
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                *self == TI1S_A::XOR
            }
        }
        #[doc = "Write proxy for field `TI1S`"]
        pub struct TI1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI1S_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIMx_CH1 pin is connected to TI1 input"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(TI1S_A::NORMAL)
            }
            #[doc = "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::XOR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: The UG bit from the TIMx_EGR register is used as trigger output"]
            RESET = 0,
            #[doc = "1: The counter enable signal, CNT_EN, is used as trigger output"]
            ENABLE = 1,
            #[doc = "2: The update event is selected as trigger output"]
            UPDATE = 2,
            #[doc = "3: The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            COMPAREPULSE = 3,
            #[doc = "4: OC1REF signal is used as trigger output"]
            COMPAREOC1 = 4,
            #[doc = "5: OC2REF signal is used as trigger output"]
            COMPAREOC2 = 5,
            #[doc = "6: OC3REF signal is used as trigger output"]
            COMPAREOC3 = 6,
            #[doc = "7: OC4REF signal is used as trigger output"]
            COMPAREOC4 = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::RESET,
                    1 => MMS_A::ENABLE,
                    2 => MMS_A::UPDATE,
                    3 => MMS_A::COMPAREPULSE,
                    4 => MMS_A::COMPAREOC1,
                    5 => MMS_A::COMPAREOC2,
                    6 => MMS_A::COMPAREOC3,
                    7 => MMS_A::COMPAREOC4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
            #[doc = "Checks if the value of the field is `COMPAREPULSE`"]
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                *self == MMS_A::COMPAREPULSE
            }
            #[doc = "Checks if the value of the field is `COMPAREOC1`"]
            #[inline(always)]
            pub fn is_compare_oc1(&self) -> bool {
                *self == MMS_A::COMPAREOC1
            }
            #[doc = "Checks if the value of the field is `COMPAREOC2`"]
            #[inline(always)]
            pub fn is_compare_oc2(&self) -> bool {
                *self == MMS_A::COMPAREOC2
            }
            #[doc = "Checks if the value of the field is `COMPAREOC3`"]
            #[inline(always)]
            pub fn is_compare_oc3(&self) -> bool {
                *self == MMS_A::COMPAREOC3
            }
            #[doc = "Checks if the value of the field is `COMPAREOC4`"]
            #[inline(always)]
            pub fn is_compare_oc4(&self) -> bool {
                *self == MMS_A::COMPAREOC4
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The UG bit from the TIMx_EGR register is used as trigger output"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "The counter enable signal, CNT_EN, is used as trigger output"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "The update event is selected as trigger output"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            #[doc = "OC1REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc1(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC1)
            }
            #[doc = "OC2REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc2(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC2)
            }
            #[doc = "OC3REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc3(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC3)
            }
            #[doc = "OC4REF signal is used as trigger output"]
            #[inline(always)]
            pub fn compare_oc4(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Capture/compare DMA selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            #[doc = "0: CCx DMA request sent when CCx event occurs"]
            ONCOMPARE = 0,
            #[doc = "1: CCx DMA request sent when update event occurs"]
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CCDS`"]
        pub type CCDS_R = crate::R<bool, CCDS_A>;
        impl CCDS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            #[doc = "Checks if the value of the field is `ONCOMPARE`"]
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                *self == CCDS_A::ONCOMPARE
            }
            #[doc = "Checks if the value of the field is `ONUPDATE`"]
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                *self == CCDS_A::ONUPDATE
            }
        }
        #[doc = "Write proxy for field `CCDS`"]
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request sent when CCx event occurs"]
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            #[doc = "CCx DMA request sent when update event occurs"]
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - TI1 selection"]
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - TI1 selection"]
            #[inline(always)]
            pub fn ti1s(&mut self) -> TI1S_W {
                TI1S_W { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "External trigger polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            #[doc = "0: ETR is noninverted, active at high level or rising edge"]
            NOTINVERTED = 0,
            #[doc = "1: ETR is inverted, active at low level or falling edge"]
            INVERTED = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ETP`"]
        pub type ETP_R = crate::R<bool, ETP_A>;
        impl ETP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::NOTINVERTED,
                    true => ETP_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINVERTED`"]
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                *self == ETP_A::NOTINVERTED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == ETP_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `ETP`"]
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ETR is noninverted, active at high level or rising edge"]
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(ETP_A::NOTINVERTED)
            }
            #[doc = "ETR is inverted, active at low level or falling edge"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(ETP_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "External clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            #[doc = "0: External clock mode 2 disabled"]
            DISABLED = 0,
            #[doc = "1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ECE`"]
        pub type ECE_R = crate::R<bool, ECE_A>;
        impl ECE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ECE`"]
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "External clock mode 2 disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            #[doc = "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "External trigger prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            #[doc = "0: Prescaler OFF"]
            DIV1 = 0,
            #[doc = "1: ETRP frequency divided by 2"]
            DIV2 = 1,
            #[doc = "2: ETRP frequency divided by 4"]
            DIV4 = 2,
            #[doc = "3: ETRP frequency divided by 8"]
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETPS`"]
        pub type ETPS_R = crate::R<u8, ETPS_A>;
        impl ETPS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ETPS_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::DIV8
            }
        }
        #[doc = "Write proxy for field `ETPS`"]
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Prescaler OFF"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            #[doc = "ETRP frequency divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            #[doc = "ETRP frequency divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            #[doc = "ETRP frequency divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "External trigger filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETF`"]
        pub type ETF_R = crate::R<u8, ETF_A>;
        impl ETF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == ETF_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == ETF_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == ETF_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `ETF`"]
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Master/Slave mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            #[doc = "0: No action"]
            NOSYNC = 0,
            #[doc = "1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, MSM_A>;
        impl MSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `NOSYNC`"]
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                *self == MSM_A::NOSYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                *self == MSM_A::SYNC
            }
        }
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            #[doc = "0: Internal Trigger 0 (ITR0)"]
            ITR0 = 0,
            #[doc = "1: Internal Trigger 1 (ITR1)"]
            ITR1 = 1,
            #[doc = "2: Internal Trigger 2 (ITR2)"]
            ITR2 = 2,
            #[doc = "4: TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED = 4,
            #[doc = "5: Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1 = 5,
            #[doc = "6: Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2 = 6,
            #[doc = "7: External Trigger input (ETRF)"]
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, TS_A>;
        impl TS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TS_A::ITR0),
                    1 => Val(TS_A::ITR1),
                    2 => Val(TS_A::ITR2),
                    4 => Val(TS_A::TI1F_ED),
                    5 => Val(TS_A::TI1FP1),
                    6 => Val(TS_A::TI2FP2),
                    7 => Val(TS_A::ETRF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ITR0`"]
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                *self == TS_A::ITR0
            }
            #[doc = "Checks if the value of the field is `ITR1`"]
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                *self == TS_A::ITR1
            }
            #[doc = "Checks if the value of the field is `ITR2`"]
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                *self == TS_A::ITR2
            }
            #[doc = "Checks if the value of the field is `TI1F_ED`"]
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                *self == TS_A::TI1F_ED
            }
            #[doc = "Checks if the value of the field is `TI1FP1`"]
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::TI1FP1
            }
            #[doc = "Checks if the value of the field is `TI2FP2`"]
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::TI2FP2
            }
            #[doc = "Checks if the value of the field is `ETRF`"]
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                *self == TS_A::ETRF
            }
        }
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Internal Trigger 0 (ITR0)"]
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            #[doc = "Internal Trigger 1 (ITR1)"]
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            #[doc = "Internal Trigger 2 (ITR2)"]
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            #[doc = "External Trigger input (ETRF)"]
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Slave mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            #[doc = "0: Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            DISABLED = 0,
            #[doc = "1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1 = 1,
            #[doc = "2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2 = 2,
            #[doc = "3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3 = 3,
            #[doc = "4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE = 4,
            #[doc = "5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE = 5,
            #[doc = "6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE = 6,
            #[doc = "7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, SMS_A>;
        impl SMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMS_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_1`"]
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_1
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_2`"]
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_2
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_3`"]
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_3
            }
            #[doc = "Checks if the value of the field is `RESET_MODE`"]
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                *self == SMS_A::RESET_MODE
            }
            #[doc = "Checks if the value of the field is `GATED_MODE`"]
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                *self == SMS_A::GATED_MODE
            }
            #[doc = "Checks if the value of the field is `TRIGGER_MODE`"]
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                *self == SMS_A::TRIGGER_MODE
            }
            #[doc = "Checks if the value of the field is `EXT_CLOCK_MODE`"]
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                *self == SMS_A::EXT_CLOCK_MODE
            }
        }
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TDE_A {
            #[doc = "0: Trigger DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger DMA request enabled"]
            ENABLED = 1,
        }
        impl From<TDE_A> for bool {
            #[inline(always)]
            fn from(variant: TDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TDE`"]
        pub type TDE_R = crate::R<bool, TDE_A>;
        impl TDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TDE_A {
                match self.bits {
                    false => TDE_A::DISABLED,
                    true => TDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TDE`"]
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TDE_A::DISABLED)
            }
            #[doc = "Trigger DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4DE_A {
            #[doc = "0: CCx DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: CCx DMA request enabled"]
            ENABLED = 1,
        }
        impl From<CC4DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC4DE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4DE`"]
        pub type CC4DE_R = crate::R<bool, CC4DE_A>;
        impl CC4DE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4DE_A {
                match self.bits {
                    false => CC4DE_A::DISABLED,
                    true => CC4DE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC4DE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC4DE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC4DE`"]
        pub struct CC4DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 DMA request enable"]
        pub type CC3DE_A = CC4DE_A;
        #[doc = "Reader of field `CC3DE`"]
        pub type CC3DE_R = crate::R<bool, CC4DE_A>;
        #[doc = "Write proxy for field `CC3DE`"]
        pub struct CC3DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 DMA request enable"]
        pub type CC2DE_A = CC4DE_A;
        #[doc = "Reader of field `CC2DE`"]
        pub type CC2DE_R = crate::R<bool, CC4DE_A>;
        #[doc = "Write proxy for field `CC2DE`"]
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 DMA request enable"]
        pub type CC1DE_A = CC4DE_A;
        #[doc = "Reader of field `CC1DE`"]
        pub type CC1DE_R = crate::R<bool, CC4DE_A>;
        #[doc = "Write proxy for field `CC1DE`"]
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Update DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            #[doc = "0: Update DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Update DMA request enabled"]
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, UDE_A>;
        impl UDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Trigger interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            #[doc = "0: Trigger interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, TIE_A>;
        impl TIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            #[doc = "Trigger interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IE_A {
            #[doc = "0: CCx interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CCx interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CC4IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4IE`"]
        pub type CC4IE_R = crate::R<bool, CC4IE_A>;
        impl CC4IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4IE_A {
                match self.bits {
                    false => CC4IE_A::DISABLED,
                    true => CC4IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC4IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC4IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC4IE`"]
        pub struct CC4IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 interrupt enable"]
        pub type CC3IE_A = CC4IE_A;
        #[doc = "Reader of field `CC3IE`"]
        pub type CC3IE_R = crate::R<bool, CC4IE_A>;
        #[doc = "Write proxy for field `CC3IE`"]
        pub struct CC3IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt enable"]
        pub type CC2IE_A = CC4IE_A;
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, CC4IE_A>;
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 interrupt enable"]
        pub type CC1IE_A = CC4IE_A;
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, CC4IE_A>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline(always)]
            pub fn cc4de(&mut self) -> CC4DE_W {
                CC4DE_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline(always)]
            pub fn cc3de(&mut self) -> CC3DE_W {
                CC3DE_W { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline(always)]
            pub fn cc4ie(&mut self) -> CC4IE_W {
                CC4IE_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline(always)]
            pub fn cc3ie(&mut self) -> CC3IE_W {
                CC3IE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/Compare 4 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_A {
            #[doc = "1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
            OVERCAPTURE = 1,
        }
        impl From<CC4OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4OF`"]
        pub type CC4OF_R = crate::R<bool, CC4OF_A>;
        impl CC4OF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC4OF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC4OF_A::OVERCAPTURE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERCAPTURE`"]
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                *self == CC4OF_A::OVERCAPTURE
            }
        }
        #[doc = "Capture/Compare 4 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC4OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4OF`"]
        pub struct CC4OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 overcapture flag"]
        pub type CC3OF_A = CC4OF_A;
        #[doc = "Reader of field `CC3OF`"]
        pub type CC3OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/Compare 3 overcapture flag"]
        pub type CC3OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC3OF`"]
        pub struct CC3OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/compare 2 overcapture flag"]
        pub type CC2OF_A = CC4OF_A;
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/compare 2 overcapture flag"]
        pub type CC2OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_A = CC4OF_A;
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, CC4OF_A>;
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_AW = CC4OF_AW;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            #[doc = "0: No trigger event occurred"]
            NOTRIGGER = 0,
            #[doc = "1: Trigger interrupt pending"]
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, TIF_A>;
        impl TIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRIGGER`"]
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                *self == TIF_A::NOTRIGGER
            }
            #[doc = "Checks if the value of the field is `TRIGGER`"]
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == TIF_A::TRIGGER
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_A {
            #[doc = "1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
            MATCH = 1,
        }
        impl From<CC4IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4IF`"]
        pub type CC4IF_R = crate::R<bool, CC4IF_A>;
        impl CC4IF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC4IF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC4IF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CC4IF_A::MATCH
            }
        }
        #[doc = "Capture/Compare 4 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC4IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4IF`"]
        pub struct CC4IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 interrupt flag"]
        pub type CC3IF_A = CC4IF_A;
        #[doc = "Reader of field `CC3IF`"]
        pub type CC3IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/Compare 3 interrupt flag"]
        pub type CC3IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC3IF`"]
        pub struct CC3IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag"]
        pub type CC2IF_A = CC4IF_A;
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/Compare 2 interrupt flag"]
        pub type CC2IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_A = CC4IF_A;
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, CC4IF_A>;
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_AW = CC4IF_AW;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline(always)]
            pub fn cc4of(&mut self) -> CC4OF_W {
                CC4OF_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline(always)]
            pub fn cc3of(&mut self) -> CC3OF_W {
                CC3OF_W { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline(always)]
            pub fn cc4if(&mut self) -> CC4IF_W {
                CC4IF_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline(always)]
            pub fn cc3if(&mut self) -> CC3IF_W {
                CC3IF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            #[doc = "1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/compare 4 generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4G_AW {
            #[doc = "1: If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            TRIGGER = 1,
        }
        impl From<CC4G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4G_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC4G`"]
        pub struct CC4G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/compare 3 generation"]
        pub type CC3G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC3G`"]
        pub struct CC3G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/compare 2 generation"]
        pub type CC2G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 generation"]
        pub type CC1G_AW = CC4G_AW;
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline(always)]
            pub fn cc4g(&mut self) -> CC4G_W {
                CC4G_W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline(always)]
            pub fn cc3g(&mut self) -> CC3G_W {
                CC3G_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC2CE`"]
        pub type OC2CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2CE`"]
        pub struct OC2CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output compare 2 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, OC2M_A>;
        impl OC2M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC2M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC2M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC2M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC2M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC2M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC2M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC2M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output compare 2 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            #[doc = "0: Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR2 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, OC2PE_A>;
        impl OC2PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC2PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC2PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR2 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CC2 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC2S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC2 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC1CE`"]
        pub type OC1CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1CE`"]
        pub struct OC1CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output compare 1 mode"]
        pub type OC1M_A = OC2M_A;
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, OC2M_A>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output compare 1 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC1PE_A {
            #[doc = "0: Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, OC1PE_A>;
        impl OC1PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::DISABLED,
                    true => OC1PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR1 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            #[doc = "0: CC1 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC1S_A>;
        impl CC1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC1S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC1S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC1S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC1 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline(always)]
            pub fn oc2ce(&mut self) -> OC2CE_W {
                OC2CE_W { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline(always)]
            pub fn oc1ce(&mut self) -> OC1CE_W {
                OC1CE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "1: CC2 channel is configured as input, IC2 is mapped on TI2"]
            TI2 = 1,
            #[doc = "2: CC2 channel is configured as input, IC2 is mapped on TI1"]
            TI1 = 2,
            #[doc = "3: CC2 channel is configured as input, IC2 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC2S_A::TI2),
                    2 => Val(CC2S_A::TI1),
                    3 => Val(CC2S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC2S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC2S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC2S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Input capture 1 filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC1F_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, IC1F_A>;
        impl IC1F_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NOFILTER,
                    1 => IC1F_A::FCK_INT_N2,
                    2 => IC1F_A::FCK_INT_N4,
                    3 => IC1F_A::FCK_INT_N8,
                    4 => IC1F_A::FDTS_DIV2_N6,
                    5 => IC1F_A::FDTS_DIV2_N8,
                    6 => IC1F_A::FDTS_DIV4_N6,
                    7 => IC1F_A::FDTS_DIV4_N8,
                    8 => IC1F_A::FDTS_DIV8_N6,
                    9 => IC1F_A::FDTS_DIV8_N8,
                    10 => IC1F_A::FDTS_DIV16_N5,
                    11 => IC1F_A::FDTS_DIV16_N6,
                    12 => IC1F_A::FDTS_DIV16_N8,
                    13 => IC1F_A::FDTS_DIV32_N5,
                    14 => IC1F_A::FDTS_DIV32_N6,
                    15 => IC1F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC1F_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == IC1F_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == IC1F_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == IC1F_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == IC1F_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Input capture 1 prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC1PSC_A {
            #[doc = "0: no prescaler, capture is done each time an edge is detected on the capture input"]
            NOPRESCALER = 0,
            #[doc = "1: Capture is done once every 2 events"]
            TWO_EVENTS = 1,
            #[doc = "2: Capture is done once every 4 events"]
            FOUR_EVENTS = 2,
            #[doc = "3: Capture is done once every 8 events"]
            EIGHT_EVENTS = 3,
        }
        impl From<IC1PSC_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1PSC_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, IC1PSC_A>;
        impl IC1PSC_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IC1PSC_A {
                match self.bits {
                    0 => IC1PSC_A::NOPRESCALER,
                    1 => IC1PSC_A::TWO_EVENTS,
                    2 => IC1PSC_A::FOUR_EVENTS,
                    3 => IC1PSC_A::EIGHT_EVENTS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOPRESCALER`"]
            #[inline(always)]
            pub fn is_no_prescaler(&self) -> bool {
                *self == IC1PSC_A::NOPRESCALER
            }
            #[doc = "Checks if the value of the field is `TWO_EVENTS`"]
            #[inline(always)]
            pub fn is_two_events(&self) -> bool {
                *self == IC1PSC_A::TWO_EVENTS
            }
            #[doc = "Checks if the value of the field is `FOUR_EVENTS`"]
            #[inline(always)]
            pub fn is_four_events(&self) -> bool {
                *self == IC1PSC_A::FOUR_EVENTS
            }
            #[doc = "Checks if the value of the field is `EIGHT_EVENTS`"]
            #[inline(always)]
            pub fn is_eight_events(&self) -> bool {
                *self == IC1PSC_A::EIGHT_EVENTS
            }
        }
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC1PSC_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "no prescaler, capture is done each time an edge is detected on the capture input"]
            #[inline(always)]
            pub fn no_prescaler(self) -> &'a mut W {
                self.variant(IC1PSC_A::NOPRESCALER)
            }
            #[doc = "Capture is done once every 2 events"]
            #[inline(always)]
            pub fn two_events(self) -> &'a mut W {
                self.variant(IC1PSC_A::TWO_EVENTS)
            }
            #[doc = "Capture is done once every 4 events"]
            #[inline(always)]
            pub fn four_events(self) -> &'a mut W {
                self.variant(IC1PSC_A::FOUR_EVENTS)
            }
            #[doc = "Capture is done once every 8 events"]
            #[inline(always)]
            pub fn eight_events(self) -> &'a mut W {
                self.variant(IC1PSC_A::EIGHT_EVENTS)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            #[doc = "1: CC1 channel is configured as input, IC1 is mapped on TI1"]
            TI1 = 1,
            #[doc = "2: CC1 channel is configured as input, IC1 is mapped on TI2"]
            TI2 = 2,
            #[doc = "3: CC1 channel is configured as input, IC1 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC1S_A>;
        impl CC1S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC1S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC1S_A::TI1),
                    2 => Val(CC1S_A::TI2),
                    3 => Val(CC1S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC1S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC1S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC1S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC1S_A::TI1)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC1S_A::TI2)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC1S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr2_output](ccmr2_output) module"]
    pub type CCMR2_OUTPUT = crate::Reg<u32, _CCMR2_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR2_OUTPUT;
    #[doc = "`read()` method returns [ccmr2_output::R](ccmr2_output::R) reader structure"]
    impl crate::Readable for CCMR2_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr2_output::W](ccmr2_output::W) writer structure"]
    impl crate::Writable for CCMR2_OUTPUT {}
    #[doc = "capture/compare mode register 2 (output mode)"]
    pub mod ccmr2_output {
        #[doc = "Reader of register CCMR2_Output"]
        pub type R = crate::R<u32, super::CCMR2_OUTPUT>;
        #[doc = "Writer for register CCMR2_Output"]
        pub type W = crate::W<u32, super::CCMR2_OUTPUT>;
        #[doc = "Register CCMR2_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR2_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `OC4CE`"]
        pub type OC4CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC4CE`"]
        pub struct OC4CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Output compare 4 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC4M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC4M`"]
        pub type OC4M_R = crate::R<u8, OC4M_A>;
        impl OC4M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::FROZEN,
                    1 => OC4M_A::ACTIVEONMATCH,
                    2 => OC4M_A::INACTIVEONMATCH,
                    3 => OC4M_A::TOGGLE,
                    4 => OC4M_A::FORCEINACTIVE,
                    5 => OC4M_A::FORCEACTIVE,
                    6 => OC4M_A::PWMMODE1,
                    7 => OC4M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC4M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC4M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC4M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC4M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC4M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC4M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC4M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC4M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC4M`"]
        pub struct OC4M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC4M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output compare 4 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC4PE_A {
            #[doc = "0: Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR4 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC4PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC4PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC4PE`"]
        pub type OC4PE_R = crate::R<bool, OC4PE_A>;
        impl OC4PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC4PE_A {
                match self.bits {
                    false => OC4PE_A::DISABLED,
                    true => OC4PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC4PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC4PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC4PE`"]
        pub struct OC4PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC4PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC4PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR4 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC4PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC4FE`"]
        pub type OC4FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC4FE`"]
        pub struct OC4FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            #[doc = "0: CC4 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC4S`"]
        pub type CC4S_R = crate::R<u8, CC4S_A>;
        impl CC4S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC4S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC4S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC4S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC4S`"]
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC4 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `OC3CE`"]
        pub type OC3CE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC3CE`"]
        pub struct OC3CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3CE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output compare 3 mode"]
        pub type OC3M_A = OC4M_A;
        #[doc = "Reader of field `OC3M`"]
        pub type OC3M_R = crate::R<u8, OC4M_A>;
        #[doc = "Write proxy for field `OC3M`"]
        pub struct OC3M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC3M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output compare 3 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC3PE_A {
            #[doc = "0: Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCR3 enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC3PE`"]
        pub type OC3PE_R = crate::R<bool, OC3PE_A>;
        impl OC3PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::DISABLED,
                    true => OC3PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC3PE`"]
        pub struct OC3PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC3PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::DISABLED)
            }
            #[doc = "Preload register on CCR3 enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC3FE`"]
        pub type OC3FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC3FE`"]
        pub struct OC3FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            #[doc = "0: CC3 channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC3S`"]
        pub type CC3S_R = crate::R<u8, CC3S_A>;
        impl CC3S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC3S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC3S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC3S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC3S`"]
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC3 channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline(always)]
            pub fn oc4ce(&mut self) -> OC4CE_W {
                OC4CE_W { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline(always)]
            pub fn oc4m(&mut self) -> OC4M_W {
                OC4M_W { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline(always)]
            pub fn oc4pe(&mut self) -> OC4PE_W {
                OC4PE_W { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline(always)]
            pub fn oc4fe(&mut self) -> OC4FE_W {
                OC4FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline(always)]
            pub fn oc3ce(&mut self) -> OC3CE_W {
                OC3CE_W { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline(always)]
            pub fn oc3m(&mut self) -> OC3M_W {
                OC3M_W { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline(always)]
            pub fn oc3pe(&mut self) -> OC3PE_W {
                OC3PE_W { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline(always)]
            pub fn oc3fe(&mut self) -> OC3FE_W {
                OC3FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr2_input](ccmr2_input) module"]
    pub type CCMR2_INPUT = crate::Reg<u32, _CCMR2_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR2_INPUT;
    #[doc = "`read()` method returns [ccmr2_input::R](ccmr2_input::R) reader structure"]
    impl crate::Readable for CCMR2_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr2_input::W](ccmr2_input::W) writer structure"]
    impl crate::Writable for CCMR2_INPUT {}
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = "Reader of register CCMR2_Input"]
        pub type R = crate::R<u32, super::CCMR2_INPUT>;
        #[doc = "Writer for register CCMR2_Input"]
        pub type W = crate::W<u32, super::CCMR2_INPUT>;
        #[doc = "Register CCMR2_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR2_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `IC4F`"]
        pub type IC4F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC4F`"]
        pub struct IC4F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC4PSC`"]
        pub type IC4PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC4PSC`"]
        pub struct IC4PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            #[doc = "1: CC4 channel is configured as input, IC4 is mapped on TI4"]
            TI4 = 1,
            #[doc = "2: CC4 channel is configured as input, IC4 is mapped on TI3"]
            TI3 = 2,
            #[doc = "3: CC4 channel is configured as input, IC4 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC4S`"]
        pub type CC4S_R = crate::R<u8, CC4S_A>;
        impl CC4S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC4S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC4S_A::TI4),
                    2 => Val(CC4S_A::TI3),
                    3 => Val(CC4S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                *self == CC4S_A::TI4
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                *self == CC4S_A::TI3
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC4S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC4S`"]
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI4"]
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC4S_A::TI4)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI3"]
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC4S_A::TI3)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC4S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `IC3F`"]
        pub type IC3F_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC3F`"]
        pub struct IC3F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3F_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC3PSC`"]
        pub type IC3PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC3PSC`"]
        pub struct IC3PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            #[doc = "1: CC3 channel is configured as input, IC3 is mapped on TI3"]
            TI3 = 1,
            #[doc = "2: CC3 channel is configured as input, IC3 is mapped on TI4"]
            TI4 = 2,
            #[doc = "3: CC3 channel is configured as input, IC3 is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC3S`"]
        pub type CC3S_R = crate::R<u8, CC3S_A>;
        impl CC3S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC3S_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(CC3S_A::TI3),
                    2 => Val(CC3S_A::TI4),
                    3 => Val(CC3S_A::TRC),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                *self == CC3S_A::TI3
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                *self == CC3S_A::TI4
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC3S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC3S`"]
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI3"]
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC3S_A::TI3)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI4"]
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC3S_A::TI4)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC3S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline(always)]
            pub fn ic4f(&mut self) -> IC4F_W {
                IC4F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline(always)]
            pub fn ic4psc(&mut self) -> IC4PSC_W {
                IC4PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline(always)]
            pub fn ic3f(&mut self) -> IC3F_W {
                IC3F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline(always)]
            pub fn ic3psc(&mut self) -> IC3PSC_W {
                IC3PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/Compare 4 output Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4NP_A {
            #[doc = "0: Negative polarity"]
            NEGATIVE = 0,
            #[doc = "1: Positive polarity"]
            POSITIVE = 1,
        }
        impl From<CC4NP_A> for bool {
            #[inline(always)]
            fn from(variant: CC4NP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4NP`"]
        pub type CC4NP_R = crate::R<bool, CC4NP_A>;
        impl CC4NP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4NP_A {
                match self.bits {
                    false => CC4NP_A::NEGATIVE,
                    true => CC4NP_A::POSITIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NEGATIVE`"]
            #[inline(always)]
            pub fn is_negative(&self) -> bool {
                *self == CC4NP_A::NEGATIVE
            }
            #[doc = "Checks if the value of the field is `POSITIVE`"]
            #[inline(always)]
            pub fn is_positive(&self) -> bool {
                *self == CC4NP_A::POSITIVE
            }
        }
        #[doc = "Write proxy for field `CC4NP`"]
        pub struct CC4NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC4NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC4NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 output Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4P_A {
            #[doc = "0: Noninverted/rising edge"]
            RISINGEDGE = 0,
            #[doc = "1: Inverted/falling edge"]
            FALLINGEDGE = 1,
        }
        impl From<CC4P_A> for bool {
            #[inline(always)]
            fn from(variant: CC4P_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4P`"]
        pub type CC4P_R = crate::R<bool, CC4P_A>;
        impl CC4P_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4P_A {
                match self.bits {
                    false => CC4P_A::RISINGEDGE,
                    true => CC4P_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == CC4P_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == CC4P_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `CC4P`"]
        pub struct CC4P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC4P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC4P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Capture/Compare 4 output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4E_A {
            #[doc = "0: Capture disabled"]
            DISABLED = 0,
            #[doc = "1: Capture enabled"]
            ENABLED = 1,
        }
        impl From<CC4E_A> for bool {
            #[inline(always)]
            fn from(variant: CC4E_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC4E`"]
        pub type CC4E_R = crate::R<bool, CC4E_A>;
        impl CC4E_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC4E_A {
                match self.bits {
                    false => CC4E_A::DISABLED,
                    true => CC4E_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC4E_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC4E_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC4E`"]
        pub struct CC4E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC4E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 output Polarity"]
        pub type CC3NP_A = CC4NP_A;
        #[doc = "Reader of field `CC3NP`"]
        pub type CC3NP_R = crate::R<bool, CC4NP_A>;
        #[doc = "Write proxy for field `CC3NP`"]
        pub struct CC3NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC4NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC4NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 output Polarity"]
        pub type CC3P_A = CC4P_A;
        #[doc = "Reader of field `CC3P`"]
        pub type CC3P_R = crate::R<bool, CC4P_A>;
        #[doc = "Write proxy for field `CC3P`"]
        pub struct CC3P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC4P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC4P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Capture/Compare 3 output enable"]
        pub type CC3E_A = CC4E_A;
        #[doc = "Reader of field `CC3E`"]
        pub type CC3E_R = crate::R<bool, CC4E_A>;
        #[doc = "Write proxy for field `CC3E`"]
        pub struct CC3E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC3E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output Polarity"]
        pub type CC2NP_A = CC4NP_A;
        #[doc = "Reader of field `CC2NP`"]
        pub type CC2NP_R = crate::R<bool, CC4NP_A>;
        #[doc = "Write proxy for field `CC2NP`"]
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC4NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC4NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output Polarity"]
        pub type CC2P_A = CC4P_A;
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, CC4P_A>;
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC4P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC4P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output enable"]
        pub type CC2E_A = CC4E_A;
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, CC4E_A>;
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output Polarity"]
        pub type CC1NP_A = CC4NP_A;
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, CC4NP_A>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC4NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC4NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output Polarity"]
        pub type CC1P_A = CC4P_A;
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, CC4P_A>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC4P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC4P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output enable"]
        pub type CC1E_A = CC4E_A;
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, CC4E_A>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 15 - Capture/Compare 4 output Polarity"]
            #[inline(always)]
            pub fn cc4np(&self) -> CC4NP_R {
                CC4NP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 15 - Capture/Compare 4 output Polarity"]
            #[inline(always)]
            pub fn cc4np(&mut self) -> CC4NP_W {
                CC4NP_W { w: self }
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc4p(&mut self) -> CC4P_W {
                CC4P_W { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline(always)]
            pub fn cc4e(&mut self) -> CC4E_W {
                CC4E_W { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3np(&mut self) -> CC3NP_W {
                CC3NP_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline(always)]
            pub fn cc3p(&mut self) -> CC3P_W {
                CC3P_W { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline(always)]
            pub fn cc3e(&mut self) -> CC3E_W {
                CC3E_W { w: self }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "DMA control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dcr](dcr) module"]
    pub type DCR = crate::Reg<u32, _DCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DCR;
    #[doc = "`read()` method returns [dcr::R](dcr::R) reader structure"]
    impl crate::Readable for DCR {}
    #[doc = "`write(|w| ..)` method takes [dcr::W](dcr::W) writer structure"]
    impl crate::Writable for DCR {}
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = "Reader of register DCR"]
        pub type R = crate::R<u32, super::DCR>;
        #[doc = "Writer for register DCR"]
        pub type W = crate::W<u32, super::DCR>;
        #[doc = "Register DCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DBL`"]
        pub type DBL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBL`"]
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `DBA`"]
        pub type DBA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DBA`"]
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmar](dmar) module"]
    pub type DMAR = crate::Reg<u32, _DMAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMAR;
    #[doc = "`read()` method returns [dmar::R](dmar::R) reader structure"]
    impl crate::Readable for DMAR {}
    #[doc = "`write(|w| ..)` method takes [dmar::W](dmar::W) writer structure"]
    impl crate::Writable for DMAR {}
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = "Reader of register DMAR"]
        pub type R = crate::R<u32, super::DMAR>;
        #[doc = "Writer for register DMAR"]
        pub type W = crate::W<u32, super::DMAR>;
        #[doc = "Register DMAR `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `DMAB`"]
        pub type DMAB_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `DMAB`"]
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
        }
    }
    #[doc = "TIM2 option register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [or](or) module"]
    pub type OR = crate::Reg<u32, _OR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OR;
    #[doc = "`read()` method returns [or::R](or::R) reader structure"]
    impl crate::Readable for OR {}
    #[doc = "`write(|w| ..)` method takes [or::W](or::W) writer structure"]
    impl crate::Writable for OR {}
    #[doc = "TIM2 option register"]
    pub mod or {
        #[doc = "Reader of register OR"]
        pub type R = crate::R<u32, super::OR>;
        #[doc = "Writer for register OR"]
        pub type W = crate::W<u32, super::OR>;
        #[doc = "Register OR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Timer2 ETR remap\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETR_RMP_A {
            #[doc = "7: TIM2 ETR input is connected to COMP1_OUT"]
            COMP1_OUT = 7,
            #[doc = "6: TIM2 ETR input is connected to COMP2_OUT"]
            COMP2_OUT = 6,
            #[doc = "5: TIM2 ETR input is connected to LSE"]
            LSE = 5,
            #[doc = "3: TIM2 ETR input is connected to HSI16 when HSI16OUTEN bit is set"]
            HSI = 3,
        }
        impl From<ETR_RMP_A> for u8 {
            #[inline(always)]
            fn from(variant: ETR_RMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETR_RMP`"]
        pub type ETR_RMP_R = crate::R<u8, ETR_RMP_A>;
        impl ETR_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, ETR_RMP_A> {
                use crate::Variant::*;
                match self.bits {
                    7 => Val(ETR_RMP_A::COMP1_OUT),
                    6 => Val(ETR_RMP_A::COMP2_OUT),
                    5 => Val(ETR_RMP_A::LSE),
                    3 => Val(ETR_RMP_A::HSI),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `COMP1_OUT`"]
            #[inline(always)]
            pub fn is_comp1_out(&self) -> bool {
                *self == ETR_RMP_A::COMP1_OUT
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == ETR_RMP_A::COMP2_OUT
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == ETR_RMP_A::LSE
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == ETR_RMP_A::HSI
            }
        }
        #[doc = "Write proxy for field `ETR_RMP`"]
        pub struct ETR_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETR_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETR_RMP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "TIM2 ETR input is connected to COMP1_OUT"]
            #[inline(always)]
            pub fn comp1_out(self) -> &'a mut W {
                self.variant(ETR_RMP_A::COMP1_OUT)
            }
            #[doc = "TIM2 ETR input is connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(ETR_RMP_A::COMP2_OUT)
            }
            #[doc = "TIM2 ETR input is connected to LSE"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(ETR_RMP_A::LSE)
            }
            #[doc = "TIM2 ETR input is connected to HSI16 when HSI16OUTEN bit is set"]
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(ETR_RMP_A::HSI)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Internal trigger\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TI4_RMP_A {
            #[doc = "1: TIM2 TI4 input connected to COMP2_OUT"]
            COMP2_OUT = 1,
            #[doc = "2: TIM2 TI4 input connected to COMP1_OUT"]
            COMP1_OUT = 2,
        }
        impl From<TI4_RMP_A> for u8 {
            #[inline(always)]
            fn from(variant: TI4_RMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TI4_RMP`"]
        pub type TI4_RMP_R = crate::R<u8, TI4_RMP_A>;
        impl TI4_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TI4_RMP_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(TI4_RMP_A::COMP2_OUT),
                    2 => Val(TI4_RMP_A::COMP1_OUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == TI4_RMP_A::COMP2_OUT
            }
            #[doc = "Checks if the value of the field is `COMP1_OUT`"]
            #[inline(always)]
            pub fn is_comp1_out(&self) -> bool {
                *self == TI4_RMP_A::COMP1_OUT
            }
        }
        #[doc = "Write proxy for field `TI4_RMP`"]
        pub struct TI4_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI4_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI4_RMP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "TIM2 TI4 input connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(TI4_RMP_A::COMP2_OUT)
            }
            #[doc = "TIM2 TI4 input connected to COMP1_OUT"]
            #[inline(always)]
            pub fn comp1_out(self) -> &'a mut W {
                self.variant(TI4_RMP_A::COMP1_OUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Timer2 ETR remap"]
            #[inline(always)]
            pub fn etr_rmp(&self) -> ETR_RMP_R {
                ETR_RMP_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 3:4 - Internal trigger"]
            #[inline(always)]
            pub fn ti4_rmp(&self) -> TI4_RMP_R {
                TI4_RMP_R::new(((self.bits >> 3) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Timer2 ETR remap"]
            #[inline(always)]
            pub fn etr_rmp(&mut self) -> ETR_RMP_W {
                ETR_RMP_W { w: self }
            }
            #[doc = "Bits 3:4 - Internal trigger"]
            #[inline(always)]
            pub fn ti4_rmp(&mut self) -> TI4_RMP_W {
                TI4_RMP_W { w: self }
            }
        }
    }
    #[doc = "TIMx counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u16, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "TIMx counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u16, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u16, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u16;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u16) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "TIMx auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u16, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "TIMx auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u16, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u16, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0xffff"]
        impl crate::ResetValue for super::ARR {
            type Type = u16;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0xffff
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u16) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "TIMx capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u16, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "TIMx capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u16, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u16, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u16;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u16) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct TIM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM3 {}
impl TIM3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0400 as *const _
    }
}
impl Deref for TIM3 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM3::ptr() }
    }
}
#[doc = "Basic-timers"]
pub struct TIM6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM6 {}
impl TIM6 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim6::RegisterBlock {
        0x4000_1000 as *const _
    }
}
impl Deref for TIM6 {
    type Target = tim6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM6::ptr() }
    }
}
#[doc = "Basic-timers"]
pub mod tim6 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        _reserved2: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved5: [u8; 12usize],
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped at update event"]
            DISABLED = 0,
            #[doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: Use UG bit from TIMx_EGR register"]
            RESET = 0,
            #[doc = "1: Use CNT bit from TIMx_CEN register"]
            ENABLE = 1,
            #[doc = "2: Use the update event"]
            UPDATE = 2,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MMS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MMS_A::RESET),
                    1 => Val(MMS_A::ENABLE),
                    2 => Val(MMS_A::UPDATE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Use UG bit from TIMx_EGR register"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "Use CNT bit from TIMx_CEN register"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "Use the update event"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update DMA request enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            #[doc = "0: Update DMA request disabled"]
            DISABLED = 0,
            #[doc = "1: Update DMA request enabled"]
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDE`"]
        pub type UDE_R = crate::R<bool, UDE_A>;
        impl UDE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UDE`"]
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
}
#[doc = "Basic-timers"]
pub struct TIM7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM7 {}
impl TIM7 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim6::RegisterBlock {
        0x4000_1400 as *const _
    }
}
impl Deref for TIM7 {
    type Target = tim6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM7::ptr() }
    }
}
#[doc = "General-purpose-timers"]
pub struct TIM21 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM21 {}
impl TIM21 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim21::RegisterBlock {
        0x4001_0800 as *const _
    }
}
impl Deref for TIM21 {
    type Target = tim21::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM21::ptr() }
    }
}
#[doc = "General-purpose-timers"]
pub mod tim21 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved7: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved11: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR,
        #[doc = "0x38 - capture/compare register 1"]
        pub ccr2: CCR,
        _reserved13: [u8; 20usize],
        #[doc = "0x50 - TIM21 option register"]
        pub or: OR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped on the update event"]
            NOTSTOPPED = 0,
            #[doc = "1: Counter stops counting on the next update event (clearing the CEN bit)"]
            STOPPED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::NOTSTOPPED,
                    true => OPM_A::STOPPED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTOPPED`"]
            #[inline(always)]
            pub fn is_not_stopped(&self) -> bool {
                *self == OPM_A::NOTSTOPPED
            }
            #[doc = "Checks if the value of the field is `STOPPED`"]
            #[inline(always)]
            pub fn is_stopped(&self) -> bool {
                *self == OPM_A::STOPPED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped on the update event"]
            #[inline(always)]
            pub fn not_stopped(self) -> &'a mut W {
                self.variant(OPM_A::NOTSTOPPED)
            }
            #[doc = "Counter stops counting on the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn stopped(self) -> &'a mut W {
                self.variant(OPM_A::STOPPED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            #[doc = "0: Counter used as upcounter"]
            UP = 0,
            #[doc = "1: Counter used as downcounter"]
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DIR`"]
        pub type DIR_R = crate::R<bool, DIR_A>;
        impl DIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                *self == DIR_A::UP
            }
            #[doc = "Checks if the value of the field is `DOWN`"]
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                *self == DIR_A::DOWN
            }
        }
        #[doc = "Write proxy for field `DIR`"]
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter used as upcounter"]
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            #[doc = "Counter used as downcounter"]
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Center-aligned mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            #[doc = "0: The counter counts up or down depending on the direction bit"]
            EDGEALIGNED = 0,
            #[doc = "1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            CENTERALIGNED1 = 1,
            #[doc = "2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            CENTERALIGNED2 = 2,
            #[doc = "3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CMS`"]
        pub type CMS_R = crate::R<u8, CMS_A>;
        impl CMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `EDGEALIGNED`"]
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                *self == CMS_A::EDGEALIGNED
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED1`"]
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                *self == CMS_A::CENTERALIGNED1
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED2`"]
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                *self == CMS_A::CENTERALIGNED2
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED3`"]
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                *self == CMS_A::CENTERALIGNED3
            }
        }
        #[doc = "Write proxy for field `CMS`"]
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The counter counts up or down depending on the direction bit"]
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO)"]
            RESET = 0,
            #[doc = "1: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO)"]
            ENABLE = 1,
            #[doc = "2: Update - The update event is selected as trigger output (TRGO)"]
            UPDATE = 2,
            #[doc = "3: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred"]
            COMPAREPULSE = 3,
            #[doc = "4: OC1REF signal is used as trigger output (TRGO)"]
            OC1REF = 4,
            #[doc = "5: OC2REF signal is used as trigger output (TRGO)"]
            OC2REF = 5,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MMS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MMS_A::RESET),
                    1 => Val(MMS_A::ENABLE),
                    2 => Val(MMS_A::UPDATE),
                    3 => Val(MMS_A::COMPAREPULSE),
                    4 => Val(MMS_A::OC1REF),
                    5 => Val(MMS_A::OC2REF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
            #[doc = "Checks if the value of the field is `COMPAREPULSE`"]
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                *self == MMS_A::COMPAREPULSE
            }
            #[doc = "Checks if the value of the field is `OC1REF`"]
            #[inline(always)]
            pub fn is_oc1ref(&self) -> bool {
                *self == MMS_A::OC1REF
            }
            #[doc = "Checks if the value of the field is `OC2REF`"]
            #[inline(always)]
            pub fn is_oc2ref(&self) -> bool {
                *self == MMS_A::OC2REF
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "Update - The update event is selected as trigger output (TRGO)"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred"]
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            #[doc = "OC1REF signal is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn oc1ref(self) -> &'a mut W {
                self.variant(MMS_A::OC1REF)
            }
            #[doc = "OC2REF signal is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn oc2ref(self) -> &'a mut W {
                self.variant(MMS_A::OC2REF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Slave mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            #[doc = "0: Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            DISABLED = 0,
            #[doc = "1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1 = 1,
            #[doc = "2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2 = 2,
            #[doc = "3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3 = 3,
            #[doc = "4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE = 4,
            #[doc = "5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE = 5,
            #[doc = "6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE = 6,
            #[doc = "7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, SMS_A>;
        impl SMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMS_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_1`"]
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_1
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_2`"]
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_2
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_3`"]
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_3
            }
            #[doc = "Checks if the value of the field is `RESET_MODE`"]
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                *self == SMS_A::RESET_MODE
            }
            #[doc = "Checks if the value of the field is `GATED_MODE`"]
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                *self == SMS_A::GATED_MODE
            }
            #[doc = "Checks if the value of the field is `TRIGGER_MODE`"]
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                *self == SMS_A::TRIGGER_MODE
            }
            #[doc = "Checks if the value of the field is `EXT_CLOCK_MODE`"]
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                *self == SMS_A::EXT_CLOCK_MODE
            }
        }
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            #[doc = "0: Internal Trigger 0 (ITR0)"]
            ITR0 = 0,
            #[doc = "1: Internal Trigger 1 (ITR1)"]
            ITR1 = 1,
            #[doc = "2: Internal Trigger 2 (ITR2)"]
            ITR2 = 2,
            #[doc = "4: TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED = 4,
            #[doc = "5: Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1 = 5,
            #[doc = "6: Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2 = 6,
            #[doc = "7: External Trigger input (ETRF)"]
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, TS_A>;
        impl TS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TS_A::ITR0),
                    1 => Val(TS_A::ITR1),
                    2 => Val(TS_A::ITR2),
                    4 => Val(TS_A::TI1F_ED),
                    5 => Val(TS_A::TI1FP1),
                    6 => Val(TS_A::TI2FP2),
                    7 => Val(TS_A::ETRF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ITR0`"]
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                *self == TS_A::ITR0
            }
            #[doc = "Checks if the value of the field is `ITR1`"]
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                *self == TS_A::ITR1
            }
            #[doc = "Checks if the value of the field is `ITR2`"]
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                *self == TS_A::ITR2
            }
            #[doc = "Checks if the value of the field is `TI1F_ED`"]
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                *self == TS_A::TI1F_ED
            }
            #[doc = "Checks if the value of the field is `TI1FP1`"]
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::TI1FP1
            }
            #[doc = "Checks if the value of the field is `TI2FP2`"]
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::TI2FP2
            }
            #[doc = "Checks if the value of the field is `ETRF`"]
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                *self == TS_A::ETRF
            }
        }
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Internal Trigger 0 (ITR0)"]
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            #[doc = "Internal Trigger 1 (ITR1)"]
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            #[doc = "Internal Trigger 2 (ITR2)"]
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            #[doc = "External Trigger input (ETRF)"]
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Master/Slave mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            #[doc = "0: No action"]
            NOSYNC = 0,
            #[doc = "1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, MSM_A>;
        impl MSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `NOSYNC`"]
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                *self == MSM_A::NOSYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                *self == MSM_A::SYNC
            }
        }
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "External trigger filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETF`"]
        pub type ETF_R = crate::R<u8, ETF_A>;
        impl ETF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == ETF_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == ETF_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == ETF_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `ETF`"]
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "External trigger prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            #[doc = "0: Prescaler OFF"]
            DIV1 = 0,
            #[doc = "1: ETRP frequency divided by 2"]
            DIV2 = 1,
            #[doc = "2: ETRP frequency divided by 4"]
            DIV4 = 2,
            #[doc = "3: ETRP frequency divided by 8"]
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETPS`"]
        pub type ETPS_R = crate::R<u8, ETPS_A>;
        impl ETPS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ETPS_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::DIV8
            }
        }
        #[doc = "Write proxy for field `ETPS`"]
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Prescaler OFF"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            #[doc = "ETRP frequency divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            #[doc = "ETRP frequency divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            #[doc = "ETRP frequency divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "External clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            #[doc = "0: External clock mode 2 disabled"]
            DISABLED = 0,
            #[doc = "1: External clock mode 2 enabled"]
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ECE`"]
        pub type ECE_R = crate::R<bool, ECE_A>;
        impl ECE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ECE`"]
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "External clock mode 2 disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            #[doc = "External clock mode 2 enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "External trigger polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            #[doc = "0: ETR is non-inverted, active at high level or rising edge"]
            RISINGEDGE = 0,
            #[doc = "1: ETR is inverted, active at low level or falling edge"]
            FALLINGEDGE = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ETP`"]
        pub type ETP_R = crate::R<bool, ETP_A>;
        impl ETP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::RISINGEDGE,
                    true => ETP_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == ETP_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == ETP_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `ETP`"]
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ETR is non-inverted, active at high level or rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(ETP_A::RISINGEDGE)
            }
            #[doc = "ETR is inverted, active at low level or falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(ETP_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            #[doc = "0: Trigger interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, TIE_A>;
        impl TIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            #[doc = "Trigger interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2IE_A {
            #[doc = "0: CCx interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CCx interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CC2IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC2IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, CC2IE_A>;
        impl CC2IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2IE_A {
                match self.bits {
                    false => CC2IE_A::DISABLED,
                    true => CC2IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC2IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC2IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 interrupt enable"]
        pub type CC1IE_A = CC2IE_A;
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, CC2IE_A>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/compare 2 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2OF_A {
            #[doc = "1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
            OVERCAPTURE = 1,
        }
        impl From<CC2OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC2OF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, CC2OF_A>;
        impl CC2OF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC2OF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC2OF_A::OVERCAPTURE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERCAPTURE`"]
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                *self == CC2OF_A::OVERCAPTURE
            }
        }
        #[doc = "Capture/compare 2 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2OF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC2OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC2OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_A = CC2OF_A;
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, CC2OF_A>;
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_AW = CC2OF_AW;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            #[doc = "0: No trigger event occurred"]
            NOTRIGGER = 0,
            #[doc = "1: Trigger interrupt pending"]
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, TIF_A>;
        impl TIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRIGGER`"]
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                *self == TIF_A::NOTRIGGER
            }
            #[doc = "Checks if the value of the field is `TRIGGER`"]
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == TIF_A::TRIGGER
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2IF_A {
            #[doc = "1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
            MATCH = 1,
        }
        impl From<CC2IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC2IF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, CC2IF_A>;
        impl CC2IF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC2IF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC2IF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CC2IF_A::MATCH
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2IF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC2IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC2IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_A = CC2IF_A;
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, CC2IF_A>;
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_AW = CC2IF_AW;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            #[doc = "1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/compare 2 generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2G_AW {
            #[doc = "1: If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            TRIGGER = 1,
        }
        impl From<CC2G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC2G_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC2G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 generation"]
        pub type CC1G_AW = CC2G_AW;
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC2G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Output Compare 2 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, OC2M_A>;
        impl OC2M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC2M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC2M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC2M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC2M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC2M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC2M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC2M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output Compare 2 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            #[doc = "0: Preload register on CCRx disabled. New values written to CCRx are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCRx enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, OC2PE_A>;
        impl OC2PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC2PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC2PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCRx disabled. New values written to CCRx are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCRx enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CCx channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC2S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Output Compare 1 mode"]
        pub type OC1M_A = OC2M_A;
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, OC2M_A>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output Compare 1 preload enable"]
        pub type OC1PE_A = OC2PE_A;
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, OC2PE_A>;
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCRx disabled. New values written to CCRx are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCRx enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection"]
        pub type CC1S_A = CC2S_A;
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC2S_A>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Input capture 2 filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC2F_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC2F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC2F_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, IC2F_A>;
        impl IC2F_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IC2F_A {
                match self.bits {
                    0 => IC2F_A::NOFILTER,
                    1 => IC2F_A::FCK_INT_N2,
                    2 => IC2F_A::FCK_INT_N4,
                    3 => IC2F_A::FCK_INT_N8,
                    4 => IC2F_A::FDTS_DIV2_N6,
                    5 => IC2F_A::FDTS_DIV2_N8,
                    6 => IC2F_A::FDTS_DIV4_N6,
                    7 => IC2F_A::FDTS_DIV4_N8,
                    8 => IC2F_A::FDTS_DIV8_N6,
                    9 => IC2F_A::FDTS_DIV8_N8,
                    10 => IC2F_A::FDTS_DIV16_N5,
                    11 => IC2F_A::FDTS_DIV16_N6,
                    12 => IC2F_A::FDTS_DIV16_N8,
                    13 => IC2F_A::FDTS_DIV32_N5,
                    14 => IC2F_A::FDTS_DIV32_N6,
                    15 => IC2F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC2F_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == IC2F_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == IC2F_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == IC2F_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == IC2F_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == IC2F_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC2F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC2F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CCx channel is configured as output"]
            OUTPUT = 0,
            #[doc = "1: CCx channel is configured as input, ICx is mapped on TI1"]
            TI1 = 1,
            #[doc = "2: CCx channel is configured as input, ICx is mapped on TI2"]
            TI2 = 2,
            #[doc = "3: CCx channel is configured as input, ICx is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2S_A {
                match self.bits {
                    0 => CC2S_A::OUTPUT,
                    1 => CC2S_A::TI1,
                    2 => CC2S_A::TI2,
                    3 => CC2S_A::TRC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC2S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC2S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC2S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Input capture 1 filter"]
        pub type IC1F_A = IC2F_A;
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, IC2F_A>;
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC2F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection"]
        pub type CC1S_A = CC2S_A;
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC2S_A>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/Compare 2 output Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2NP_A {
            #[doc = "0: Negative polarity"]
            NEGATIVE = 0,
            #[doc = "1: Positive polarity"]
            POSITIVE = 1,
        }
        impl From<CC2NP_A> for bool {
            #[inline(always)]
            fn from(variant: CC2NP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2NP`"]
        pub type CC2NP_R = crate::R<bool, CC2NP_A>;
        impl CC2NP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2NP_A {
                match self.bits {
                    false => CC2NP_A::NEGATIVE,
                    true => CC2NP_A::POSITIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NEGATIVE`"]
            #[inline(always)]
            pub fn is_negative(&self) -> bool {
                *self == CC2NP_A::NEGATIVE
            }
            #[doc = "Checks if the value of the field is `POSITIVE`"]
            #[inline(always)]
            pub fn is_positive(&self) -> bool {
                *self == CC2NP_A::POSITIVE
            }
        }
        #[doc = "Write proxy for field `CC2NP`"]
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC2NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC2NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2P_A {
            #[doc = "0: Noninverted/rising edge"]
            RISINGEDGE = 0,
            #[doc = "1: Inverted/falling edge"]
            FALLINGEDGE = 1,
        }
        impl From<CC2P_A> for bool {
            #[inline(always)]
            fn from(variant: CC2P_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, CC2P_A>;
        impl CC2P_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2P_A {
                match self.bits {
                    false => CC2P_A::RISINGEDGE,
                    true => CC2P_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == CC2P_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == CC2P_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC2P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC2P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2E_A {
            #[doc = "0: Capture disabled"]
            DISABLED = 0,
            #[doc = "1: Capture enabled"]
            ENABLED = 1,
        }
        impl From<CC2E_A> for bool {
            #[inline(always)]
            fn from(variant: CC2E_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, CC2E_A>;
        impl CC2E_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2E_A {
                match self.bits {
                    false => CC2E_A::DISABLED,
                    true => CC2E_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC2E_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC2E_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output Polarity"]
        pub type CC1NP_A = CC2NP_A;
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, CC2NP_A>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC2NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC2NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output Polarity"]
        pub type CC1P_A = CC2P_A;
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, CC2P_A>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC2P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC2P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output enable"]
        pub type CC1E_A = CC2E_A;
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, CC2E_A>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
    #[doc = "TIM21 option register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [or](or) module"]
    pub type OR = crate::Reg<u32, _OR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OR;
    #[doc = "`read()` method returns [or::R](or::R) reader structure"]
    impl crate::Readable for OR {}
    #[doc = "`write(|w| ..)` method takes [or::W](or::W) writer structure"]
    impl crate::Writable for OR {}
    #[doc = "TIM21 option register"]
    pub mod or {
        #[doc = "Reader of register OR"]
        pub type R = crate::R<u32, super::OR>;
        #[doc = "Writer for register OR"]
        pub type W = crate::W<u32, super::OR>;
        #[doc = "Register OR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Timer21 ETR remap\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETR_RMP_A {
            #[doc = "0: TIM2x ETR input connected to GPIO"]
            GPIO = 0,
            #[doc = "1: TIM2x ETR input connected to COMP2_OUT"]
            COMP2_OUT = 1,
            #[doc = "2: TIM2x ETR input connected to COMP1_OUT"]
            COMP1_OUT = 2,
            #[doc = "3: TIM2x ETR input connected to LSE clock"]
            LSE = 3,
        }
        impl From<ETR_RMP_A> for u8 {
            #[inline(always)]
            fn from(variant: ETR_RMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETR_RMP`"]
        pub type ETR_RMP_R = crate::R<u8, ETR_RMP_A>;
        impl ETR_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETR_RMP_A {
                match self.bits {
                    0 => ETR_RMP_A::GPIO,
                    1 => ETR_RMP_A::COMP2_OUT,
                    2 => ETR_RMP_A::COMP1_OUT,
                    3 => ETR_RMP_A::LSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `GPIO`"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == ETR_RMP_A::GPIO
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == ETR_RMP_A::COMP2_OUT
            }
            #[doc = "Checks if the value of the field is `COMP1_OUT`"]
            #[inline(always)]
            pub fn is_comp1_out(&self) -> bool {
                *self == ETR_RMP_A::COMP1_OUT
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == ETR_RMP_A::LSE
            }
        }
        #[doc = "Write proxy for field `ETR_RMP`"]
        pub struct ETR_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETR_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETR_RMP_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "TIM2x ETR input connected to GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut W {
                self.variant(ETR_RMP_A::GPIO)
            }
            #[doc = "TIM2x ETR input connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(ETR_RMP_A::COMP2_OUT)
            }
            #[doc = "TIM2x ETR input connected to COMP1_OUT"]
            #[inline(always)]
            pub fn comp1_out(self) -> &'a mut W {
                self.variant(ETR_RMP_A::COMP1_OUT)
            }
            #[doc = "TIM2x ETR input connected to LSE clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(ETR_RMP_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Timer21 TI1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TI1_RMP_A {
            #[doc = "0: TIM2x TI1 input connected to GPIO"]
            GPIO = 0,
            #[doc = "1: TIM2x TI1 input connected to COMP2_OUT"]
            COMP2_OUT = 1,
            #[doc = "2: TIM2x TI1 input connected to COMP1_OUT"]
            COMP1_OUT = 2,
        }
        impl From<TI1_RMP_A> for u8 {
            #[inline(always)]
            fn from(variant: TI1_RMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TI1_RMP`"]
        pub type TI1_RMP_R = crate::R<u8, TI1_RMP_A>;
        impl TI1_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TI1_RMP_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TI1_RMP_A::GPIO),
                    1 => Val(TI1_RMP_A::COMP2_OUT),
                    2 => Val(TI1_RMP_A::COMP1_OUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `GPIO`"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == TI1_RMP_A::GPIO
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == TI1_RMP_A::COMP2_OUT
            }
            #[doc = "Checks if the value of the field is `COMP1_OUT`"]
            #[inline(always)]
            pub fn is_comp1_out(&self) -> bool {
                *self == TI1_RMP_A::COMP1_OUT
            }
        }
        #[doc = "Write proxy for field `TI1_RMP`"]
        pub struct TI1_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI1_RMP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "TIM2x TI1 input connected to GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut W {
                self.variant(TI1_RMP_A::GPIO)
            }
            #[doc = "TIM2x TI1 input connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(TI1_RMP_A::COMP2_OUT)
            }
            #[doc = "TIM2x TI1 input connected to COMP1_OUT"]
            #[inline(always)]
            pub fn comp1_out(self) -> &'a mut W {
                self.variant(TI1_RMP_A::COMP1_OUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 2)) | (((value as u32) & 0x07) << 2);
                self.w
            }
        }
        #[doc = "Timer21 TI2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI2_RMP_A {
            #[doc = "0: TIM2x TI2 input connected to GPIO"]
            GPIO = 0,
            #[doc = "1: TIM2x TI2 input connected to COMP2_OUT"]
            COMP2_OUT = 1,
        }
        impl From<TI2_RMP_A> for bool {
            #[inline(always)]
            fn from(variant: TI2_RMP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TI2_RMP`"]
        pub type TI2_RMP_R = crate::R<bool, TI2_RMP_A>;
        impl TI2_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TI2_RMP_A {
                match self.bits {
                    false => TI2_RMP_A::GPIO,
                    true => TI2_RMP_A::COMP2_OUT,
                }
            }
            #[doc = "Checks if the value of the field is `GPIO`"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == TI2_RMP_A::GPIO
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == TI2_RMP_A::COMP2_OUT
            }
        }
        #[doc = "Write proxy for field `TI2_RMP`"]
        pub struct TI2_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI2_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI2_RMP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIM2x TI2 input connected to GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut W {
                self.variant(TI2_RMP_A::GPIO)
            }
            #[doc = "TIM2x TI2 input connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(TI2_RMP_A::COMP2_OUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Timer21 ETR remap"]
            #[inline(always)]
            pub fn etr_rmp(&self) -> ETR_RMP_R {
                ETR_RMP_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:4 - Timer21 TI1"]
            #[inline(always)]
            pub fn ti1_rmp(&self) -> TI1_RMP_R {
                TI1_RMP_R::new(((self.bits >> 2) & 0x07) as u8)
            }
            #[doc = "Bit 5 - Timer21 TI2"]
            #[inline(always)]
            pub fn ti2_rmp(&self) -> TI2_RMP_R {
                TI2_RMP_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Timer21 ETR remap"]
            #[inline(always)]
            pub fn etr_rmp(&mut self) -> ETR_RMP_W {
                ETR_RMP_W { w: self }
            }
            #[doc = "Bits 2:4 - Timer21 TI1"]
            #[inline(always)]
            pub fn ti1_rmp(&mut self) -> TI1_RMP_W {
                TI1_RMP_W { w: self }
            }
            #[doc = "Bit 5 - Timer21 TI2"]
            #[inline(always)]
            pub fn ti2_rmp(&mut self) -> TI2_RMP_W {
                TI2_RMP_W { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct TIM22 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM22 {}
impl TIM22 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tim22::RegisterBlock {
        0x4001_1400 as *const _
    }
}
impl Deref for TIM22 {
    type Target = tim22::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIM22::ptr() }
    }
}
#[doc = "General-purpose-timers"]
pub mod tim22 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved7: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved11: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR,
        #[doc = "0x38 - capture/compare register 1"]
        pub ccr2: CCR,
        _reserved13: [u8; 20usize],
        #[doc = "0x50 - TIM22 option register"]
        pub or: OR,
    }
    impl RegisterBlock {
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &CCMR1_INPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register 1 (input mode)"]
        #[inline(always)]
        pub fn ccmr1_input_mut(&self) -> &mut CCMR1_INPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_INPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &CCMR1_OUTPUT {
            unsafe { &*(((self as *const Self) as *const u8).add(24usize) as *const CCMR1_OUTPUT) }
        }
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        #[inline(always)]
        pub fn ccmr1_output_mut(&self) -> &mut CCMR1_OUTPUT {
            unsafe { &mut *(((self as *const Self) as *mut u8).add(24usize) as *mut CCMR1_OUTPUT) }
        }
    }
    #[doc = "control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Counter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            #[doc = "0: Counter disabled"]
            DISABLED = 0,
            #[doc = "1: Counter enabled"]
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CEN`"]
        pub type CEN_R = crate::R<bool, CEN_A>;
        impl CEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CEN`"]
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Update disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            #[doc = "0: Update event enabled"]
            ENABLED = 0,
            #[doc = "1: Update event disabled"]
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UDIS`"]
        pub type UDIS_R = crate::R<bool, UDIS_A>;
        impl UDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `UDIS`"]
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update event enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update request source\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            #[doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT = 0,
            #[doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `URS`"]
        pub type URS_R = crate::R<bool, URS_A>;
        impl URS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                *self == URS_A::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                *self == URS_A::COUNTERONLY
            }
        }
        #[doc = "Write proxy for field `URS`"]
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "One-pulse mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            #[doc = "0: Counter is not stopped on the update event"]
            NOTSTOPPED = 0,
            #[doc = "1: Counter stops counting on the next update event (clearing the CEN bit)"]
            STOPPED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OPM`"]
        pub type OPM_R = crate::R<bool, OPM_A>;
        impl OPM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::NOTSTOPPED,
                    true => OPM_A::STOPPED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTOPPED`"]
            #[inline(always)]
            pub fn is_not_stopped(&self) -> bool {
                *self == OPM_A::NOTSTOPPED
            }
            #[doc = "Checks if the value of the field is `STOPPED`"]
            #[inline(always)]
            pub fn is_stopped(&self) -> bool {
                *self == OPM_A::STOPPED
            }
        }
        #[doc = "Write proxy for field `OPM`"]
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter is not stopped on the update event"]
            #[inline(always)]
            pub fn not_stopped(self) -> &'a mut W {
                self.variant(OPM_A::NOTSTOPPED)
            }
            #[doc = "Counter stops counting on the next update event (clearing the CEN bit)"]
            #[inline(always)]
            pub fn stopped(self) -> &'a mut W {
                self.variant(OPM_A::STOPPED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            #[doc = "0: Counter used as upcounter"]
            UP = 0,
            #[doc = "1: Counter used as downcounter"]
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DIR`"]
        pub type DIR_R = crate::R<bool, DIR_A>;
        impl DIR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                *self == DIR_A::UP
            }
            #[doc = "Checks if the value of the field is `DOWN`"]
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                *self == DIR_A::DOWN
            }
        }
        #[doc = "Write proxy for field `DIR`"]
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Counter used as upcounter"]
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            #[doc = "Counter used as downcounter"]
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Center-aligned mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            #[doc = "0: The counter counts up or down depending on the direction bit"]
            EDGEALIGNED = 0,
            #[doc = "1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            CENTERALIGNED1 = 1,
            #[doc = "2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            CENTERALIGNED2 = 2,
            #[doc = "3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CMS`"]
        pub type CMS_R = crate::R<u8, CMS_A>;
        impl CMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `EDGEALIGNED`"]
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                *self == CMS_A::EDGEALIGNED
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED1`"]
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                *self == CMS_A::CENTERALIGNED1
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED2`"]
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                *self == CMS_A::CENTERALIGNED2
            }
            #[doc = "Checks if the value of the field is `CENTERALIGNED3`"]
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                *self == CMS_A::CENTERALIGNED3
            }
        }
        #[doc = "Write proxy for field `CMS`"]
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The counter counts up or down depending on the direction bit"]
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."]
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."]
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            #[doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."]
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | (((value as u32) & 0x03) << 5);
                self.w
            }
        }
        #[doc = "Auto-reload preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            #[doc = "0: TIMx_APRR register is not buffered"]
            DISABLED = 0,
            #[doc = "1: TIMx_APRR register is buffered"]
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ARPE`"]
        pub type ARPE_R = crate::R<bool, ARPE_A>;
        impl ARPE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ARPE`"]
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Clock division\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            #[doc = "0: t_DTS = t_CK_INT"]
            DIV1 = 0,
            #[doc = "1: t_DTS = 2  t_CK_INT"]
            DIV2 = 1,
            #[doc = "2: t_DTS = 4  t_CK_INT"]
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CKD`"]
        pub type CKD_R = crate::R<u8, CKD_A>;
        impl CKD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CKD_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CKD_A::DIV1),
                    1 => Val(CKD_A::DIV2),
                    2 => Val(CKD_A::DIV4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CKD_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CKD_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CKD_A::DIV4
            }
        }
        #[doc = "Write proxy for field `CKD`"]
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "t_DTS = t_CK_INT"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            #[doc = "t_DTS = 2  t_CK_INT"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            #[doc = "t_DTS = 4  t_CK_INT"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Counter enable"]
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
        }
    }
    #[doc = "control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Master mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            #[doc = "0: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO)"]
            RESET = 0,
            #[doc = "1: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO)"]
            ENABLE = 1,
            #[doc = "2: Update - The update event is selected as trigger output (TRGO)"]
            UPDATE = 2,
            #[doc = "3: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred"]
            COMPAREPULSE = 3,
            #[doc = "4: OC1REF signal is used as trigger output (TRGO)"]
            OC1REF = 4,
            #[doc = "5: OC2REF signal is used as trigger output (TRGO)"]
            OC2REF = 5,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `MMS`"]
        pub type MMS_R = crate::R<u8, MMS_A>;
        impl MMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, MMS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(MMS_A::RESET),
                    1 => Val(MMS_A::ENABLE),
                    2 => Val(MMS_A::UPDATE),
                    3 => Val(MMS_A::COMPAREPULSE),
                    4 => Val(MMS_A::OC1REF),
                    5 => Val(MMS_A::OC2REF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::UPDATE
            }
            #[doc = "Checks if the value of the field is `COMPAREPULSE`"]
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                *self == MMS_A::COMPAREPULSE
            }
            #[doc = "Checks if the value of the field is `OC1REF`"]
            #[inline(always)]
            pub fn is_oc1ref(&self) -> bool {
                *self == MMS_A::OC1REF
            }
            #[doc = "Checks if the value of the field is `OC2REF`"]
            #[inline(always)]
            pub fn is_oc2ref(&self) -> bool {
                *self == MMS_A::OC2REF
            }
        }
        #[doc = "Write proxy for field `MMS`"]
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            #[doc = "Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            #[doc = "Update - The update event is selected as trigger output (TRGO)"]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            #[doc = "Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred"]
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            #[doc = "OC1REF signal is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn oc1ref(self) -> &'a mut W {
                self.variant(MMS_A::OC1REF)
            }
            #[doc = "OC2REF signal is used as trigger output (TRGO)"]
            #[inline(always)]
            pub fn oc2ref(self) -> &'a mut W {
                self.variant(MMS_A::OC2REF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
        }
    }
    #[doc = "slave mode control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](smcr) module"]
    pub type SMCR = crate::Reg<u32, _SMCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SMCR;
    #[doc = "`read()` method returns [smcr::R](smcr::R) reader structure"]
    impl crate::Readable for SMCR {}
    #[doc = "`write(|w| ..)` method takes [smcr::W](smcr::W) writer structure"]
    impl crate::Writable for SMCR {}
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = "Reader of register SMCR"]
        pub type R = crate::R<u32, super::SMCR>;
        #[doc = "Writer for register SMCR"]
        pub type W = crate::W<u32, super::SMCR>;
        #[doc = "Register SMCR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SMCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Slave mode selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            #[doc = "0: Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            DISABLED = 0,
            #[doc = "1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1 = 1,
            #[doc = "2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2 = 2,
            #[doc = "3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3 = 3,
            #[doc = "4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE = 4,
            #[doc = "5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE = 5,
            #[doc = "6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE = 6,
            #[doc = "7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `SMS`"]
        pub type SMS_R = crate::R<u8, SMS_A>;
        impl SMS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SMS_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_1`"]
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_1
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_2`"]
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_2
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_3`"]
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                *self == SMS_A::ENCODER_MODE_3
            }
            #[doc = "Checks if the value of the field is `RESET_MODE`"]
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                *self == SMS_A::RESET_MODE
            }
            #[doc = "Checks if the value of the field is `GATED_MODE`"]
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                *self == SMS_A::GATED_MODE
            }
            #[doc = "Checks if the value of the field is `TRIGGER_MODE`"]
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                *self == SMS_A::TRIGGER_MODE
            }
            #[doc = "Checks if the value of the field is `EXT_CLOCK_MODE`"]
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                *self == SMS_A::EXT_CLOCK_MODE
            }
        }
        #[doc = "Write proxy for field `SMS`"]
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Trigger selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            #[doc = "0: Internal Trigger 0 (ITR0)"]
            ITR0 = 0,
            #[doc = "1: Internal Trigger 1 (ITR1)"]
            ITR1 = 1,
            #[doc = "2: Internal Trigger 2 (ITR2)"]
            ITR2 = 2,
            #[doc = "4: TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED = 4,
            #[doc = "5: Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1 = 5,
            #[doc = "6: Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2 = 6,
            #[doc = "7: External Trigger input (ETRF)"]
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TS`"]
        pub type TS_R = crate::R<u8, TS_A>;
        impl TS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TS_A::ITR0),
                    1 => Val(TS_A::ITR1),
                    2 => Val(TS_A::ITR2),
                    4 => Val(TS_A::TI1F_ED),
                    5 => Val(TS_A::TI1FP1),
                    6 => Val(TS_A::TI2FP2),
                    7 => Val(TS_A::ETRF),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ITR0`"]
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                *self == TS_A::ITR0
            }
            #[doc = "Checks if the value of the field is `ITR1`"]
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                *self == TS_A::ITR1
            }
            #[doc = "Checks if the value of the field is `ITR2`"]
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                *self == TS_A::ITR2
            }
            #[doc = "Checks if the value of the field is `TI1F_ED`"]
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                *self == TS_A::TI1F_ED
            }
            #[doc = "Checks if the value of the field is `TI1FP1`"]
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::TI1FP1
            }
            #[doc = "Checks if the value of the field is `TI2FP2`"]
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::TI2FP2
            }
            #[doc = "Checks if the value of the field is `ETRF`"]
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                *self == TS_A::ETRF
            }
        }
        #[doc = "Write proxy for field `TS`"]
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Internal Trigger 0 (ITR0)"]
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            #[doc = "Internal Trigger 1 (ITR1)"]
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            #[doc = "Internal Trigger 2 (ITR2)"]
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            #[doc = "External Trigger input (ETRF)"]
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Master/Slave mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            #[doc = "0: No action"]
            NOSYNC = 0,
            #[doc = "1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSM`"]
        pub type MSM_R = crate::R<bool, MSM_A>;
        impl MSM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `NOSYNC`"]
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                *self == MSM_A::NOSYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                *self == MSM_A::SYNC
            }
        }
        #[doc = "Write proxy for field `MSM`"]
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No action"]
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "External trigger filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETF`"]
        pub type ETF_R = crate::R<u8, ETF_A>;
        impl ETF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == ETF_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == ETF_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == ETF_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == ETF_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `ETF`"]
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "External trigger prescaler\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            #[doc = "0: Prescaler OFF"]
            DIV1 = 0,
            #[doc = "1: ETRP frequency divided by 2"]
            DIV2 = 1,
            #[doc = "2: ETRP frequency divided by 4"]
            DIV4 = 2,
            #[doc = "3: ETRP frequency divided by 8"]
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETPS`"]
        pub type ETPS_R = crate::R<u8, ETPS_A>;
        impl ETPS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == ETPS_A::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::DIV8
            }
        }
        #[doc = "Write proxy for field `ETPS`"]
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "Prescaler OFF"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            #[doc = "ETRP frequency divided by 2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            #[doc = "ETRP frequency divided by 4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            #[doc = "ETRP frequency divided by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "External clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            #[doc = "0: External clock mode 2 disabled"]
            DISABLED = 0,
            #[doc = "1: External clock mode 2 enabled"]
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ECE`"]
        pub type ECE_R = crate::R<bool, ECE_A>;
        impl ECE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `ECE`"]
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "External clock mode 2 disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            #[doc = "External clock mode 2 enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "External trigger polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            #[doc = "0: ETR is non-inverted, active at high level or rising edge"]
            RISINGEDGE = 0,
            #[doc = "1: ETR is inverted, active at low level or falling edge"]
            FALLINGEDGE = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ETP`"]
        pub type ETP_R = crate::R<bool, ETP_A>;
        impl ETP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::RISINGEDGE,
                    true => ETP_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == ETP_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == ETP_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `ETP`"]
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "ETR is non-inverted, active at high level or rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(ETP_A::RISINGEDGE)
            }
            #[doc = "ETR is inverted, active at low level or falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(ETP_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dier](dier) module"]
    pub type DIER = crate::Reg<u32, _DIER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIER;
    #[doc = "`read()` method returns [dier::R](dier::R) reader structure"]
    impl crate::Readable for DIER {}
    #[doc = "`write(|w| ..)` method takes [dier::W](dier::W) writer structure"]
    impl crate::Writable for DIER {}
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = "Reader of register DIER"]
        pub type R = crate::R<u32, super::DIER>;
        #[doc = "Writer for register DIER"]
        pub type W = crate::W<u32, super::DIER>;
        #[doc = "Register DIER `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            #[doc = "0: Trigger interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Trigger interrupt enabled"]
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIE`"]
        pub type TIE_R = crate::R<bool, TIE_A>;
        impl TIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TIE`"]
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Trigger interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            #[doc = "Trigger interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2IE_A {
            #[doc = "0: CCx interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: CCx interrupt enabled"]
            ENABLED = 1,
        }
        impl From<CC2IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC2IE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2IE`"]
        pub type CC2IE_R = crate::R<bool, CC2IE_A>;
        impl CC2IE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2IE_A {
                match self.bits {
                    false => CC2IE_A::DISABLED,
                    true => CC2IE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC2IE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC2IE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC2IE`"]
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 interrupt enable"]
        pub type CC1IE_A = CC2IE_A;
        #[doc = "Reader of field `CC1IE`"]
        pub type CC1IE_R = crate::R<bool, CC2IE_A>;
        #[doc = "Write proxy for field `CC1IE`"]
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2IE_A::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2IE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            #[doc = "0: Update interrupt disabled"]
            DISABLED = 0,
            #[doc = "1: Update interrupt enabled"]
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIE`"]
        pub type UIE_R = crate::R<bool, UIE_A>;
        impl UIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UIE`"]
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
        }
    }
    #[doc = "status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "status register"]
    pub mod sr {
        #[doc = "Reader of register SR"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register SR"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register SR `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/compare 2 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2OF_A {
            #[doc = "1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
            OVERCAPTURE = 1,
        }
        impl From<CC2OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC2OF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2OF`"]
        pub type CC2OF_R = crate::R<bool, CC2OF_A>;
        impl CC2OF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC2OF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC2OF_A::OVERCAPTURE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERCAPTURE`"]
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                *self == CC2OF_A::OVERCAPTURE
            }
        }
        #[doc = "Capture/compare 2 overcapture flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2OF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC2OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC2OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC2OF`"]
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_A = CC2OF_A;
        #[doc = "Reader of field `CC1OF`"]
        pub type CC1OF_R = crate::R<bool, CC2OF_A>;
        #[doc = "Capture/Compare 1 overcapture flag"]
        pub type CC1OF_AW = CC2OF_AW;
        #[doc = "Write proxy for field `CC1OF`"]
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2OF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            #[doc = "0: No trigger event occurred"]
            NOTRIGGER = 0,
            #[doc = "1: Trigger interrupt pending"]
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TIF`"]
        pub type TIF_R = crate::R<bool, TIF_A>;
        impl TIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRIGGER`"]
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                *self == TIF_A::NOTRIGGER
            }
            #[doc = "Checks if the value of the field is `TRIGGER`"]
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == TIF_A::TRIGGER
            }
        }
        #[doc = "Trigger interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TIF`"]
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2IF_A {
            #[doc = "1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
            MATCH = 1,
        }
        impl From<CC2IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC2IF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2IF`"]
        pub type CC2IF_R = crate::R<bool, CC2IF_A>;
        impl CC2IF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<bool, CC2IF_A> {
                use crate::Variant::*;
                match self.bits {
                    true => Val(CC2IF_A::MATCH),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline(always)]
            pub fn is_match_(&self) -> bool {
                *self == CC2IF_A::MATCH
            }
        }
        #[doc = "Capture/Compare 2 interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2IF_AW {
            #[doc = "0: Clear flag"]
            CLEAR = 0,
        }
        impl From<CC2IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC2IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC2IF`"]
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_A = CC2IF_A;
        #[doc = "Reader of field `CC1IF`"]
        pub type CC1IF_R = crate::R<bool, CC2IF_A>;
        #[doc = "Capture/compare 1 interrupt flag"]
        pub type CC1IF_AW = CC2IF_AW;
        #[doc = "Write proxy for field `CC1IF`"]
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clear flag"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2IF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update interrupt flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            #[doc = "0: No update occurred"]
            CLEAR = 0,
            #[doc = "1: Update interrupt pending."]
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UIF`"]
        pub type UIF_R = crate::R<bool, UIF_A>;
        impl UIF_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == UIF_A::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                *self == UIF_A::UPDATEPENDING
            }
        }
        #[doc = "Write proxy for field `UIF`"]
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "No update occurred"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
        }
    }
    #[doc = "event generation register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [egr](egr) module"]
    pub type EGR = crate::Reg<u32, _EGR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EGR;
    #[doc = "`write(|w| ..)` method takes [egr::W](egr::W) writer structure"]
    impl crate::Writable for EGR {}
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = "Writer for register EGR"]
        pub type W = crate::W<u32, super::EGR>;
        #[doc = "Register EGR `reset()`'s with value 0"]
        impl crate::ResetValue for super::EGR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Trigger generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            #[doc = "1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TG`"]
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Capture/compare 2 generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2G_AW {
            #[doc = "1: If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            TRIGGER = 1,
        }
        impl From<CC2G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC2G_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CC2G`"]
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC2G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/compare 1 generation"]
        pub type CC1G_AW = CC2G_AW;
        #[doc = "Write proxy for field `CC1G`"]
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "If CCx is an output: CCxIF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CCx is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC2G_AW::TRIGGER)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Update generation\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            #[doc = "1: Re-initializes the timer counter and generates an update of the registers."]
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `UG`"]
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the registers."]
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 6 - Trigger generation"]
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_output](ccmr1_output) module"]
    pub type CCMR1_OUTPUT = crate::Reg<u32, _CCMR1_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_OUTPUT;
    #[doc = "`read()` method returns [ccmr1_output::R](ccmr1_output::R) reader structure"]
    impl crate::Readable for CCMR1_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_output::W](ccmr1_output::W) writer structure"]
    impl crate::Writable for CCMR1_OUTPUT {}
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = "Reader of register CCMR1_Output"]
        pub type R = crate::R<u32, super::CCMR1_OUTPUT>;
        #[doc = "Writer for register CCMR1_Output"]
        pub type W = crate::W<u32, super::CCMR1_OUTPUT>;
        #[doc = "Register CCMR1_Output `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Output Compare 2 mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            #[doc = "0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            FROZEN = 0,
            #[doc = "1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            ACTIVEONMATCH = 1,
            #[doc = "2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            INACTIVEONMATCH = 2,
            #[doc = "3: OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            TOGGLE = 3,
            #[doc = "4: OCyREF is forced low"]
            FORCEINACTIVE = 4,
            #[doc = "5: OCyREF is forced high"]
            FORCEACTIVE = 5,
            #[doc = "6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            PWMMODE1 = 6,
            #[doc = "7: Inversely to PwmMode1"]
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `OC2M`"]
        pub type OC2M_R = crate::R<u8, OC2M_A>;
        impl OC2M_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FROZEN`"]
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::FROZEN
            }
            #[doc = "Checks if the value of the field is `ACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                *self == OC2M_A::ACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `INACTIVEONMATCH`"]
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                *self == OC2M_A::INACTIVEONMATCH
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                *self == OC2M_A::TOGGLE
            }
            #[doc = "Checks if the value of the field is `FORCEINACTIVE`"]
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                *self == OC2M_A::FORCEINACTIVE
            }
            #[doc = "Checks if the value of the field is `FORCEACTIVE`"]
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                *self == OC2M_A::FORCEACTIVE
            }
            #[doc = "Checks if the value of the field is `PWMMODE1`"]
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                *self == OC2M_A::PWMMODE1
            }
            #[doc = "Checks if the value of the field is `PWMMODE2`"]
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                *self == OC2M_A::PWMMODE2
            }
        }
        #[doc = "Write proxy for field `OC2M`"]
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | (((value as u32) & 0x07) << 12);
                self.w
            }
        }
        #[doc = "Output Compare 2 preload enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            #[doc = "0: Preload register on CCRx disabled. New values written to CCRx are taken into account immediately"]
            DISABLED = 0,
            #[doc = "1: Preload register on CCRx enabled. Preload value is loaded into active register on each update event"]
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OC2PE`"]
        pub type OC2PE_R = crate::R<bool, OC2PE_A>;
        impl OC2PE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC2PE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC2PE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `OC2PE`"]
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCRx disabled. New values written to CCRx are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCRx enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `OC2FE`"]
        pub type OC2FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC2FE`"]
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CCx channel is configured as output"]
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CC2S_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CC2S_A::OUTPUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Output Compare 1 mode"]
        pub type OC1M_A = OC2M_A;
        #[doc = "Reader of field `OC1M`"]
        pub type OC1M_R = crate::R<u8, OC2M_A>;
        #[doc = "Write proxy for field `OC1M`"]
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs"]
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            #[doc = "Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            #[doc = "Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register"]
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            #[doc = "OCyREF toggles when TIMx_CNT=TIMx_CCRy"]
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            #[doc = "OCyREF is forced low"]
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            #[doc = "OCyREF is forced high"]
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            #[doc = "In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active"]
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            #[doc = "Inversely to PwmMode1"]
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | (((value as u32) & 0x07) << 4);
                self.w
            }
        }
        #[doc = "Output Compare 1 preload enable"]
        pub type OC1PE_A = OC2PE_A;
        #[doc = "Reader of field `OC1PE`"]
        pub type OC1PE_R = crate::R<bool, OC2PE_A>;
        #[doc = "Write proxy for field `OC1PE`"]
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Preload register on CCRx disabled. New values written to CCRx are taken into account immediately"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            #[doc = "Preload register on CCRx enabled. Preload value is loaded into active register on each update event"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `OC1FE`"]
        pub type OC1FE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `OC1FE`"]
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection"]
        pub type CC1S_A = CC2S_A;
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC2S_A>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmr1_input](ccmr1_input) module"]
    pub type CCMR1_INPUT = crate::Reg<u32, _CCMR1_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCMR1_INPUT;
    #[doc = "`read()` method returns [ccmr1_input::R](ccmr1_input::R) reader structure"]
    impl crate::Readable for CCMR1_INPUT {}
    #[doc = "`write(|w| ..)` method takes [ccmr1_input::W](ccmr1_input::W) writer structure"]
    impl crate::Writable for CCMR1_INPUT {}
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = "Reader of register CCMR1_Input"]
        pub type R = crate::R<u32, super::CCMR1_INPUT>;
        #[doc = "Writer for register CCMR1_Input"]
        pub type W = crate::W<u32, super::CCMR1_INPUT>;
        #[doc = "Register CCMR1_Input `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCMR1_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Input capture 2 filter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC2F_A {
            #[doc = "0: No filter, sampling is done at fDTS"]
            NOFILTER = 0,
            #[doc = "1: fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2 = 1,
            #[doc = "2: fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4 = 2,
            #[doc = "3: fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8 = 3,
            #[doc = "4: fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6 = 4,
            #[doc = "5: fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8 = 5,
            #[doc = "6: fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6 = 6,
            #[doc = "7: fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8 = 7,
            #[doc = "8: fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6 = 8,
            #[doc = "9: fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8 = 9,
            #[doc = "10: fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5 = 10,
            #[doc = "11: fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6 = 11,
            #[doc = "12: fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8 = 12,
            #[doc = "13: fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5 = 13,
            #[doc = "14: fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6 = 14,
            #[doc = "15: fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC2F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC2F_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `IC2F`"]
        pub type IC2F_R = crate::R<u8, IC2F_A>;
        impl IC2F_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IC2F_A {
                match self.bits {
                    0 => IC2F_A::NOFILTER,
                    1 => IC2F_A::FCK_INT_N2,
                    2 => IC2F_A::FCK_INT_N4,
                    3 => IC2F_A::FCK_INT_N8,
                    4 => IC2F_A::FDTS_DIV2_N6,
                    5 => IC2F_A::FDTS_DIV2_N8,
                    6 => IC2F_A::FDTS_DIV4_N6,
                    7 => IC2F_A::FDTS_DIV4_N8,
                    8 => IC2F_A::FDTS_DIV8_N6,
                    9 => IC2F_A::FDTS_DIV8_N8,
                    10 => IC2F_A::FDTS_DIV16_N5,
                    11 => IC2F_A::FDTS_DIV16_N6,
                    12 => IC2F_A::FDTS_DIV16_N8,
                    13 => IC2F_A::FDTS_DIV32_N5,
                    14 => IC2F_A::FDTS_DIV32_N6,
                    15 => IC2F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC2F_A::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == IC2F_A::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == IC2F_A::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == IC2F_A::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == IC2F_A::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == IC2F_A::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == IC2F_A::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == IC2F_A::FDTS_DIV32_N8
            }
        }
        #[doc = "Write proxy for field `IC2F`"]
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC2F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC2F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `IC2PSC`"]
        pub type IC2PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC2PSC`"]
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            #[doc = "0: CCx channel is configured as output"]
            OUTPUT = 0,
            #[doc = "1: CCx channel is configured as input, ICx is mapped on TI1"]
            TI1 = 1,
            #[doc = "2: CCx channel is configured as input, ICx is mapped on TI2"]
            TI2 = 2,
            #[doc = "3: CCx channel is configured as input, ICx is mapped on TRC"]
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `CC2S`"]
        pub type CC2S_R = crate::R<u8, CC2S_A>;
        impl CC2S_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2S_A {
                match self.bits {
                    0 => CC2S_A::OUTPUT,
                    1 => CC2S_A::TI1,
                    2 => CC2S_A::TI2,
                    3 => CC2S_A::TRC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::OUTPUT
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                *self == CC2S_A::TI1
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                *self == CC2S_A::TI2
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                *self == CC2S_A::TRC
            }
        }
        #[doc = "Write proxy for field `CC2S`"]
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Input capture 1 filter"]
        pub type IC1F_A = IC2F_A;
        #[doc = "Reader of field `IC1F`"]
        pub type IC1F_R = crate::R<u8, IC2F_A>;
        #[doc = "Write proxy for field `IC1F`"]
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC2F_A::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC2F_A::FDTS_DIV32_N8)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `IC1PSC`"]
        pub type IC1PSC_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `IC1PSC`"]
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 selection"]
        pub type CC1S_A = CC2S_A;
        #[doc = "Reader of field `CC1S`"]
        pub type CC1S_R = crate::R<u8, CC2S_A>;
        #[doc = "Write proxy for field `CC1S`"]
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "CCx channel is configured as output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI1"]
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TI2"]
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            #[doc = "CCx channel is configured as input, ICx is mapped on TRC"]
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccer](ccer) module"]
    pub type CCER = crate::Reg<u32, _CCER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCER;
    #[doc = "`read()` method returns [ccer::R](ccer::R) reader structure"]
    impl crate::Readable for CCER {}
    #[doc = "`write(|w| ..)` method takes [ccer::W](ccer::W) writer structure"]
    impl crate::Writable for CCER {}
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = "Reader of register CCER"]
        pub type R = crate::R<u32, super::CCER>;
        #[doc = "Writer for register CCER"]
        pub type W = crate::W<u32, super::CCER>;
        #[doc = "Register CCER `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Capture/Compare 2 output Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2NP_A {
            #[doc = "0: Negative polarity"]
            NEGATIVE = 0,
            #[doc = "1: Positive polarity"]
            POSITIVE = 1,
        }
        impl From<CC2NP_A> for bool {
            #[inline(always)]
            fn from(variant: CC2NP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2NP`"]
        pub type CC2NP_R = crate::R<bool, CC2NP_A>;
        impl CC2NP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2NP_A {
                match self.bits {
                    false => CC2NP_A::NEGATIVE,
                    true => CC2NP_A::POSITIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NEGATIVE`"]
            #[inline(always)]
            pub fn is_negative(&self) -> bool {
                *self == CC2NP_A::NEGATIVE
            }
            #[doc = "Checks if the value of the field is `POSITIVE`"]
            #[inline(always)]
            pub fn is_positive(&self) -> bool {
                *self == CC2NP_A::POSITIVE
            }
        }
        #[doc = "Write proxy for field `CC2NP`"]
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC2NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC2NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output Polarity\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2P_A {
            #[doc = "0: Noninverted/rising edge"]
            RISINGEDGE = 0,
            #[doc = "1: Inverted/falling edge"]
            FALLINGEDGE = 1,
        }
        impl From<CC2P_A> for bool {
            #[inline(always)]
            fn from(variant: CC2P_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2P`"]
        pub type CC2P_R = crate::R<bool, CC2P_A>;
        impl CC2P_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2P_A {
                match self.bits {
                    false => CC2P_A::RISINGEDGE,
                    true => CC2P_A::FALLINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `RISINGEDGE`"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == CC2P_A::RISINGEDGE
            }
            #[doc = "Checks if the value of the field is `FALLINGEDGE`"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == CC2P_A::FALLINGEDGE
            }
        }
        #[doc = "Write proxy for field `CC2P`"]
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC2P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC2P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Capture/Compare 2 output enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2E_A {
            #[doc = "0: Capture disabled"]
            DISABLED = 0,
            #[doc = "1: Capture enabled"]
            ENABLED = 1,
        }
        impl From<CC2E_A> for bool {
            #[inline(always)]
            fn from(variant: CC2E_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CC2E`"]
        pub type CC2E_R = crate::R<bool, CC2E_A>;
        impl CC2E_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CC2E_A {
                match self.bits {
                    false => CC2E_A::DISABLED,
                    true => CC2E_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CC2E_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CC2E_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CC2E`"]
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC2E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output Polarity"]
        pub type CC1NP_A = CC2NP_A;
        #[doc = "Reader of field `CC1NP`"]
        pub type CC1NP_R = crate::R<bool, CC2NP_A>;
        #[doc = "Write proxy for field `CC1NP`"]
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1NP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Negative polarity"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(CC2NP_A::NEGATIVE)
            }
            #[doc = "Positive polarity"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(CC2NP_A::POSITIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output Polarity"]
        pub type CC1P_A = CC2P_A;
        #[doc = "Reader of field `CC1P`"]
        pub type CC1P_R = crate::R<bool, CC2P_A>;
        #[doc = "Write proxy for field `CC1P`"]
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1P_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Noninverted/rising edge"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut W {
                self.variant(CC2P_A::RISINGEDGE)
            }
            #[doc = "Inverted/falling edge"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut W {
                self.variant(CC2P_A::FALLINGEDGE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Capture/Compare 1 output enable"]
        pub type CC1E_A = CC2E_A;
        #[doc = "Reader of field `CC1E`"]
        pub type CC1E_R = crate::R<bool, CC2E_A>;
        #[doc = "Write proxy for field `CC1E`"]
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CC1E_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Capture disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2E_A::DISABLED)
            }
            #[doc = "Capture enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2E_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
        }
    }
    #[doc = "counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](cnt) module"]
    pub type CNT = crate::Reg<u32, _CNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CNT;
    #[doc = "`read()` method returns [cnt::R](cnt::R) reader structure"]
    impl crate::Readable for CNT {}
    #[doc = "`write(|w| ..)` method takes [cnt::W](cnt::W) writer structure"]
    impl crate::Writable for CNT {}
    #[doc = "counter"]
    pub mod cnt {
        #[doc = "Reader of register CNT"]
        pub type R = crate::R<u32, super::CNT>;
        #[doc = "Writer for register CNT"]
        pub type W = crate::W<u32, super::CNT>;
        #[doc = "Register CNT `reset()`'s with value 0"]
        impl crate::ResetValue for super::CNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CNT`"]
        pub type CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CNT`"]
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - counter value"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
        }
    }
    #[doc = "prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psc](psc) module"]
    pub type PSC = crate::Reg<u32, _PSC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PSC;
    #[doc = "`read()` method returns [psc::R](psc::R) reader structure"]
    impl crate::Readable for PSC {}
    #[doc = "`write(|w| ..)` method takes [psc::W](psc::W) writer structure"]
    impl crate::Writable for PSC {}
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = "Reader of register PSC"]
        pub type R = crate::R<u32, super::PSC>;
        #[doc = "Writer for register PSC"]
        pub type W = crate::W<u32, super::PSC>;
        #[doc = "Register PSC `reset()`'s with value 0"]
        impl crate::ResetValue for super::PSC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `PSC`"]
        pub type PSC_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `PSC`"]
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
        }
    }
    #[doc = "auto-reload register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [arr](arr) module"]
    pub type ARR = crate::Reg<u32, _ARR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ARR;
    #[doc = "`read()` method returns [arr::R](arr::R) reader structure"]
    impl crate::Readable for ARR {}
    #[doc = "`write(|w| ..)` method takes [arr::W](arr::W) writer structure"]
    impl crate::Writable for ARR {}
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = "Reader of register ARR"]
        pub type R = crate::R<u32, super::ARR>;
        #[doc = "Writer for register ARR"]
        pub type W = crate::W<u32, super::ARR>;
        #[doc = "Register ARR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ARR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ARR`"]
        pub type ARR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `ARR`"]
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "capture/compare register 1"]
    pub mod ccr {
        #[doc = "Reader of register CCR%s"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register CCR%s"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register CCR%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `CCR`"]
        pub type CCR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `CCR`"]
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
        }
    }
    #[doc = "TIM22 option register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [or](or) module"]
    pub type OR = crate::Reg<u32, _OR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OR;
    #[doc = "`read()` method returns [or::R](or::R) reader structure"]
    impl crate::Readable for OR {}
    #[doc = "`write(|w| ..)` method takes [or::W](or::W) writer structure"]
    impl crate::Writable for OR {}
    #[doc = "TIM22 option register"]
    pub mod or {
        #[doc = "Reader of register OR"]
        pub type R = crate::R<u32, super::OR>;
        #[doc = "Writer for register OR"]
        pub type W = crate::W<u32, super::OR>;
        #[doc = "Register OR `reset()`'s with value 0"]
        impl crate::ResetValue for super::OR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Timer22 ETR remap\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETR_RMP_A {
            #[doc = "0: TIM2x ETR input connected to GPIO"]
            GPIO = 0,
            #[doc = "1: TIM2x ETR input connected to COMP2_OUT"]
            COMP2_OUT = 1,
            #[doc = "2: TIM2x ETR input connected to COMP1_OUT"]
            COMP1_OUT = 2,
            #[doc = "3: TIM2x ETR input connected to LSE clock"]
            LSE = 3,
        }
        impl From<ETR_RMP_A> for u8 {
            #[inline(always)]
            fn from(variant: ETR_RMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `ETR_RMP`"]
        pub type ETR_RMP_R = crate::R<u8, ETR_RMP_A>;
        impl ETR_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETR_RMP_A {
                match self.bits {
                    0 => ETR_RMP_A::GPIO,
                    1 => ETR_RMP_A::COMP2_OUT,
                    2 => ETR_RMP_A::COMP1_OUT,
                    3 => ETR_RMP_A::LSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `GPIO`"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == ETR_RMP_A::GPIO
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == ETR_RMP_A::COMP2_OUT
            }
            #[doc = "Checks if the value of the field is `COMP1_OUT`"]
            #[inline(always)]
            pub fn is_comp1_out(&self) -> bool {
                *self == ETR_RMP_A::COMP1_OUT
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == ETR_RMP_A::LSE
            }
        }
        #[doc = "Write proxy for field `ETR_RMP`"]
        pub struct ETR_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETR_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ETR_RMP_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "TIM2x ETR input connected to GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut W {
                self.variant(ETR_RMP_A::GPIO)
            }
            #[doc = "TIM2x ETR input connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(ETR_RMP_A::COMP2_OUT)
            }
            #[doc = "TIM2x ETR input connected to COMP1_OUT"]
            #[inline(always)]
            pub fn comp1_out(self) -> &'a mut W {
                self.variant(ETR_RMP_A::COMP1_OUT)
            }
            #[doc = "TIM2x ETR input connected to LSE clock"]
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(ETR_RMP_A::LSE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Timer22 TI1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TI1_RMP_A {
            #[doc = "0: TIM2x TI1 input connected to GPIO"]
            GPIO = 0,
            #[doc = "1: TIM2x TI1 input connected to COMP2_OUT"]
            COMP2_OUT = 1,
            #[doc = "2: TIM2x TI1 input connected to COMP1_OUT"]
            COMP1_OUT = 2,
        }
        impl From<TI1_RMP_A> for u8 {
            #[inline(always)]
            fn from(variant: TI1_RMP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `TI1_RMP`"]
        pub type TI1_RMP_R = crate::R<u8, TI1_RMP_A>;
        impl TI1_RMP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TI1_RMP_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TI1_RMP_A::GPIO),
                    1 => Val(TI1_RMP_A::COMP2_OUT),
                    2 => Val(TI1_RMP_A::COMP1_OUT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `GPIO`"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == TI1_RMP_A::GPIO
            }
            #[doc = "Checks if the value of the field is `COMP2_OUT`"]
            #[inline(always)]
            pub fn is_comp2_out(&self) -> bool {
                *self == TI1_RMP_A::COMP2_OUT
            }
            #[doc = "Checks if the value of the field is `COMP1_OUT`"]
            #[inline(always)]
            pub fn is_comp1_out(&self) -> bool {
                *self == TI1_RMP_A::COMP1_OUT
            }
        }
        #[doc = "Write proxy for field `TI1_RMP`"]
        pub struct TI1_RMP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1_RMP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TI1_RMP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "TIM2x TI1 input connected to GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut W {
                self.variant(TI1_RMP_A::GPIO)
            }
            #[doc = "TIM2x TI1 input connected to COMP2_OUT"]
            #[inline(always)]
            pub fn comp2_out(self) -> &'a mut W {
                self.variant(TI1_RMP_A::COMP2_OUT)
            }
            #[doc = "TIM2x TI1 input connected to COMP1_OUT"]
            #[inline(always)]
            pub fn comp1_out(self) -> &'a mut W {
                self.variant(TI1_RMP_A::COMP1_OUT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Timer22 ETR remap"]
            #[inline(always)]
            pub fn etr_rmp(&self) -> ETR_RMP_R {
                ETR_RMP_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - Timer22 TI1"]
            #[inline(always)]
            pub fn ti1_rmp(&self) -> TI1_RMP_R {
                TI1_RMP_R::new(((self.bits >> 2) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Timer22 ETR remap"]
            #[inline(always)]
            pub fn etr_rmp(&mut self) -> ETR_RMP_W {
                ETR_RMP_W { w: self }
            }
            #[doc = "Bits 2:3 - Timer22 TI1"]
            #[inline(always)]
            pub fn ti1_rmp(&mut self) -> TI1_RMP_W {
                TI1_RMP_W { w: self }
            }
        }
    }
}
#[doc = "Lower power Universal asynchronous receiver transmitter"]
pub struct LPUART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LPUART1 {}
impl LPUART1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lpuart1::RegisterBlock {
        0x4000_4800 as *const _
    }
}
impl Deref for LPUART1 {
    type Target = lpuart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*LPUART1::ptr() }
    }
}
#[doc = "Lower power Universal asynchronous receiver transmitter"]
pub mod lpuart1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - Control register 3"]
        pub cr3: CR3,
        #[doc = "0x0c - Baud rate register"]
        pub brr: BRR,
        _reserved4: [u8; 8usize],
        #[doc = "0x18 - Request register"]
        pub rqr: RQR,
        #[doc = "0x1c - Interrupt & status register"]
        pub isr: ISR,
        #[doc = "0x20 - Interrupt flag clear register"]
        pub icr: ICR,
        #[doc = "0x24 - Receive data register"]
        pub rdr: RDR,
        #[doc = "0x28 - Transmit data register"]
        pub tdr: TDR,
    }
    #[doc = "Control register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr1](cr1) module"]
    pub type CR1 = crate::Reg<u32, _CR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR1;
    #[doc = "`read()` method returns [cr1::R](cr1::R) reader structure"]
    impl crate::Readable for CR1 {}
    #[doc = "`write(|w| ..)` method takes [cr1::W](cr1::W) writer structure"]
    impl crate::Writable for CR1 {}
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = "Reader of register CR1"]
        pub type R = crate::R<u32, super::CR1>;
        #[doc = "Writer for register CR1"]
        pub type W = crate::W<u32, super::CR1>;
        #[doc = "Register CR1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Word length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M1_A {
            #[doc = "0: Use M0 to set the data bits"]
            M0 = 0,
            #[doc = "1: 1 start bit, 7 data bits, n stop bits"]
            BIT7 = 1,
        }
        impl From<M1_A> for bool {
            #[inline(always)]
            fn from(variant: M1_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `M1`"]
        pub type M1_R = crate::R<bool, M1_A>;
        impl M1_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> M1_A {
                match self.bits {
                    false => M1_A::M0,
                    true => M1_A::BIT7,
                }
            }
            #[doc = "Checks if the value of the field is `M0`"]
            #[inline(always)]
            pub fn is_m0(&self) -> bool {
                *self == M1_A::M0
            }
            #[doc = "Checks if the value of the field is `BIT7`"]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == M1_A::BIT7
            }
        }
        #[doc = "Write proxy for field `M1`"]
        pub struct M1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: M1_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Use M0 to set the data bits"]
            #[inline(always)]
            pub fn m0(self) -> &'a mut W {
                self.variant(M1_A::M0)
            }
            #[doc = "1 start bit, 7 data bits, n stop bits"]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut W {
                self.variant(M1_A::BIT7)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Character match interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated when the CMF bit is set in the ISR register"]
            ENABLED = 1,
        }
        impl From<CMIE_A> for bool {
            #[inline(always)]
            fn from(variant: CMIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CMIE`"]
        pub type CMIE_R = crate::R<bool, CMIE_A>;
        impl CMIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CMIE_A {
                match self.bits {
                    false => CMIE_A::DISABLED,
                    true => CMIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CMIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CMIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CMIE`"]
        pub struct CMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CMIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated when the CMF bit is set in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CMIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Mute mode enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MME_A {
            #[doc = "0: Receiver in active mode permanently"]
            DISABLED = 0,
            #[doc = "1: Receiver can switch between mute mode and active mode"]
            ENABLED = 1,
        }
        impl From<MME_A> for bool {
            #[inline(always)]
            fn from(variant: MME_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MME`"]
        pub type MME_R = crate::R<bool, MME_A>;
        impl MME_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MME_A {
                match self.bits {
                    false => MME_A::DISABLED,
                    true => MME_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MME_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MME_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `MME`"]
        pub struct MME_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MME_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MME_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver in active mode permanently"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MME_A::DISABLED)
            }
            #[doc = "Receiver can switch between mute mode and active mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MME_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Word length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M0_A {
            #[doc = "0: 1 start bit, 8 data bits, n stop bits"]
            BIT8 = 0,
            #[doc = "1: 1 start bit, 9 data bits, n stop bits"]
            BIT9 = 1,
        }
        impl From<M0_A> for bool {
            #[inline(always)]
            fn from(variant: M0_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `M0`"]
        pub type M0_R = crate::R<bool, M0_A>;
        impl M0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> M0_A {
                match self.bits {
                    false => M0_A::BIT8,
                    true => M0_A::BIT9,
                }
            }
            #[doc = "Checks if the value of the field is `BIT8`"]
            #[inline(always)]
            pub fn is_bit8(&self) -> bool {
                *self == M0_A::BIT8
            }
            #[doc = "Checks if the value of the field is `BIT9`"]
            #[inline(always)]
            pub fn is_bit9(&self) -> bool {
                *self == M0_A::BIT9
            }
        }
        #[doc = "Write proxy for field `M0`"]
        pub struct M0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: M0_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "1 start bit, 8 data bits, n stop bits"]
            #[inline(always)]
            pub fn bit8(self) -> &'a mut W {
                self.variant(M0_A::BIT8)
            }
            #[doc = "1 start bit, 9 data bits, n stop bits"]
            #[inline(always)]
            pub fn bit9(self) -> &'a mut W {
                self.variant(M0_A::BIT9)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Receiver wakeup method\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKE_A {
            #[doc = "0: Idle line"]
            IDLE = 0,
            #[doc = "1: Address mask"]
            ADDRESS = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WAKE`"]
        pub type WAKE_R = crate::R<bool, WAKE_A>;
        impl WAKE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IDLE,
                    true => WAKE_A::ADDRESS,
                }
            }
            #[doc = "Checks if the value of the field is `IDLE`"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == WAKE_A::IDLE
            }
            #[doc = "Checks if the value of the field is `ADDRESS`"]
            #[inline(always)]
            pub fn is_address(&self) -> bool {
                *self == WAKE_A::ADDRESS
            }
        }
        #[doc = "Write proxy for field `WAKE`"]
        pub struct WAKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAKE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAKE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Idle line"]
            #[inline(always)]
            pub fn idle(self) -> &'a mut W {
                self.variant(WAKE_A::IDLE)
            }
            #[doc = "Address mask"]
            #[inline(always)]
            pub fn address(self) -> &'a mut W {
                self.variant(WAKE_A::ADDRESS)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Parity control enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PCE_A {
            #[doc = "0: Parity control disabled"]
            DISABLED = 0,
            #[doc = "1: Parity control enabled"]
            ENABLED = 1,
        }
        impl From<PCE_A> for bool {
            #[inline(always)]
            fn from(variant: PCE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PCE`"]
        pub type PCE_R = crate::R<bool, PCE_A>;
        impl PCE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PCE_A {
                match self.bits {
                    false => PCE_A::DISABLED,
                    true => PCE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PCE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PCE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PCE`"]
        pub struct PCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PCE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Parity control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PCE_A::DISABLED)
            }
            #[doc = "Parity control enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PCE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Parity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PS_A {
            #[doc = "0: Even parity"]
            EVEN = 0,
            #[doc = "1: Odd parity"]
            ODD = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PS`"]
        pub type PS_R = crate::R<bool, PS_A>;
        impl PS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::EVEN,
                    true => PS_A::ODD,
                }
            }
            #[doc = "Checks if the value of the field is `EVEN`"]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == PS_A::EVEN
            }
            #[doc = "Checks if the value of the field is `ODD`"]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == PS_A::ODD
            }
        }
        #[doc = "Write proxy for field `PS`"]
        pub struct PS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Even parity"]
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::EVEN)
            }
            #[doc = "Odd parity"]
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::ODD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "PE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever PE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<PEIE_A> for bool {
            #[inline(always)]
            fn from(variant: PEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `PEIE`"]
        pub type PEIE_R = crate::R<bool, PEIE_A>;
        impl PEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PEIE_A {
                match self.bits {
                    false => PEIE_A::DISABLED,
                    true => PEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `PEIE`"]
        pub struct PEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever PE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever TXE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXEIE`"]
        pub type TXEIE_R = crate::R<bool, TXEIE_A>;
        impl TXEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::DISABLED,
                    true => TXEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TXEIE`"]
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever TXE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Transmission complete interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever TC=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TCIE`"]
        pub type TCIE_R = crate::R<bool, TCIE_A>;
        impl TCIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TCIE`"]
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever TC=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "RXNE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXNEIE`"]
        pub type RXNEIE_R = crate::R<bool, RXNEIE_A>;
        impl RXNEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::DISABLED,
                    true => RXNEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXNEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXNEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RXNEIE`"]
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "IDLE interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLEIE_A {
            #[doc = "0: Interrupt is disabled"]
            DISABLED = 0,
            #[doc = "1: Interrupt is generated whenever IDLE=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `IDLEIE`"]
        pub type IDLEIE_R = crate::R<bool, IDLEIE_A>;
        impl IDLEIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::DISABLED,
                    true => IDLEIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IDLEIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IDLEIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `IDLEIE`"]
        pub struct IDLEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLEIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLEIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::DISABLED)
            }
            #[doc = "Interrupt is generated whenever IDLE=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Transmitter enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TE_A {
            #[doc = "0: Transmitter is disabled"]
            DISABLED = 0,
            #[doc = "1: Transmitter is enabled"]
            ENABLED = 1,
        }
        impl From<TE_A> for bool {
            #[inline(always)]
            fn from(variant: TE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TE`"]
        pub type TE_R = crate::R<bool, TE_A>;
        impl TE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TE_A {
                match self.bits {
                    false => TE_A::DISABLED,
                    true => TE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `TE`"]
        pub struct TE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Transmitter is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TE_A::DISABLED)
            }
            #[doc = "Transmitter is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Receiver enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RE_A {
            #[doc = "0: Receiver is disabled"]
            DISABLED = 0,
            #[doc = "1: Receiver is enabled"]
            ENABLED = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RE`"]
        pub type RE_R = crate::R<bool, RE_A>;
        impl RE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::DISABLED,
                    true => RE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RE`"]
        pub struct RE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Receiver is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::DISABLED)
            }
            #[doc = "Receiver is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "USART enable in Stop mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UESM_A {
            #[doc = "0: USART not able to wake up the MCU from Stop mode"]
            DISABLED = 0,
            #[doc = "1: USART able to wake up the MCU from Stop mode"]
            ENABLED = 1,
        }
        impl From<UESM_A> for bool {
            #[inline(always)]
            fn from(variant: UESM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UESM`"]
        pub type UESM_R = crate::R<bool, UESM_A>;
        impl UESM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UESM_A {
                match self.bits {
                    false => UESM_A::DISABLED,
                    true => UESM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UESM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UESM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UESM`"]
        pub struct UESM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UESM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UESM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "USART not able to wake up the MCU from Stop mode"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UESM_A::DISABLED)
            }
            #[doc = "USART able to wake up the MCU from Stop mode"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UESM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "USART enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UE_A {
            #[doc = "0: UART is disabled"]
            DISABLED = 0,
            #[doc = "1: UART is enabled"]
            ENABLED = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `UE`"]
        pub type UE_R = crate::R<bool, UE_A>;
        impl UE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::DISABLED,
                    true => UE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `UE`"]
        pub struct UE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "UART is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::DISABLED)
            }
            #[doc = "UART is enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `DEAT`"]
        pub type DEAT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DEAT`"]
        pub struct DEAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEAT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 21)) | (((value as u32) & 0x1f) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `DEDT`"]
        pub type DEDT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `DEDT`"]
        pub struct DEDT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEDT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 16)) | (((value as u32) & 0x1f) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 28 - Word length"]
            #[inline(always)]
            pub fn m1(&self) -> M1_R {
                M1_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Character match interrupt enable"]
            #[inline(always)]
            pub fn cmie(&self) -> CMIE_R {
                CMIE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Mute mode enable"]
            #[inline(always)]
            pub fn mme(&self) -> MME_R {
                MME_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m0(&self) -> M0_R {
                M0_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Receiver wakeup method"]
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - interrupt enable"]
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - USART enable in Stop mode"]
            #[inline(always)]
            pub fn uesm(&self) -> UESM_R {
                UESM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - USART enable"]
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 21:25 - Driver Enable assertion time"]
            #[inline(always)]
            pub fn deat(&self) -> DEAT_R {
                DEAT_R::new(((self.bits >> 21) & 0x1f) as u8)
            }
            #[doc = "Bits 16:20 - Driver Enable de-assertion time"]
            #[inline(always)]
            pub fn dedt(&self) -> DEDT_R {
                DEDT_R::new(((self.bits >> 16) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 28 - Word length"]
            #[inline(always)]
            pub fn m1(&mut self) -> M1_W {
                M1_W { w: self }
            }
            #[doc = "Bit 14 - Character match interrupt enable"]
            #[inline(always)]
            pub fn cmie(&mut self) -> CMIE_W {
                CMIE_W { w: self }
            }
            #[doc = "Bit 13 - Mute mode enable"]
            #[inline(always)]
            pub fn mme(&mut self) -> MME_W {
                MME_W { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline(always)]
            pub fn m0(&mut self) -> M0_W {
                M0_W { w: self }
            }
            #[doc = "Bit 11 - Receiver wakeup method"]
            #[inline(always)]
            pub fn wake(&mut self) -> WAKE_W {
                WAKE_W { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline(always)]
            pub fn pce(&mut self) -> PCE_W {
                PCE_W { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W {
                PS_W { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline(always)]
            pub fn peie(&mut self) -> PEIE_W {
                PEIE_W { w: self }
            }
            #[doc = "Bit 7 - interrupt enable"]
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline(always)]
            pub fn idleie(&mut self) -> IDLEIE_W {
                IDLEIE_W { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline(always)]
            pub fn te(&mut self) -> TE_W {
                TE_W { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline(always)]
            pub fn re(&mut self) -> RE_W {
                RE_W { w: self }
            }
            #[doc = "Bit 1 - USART enable in Stop mode"]
            #[inline(always)]
            pub fn uesm(&mut self) -> UESM_W {
                UESM_W { w: self }
            }
            #[doc = "Bit 0 - USART enable"]
            #[inline(always)]
            pub fn ue(&mut self) -> UE_W {
                UE_W { w: self }
            }
            #[doc = "Bits 21:25 - Driver Enable assertion time"]
            #[inline(always)]
            pub fn deat(&mut self) -> DEAT_W {
                DEAT_W { w: self }
            }
            #[doc = "Bits 16:20 - Driver Enable de-assertion time"]
            #[inline(always)]
            pub fn dedt(&mut self) -> DEDT_W {
                DEDT_W { w: self }
            }
        }
    }
    #[doc = "Control register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr2](cr2) module"]
    pub type CR2 = crate::Reg<u32, _CR2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR2;
    #[doc = "`read()` method returns [cr2::R](cr2::R) reader structure"]
    impl crate::Readable for CR2 {}
    #[doc = "`write(|w| ..)` method takes [cr2::W](cr2::W) writer structure"]
    impl crate::Writable for CR2 {}
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = "Reader of register CR2"]
        pub type R = crate::R<u32, super::CR2>;
        #[doc = "Writer for register CR2"]
        pub type W = crate::W<u32, super::CR2>;
        #[doc = "Register CR2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Most significant bit first\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSBFIRST_A {
            #[doc = "0: data is transmitted/received with data bit 0 first, following the start bit"]
            LSB = 0,
            #[doc = "1: data is transmitted/received with MSB (bit 7/8/9) first, following the start bit"]
            MSB = 1,
        }
        impl From<MSBFIRST_A> for bool {
            #[inline(always)]
            fn from(variant: MSBFIRST_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `MSBFIRST`"]
        pub type MSBFIRST_R = crate::R<bool, MSBFIRST_A>;
        impl MSBFIRST_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MSBFIRST_A {
                match self.bits {
                    false => MSBFIRST_A::LSB,
                    true => MSBFIRST_A::MSB,
                }
            }
            #[doc = "Checks if the value of the field is `LSB`"]
            #[inline(always)]
            pub fn is_lsb(&self) -> bool {
                *self == MSBFIRST_A::LSB
            }
            #[doc = "Checks if the value of the field is `MSB`"]
            #[inline(always)]
            pub fn is_msb(&self) -> bool {
                *self == MSBFIRST_A::MSB
            }
        }
        #[doc = "Write proxy for field `MSBFIRST`"]
        pub struct MSBFIRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSBFIRST_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSBFIRST_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "data is transmitted/received with data bit 0 first, following the start bit"]
            #[inline(always)]
            pub fn lsb(self) -> &'a mut W {
                self.variant(MSBFIRST_A::LSB)
            }
            #[doc = "data is transmitted/received with MSB (bit 7/8/9) first, following the start bit"]
            #[inline(always)]
            pub fn msb(self) -> &'a mut W {
                self.variant(MSBFIRST_A::MSB)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Binary data inversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATAINV_A {
            #[doc = "0: Logical data from the data register are send/received in positive/direct logic"]
            POSITIVE = 0,
            #[doc = "1: Logical data from the data register are send/received in negative/inverse logic"]
            NEGATIVE = 1,
        }
        impl From<DATAINV_A> for bool {
            #[inline(always)]
            fn from(variant: DATAINV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DATAINV`"]
        pub type DATAINV_R = crate::R<bool, DATAINV_A>;
        impl DATAINV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATAINV_A {
                match self.bits {
                    false => DATAINV_A::POSITIVE,
                    true => DATAINV_A::NEGATIVE,
                }
            }
            #[doc = "Checks if the value of the field is `POSITIVE`"]
            #[inline(always)]
            pub fn is_positive(&self) -> bool {
                *self == DATAINV_A::POSITIVE
            }
            #[doc = "Checks if the value of the field is `NEGATIVE`"]
            #[inline(always)]
            pub fn is_negative(&self) -> bool {
                *self == DATAINV_A::NEGATIVE
            }
        }
        #[doc = "Write proxy for field `DATAINV`"]
        pub struct DATAINV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATAINV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATAINV_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Logical data from the data register are send/received in positive/direct logic"]
            #[inline(always)]
            pub fn positive(self) -> &'a mut W {
                self.variant(DATAINV_A::POSITIVE)
            }
            #[doc = "Logical data from the data register are send/received in negative/inverse logic"]
            #[inline(always)]
            pub fn negative(self) -> &'a mut W {
                self.variant(DATAINV_A::NEGATIVE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "TX pin active level inversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXINV_A {
            #[doc = "0: TX pin signal works using the standard logic levels"]
            STANDARD = 0,
            #[doc = "1: TX pin signal values are inverted"]
            INVERTED = 1,
        }
        impl From<TXINV_A> for bool {
            #[inline(always)]
            fn from(variant: TXINV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `TXINV`"]
        pub type TXINV_R = crate::R<bool, TXINV_A>;
        impl TXINV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TXINV_A {
                match self.bits {
                    false => TXINV_A::STANDARD,
                    true => TXINV_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == TXINV_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == TXINV_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `TXINV`"]
        pub struct TXINV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXINV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXINV_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TX pin signal works using the standard logic levels"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(TXINV_A::STANDARD)
            }
            #[doc = "TX pin signal values are inverted"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(TXINV_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "RX pin active level inversion\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXINV_A {
            #[doc = "0: RX pin signal works using the standard logic levels"]
            STANDARD = 0,
            #[doc = "1: RX pin signal values are inverted"]
            INVERTED = 1,
        }
        impl From<RXINV_A> for bool {
            #[inline(always)]
            fn from(variant: RXINV_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RXINV`"]
        pub type RXINV_R = crate::R<bool, RXINV_A>;
        impl RXINV_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXINV_A {
                match self.bits {
                    false => RXINV_A::STANDARD,
                    true => RXINV_A::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == RXINV_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                *self == RXINV_A::INVERTED
            }
        }
        #[doc = "Write proxy for field `RXINV`"]
        pub struct RXINV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXINV_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXINV_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RX pin signal works using the standard logic levels"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(RXINV_A::STANDARD)
            }
            #[doc = "RX pin signal values are inverted"]
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(RXINV_A::INVERTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Swap TX/RX pins\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWAP_A {
            #[doc = "0: TX/RX pins are used as defined in standard pinout"]
            STANDARD = 0,
            #[doc = "1: The TX and RX pins functions are swapped"]
            SWAPPED = 1,
        }
        impl From<SWAP_A> for bool {
            #[inline(always)]
            fn from(variant: SWAP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `SWAP`"]
        pub type SWAP_R = crate::R<bool, SWAP_A>;
        impl SWAP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> SWAP_A {
                match self.bits {
                    false => SWAP_A::STANDARD,
                    true => SWAP_A::SWAPPED,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == SWAP_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `SWAPPED`"]
            #[inline(always)]
            pub fn is_swapped(&self) -> bool {
                *self == SWAP_A::SWAPPED
            }
        }
        #[doc = "Write proxy for field `SWAP`"]
        pub struct SWAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWAP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWAP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "TX/RX pins are used as defined in standard pinout"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(SWAP_A::STANDARD)
            }
            #[doc = "The TX and RX pins functions are swapped"]
            #[inline(always)]
            pub fn swapped(self) -> &'a mut W {
                self.variant(SWAP_A::SWAPPED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "STOP bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum STOP_A {
            #[doc = "0: 1 stop bit"]
            STOP1 = 0,
            #[doc = "1: 0.5 stop bit"]
            STOP0P5 = 1,
            #[doc = "2: 2 stop bit"]
            STOP2 = 2,
            #[doc = "3: 1.5 stop bit"]
            STOP1P5 = 3,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `STOP`"]
        pub type STOP_R = crate::R<u8, STOP_A>;
        impl STOP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    0 => STOP_A::STOP1,
                    1 => STOP_A::STOP0P5,
                    2 => STOP_A::STOP2,
                    3 => STOP_A::STOP1P5,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STOP1`"]
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                *self == STOP_A::STOP1
            }
            #[doc = "Checks if the value of the field is `STOP0P5`"]
            #[inline(always)]
            pub fn is_stop0p5(&self) -> bool {
                *self == STOP_A::STOP0P5
            }
            #[doc = "Checks if the value of the field is `STOP2`"]
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                *self == STOP_A::STOP2
            }
            #[doc = "Checks if the value of the field is `STOP1P5`"]
            #[inline(always)]
            pub fn is_stop1p5(&self) -> bool {
                *self == STOP_A::STOP1P5
            }
        }
        #[doc = "Write proxy for field `STOP`"]
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "1 stop bit"]
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::STOP1)
            }
            #[doc = "0.5 stop bit"]
            #[inline(always)]
            pub fn stop0p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP0P5)
            }
            #[doc = "2 stop bit"]
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::STOP2)
            }
            #[doc = "1.5 stop bit"]
            #[inline(always)]
            pub fn stop1p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP1P5)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | (((value as u32) & 0x03) << 12);
                self.w
            }
        }
        #[doc = "Clock enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKEN_A {
            #[doc = "0: CK pin disabled"]
            DISABLED = 0,
            #[doc = "1: CK pin enabled"]
            ENABLED = 1,
        }
        impl From<CLKEN_A> for bool {
            #[inline(always)]
            fn from(variant: CLKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CLKEN`"]
        pub type CLKEN_R = crate::R<bool, CLKEN_A>;
        impl CLKEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CLKEN_A {
                match self.bits {
                    false => CLKEN_A::DISABLED,
                    true => CLKEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CLKEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CLKEN_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CLKEN`"]
        pub struct CLKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKEN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CK pin disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CLKEN_A::DISABLED)
            }
            #[doc = "CK pin enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CLKEN_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "7-bit Address Detection/4-bit Address Detection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDM7_A {
            #[doc = "0: 4-bit address detection"]
            BIT4 = 0,
            #[doc = "1: 7-bit address detection"]
            BIT7 = 1,
        }
        impl From<ADDM7_A> for bool {
            #[inline(always)]
            fn from(variant: ADDM7_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `ADDM7`"]
        pub type ADDM7_R = crate::R<bool, ADDM7_A>;
        impl ADDM7_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDM7_A {
                match self.bits {
                    false => ADDM7_A::BIT4,
                    true => ADDM7_A::BIT7,
                }
            }
            #[doc = "Checks if the value of the field is `BIT4`"]
            #[inline(always)]
            pub fn is_bit4(&self) -> bool {
                *self == ADDM7_A::BIT4
            }
            #[doc = "Checks if the value of the field is `BIT7`"]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == ADDM7_A::BIT7
            }
        }
        #[doc = "Write proxy for field `ADDM7`"]
        pub struct ADDM7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDM7_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDM7_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "4-bit address detection"]
            #[inline(always)]
            pub fn bit4(self) -> &'a mut W {
                self.variant(ADDM7_A::BIT4)
            }
            #[doc = "7-bit address detection"]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut W {
                self.variant(ADDM7_A::BIT7)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `ADD`"]
        pub type ADD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ADD`"]
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 19 - Most significant bit first"]
            #[inline(always)]
            pub fn msbfirst(&self) -> MSBFIRST_R {
                MSBFIRST_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Binary data inversion"]
            #[inline(always)]
            pub fn datainv(&self) -> DATAINV_R {
                DATAINV_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - TX pin active level inversion"]
            #[inline(always)]
            pub fn txinv(&self) -> TXINV_R {
                TXINV_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - RX pin active level inversion"]
            #[inline(always)]
            pub fn rxinv(&self) -> RXINV_R {
                RXINV_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Swap TX/RX pins"]
            #[inline(always)]
            pub fn swap(&self) -> SWAP_R {
                SWAP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
            #[inline(always)]
            pub fn addm7(&self) -> ADDM7_R {
                ADDM7_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bits 24:31 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 19 - Most significant bit first"]
            #[inline(always)]
            pub fn msbfirst(&mut self) -> MSBFIRST_W {
                MSBFIRST_W { w: self }
            }
            #[doc = "Bit 18 - Binary data inversion"]
            #[inline(always)]
            pub fn datainv(&mut self) -> DATAINV_W {
                DATAINV_W { w: self }
            }
            #[doc = "Bit 17 - TX pin active level inversion"]
            #[inline(always)]
            pub fn txinv(&mut self) -> TXINV_W {
                TXINV_W { w: self }
            }
            #[doc = "Bit 16 - RX pin active level inversion"]
            #[inline(always)]
            pub fn rxinv(&mut self) -> RXINV_W {
                RXINV_W { w: self }
            }
            #[doc = "Bit 15 - Swap TX/RX pins"]
            #[inline(always)]
            pub fn swap(&mut self) -> SWAP_W {
                SWAP_W { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline(always)]
            pub fn clken(&mut self) -> CLKEN_W {
                CLKEN_W { w: self }
            }
            #[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
            #[inline(always)]
            pub fn addm7(&mut self) -> ADDM7_W {
                ADDM7_W { w: self }
            }
            #[doc = "Bits 24:31 - Address of the USART node"]
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
        }
    }
    #[doc = "Control register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr3](cr3) module"]
    pub type CR3 = crate::Reg<u32, _CR3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR3;
    #[doc = "`read()` method returns [cr3::R](cr3::R) reader structure"]
    impl crate::Readable for CR3 {}
    #[doc = "`write(|w| ..)` method takes [cr3::W](cr3::W) writer structure"]
    impl crate::Writable for CR3 {}
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = "Reader of register CR3"]
        pub type R = crate::R<u32, super::CR3>;
        #[doc = "Writer for register CR3"]
        pub type W = crate::W<u32, super::CR3>;
        #[doc = "Register CR3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Wakeup from Stop mode interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUFIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An USART interrupt is generated whenever WUF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<WUFIE_A> for bool {
            #[inline(always)]
            fn from(variant: WUFIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `WUFIE`"]
        pub type WUFIE_R = crate::R<bool, WUFIE_A>;
        impl WUFIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WUFIE_A {
                match self.bits {
                    false => WUFIE_A::DISABLED,
                    true => WUFIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WUFIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WUFIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `WUFIE`"]
        pub struct WUFIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUFIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUFIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WUFIE_A::DISABLED)
            }
            #[doc = "An USART interrupt is generated whenever WUF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WUFIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Wakeup from Stop mode interrupt flag selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WUS_A {
            #[doc = "0: WUF active on address match"]
            ADDRESS = 0,
            #[doc = "2: WuF active on Start bit detection"]
            START = 2,
            #[doc = "3: WUF active on RXNE"]
            RXNE = 3,
        }
        impl From<WUS_A> for u8 {
            #[inline(always)]
            fn from(variant: WUS_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `WUS`"]
        pub type WUS_R = crate::R<u8, WUS_A>;
        impl WUS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, WUS_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(WUS_A::ADDRESS),
                    2 => Val(WUS_A::START),
                    3 => Val(WUS_A::RXNE),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ADDRESS`"]
            #[inline(always)]
            pub fn is_address(&self) -> bool {
                *self == WUS_A::ADDRESS
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == WUS_A::START
            }
            #[doc = "Checks if the value of the field is `RXNE`"]
            #[inline(always)]
            pub fn is_rxne(&self) -> bool {
                *self == WUS_A::RXNE
            }
        }
        #[doc = "Write proxy for field `WUS`"]
        pub struct WUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "WUF active on address match"]
            #[inline(always)]
            pub fn address(self) -> &'a mut W {
                self.variant(WUS_A::ADDRESS)
            }
            #[doc = "WuF active on Start bit detection"]
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(WUS_A::START)
            }
            #[doc = "WUF active on RXNE"]
            #[inline(always)]
            pub fn rxne(self) -> &'a mut W {
                self.variant(WUS_A::RXNE)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | (((value as u32) & 0x03) << 20);
                self.w
            }
        }
        #[doc = "Driver enable polarity selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEP_A {
            #[doc = "0: DE signal is active high"]
            HIGH = 0,
            #[doc = "1: DE signal is active low"]
            LOW = 1,
        }
        impl From<DEP_A> for bool {
            #[inline(always)]
            fn from(variant: DEP_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DEP`"]
        pub type DEP_R = crate::R<bool, DEP_A>;
        impl DEP_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DEP_A {
                match self.bits {
                    false => DEP_A::HIGH,
                    true => DEP_A::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == DEP_A::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == DEP_A::LOW
            }
        }
        #[doc = "Write proxy for field `DEP`"]
        pub struct DEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEP_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DEP_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DE signal is active high"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(DEP_A::HIGH)
            }
            #[doc = "DE signal is active low"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(DEP_A::LOW)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Driver enable mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEM_A {
            #[doc = "0: DE function is disabled"]
            DISABLED = 0,
            #[doc = "1: The DE signal is output on the RTS pin"]
            ENABLED = 1,
        }
        impl From<DEM_A> for bool {
            #[inline(always)]
            fn from(variant: DEM_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DEM`"]
        pub type DEM_R = crate::R<bool, DEM_A>;
        impl DEM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DEM_A {
                match self.bits {
                    false => DEM_A::DISABLED,
                    true => DEM_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DEM_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DEM_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DEM`"]
        pub struct DEM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DEM_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DE function is disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DEM_A::DISABLED)
            }
            #[doc = "The DE signal is output on the RTS pin"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DEM_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "DMA Disable on Reception Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DDRE_A {
            #[doc = "0: DMA is not disabled in case of reception error"]
            NOTDISABLED = 0,
            #[doc = "1: DMA is disabled following a reception error"]
            DISABLED = 1,
        }
        impl From<DDRE_A> for bool {
            #[inline(always)]
            fn from(variant: DDRE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DDRE`"]
        pub type DDRE_R = crate::R<bool, DDRE_A>;
        impl DDRE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DDRE_A {
                match self.bits {
                    false => DDRE_A::NOTDISABLED,
                    true => DDRE_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDISABLED`"]
            #[inline(always)]
            pub fn is_not_disabled(&self) -> bool {
                *self == DDRE_A::NOTDISABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DDRE_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `DDRE`"]
        pub struct DDRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DDRE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DDRE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA is not disabled in case of reception error"]
            #[inline(always)]
            pub fn not_disabled(self) -> &'a mut W {
                self.variant(DDRE_A::NOTDISABLED)
            }
            #[doc = "DMA is disabled following a reception error"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DDRE_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Overrun Disable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRDIS_A {
            #[doc = "0: Overrun Error Flag, ORE, is set when received data is not read before receiving new data"]
            ENABLED = 0,
            #[doc = "1: Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register"]
            DISABLED = 1,
        }
        impl From<OVRDIS_A> for bool {
            #[inline(always)]
            fn from(variant: OVRDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `OVRDIS`"]
        pub type OVRDIS_R = crate::R<bool, OVRDIS_A>;
        impl OVRDIS_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> OVRDIS_A {
                match self.bits {
                    false => OVRDIS_A::ENABLED,
                    true => OVRDIS_A::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OVRDIS_A::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OVRDIS_A::DISABLED
            }
        }
        #[doc = "Write proxy for field `OVRDIS`"]
        pub struct OVRDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVRDIS_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OVRDIS_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Overrun Error Flag, ORE, is set when received data is not read before receiving new data"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OVRDIS_A::ENABLED)
            }
            #[doc = "Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OVRDIS_A::DISABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "CTS interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An interrupt is generated whenever CTSIF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<CTSIE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CTSIE`"]
        pub type CTSIE_R = crate::R<bool, CTSIE_A>;
        impl CTSIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTSIE_A {
                match self.bits {
                    false => CTSIE_A::DISABLED,
                    true => CTSIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CTSIE`"]
        pub struct CTSIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSIE_A::DISABLED)
            }
            #[doc = "An interrupt is generated whenever CTSIF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "CTS enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSE_A {
            #[doc = "0: CTS hardware flow control disabled"]
            DISABLED = 0,
            #[doc = "1: CTS mode enabled, data is only transmitted when the CTS input is asserted"]
            ENABLED = 1,
        }
        impl From<CTSE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `CTSE`"]
        pub type CTSE_R = crate::R<bool, CTSE_A>;
        impl CTSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTSE_A {
                match self.bits {
                    false => CTSE_A::DISABLED,
                    true => CTSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `CTSE`"]
        pub struct CTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "CTS hardware flow control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSE_A::DISABLED)
            }
            #[doc = "CTS mode enabled, data is only transmitted when the CTS input is asserted"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "RTS enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTSE_A {
            #[doc = "0: RTS hardware flow control disabled"]
            DISABLED = 0,
            #[doc = "1: RTS output enabled, data is only requested when there is space in the receive buffer"]
            ENABLED = 1,
        }
        impl From<RTSE_A> for bool {
            #[inline(always)]
            fn from(variant: RTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `RTSE`"]
        pub type RTSE_R = crate::R<bool, RTSE_A>;
        impl RTSE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTSE_A {
                match self.bits {
                    false => RTSE_A::DISABLED,
                    true => RTSE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTSE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTSE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `RTSE`"]
        pub struct RTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTSE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RTSE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RTS hardware flow control disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTSE_A::DISABLED)
            }
            #[doc = "RTS output enabled, data is only requested when there is space in the receive buffer"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTSE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "DMA enable transmitter\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAT_A {
            #[doc = "0: DMA mode is disabled for transmission"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for transmission"]
            ENABLED = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAT`"]
        pub type DMAT_R = crate::R<bool, DMAT_A>;
        impl DMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::DISABLED,
                    true => DMAT_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAT_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAT_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAT`"]
        pub struct DMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAT_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for transmission"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for transmission"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "DMA enable receiver\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR_A {
            #[doc = "0: DMA mode is disabled for reception"]
            DISABLED = 0,
            #[doc = "1: DMA mode is enabled for reception"]
            ENABLED = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `DMAR`"]
        pub type DMAR_R = crate::R<bool, DMAR_A>;
        impl DMAR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::DISABLED,
                    true => DMAR_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAR_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAR_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `DMAR`"]
        pub struct DMAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMAR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "DMA mode is disabled for reception"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::DISABLED)
            }
            #[doc = "DMA mode is enabled for reception"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Half-duplex selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HDSEL_A {
            #[doc = "0: Half duplex mode is not selected"]
            NOTSELECTED = 0,
            #[doc = "1: Half duplex mode is selected"]
            SELECTED = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `HDSEL`"]
        pub type HDSEL_R = crate::R<bool, HDSEL_A>;
        impl HDSEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::NOTSELECTED,
                    true => HDSEL_A::SELECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSELECTED`"]
            #[inline(always)]
            pub fn is_not_selected(&self) -> bool {
                *self == HDSEL_A::NOTSELECTED
            }
            #[doc = "Checks if the value of the field is `SELECTED`"]
            #[inline(always)]
            pub fn is_selected(&self) -> bool {
                *self == HDSEL_A::SELECTED
            }
        }
        #[doc = "Write proxy for field `HDSEL`"]
        pub struct HDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HDSEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HDSEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Half duplex mode is not selected"]
            #[inline(always)]
            pub fn not_selected(self) -> &'a mut W {
                self.variant(HDSEL_A::NOTSELECTED)
            }
            #[doc = "Half duplex mode is selected"]
            #[inline(always)]
            pub fn selected(self) -> &'a mut W {
                self.variant(HDSEL_A::SELECTED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Error interrupt enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EIE_A {
            #[doc = "0: Interrupt is inhibited"]
            DISABLED = 0,
            #[doc = "1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register"]
            ENABLED = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `EIE`"]
        pub type EIE_R = crate::R<bool, EIE_A>;
        impl EIE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::DISABLED,
                    true => EIE_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EIE_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EIE_A::ENABLED
            }
        }
        #[doc = "Write proxy for field `EIE`"]
        pub struct EIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EIE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Interrupt is inhibited"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::DISABLED)
            }
            #[doc = "An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::ENABLED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
            #[inline(always)]
            pub fn wufie(&self) -> WUFIE_R {
                WUFIE_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
            #[inline(always)]
            pub fn wus(&self) -> WUS_R {
                WUS_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            #[doc = "Bit 15 - Driver enable polarity selection"]
            #[inline(always)]
            pub fn dep(&self) -> DEP_R {
                DEP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Driver enable mode"]
            #[inline(always)]
            pub fn dem(&self) -> DEM_R {
                DEM_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 13 - DMA Disable on Reception Error"]
            #[inline(always)]
            pub fn ddre(&self) -> DDRE_R {
                DDRE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Overrun Disable"]
            #[inline(always)]
            pub fn ovrdis(&self) -> OVRDIS_R {
                OVRDIS_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
            #[inline(always)]
            pub fn wufie(&mut self) -> WUFIE_W {
                WUFIE_W { w: self }
            }
            #[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
            #[inline(always)]
            pub fn wus(&mut self) -> WUS_W {
                WUS_W { w: self }
            }
            #[doc = "Bit 15 - Driver enable polarity selection"]
            #[inline(always)]
            pub fn dep(&mut self) -> DEP_W {
                DEP_W { w: self }
            }
            #[doc = "Bit 14 - Driver enable mode"]
            #[inline(always)]
            pub fn dem(&mut self) -> DEM_W {
                DEM_W { w: self }
            }
            #[doc = "Bit 13 - DMA Disable on Reception Error"]
            #[inline(always)]
            pub fn ddre(&mut self) -> DDRE_W {
                DDRE_W { w: self }
            }
            #[doc = "Bit 12 - Overrun Disable"]
            #[inline(always)]
            pub fn ovrdis(&mut self) -> OVRDIS_W {
                OVRDIS_W { w: self }
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline(always)]
            pub fn ctsie(&mut self) -> CTSIE_W {
                CTSIE_W { w: self }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline(always)]
            pub fn ctse(&mut self) -> CTSE_W {
                CTSE_W { w: self }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline(always)]
            pub fn rtse(&mut self) -> RTSE_W {
                RTSE_W { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline(always)]
            pub fn dmat(&mut self) -> DMAT_W {
                DMAT_W { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline(always)]
            pub fn dmar(&mut self) -> DMAR_W {
                DMAR_W { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline(always)]
            pub fn hdsel(&mut self) -> HDSEL_W {
                HDSEL_W { w: self }
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline(always)]
            pub fn eie(&mut self) -> EIE_W {
                EIE_W { w: self }
            }
        }
    }
    #[doc = "Baud rate register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [brr](brr) module"]
    pub type BRR = crate::Reg<u32, _BRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BRR;
    #[doc = "`read()` method returns [brr::R](brr::R) reader structure"]
    impl crate::Readable for BRR {}
    #[doc = "`write(|w| ..)` method takes [brr::W](brr::W) writer structure"]
    impl crate::Writable for BRR {}
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = "Reader of register BRR"]
        pub type R = crate::R<u32, super::BRR>;
        #[doc = "Writer for register BRR"]
        pub type W = crate::W<u32, super::BRR>;
        #[doc = "Register BRR `reset()`'s with value 0"]
        impl crate::ResetValue for super::BRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `BRR`"]
        pub type BRR_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `BRR`"]
        pub struct BRR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BRR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x000f_ffff) | ((value as u32) & 0x000f_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:19 - BRR"]
            #[inline(always)]
            pub fn brr(&self) -> BRR_R {
                BRR_R::new((self.bits & 0x000f_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:19 - BRR"]
            #[inline(always)]
            pub fn brr(&mut self) -> BRR_W {
                BRR_W { w: self }
            }
        }
    }
    #[doc = "Request register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rqr](rqr) module"]
    pub type RQR = crate::Reg<u32, _RQR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RQR;
    #[doc = "`write(|w| ..)` method takes [rqr::W](rqr::W) writer structure"]
    impl crate::Writable for RQR {}
    #[doc = "Request register"]
    pub mod rqr {
        #[doc = "Writer for register RQR"]
        pub type W = crate::W<u32, super::RQR>;
        #[doc = "Register RQR `reset()`'s with value 0"]
        impl crate::ResetValue for super::RQR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Receive data flush request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXFRQ_AW {
            #[doc = "1: clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition"]
            DISCARD = 1,
        }
        impl From<RXFRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: RXFRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `RXFRQ`"]
        pub struct RXFRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXFRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXFRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition"]
            #[inline(always)]
            pub fn discard(self) -> &'a mut W {
                self.variant(RXFRQ_AW::DISCARD)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Mute mode request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MMRQ_AW {
            #[doc = "1: Puts the USART in mute mode and sets the RWU flag"]
            MUTE = 1,
        }
        impl From<MMRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: MMRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `MMRQ`"]
        pub struct MMRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MMRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Puts the USART in mute mode and sets the RWU flag"]
            #[inline(always)]
            pub fn mute(self) -> &'a mut W {
                self.variant(MMRQ_AW::MUTE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Send break request\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBKRQ_AW {
            #[doc = "1: sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available"]
            BREAK = 1,
        }
        impl From<SBKRQ_AW> for bool {
            #[inline(always)]
            fn from(variant: SBKRQ_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `SBKRQ`"]
        pub struct SBKRQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBKRQ_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SBKRQ_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available"]
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBKRQ_AW::BREAK)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 3 - Receive data flush request"]
            #[inline(always)]
            pub fn rxfrq(&mut self) -> RXFRQ_W {
                RXFRQ_W { w: self }
            }
            #[doc = "Bit 2 - Mute mode request"]
            #[inline(always)]
            pub fn mmrq(&mut self) -> MMRQ_W {
                MMRQ_W { w: self }
            }
            #[doc = "Bit 1 - Send break request"]
            #[inline(always)]
            pub fn sbkrq(&mut self) -> SBKRQ_W {
                SBKRQ_W { w: self }
            }
        }
    }
    #[doc = "Interrupt & status register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "Interrupt & status register"]
    pub mod isr {
        #[doc = "Reader of register ISR"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Reader of field `REACK`"]
        pub type REACK_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TEACK`"]
        pub type TEACK_R = crate::R<bool, bool>;
        #[doc = "Reader of field `WUF`"]
        pub type WUF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RWU`"]
        pub type RWU_R = crate::R<bool, bool>;
        #[doc = "Reader of field `SBKF`"]
        pub type SBKF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `CMF`"]
        pub type CMF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `BUSY`"]
        pub type BUSY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `CTS`"]
        pub type CTS_R = crate::R<bool, bool>;
        #[doc = "Reader of field `CTSIF`"]
        pub type CTSIF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TXE`"]
        pub type TXE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `TC`"]
        pub type TC_R = crate::R<bool, bool>;
        #[doc = "Reader of field `RXNE`"]
        pub type RXNE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `IDLE`"]
        pub type IDLE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `ORE`"]
        pub type ORE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `NF`"]
        pub type NF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `FE`"]
        pub type FE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `PE`"]
        pub type PE_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 22 - REACK"]
            #[inline(always)]
            pub fn reack(&self) -> REACK_R {
                REACK_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 21 - TEACK"]
            #[inline(always)]
            pub fn teack(&self) -> TEACK_R {
                TEACK_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 20 - WUF"]
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 19 - RWU"]
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 18 - SBKF"]
            #[inline(always)]
            pub fn sbkf(&self) -> SBKF_R {
                SBKF_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 17 - CMF"]
            #[inline(always)]
            pub fn cmf(&self) -> CMF_R {
                CMF_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 16 - BUSY"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 10 - CTS"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 9 - CTSIF"]
            #[inline(always)]
            pub fn ctsif(&self) -> CTSIF_R {
                CTSIF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 7 - TXE"]
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 6 - TC"]
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RXNE"]
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 4 - IDLE"]
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 3 - ORE"]
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 2 - NF"]
            #[inline(always)]
            pub fn nf(&self) -> NF_R {
                NF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 1 - FE"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - PE"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Interrupt flag clear register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
    pub type ICR = crate::Reg<u32, _ICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICR;
    #[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
    impl crate::Writable for ICR {}
    #[doc = "Interrupt flag clear register"]
    pub mod icr {
        #[doc = "Writer for register ICR"]
        pub type W = crate::W<u32, super::ICR>;
        #[doc = "Register ICR `reset()`'s with value 0"]
        impl crate::ResetValue for super::ICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Wakeup from Stop mode clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WUCF_AW {
            #[doc = "1: Clears the WUF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<WUCF_AW> for bool {
            #[inline(always)]
            fn from(variant: WUCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `WUCF`"]
        pub struct WUCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WUCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WUCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the WUF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(WUCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Character match clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CMCF_AW {
            #[doc = "1: Clears the CMF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CMCF_AW> for bool {
            #[inline(always)]
            fn from(variant: CMCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CMCF`"]
        pub struct CMCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CMCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the CMF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CMCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "CTS clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSCF_AW {
            #[doc = "1: Clears the CTSIF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<CTSCF_AW> for bool {
            #[inline(always)]
            fn from(variant: CTSCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `CTSCF`"]
        pub struct CTSCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the CTSIF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTSCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Transmission complete clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCCF_AW {
            #[doc = "1: Clears the TC flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<TCCF_AW> for bool {
            #[inline(always)]
            fn from(variant: TCCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `TCCF`"]
        pub struct TCCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TCCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the TC flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TCCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Idle line detected clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLECF_AW {
            #[doc = "1: Clears the IDLE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<IDLECF_AW> for bool {
            #[inline(always)]
            fn from(variant: IDLECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `IDLECF`"]
        pub struct IDLECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IDLECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the IDLE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(IDLECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Overrun error clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ORECF_AW {
            #[doc = "1: Clears the ORE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<ORECF_AW> for bool {
            #[inline(always)]
            fn from(variant: ORECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `ORECF`"]
        pub struct ORECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ORECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ORECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the ORE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ORECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Noise detected clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NCF_AW {
            #[doc = "1: Clears the NF flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<NCF_AW> for bool {
            #[inline(always)]
            fn from(variant: NCF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `NCF`"]
        pub struct NCF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NCF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: NCF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the NF flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(NCF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Framing error clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FECF_AW {
            #[doc = "1: Clears the FE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<FECF_AW> for bool {
            #[inline(always)]
            fn from(variant: FECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `FECF`"]
        pub struct FECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the FE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(FECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Parity error clear flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECF_AW {
            #[doc = "1: Clears the PE flag in the ISR register"]
            CLEAR = 1,
        }
        impl From<PECF_AW> for bool {
            #[inline(always)]
            fn from(variant: PECF_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Write proxy for field `PECF`"]
        pub struct PECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECF_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PECF_AW) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Clears the PE flag in the ISR register"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PECF_AW::CLEAR)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl W {
            #[doc = "Bit 20 - Wakeup from Stop mode clear flag"]
            #[inline(always)]
            pub fn wucf(&mut self) -> WUCF_W {
                WUCF_W { w: self }
            }
            #[doc = "Bit 17 - Character match clear flag"]
            #[inline(always)]
            pub fn cmcf(&mut self) -> CMCF_W {
                CMCF_W { w: self }
            }
            #[doc = "Bit 9 - CTS clear flag"]
            #[inline(always)]
            pub fn ctscf(&mut self) -> CTSCF_W {
                CTSCF_W { w: self }
            }
            #[doc = "Bit 6 - Transmission complete clear flag"]
            #[inline(always)]
            pub fn tccf(&mut self) -> TCCF_W {
                TCCF_W { w: self }
            }
            #[doc = "Bit 4 - Idle line detected clear flag"]
            #[inline(always)]
            pub fn idlecf(&mut self) -> IDLECF_W {
                IDLECF_W { w: self }
            }
            #[doc = "Bit 3 - Overrun error clear flag"]
            #[inline(always)]
            pub fn orecf(&mut self) -> ORECF_W {
                ORECF_W { w: self }
            }
            #[doc = "Bit 2 - Noise detected clear flag"]
            #[inline(always)]
            pub fn ncf(&mut self) -> NCF_W {
                NCF_W { w: self }
            }
            #[doc = "Bit 1 - Framing error clear flag"]
            #[inline(always)]
            pub fn fecf(&mut self) -> FECF_W {
                FECF_W { w: self }
            }
            #[doc = "Bit 0 - Parity error clear flag"]
            #[inline(always)]
            pub fn pecf(&mut self) -> PECF_W {
                PECF_W { w: self }
            }
        }
    }
    #[doc = "Receive data register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rdr](rdr) module"]
    pub type RDR = crate::Reg<u32, _RDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RDR;
    #[doc = "`read()` method returns [rdr::R](rdr::R) reader structure"]
    impl crate::Readable for RDR {}
    #[doc = "Receive data register"]
    pub mod rdr {
        #[doc = "Reader of register RDR"]
        pub type R = crate::R<u32, super::RDR>;
        #[doc = "Reader of field `RDR`"]
        pub type RDR_R = crate::R<u16, u16>;
        impl R {
            #[doc = "Bits 0:8 - Receive data value"]
            #[inline(always)]
            pub fn rdr(&self) -> RDR_R {
                RDR_R::new((self.bits & 0x01ff) as u16)
            }
        }
    }
    #[doc = "Transmit data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tdr](tdr) module"]
    pub type TDR = crate::Reg<u32, _TDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TDR;
    #[doc = "`read()` method returns [tdr::R](tdr::R) reader structure"]
    impl crate::Readable for TDR {}
    #[doc = "`write(|w| ..)` method takes [tdr::W](tdr::W) writer structure"]
    impl crate::Writable for TDR {}
    #[doc = "Transmit data register"]
    pub mod tdr {
        #[doc = "Reader of register TDR"]
        pub type R = crate::R<u32, super::TDR>;
        #[doc = "Writer for register TDR"]
        pub type W = crate::W<u32, super::TDR>;
        #[doc = "Register TDR `reset()`'s with value 0"]
        impl crate::ResetValue for super::TDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `TDR`"]
        pub type TDR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `TDR`"]
        pub struct TDR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | ((value as u32) & 0x01ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:8 - Transmit data value"]
            #[inline(always)]
            pub fn tdr(&self) -> TDR_R {
                TDR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:8 - Transmit data value"]
            #[inline(always)]
            pub fn tdr(&mut self) -> TDR_W {
                TDR_W { w: self }
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "AES"]
    pub AES: AES,
    #[doc = "DMA1"]
    pub DMA1: DMA1,
    #[doc = "CRC"]
    pub CRC: CRC,
    #[doc = "GPIOA"]
    pub GPIOA: GPIOA,
    #[doc = "GPIOB"]
    pub GPIOB: GPIOB,
    #[doc = "GPIOC"]
    pub GPIOC: GPIOC,
    #[doc = "GPIOD"]
    pub GPIOD: GPIOD,
    #[doc = "GPIOH"]
    pub GPIOH: GPIOH,
    #[doc = "GPIOE"]
    pub GPIOE: GPIOE,
    #[doc = "LPTIM"]
    pub LPTIM: LPTIM,
    #[doc = "RTC"]
    pub RTC: RTC,
    #[doc = "USART1"]
    pub USART1: USART1,
    #[doc = "USART2"]
    pub USART2: USART2,
    #[doc = "USART4"]
    pub USART4: USART4,
    #[doc = "USART5"]
    pub USART5: USART5,
    #[doc = "IWDG"]
    pub IWDG: IWDG,
    #[doc = "WWDG"]
    pub WWDG: WWDG,
    #[doc = "FW"]
    pub FW: FW,
    #[doc = "RCC"]
    pub RCC: RCC,
    #[doc = "SYSCFG"]
    pub SYSCFG: SYSCFG,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "I2C3"]
    pub I2C3: I2C3,
    #[doc = "PWR"]
    pub PWR: PWR,
    #[doc = "FLASH"]
    pub FLASH: FLASH,
    #[doc = "EXTI"]
    pub EXTI: EXTI,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "DBG"]
    pub DBG: DBG,
    #[doc = "TIM2"]
    pub TIM2: TIM2,
    #[doc = "TIM3"]
    pub TIM3: TIM3,
    #[doc = "TIM6"]
    pub TIM6: TIM6,
    #[doc = "TIM7"]
    pub TIM7: TIM7,
    #[doc = "TIM21"]
    pub TIM21: TIM21,
    #[doc = "TIM22"]
    pub TIM22: TIM22,
    #[doc = "LPUART1"]
    pub LPUART1: LPUART1,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            AES: AES {
                _marker: PhantomData,
            },
            DMA1: DMA1 {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            GPIOH: GPIOH {
                _marker: PhantomData,
            },
            GPIOE: GPIOE {
                _marker: PhantomData,
            },
            LPTIM: LPTIM {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            USART2: USART2 {
                _marker: PhantomData,
            },
            USART4: USART4 {
                _marker: PhantomData,
            },
            USART5: USART5 {
                _marker: PhantomData,
            },
            IWDG: IWDG {
                _marker: PhantomData,
            },
            WWDG: WWDG {
                _marker: PhantomData,
            },
            FW: FW {
                _marker: PhantomData,
            },
            RCC: RCC {
                _marker: PhantomData,
            },
            SYSCFG: SYSCFG {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            I2C3: I2C3 {
                _marker: PhantomData,
            },
            PWR: PWR {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            DBG: DBG {
                _marker: PhantomData,
            },
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            TIM3: TIM3 {
                _marker: PhantomData,
            },
            TIM6: TIM6 {
                _marker: PhantomData,
            },
            TIM7: TIM7 {
                _marker: PhantomData,
            },
            TIM21: TIM21 {
                _marker: PhantomData,
            },
            TIM22: TIM22 {
                _marker: PhantomData,
            },
            LPUART1: LPUART1 {
                _marker: PhantomData,
            },
        }
    }
}
